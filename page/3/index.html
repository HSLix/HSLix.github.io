<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>LuYaoQi&#39;s Blogs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="normal wants to be special">
<meta property="og:type" content="website">
<meta property="og:title" content="LuYaoQi&#39;s Blogs">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="LuYaoQi&#39;s Blogs">
<meta property="og:description" content="normal wants to be special">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="陆爻齐-LuYaoQi">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="LuYaoQi's Blogs" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">LuYaoQi&#39;s Blogs</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Hello my World</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-【深度学习】一站式解决配置图神经网络GNN环境各种问题——以配置HopGNN运行环境为例记录" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/03/25/%E3%80%90%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%91%E4%B8%80%E7%AB%99%E5%BC%8F%E8%A7%A3%E5%86%B3%E9%85%8D%E7%BD%AE%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CGNN%E7%8E%AF%E5%A2%83%E5%90%84%E7%A7%8D%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94%E4%BB%A5%E9%85%8D%E7%BD%AEHopGNN%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E4%B8%BA%E4%BE%8B%E8%AE%B0%E5%BD%95/" class="article-date">
  <time class="dt-published" datetime="2024-03-25T06:06:00.000Z" itemprop="datePublished">2024-03-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/03/25/%E3%80%90%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%91%E4%B8%80%E7%AB%99%E5%BC%8F%E8%A7%A3%E5%86%B3%E9%85%8D%E7%BD%AE%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CGNN%E7%8E%AF%E5%A2%83%E5%90%84%E7%A7%8D%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94%E4%BB%A5%E9%85%8D%E7%BD%AEHopGNN%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E4%B8%BA%E4%BE%8B%E8%AE%B0%E5%BD%95/">【深度学习】一站式解决配置图神经网络 GNN 环境各种问题——以配置 HopGNN 运行环境为例记录</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a id="section1"></a><br>当这篇文章发布时，估计成品论文已经出来了，不过本文的目的是以一个 python 菜鸟和科研新手的角度，记录配置环境时发现和解决问题的记录，希望能帮到未来的自己和遇到类似报错的你。</p>
<p>本文大致分为三个板块，第一个 <a href="#section1">前言</a>，第二个是 <a href="#section2">配置环境的具体记录（含各种报错）</a>，第三个则是 <a href="#section3">记录我总结的配置相关环境的办法</a>。</p>
<p><strong>注意</strong><br>陆爻齐在后续配置其它环境时也碰到了其它的问题，相关内容会记录到 <a href="#section4">补充内容</a>。</p>
<h1 id="配置环境的具体记录"><a href="#配置环境的具体记录" class="headerlink" title="配置环境的具体记录"></a>配置环境的具体记录</h1><p><a id="section2"></a></p>
<h2 id="官方提示与配置设备"><a href="#官方提示与配置设备" class="headerlink" title="官方提示与配置设备"></a>官方提示与配置设备</h2><p>配环境，首先肯定先看官方怎么说<br><a target="_blank" rel="noopener" href="https://github.com/JC-202/HopGNN">HopGNN GitHub地址</a><br>无requirement，其中的Dependencies中内容是</p>
<ul>
<li>python 3.7.3</li>
<li>pytorch 1.10.1</li>
<li>dgl 0.6.0</li>
<li>ogb 1.2.3</li>
<li>torch-geometric 2.0.3</li>
</ul>
<p>而程序通过bash启动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash scripts/citation.sh</span><br><span class="line">bash scripts/heterophily.sh</span><br><span class="line">bash scripts/large.sh </span><br></pre></td></tr></table></figure>


<p>笔者采用anaconda3来配置环境，由于设备配有独立显卡，故决定下载cuda利用上gpu。</p>
<h2 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h2><h3 id="bash配置"><a href="#bash配置" class="headerlink" title="bash配置"></a>bash配置</h3><p>第一个问题是安装的bash识别不到conda，而window的cmd可以，报错如下<br><code>bash: conda: command not found</code><br>故参考文章CSDN博客顺利解决：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Vertira/article/details/136271584">windows 中， bash: conda: command not found（已解决）</a></p>
<p>但是，虽然能识别 conda 指令，却不能在打开终端后直接运行 conda acivate 命令，必须用 source activate 环境来启动，后面才能直接激活环境。不过并没有太大影响，故按下不表。</p>
<h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>conda python3.7.3<br>pytorch 1.10.1在torch官网下<br>dgl，ogb，和torch-geometric都在aconda搜索下载<br>均为对应版本</p>
<p>然后运行<br>bash scripts&#x2F;citation.sh<br>提示缺少模块einops，conda install后，发现版本0.7.0不匹配，故降级0.6.0<br>然后提示缺少模块scikit-learn，conda install 1.0.2解决<br>接着提示缺少模块pandas，conda install 1.3.5<br>提示缺少tqdm，conda install 4.64.1</p>
<p>现在不缺模块了，报错如下</p>
<details> <summary>ErrorReport</summary>
$ bash scripts/citation.sh
Traceback (most recent call last):
  File "train.py", line 8, in <module>
    from datasets.dataloader import load_data
  File "D:\Code\HopGNN\datasets\dataloader.py", line 5, in <module>
    from ogb.nodeproppred import PygNodePropPredDataset
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\ogb\nodeproppred\__init__.py", line 10, in <module>
    from .dataset_dgl import DglNodePropPredDataset
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\ogb\nodeproppred\dataset_dgl.py", line 6, in <module>
    from dgl.data.utils import load_graphs, save_graphs, Subset
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\__init__.py", line 13, in <module>
    from .backend import load_backend, backend_name
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\backend\__init__.py", line 95, in <module>
    load_backend(get_preferred_backend())
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\backend\__init__.py", line 41, in load_backend
    from .._ffi.base import load_tensor_adapter # imports DGL C library
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\_ffi\base.py", line 44, in <module>
    _LIB, _LIB_NAME, _DIR_NAME = _load_lib()
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\_ffi\base.py", line 33, in _load_lib
    lib_path = libinfo.find_lib_path()
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\_ffi\libinfo.py", line 83, in find_lib_path
    raise RuntimeError(message)
RuntimeError: Cannot find the files.
List of candidates:
D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\libdgl.dll
D:\anaconda3\envs\hopgnn\lib\build\libdgl.dll
D:\anaconda3\envs\hopgnn\lib\build\Release\libdgl.dll
D:\anaconda3\envs\hopgnn\lib\lib\libdgl.dll
D:\anaconda3\envs\hopgnn\libdgl.dll
D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\dgl.dll
D:\anaconda3\envs\hopgnn\lib\build\dgl.dll
D:\anaconda3\envs\hopgnn\lib\build\Release\dgl.dll
D:\anaconda3\envs\hopgnn\lib\lib\dgl.dll
D:\anaconda3\envs\hopgnn\dgl.dll
Traceback (most recent call last):
  File "train.py", line 8, in <module>
    from datasets.dataloader import load_data
  File "D:\Code\HopGNN\datasets\dataloader.py", line 5, in <module>
    from ogb.nodeproppred import PygNodePropPredDataset
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\ogb\nodeproppred\__init__.py", line 10, in <module>
    from .dataset_dgl import DglNodePropPredDataset
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\ogb\nodeproppred\dataset_dgl.py", line 6, in <module>
    from dgl.data.utils import load_graphs, save_graphs, Subset
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\__init__.py", line 13, in <module>
    from .backend import load_backend, backend_name
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\backend\__init__.py", line 95, in <module>
    load_backend(get_preferred_backend())
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\backend\__init__.py", line 41, in load_backend
    from .._ffi.base import load_tensor_adapter # imports DGL C library
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\_ffi\base.py", line 44, in <module>
    _LIB, _LIB_NAME, _DIR_NAME = _load_lib()
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\_ffi\base.py", line 33, in _load_lib
    lib_path = libinfo.find_lib_path()
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\_ffi\libinfo.py", line 83, in find_lib_path
    raise RuntimeError(message)
RuntimeError: Cannot find the files.
List of candidates:
D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\libdgl.dll
D:\anaconda3\envs\hopgnn\lib\build\libdgl.dll
D:\anaconda3\envs\hopgnn\lib\build\Release\libdgl.dll
D:\anaconda3\envs\hopgnn\lib\lib\libdgl.dll
D:\anaconda3\envs\hopgnn\libdgl.dll
D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\dgl.dll
D:\anaconda3\envs\hopgnn\lib\build\dgl.dll
D:\anaconda3\envs\hopgnn\lib\build\Release\dgl.dll
D:\anaconda3\envs\hopgnn\lib\lib\dgl.dll
D:\anaconda3\envs\hopgnn\dgl.dll
Traceback (most recent call last):
  File "train.py", line 8, in <module>
    from datasets.dataloader import load_data
  File "D:\Code\HopGNN\datasets\dataloader.py", line 5, in <module>
    from ogb.nodeproppred import PygNodePropPredDataset
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\ogb\nodeproppred\__init__.py", line 10, in <module>
    from .dataset_dgl import DglNodePropPredDataset
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\ogb\nodeproppred\dataset_dgl.py", line 6, in <module>
    from dgl.data.utils import load_graphs, save_graphs, Subset
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\__init__.py", line 13, in <module>
    from .backend import load_backend, backend_name
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\backend\__init__.py", line 95, in <module>
    load_backend(get_preferred_backend())
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\backend\__init__.py", line 41, in load_backend
    from .._ffi.base import load_tensor_adapter # imports DGL C library
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\_ffi\base.py", line 44, in <module>
    _LIB, _LIB_NAME, _DIR_NAME = _load_lib()
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\_ffi\base.py", line 33, in _load_lib
    lib_path = libinfo.find_lib_path()
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\_ffi\libinfo.py", line 83, in find_lib_path
    raise RuntimeError(message)
RuntimeError: Cannot find the files.
List of candidates:
D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\libdgl.dll
D:\anaconda3\envs\hopgnn\lib\build\libdgl.dll
D:\anaconda3\envs\hopgnn\lib\build\Release\libdgl.dll
D:\anaconda3\envs\hopgnn\lib\lib\libdgl.dll
D:\anaconda3\envs\hopgnn\libdgl.dll
D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\dgl.dll
D:\anaconda3\envs\hopgnn\lib\build\dgl.dll
D:\anaconda3\envs\hopgnn\lib\build\Release\dgl.dll
D:\anaconda3\envs\hopgnn\lib\lib\dgl.dll
D:\anaconda3\envs\hopgnn\dgl.dll
</details>
经分析，推测为dgl版本不匹配，更新为最新版仍不匹配，经搜索发现可发现解决方案无用

<p>所以，我将除torch外的部分包都卸载，用pip重新安装最新版（<del>虽然犯了conda和pip混用的忌，但木得办法</del>）<br>pip将torch换为1.13，ogb换为1.3.6 dgl换为2.0.0 torch-geometric换为2.3.1<br>然后出现了新的报错</p>
<details><summary>ErrorReport</summary>
$ bash scripts/citation.sh
Traceback (most recent call last):
  File "train.py", line 8, in <module>
    from datasets.dataloader import load_data
  File "D:\Code\HopGNN\datasets\dataloader.py", line 8, in <module>
    from dgl.data import *
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\__init__.py", line 16, in <module>
    from . import (
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\dataloading\__init__.py", line 13, in <module>
    from .dataloader import *
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\dataloading\dataloader.py", line 27, in <module>
    from ..distributed import DistGraph
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\distributed\__init__.py", line 5, in <module>
    from .dist_graph import DistGraph, DistGraphServer, edge_split, node_split
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\distributed\dist_graph.py", line 37, in <module>
    from .partition import (
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\distributed\partition.py", line 15, in <module>
    from ..data.utils import load_graphs, load_tensors, save_graphs, save_tensors
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\data\__init__.py", line 7, in <module>
    from . import citation_graph as citegrh
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\data\citation_graph.py", line 20, in <module>
    from .dgl_dataset import DGLBuiltinDataset
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\data\dgl_dataset.py", line 12, in <module>
    from .utils import download, extract_archive, get_download_dir, makedirs
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\data\utils.py", line 14, in <module>
    import requests
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\requests\__init__.py", line 43, in <module>
    import urllib3
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\urllib3\__init__.py", line 42, in <module>
    "urllib3 v2.0 only supports OpenSSL 1.1.1+, currently "
ImportError: urllib3 v2.0 only supports OpenSSL 1.1.1+, currently the 'ssl' module is compiled with 'OpenSSL 1.1.0i  14 Aug 2018'. See: https://github.com/urllib3/urllib3/issues/2168
Traceback (most recent call last):
  File "train.py", line 8, in <module>
    from datasets.dataloader import load_data
  File "D:\Code\HopGNN\datasets\dataloader.py", line 8, in <module>
    from dgl.data import *
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\__init__.py", line 16, in <module>
    from . import (
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\dataloading\__init__.py", line 13, in <module>
    from .dataloader import *
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\dataloading\dataloader.py", line 27, in <module>
    from ..distributed import DistGraph
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\distributed\__init__.py", line 5, in <module>
    from .dist_graph import DistGraph, DistGraphServer, edge_split, node_split
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\distributed\dist_graph.py", line 37, in <module>
    from .partition import (
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\distributed\partition.py", line 15, in <module>
    from ..data.utils import load_graphs, load_tensors, save_graphs, save_tensors
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\data\__init__.py", line 7, in <module>
    from . import citation_graph as citegrh
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\data\citation_graph.py", line 20, in <module>
    from .dgl_dataset import DGLBuiltinDataset
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\data\dgl_dataset.py", line 12, in <module>
    from .utils import download, extract_archive, get_download_dir, makedirs
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\data\utils.py", line 14, in <module>
    import requests
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\requests\__init__.py", line 43, in <module>
    import urllib3
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\urllib3\__init__.py", line 42, in <module>
    "urllib3 v2.0 only supports OpenSSL 1.1.1+, currently "
ImportError: urllib3 v2.0 only supports OpenSSL 1.1.1+, currently the 'ssl' module is compiled with 'OpenSSL 1.1.0i  14 Aug 2018'. See: https://github.com/urllib3/urllib3/issues/2168
Traceback (most recent call last):
  File "train.py", line 8, in <module>
    from datasets.dataloader import load_data
  File "D:\Code\HopGNN\datasets\dataloader.py", line 8, in <module>
    from dgl.data import *
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\__init__.py", line 16, in <module>
    from . import (
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\dataloading\__init__.py", line 13, in <module>
    from .dataloader import *
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\dataloading\dataloader.py", line 27, in <module>
    from ..distributed import DistGraph
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\distributed\__init__.py", line 5, in <module>
    from .dist_graph import DistGraph, DistGraphServer, edge_split, node_split
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\distributed\dist_graph.py", line 37, in <module>
    from .partition import (
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\distributed\partition.py", line 15, in <module>
    from ..data.utils import load_graphs, load_tensors, save_graphs, save_tensors
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\data\__init__.py", line 7, in <module>
    from . import citation_graph as citegrh
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\data\citation_graph.py", line 20, in <module>
    from .dgl_dataset import DGLBuiltinDataset
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\data\dgl_dataset.py", line 12, in <module>
    from .utils import download, extract_archive, get_download_dir, makedirs
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\data\utils.py", line 14, in <module>
    import requests
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\requests\__init__.py", line 43, in <module>
    import urllib3
  File "D:\anaconda3\envs\hopgnn\lib\site-packages\urllib3\__init__.py", line 42, in <module>
    "urllib3 v2.0 only supports OpenSSL 1.1.1+, currently "
ImportError: urllib3 v2.0 only supports OpenSSL 1.1.1+, currently the 'ssl' module is compiled with 'OpenSSL 1.1.0i  14 Aug 2018'. See: https://github.com/urllib3/urllib3/issues/2168
</details>

<p>经查找，执行pip install urllib3&#x3D;&#x3D;1.26.15，解决<br>然后又出现<code>ModuleNotFoundError: No module named &#39;torch_sparse&#39;</code>，故pip安装torchsparse<br><code>ModuleNotFoundError: No module named &#39;torch_scatter&#39;</code> 故pip安装torchscatter<br><code>ModuleNotFoundError: No module named &#39;google_drive_downloader&#39;</code> 故pip安装</p>
<p>再次运行，这次报错<code>AssertionError: Torch not compiled with CUDA enabled</code><br>然后发现torch版本不对，发现下的是cpu版本，故删除重下，pytroch1.13.1 cuda11.7 cudacnn8.9.7参照适配表应不冲突</p>
<p>于是在配置正确的torch sca什么的之类后，成功跑通前两个，但第三个出现错误如下<br><code>ValueError: Cannot load file containing pickled data when allow_pickle=False</code></p>
<p>经把对应地方 allow pickle变true后，错误变成了<br><code>OSError Failed to interpret file as a pickle</code></p>
<p>经查询没有什么可用的办法，于是接下来八小时尝试了配置与要求环境一摸一样的环境，配置python版本更低的环境（参照一些github issue的回答，回退版本可能解决），但还是无果</p>
<p>中间出现报错<br><code>RuntimeError: Not compiled with CUDA support</code><br>参考博客解决<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44501429/article/details/129178459">RuntimeError: Not compiled with CUDA support此类错误解决方案</a></p>
<p>在经过学长解放思想，指点后，秉承能跑起来的就是好环境的原则，将python3.7更为python3.8，如此，便能下载更新的pytorch2.*版本。</p>
<p>但仍没有突破，于是查到之前的错误可能是下载文件不完整，于是删掉库重新clone并下载文件后，又出现新的错误报告<br><code>AttributeError: module numpy has no attribute int</code><br>参考文章 <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46669612/article/details/129624331">AttributeError: module numpy has no attribute int .报错解决方案</a><br>经查询，numpy回退1.22.2后解决，这下彻底解决</p>
<p>同时又用之前的python3.7试着跑第三条，仍然报错，说明还是要结合python3.8以上版本的这个环境</p>
<h1 id="配置环境参考流程（运用Nvidia-GPU，pytorch、pyg的环境）"><a href="#配置环境参考流程（运用Nvidia-GPU，pytorch、pyg的环境）" class="headerlink" title="配置环境参考流程（运用Nvidia GPU，pytorch、pyg的环境）"></a>配置环境参考流程（运用Nvidia GPU，pytorch、pyg的环境）</h1><p><a id="section3"></a></p>
<p>首先是确认，设备有 nvidia 显卡</p>
<p>然后查看是否满足配置 CUDA 的环境，nvidia 控制面板-系统信息-组件中的 3d 设置右侧产品名称的右侧有 CUDA 后面一串数字，这就是自己电脑支持的 CUDA 版本，一般选择配套的，作者有时候会选择略低于这个的版本，不能高于。具体情况视情况而定。</p>
<p>接着结合自己的需求和 <a target="_blank" rel="noopener" href="https://blog.csdn.net/u011489887/article/details/135250561">pytorch与cuda版本对应关系汇总</a> 来确定要下载的CUDA版本和pytorch版本</p>
<p>再到 <a target="_blank" rel="noopener" href="https://developer.nvidia.com/cuda-toolkit-archive">CUDA官网</a> 下载cuda版本，安装用自定义，一般只用下CUDA即可，安装后配置环境变量并测试。此处安装程序开始选择的文件夹是临时安装文件夹，安装完成后会自行删除。</p>
<p>再到下载cuDNN，根据对应版本在 <a target="_blank" rel="noopener" href="https://developer.nvidia.com/rdp/cudnn-archive">cuDNN官网</a> 下载即可（第一次下载需要注册账号），下载后将文件夹的bin，include，lib三个文件夹“替换”（直接拷贝即可）CUDA安装位置内的同名文件夹，再配置对应环境变量后验证</p>
<p>下面到 <a target="_blank" rel="noopener" href="https://pytorch.org/get-started/previous-versions/#conda">pytorch官网</a> 下载对应 torch 版本，也可以自行在这个<a target="_blank" rel="noopener" href="http://download.pytorch.org/whl/torch_stable.html">网站</a>下载（笔者偏向使用后者）</p>
<p>最后，如果要用到 pyg，就可以参考自己的 pytorch 版本和 CUDA 版本，在 <a target="_blank" rel="noopener" href="https://data.pyg.org/whl/">该网站</a> 按需下载库，然后直接 pip install torch-geometric。（应该 pyg 下最新就行）<br>PS：cp38 代表适配 python 3.8</p>
<p>对于多个 CUDA 版本的管理，笔者参考 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_50677040/article/details/132131346">这篇博客</a></p>
<p>参考博客如下，后面再用我自己的话做个综合<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/by99031433/article/details/127721199">pytorch1.13安装</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/shdabai/article/details/131248257">window11系统CUDA、cuDNN 安装以及环境变量配置</a></p>
<h1 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h1><p><a id="section4"></a></p>
<h2 id="dgl"><a href="#dgl" class="headerlink" title="dgl"></a>dgl</h2><p>dgl 也分 cpu 和 gpu 版本，可以到 <a target="_blank" rel="noopener" href="https://www.dgl.ai/pages/start.html">官网</a> 找到对应的下载方式，当然也有类似 torch 的离线下载方式，在这个 <a target="_blank" rel="noopener" href="https://data.dgl.ai/wheels/repo.html">网站</a>。</p>
<p><strong>注意</strong>，该网站对 cuda 的 dgl 版本较为落后，最新不过 1.0.0，想要更新的 cuda 版本需要略微改动网址，该网址为 <a target="_blank" rel="noopener" href="https://data.dgl.ai/wheels/repo.html">https://data.dgl.ai/wheels/repo.html</a> ，只要改成 <a target="_blank" rel="noopener" href="https://data.dgl.ai/wheels/cu116/repo.html">https://data.dgl.ai/wheels/cu116/repo.html</a> 就能获取到 1.0.0 以上的 cuda11.6 的 dgl，你学废了吗：）</p>
<p>dgl 的数据集会放在根目录的 .dgl 文件夹下，linux 系统中，可输入 <code>cd ~</code>进入根目录，然后通过 <code>ls -al</code> 来详细输出每个文件找到文件夹，接着可通过 <code>cd .dgl</code> 进入数据集文件夹，可以自行寻找数据集放入其中使用。</p>
<h2 id="报错-Device-API-gpu-is-not-enabled-Please-install-the-cuda-version-of-dgl"><a href="#报错-Device-API-gpu-is-not-enabled-Please-install-the-cuda-version-of-dgl" class="headerlink" title="报错 Device API gpu is not enabled. Please install the cuda version of dgl"></a>报错 Device API gpu is not enabled. Please install the cuda version of dgl</h2><p>可以尝试回退dgl对应的cuda版本，参照<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/434494642">该文章</a>cuda11.3装 dgl-cuda113 报错，可以装 dgl-cuda110 试试</p>
<h2 id="报错-RuntimeError-Could-not-infer-dtype-of-numpy-int64"><a href="#报错-RuntimeError-Could-not-infer-dtype-of-numpy-int64" class="headerlink" title="报错 RuntimeError: Could not infer dtype of numpy.int64"></a>报错 RuntimeError: Could not infer dtype of numpy.int64</h2><p>如果最后一条语句来自 dgl，很可能是因为 numpy 版本过新，即 numpy 的 2.* 版本，回退到 1.* 的版本即可解决</p>
<p>参考 <a target="_blank" rel="noopener" href="https://github.com/DLR-RM/stable-baselines3/issues/1960">GitHub</a></p>
<h2 id="报错-AttributeError-module-‘dgl-function’-has-no-attribute-‘copy-src’"><a href="#报错-AttributeError-module-‘dgl-function’-has-no-attribute-‘copy-src’" class="headerlink" title="报错 AttributeError: module ‘dgl.function’ has no attribute ‘copy_src’"></a>报错 AttributeError: module ‘dgl.function’ has no attribute ‘copy_src’</h2><p>该报错是因为 dgl 版本过新，该函数自 1.* 版本开始就删掉了，回退之前版本即可解决，比如 0.9.1</p>
<p>参考 <a target="_blank" rel="noopener" href="https://github.com/XingyanLiu/CAME/issues/24">GitHub</a></p>
<h2 id="多个-CUDA-可能发生的环境-CUDA-不变化问题"><a href="#多个-CUDA-可能发生的环境-CUDA-不变化问题" class="headerlink" title="多个 CUDA 可能发生的环境 CUDA 不变化问题"></a>多个 CUDA 可能发生的环境 CUDA 不变化问题</h2><p>通过修改环境变量 Path 几个 CUDA 的顺序确实能改变在命令行窗口输入<code>nvcc -V</code>显示的版本号，不过，一旦 conda create 了一个环境，那么环境里的 CUDA 就固定了，不可更换（至少此时笔者还不知如何更换）</p>
<h2 id="离线-pip-安装-torch-问题报错"><a href="#离线-pip-安装-torch-问题报错" class="headerlink" title="离线 pip 安装 torch 问题报错"></a>离线 pip 安装 torch 问题报错</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WARNING: Retrying (Retry(total=4, connect=None, read=None, redirect=None, status=None)) after connection broken by &#x27;SSLError(SSLError(1, &#x27;[SSL: KRB5_S_TKT_NYV] unexpected eof while reading (_ssl.c:1091)&#x27;))&#x27;: /simple/typing-extensions/</span><br><span class="line">WARNING: Retrying (Retry(total=3, connect=None, read=None, redirect=None, status=None)) after connection broken by &#x27;SSLError(SSLError(1, &#x27;[SSL: KRB5_S_TKT_NYV] unexpected eof while reading (_ssl.c:1091)&#x27;))&#x27;: /simple/typing-extensions/</span><br><span class="line">WARNING: Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by &#x27;SSLError(SSLError(1, &#x27;[SSL: KRB5_S_TKT_NYV] unexpected eof while reading (_ssl.c:1091)&#x27;))&#x27;: /simple/typing-extensions/</span><br><span class="line">WARNING: Retrying (Retry(total=1, connect=None, read=None, redirect=None, status=None)) after connection broken by &#x27;SSLError(SSLError(1, &#x27;[SSL: KRB5_S_TKT_NYV] unexpected eof while reading (_ssl.c:1091)&#x27;))&#x27;: /simple/typing-extensions/</span><br><span class="line">WARNING: Retrying (Retry(total=0, connect=None, read=None, redirect=None, status=None)) after connection broken by &#x27;SSLError(SSLError(1, &#x27;[SSL: KRB5_S_TKT_NYV] unexpected eof while reading (_ssl.c:1091)&#x27;))&#x27;: /simple/typing-extensions/</span><br><span class="line">Could not fetch URL https://pypi.org/simple/typing-extensions/: There was a problem confirming the ssl certificate: HTTPSConnectionPool(host=&#x27;pypi.org&#x27;, port=443): Max retries exceeded with url: /simple/typing-extensions/ (Caused by SSLError(SSLError(1, &#x27;[SSL: KRB5_S_TKT_NYV] unexpected eof while reading (_ssl.c:1091)&#x27;))) - skipping</span><br><span class="line">INFO: pip is looking at multiple versions of torch to determine which version is compatible with other requirements. This could take a while.</span><br><span class="line">ERROR: Could not find a version that satisfies the requirement typing-extensions (from torch) (from versions: none)</span><br><span class="line">ERROR: No matching distribution found for typing-extensions</span><br></pre></td></tr></table></figure>
<p>很显然，这是网络问题，笔者在关闭梯子后问题消失</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>小小 Python 环境配得汗流浃背，本以为此前经历了 LALC 的磨练能顺利些，不曾想如此“有意思”，希望本文的记录有所帮助</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/03/25/%E3%80%90%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%91%E4%B8%80%E7%AB%99%E5%BC%8F%E8%A7%A3%E5%86%B3%E9%85%8D%E7%BD%AE%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CGNN%E7%8E%AF%E5%A2%83%E5%90%84%E7%A7%8D%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94%E4%BB%A5%E9%85%8D%E7%BD%AEHopGNN%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E4%B8%BA%E4%BE%8B%E8%AE%B0%E5%BD%95/" data-id="cm7j3ftha002buwagbqui5038" data-title="【深度学习】一站式解决配置图神经网络 GNN 环境各种问题——以配置 HopGNN 运行环境为例记录" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" rel="tag">深度学习</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-[CS61A-Fall-2020]学习记录4 Lecture4中有意思的点" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/02/29/%5BCS61A-Fall-2020%5D%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%954%20Lecture4%E4%B8%AD%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E7%82%B9/" class="article-date">
  <time class="dt-published" datetime="2024-02-29T13:27:00.000Z" itemprop="datePublished">2024-02-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/02/29/%5BCS61A-Fall-2020%5D%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%954%20Lecture4%E4%B8%AD%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E7%82%B9/">【CS61A-Fall-2020】学习记录四 Lecture4中有意思的点</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>观前提示，笔者写的代码答案放在 <a target="_blank" rel="noopener" href="https://github.com/HSLix/CS61A-Fall-2020">GitHub仓库</a> 中，此处仅记录过程与心得。</p>
<p>此外，请最好在尝试独立完成该任务后再看本文，否则就很可能失去了体验本项目精华的机会</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h3><p>课堂中在讲授函数，如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from math import pi</span><br><span class="line"></span><br><span class="line">def area_circle(r):</span><br><span class="line">    return r * r * pi</span><br></pre></td></tr></table></figure>
<p>但老师提出，当r为-10时，函数不会报错，于是引入assert来检测参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from math import pi</span><br><span class="line"></span><br><span class="line">def area_circle(r):</span><br><span class="line">    # 参数应为正数</span><br><span class="line">    assert r &gt; 0, &#x27;A length must be positive&#x27;</span><br><span class="line">    return r * r * pi</span><br><span class="line">assert r &gt; 0</span><br></pre></td></tr></table></figure>
<p>也就是当r大于0时，无事发生；否则发生错误并提示后面的语句</p>
<h3 id="Higher-Order-Functions"><a href="#Higher-Order-Functions" class="headerlink" title="Higher-Order Functions"></a>Higher-Order Functions</h3><p>一开始读题并不懂，什么是高等级的函数呢？课上有个例子大致如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def make_adder(k):</span><br><span class="line">    def adder(n):</span><br><span class="line">        return n + k</span><br><span class="line">    return adder</span><br></pre></td></tr></table></figure>
<p>make_adder函数内又定义了个adder函数</p>
<p>此时，如果调用make_adder(1)，会返回一个k为1的adder函数</p>
<p>而如果调用make_adder(1)(2)，则相当于调用adder(2)，此时k&#x3D;1</p>
<p>像这样的方式可以十分方便地减少重复代码，分离函数功能，更接近DRY(Don’t Repeat Yourself)</p>
<h3 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h3><p>square &#x3D; lambda x: x * x<br>lambda表达式使得简单函数无需用def定义后再调用</p>
<p>在python中，与def相比，lambda定义出的函数有一个特点，那就是没有内在自己的名字</p>
<p>直接输入上式， square，会发现在内存中，square对应的函数其实是lambda，不叫square</p>
<p>老师表示该功能在python中不常用，但其他有的地方会很重要，故学习并记录</p>
<p>下面是一个稍微有些难度的例子，与lambda本身关系不大</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 寻找到f值为True的正数x</span><br><span class="line">def search(f):</span><br><span class="line">    x = 0</span><br><span class="line">    while True:</span><br><span class="line">        if f(x):</span><br><span class="line">            return x</span><br><span class="line">        x += 1</span><br><span class="line"></span><br><span class="line">def square(x):</span><br><span class="line">    return x * x</span><br><span class="line"></span><br><span class="line"># 可以求出y对应的x满足f（x） == y</span><br><span class="line">def inverse(f):</span><br><span class="line">    return lambda y: search(lambda x, f(x) == y)</span><br></pre></td></tr></table></figure>
<p>这里的inverse函数在初次看的时候有些令人费解，但一点点看</p>
<p>首先从输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sqrt = inverse(square)</span><br><span class="line">&gt;&gt;&gt; square(8)</span><br><span class="line">64</span><br><span class="line">&gt;&gt;&gt; sqrt(64)</span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<p>可见sqrt通过inverse承担了解平方的功能</p>
<p>inverse中f对应的是square，而在search函数中的f对应的是lambda x, f(x) &#x3D;&#x3D; y</p>
<p>sqrt(64)的64则是赋给了y，然后再在search中寻找让f(x) &#x3D;&#x3D; y成立的正数x并返回</p>
<p>If的另一种表达<br>直接举栗子比较清晰</p>
<p>x &#x3D; 0<br>x &#x3D; 1 if x &gt; 0 else x &#x3D; -1<br>x &gt; 0是条件，满足该条件时执行if前，否则执行else后</p>
<p>当作拓展知识吧</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/02/29/[CS61A-Fall-2020]%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%954%20Lecture4%E4%B8%AD%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E7%82%B9/" data-id="cm7j3ftgl0008uwag61d95ubv" data-title="【CS61A-Fall-2020】学习记录四 Lecture4中有意思的点" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CS61A/" rel="tag">CS61A</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/" rel="tag">Python</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-[CS61A-Fall-2020]学习记录3 Lab1 题解思路分享" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/02/29/%5BCS61A-Fall-2020%5D%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%953%20Lab1%20%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF%E5%88%86%E4%BA%AB/" class="article-date">
  <time class="dt-published" datetime="2024-02-29T11:30:00.000Z" itemprop="datePublished">2024-02-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/02/29/%5BCS61A-Fall-2020%5D%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%953%20Lab1%20%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF%E5%88%86%E4%BA%AB/">【CS61A-Fall-2020】学习记录三 Lab1 题解思路分享</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>观前提示，笔者写的代码答案放在 <a target="_blank" rel="noopener" href="https://github.com/HSLix/CS61A-Fall-2020">GitHub仓库</a> 中，此处仅记录过程与心得。</p>
<p>此外，请最好在尝试独立完成该任务后再看本文，否则就很可能失去了体验本项目精华的机会</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="Q1-WWPD-Control"><a href="#Q1-WWPD-Control" class="headerlink" title="Q1: WWPD: Control"></a>Q1: WWPD: Control</h3><h3 id="Q2-WWPD-Veritasiness"><a href="#Q2-WWPD-Veritasiness" class="headerlink" title="Q2: WWPD: Veritasiness"></a>Q2: WWPD: Veritasiness</h3><h3 id="Q3-Debugging-Quiz"><a href="#Q3-Debugging-Quiz" class="headerlink" title="Q3: Debugging Quiz!"></a>Q3: Debugging Quiz!</h3><p>前三问分别问函数执行结果，python中布尔运算结果，程序报错最可能情况</p>
<p>所以就摘录部分令我印象深刻的知识点也就是做错的（悲</p>
<p>复制代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def how_big(x):</span><br><span class="line">...     if x &gt; 10:</span><br><span class="line">...         print(&#x27;huge&#x27;)</span><br><span class="line">...     elif x &gt; 5:</span><br><span class="line">...         return &#x27;big&#x27;</span><br><span class="line">...     elif x &gt; 0:</span><br><span class="line">...         print(&#x27;small&#x27;)</span><br><span class="line">...     else:</span><br><span class="line">...         print(&quot;nothin&quot;)</span><br><span class="line">&gt;&gt;&gt; how_big(7)</span><br></pre></td></tr></table></figure>

<p>“这题好简单啊，有什么难的吗？不就是big？”</p>
<p>是big，也不是</p>
<p>仔细看，elif x&gt;5: 下面是return ‘big’不是print</p>
<p>所以答案是’big’</p>
<p>而对于布尔运算则有两种代表情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 1 and 3 and 6 and 10 and 15</span><br></pre></td></tr></table></figure>
<p>在结果为对的布尔运算中，返回最后对的部分，</p>
<p>所以这题答案为15</p>
<p>而结果为错的布尔运算中，则返回第一个错的部分</p>
<h3 id="Q4-Falling-Factorial"><a href="#Q4-Falling-Factorial" class="headerlink" title="Q4: Falling Factorial"></a>Q4: Falling Factorial</h3><p>Let’s write a function falling, which is a “falling” factorial that takes two arguments, n and k, and returns the product of k consecutive numbers, starting from n and working downwards.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def falling(n, k):</span><br><span class="line">    &quot;&quot;&quot;Compute the falling factorial of n to depth k.</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; falling(6, 3)  # 6 * 5 * 4</span><br><span class="line">    120</span><br><span class="line">    &gt;&gt;&gt; falling(4, 3)  # 4 * 3 * 2</span><br><span class="line">    24</span><br><span class="line">    &gt;&gt;&gt; falling(4, 1)  # 4</span><br><span class="line">    4</span><br><span class="line">    &gt;&gt;&gt; falling(4, 0)</span><br><span class="line">    1</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    &quot;*** YOUR CODE HERE ***&quot;</span><br></pre></td></tr></table></figure>
<p>题目大意，接收两参数n，k，执行k次，从n向下递减数连乘，并规定乘0次的结果为1</p>
<p>解题过程，先定个result&#x3D;1，并返回result，然后以k&gt;0为条件建立循环，并在其中用n乘result，n–</p>
<h3 id="Q5-Sum-Digits"><a href="#Q5-Sum-Digits" class="headerlink" title="Q5: Sum Digits"></a>Q5: Sum Digits</h3><p>Write a function that takes in a nonnegative integer and sums its digits. (Using floor division and modulo might be helpful here!)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def sum_digits(y):</span><br><span class="line">    &quot;&quot;&quot;Sum all the digits of y.</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; sum_digits(10) # 1 + 0 = 1</span><br><span class="line">    1</span><br><span class="line">    &gt;&gt;&gt; sum_digits(4224) # 4 + 2 + 2 + 4 = 12</span><br><span class="line">    12</span><br><span class="line">    &gt;&gt;&gt; sum_digits(1234567890)</span><br><span class="line">    45</span><br><span class="line">    &gt;&gt;&gt; a = sum_digits(123) # make sure that you are using return rather than print</span><br><span class="line">    &gt;&gt;&gt; a</span><br><span class="line">    6</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    &quot;*** YOUR CODE HERE ***&quot;</span><br></pre></td></tr></table></figure>
<p>题目大意，输入一个正数，返回该数各位之和</p>
<p>解题过程，循环条件为该数大于零，不断取余并用10整除该数，再将余数相加</p>
<h3 id="Q6-WWPD-What-If"><a href="#Q6-WWPD-What-If" class="headerlink" title="Q6: WWPD: What If?"></a>Q6: WWPD: What If?</h3><p>该题要注意的是，if如果有满足的条件，后面的elif，else不会执行，同时还要看好if和else的对应关系。</p>
<h3 id="Q7-Double-Eights"><a href="#Q7-Double-Eights" class="headerlink" title="Q7: Double Eights"></a>Q7: Double Eights</h3><p>Write a function that takes in a number and determines if the digits contain two adjacent 8s.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def double_eights(n):</span><br><span class="line">    &quot;&quot;&quot;Return true if n has two eights in a row.</span><br><span class="line">    &gt;&gt;&gt; double_eights(8)</span><br><span class="line">    False</span><br><span class="line">    &gt;&gt;&gt; double_eights(88)</span><br><span class="line">    True</span><br><span class="line">    &gt;&gt;&gt; double_eights(2882)</span><br><span class="line">    True</span><br><span class="line">    &gt;&gt;&gt; double_eights(880088)</span><br><span class="line">    True</span><br><span class="line">    &gt;&gt;&gt; double_eights(12345)</span><br><span class="line">    False</span><br><span class="line">    &gt;&gt;&gt; double_eights(80808080)</span><br><span class="line">    False</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    &quot;*** YOUR CODE HERE ***&quot;</span><br></pre></td></tr></table></figure>
<p>题目大意，检测一个给定数字有无两个紧挨的8</p>
<p>解题过程，循环取余，判断数字是否为8，是则让计数器加一，计数器为2时结果为真，停止循环，最后计数器仍不为2则为假。易错点是数字非8时，记得将计数器归0</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>题不难，但让我很好的领略了一些python的特点，期待后续的学习</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/02/29/[CS61A-Fall-2020]%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%953%20Lab1%20%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF%E5%88%86%E4%BA%AB/" data-id="cm7j3ftgj0004uwag29sbddmf" data-title="【CS61A-Fall-2020】学习记录三 Lab1 题解思路分享" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CS61A/" rel="tag">CS61A</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/" rel="tag">Python</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-[CS61A-Fall-2020]学习记录2 Lecture1，2，3中有意思的点" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/02/29/%5BCS61A-Fall-2020%5D%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952%20Lecture1%EF%BC%8C2%EF%BC%8C3%E4%B8%AD%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E7%82%B9/" class="article-date">
  <time class="dt-published" datetime="2024-02-29T11:28:00.000Z" itemprop="datePublished">2024-02-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/02/29/%5BCS61A-Fall-2020%5D%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952%20Lecture1%EF%BC%8C2%EF%BC%8C3%E4%B8%AD%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E7%82%B9/">【CS61A-Fall-2020】学习记录二 Lecture1，2，3中有意思的点</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>观前提示，笔者写的代码答案放在 <a target="_blank" rel="noopener" href="https://github.com/HSLix/CS61A-Fall-2020">GitHub仓库</a> 中，此处仅记录过程与心得。</p>
<p>此外，请最好在尝试独立完成该任务后再看本文，否则就很可能失去了体验本项目精华的机会</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="doctest"><a href="#doctest" class="headerlink" title="doctest"></a>doctest</h3><p>好东西啊，此前的学习从未看到过，可以在函数的注释中通过特定格式便可书写文档测试，比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def divide_exact(n, d):</span><br><span class="line"> 　&#x27;&#x27;&#x27;</span><br><span class="line">    Return the quotient and remainder of dividing N by D.</span><br><span class="line">    &gt;&gt;&gt;q, r = divide_exact(2013, 10)</span><br><span class="line">    &gt;&gt;&gt;q</span><br><span class="line">    201</span><br><span class="line">    &gt;&gt;&gt; r</span><br><span class="line">    3</span><br><span class="line">    &#x27;&#x27;&#x27;    </span><br><span class="line">    return floordiv(n, d), mod(n, d)</span><br></pre></td></tr></table></figure>
<p>假设该 python 文件命名为 file.py，此时在本文件夹打开 bash，并输入命令行</p>
<p>python3  file.py 就能通过 doctest 来检查，如果没有其它输出，说明测试正常</p>
<p>可通过 -v 来显示运行过程，</p>
<p>当写成python3 -m doctest -v file.py时，该命令会详细运行测试用例</p>
<p>此外，doctest只会在命令行这种测试环境下才会运行，不用担心会在正式使用时误触发</p>
<h3 id="None"><a href="#None" class="headerlink" title="None"></a>None</h3><p>与C不同，python的函数都有返回，只是一部分返回为None，举个栗子</p>
<p>print(3)<br>会输出3，那么</p>
<p>print(print(1), print(2))<br>会输出什么呢？</p>
<p>答案是……</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">None None</span><br></pre></td></tr></table></figure>

<p>为什么呢？</p>
<p>因为python在调用函数时会先将参数计算尽，所以才会先输出1，再输出2</p>
<p>而后面出现的 None None 则是 print 函数返回的是 None</p>
<p>老师将函数大致分为两类</p>
<p>pure functions 和 non-pure fuctions，前者单纯返回函数值，后者除函数值有其他的操作</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/02/29/[CS61A-Fall-2020]%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952%20Lecture1%EF%BC%8C2%EF%BC%8C3%E4%B8%AD%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E7%82%B9/" data-id="cm7j3ftgf0001uwagd3fv8bxj" data-title="【CS61A-Fall-2020】学习记录二 Lecture1，2，3中有意思的点" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CS61A/" rel="tag">CS61A</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/" rel="tag">Python</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-[CS61A-Fall-2020]学习记录1 Homework1 题解思路分享" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/02/29/%5BCS61A-Fall-2020%5D%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951%20Homework1%20%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF%E5%88%86%E4%BA%AB/" class="article-date">
  <time class="dt-published" datetime="2024-02-29T11:27:00.000Z" itemprop="datePublished">2024-02-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/02/29/%5BCS61A-Fall-2020%5D%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951%20Homework1%20%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF%E5%88%86%E4%BA%AB/">【CS61A-Fall-2020】学习记录一 Homework1 题解思路分享</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>观前提示，笔者写的代码答案放在 <a target="_blank" rel="noopener" href="https://github.com/HSLix/CS61A-Fall-2020">GitHub仓库</a> 中，此处仅记录过程与心得。</p>
<p>此外，请最好在尝试独立完成该任务后再看本文，否则就很可能失去了体验本项目精华的机会</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>首先来看下hw的第一道题</p>
<h3 id="Q2-A-Plus-Abs-B"><a href="#Q2-A-Plus-Abs-B" class="headerlink" title="Q2: A Plus Abs B"></a>Q2: A Plus Abs B</h3><p>Fill in the blanks in the following function for adding a to the absolute value of b, without calling abs. You may not modify any of the provided code other than the two blanks.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from operator import add, sub</span><br><span class="line"></span><br><span class="line">def a_plus_abs_b(a, b):</span><br><span class="line">    &quot;&quot;&quot;Return a+abs(b), but without calling abs.</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; a_plus_abs_b(2, 3)</span><br><span class="line">    5</span><br><span class="line">    &gt;&gt;&gt; a_plus_abs_b(2, -3)</span><br><span class="line">    5</span><br><span class="line">    &gt;&gt;&gt; # a check that you didn&#x27;t change the return statement!</span><br><span class="line">    &gt;&gt;&gt; import inspect, re</span><br><span class="line">    &gt;&gt;&gt; re.findall(r&#x27;^\s*(return .*)&#x27;, inspect.getsource(a_plus_abs_b), re.M)</span><br><span class="line">    [&#x27;return f(a, b)&#x27;]</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if b &lt; 0:</span><br><span class="line">        f = _____</span><br><span class="line">    else:</span><br><span class="line">        f = _____</span><br><span class="line">    return f(a, b)</span><br></pre></td></tr></table></figure>
<p>题目大意，赋予f一个函数满足在不使用abs函数的情况下，实现a+abs（b）的效果</p>
<p>解题过程，刚开始没注意到是赋予函数，于是分别填了a - b和a + b的错误答案，看了报错类型才反应过来，然后想起python可以函数赋予，于是将sub和add分别赋予f即可</p>
<h3 id="Q3-Two-of-Three"><a href="#Q3-Two-of-Three" class="headerlink" title="Q3: Two of Three"></a>Q3: Two of Three</h3><p>Write a function that takes three positive numbers as arguments and returns the sum of the squares of the two smallest numbers. Use only a single line for the body of the function.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def two_of_three(x, y, z):</span><br><span class="line">    &quot;&quot;&quot;Return a*a + b*b, where a and b are the two smallest members of the</span><br><span class="line">    positive numbers x, y, and z.</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; two_of_three(1, 2, 3)</span><br><span class="line">    5</span><br><span class="line">    &gt;&gt;&gt; two_of_three(5, 3, 1)</span><br><span class="line">    10</span><br><span class="line">    &gt;&gt;&gt; two_of_three(10, 2, 8)</span><br><span class="line">    68</span><br><span class="line">    &gt;&gt;&gt; two_of_three(5, 5, 5)</span><br><span class="line">    50</span><br><span class="line">    &gt;&gt;&gt; # check that your code consists of nothing but an expression (this docstring)</span><br><span class="line">    &gt;&gt;&gt; # a return statement</span><br><span class="line">    &gt;&gt;&gt; import inspect, ast</span><br><span class="line">    &gt;&gt;&gt; [type(x).__name__ for x in ast.parse(inspect.getsource(two_of_three)).body[0].body]</span><br><span class="line">    [&#x27;Expr&#x27;, &#x27;Return&#x27;]</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    return _____</span><br></pre></td></tr></table></figure>
<p>题目大意，返回三个参数中最小两个的平方和</p>
<p>解题过程，刚开始想了会如何在一行里选出三个参数中最小两个，然后马上想到全部一起平方加起来再减去最大的平方不就行了吗</p>
<h3 id="Q4-Largest-Factor"><a href="#Q4-Largest-Factor" class="headerlink" title="Q4: Largest Factor"></a>Q4: Largest Factor</h3><p>Write a function that takes an integer n that is greater than 1 and returns the largest integer that is smaller than n and evenly divides n.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def largest_factor(n):</span><br><span class="line">    &quot;&quot;&quot;Return the largest factor of n that is smaller than n.</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; largest_factor(15) # factors are 1, 3, 5</span><br><span class="line">    5</span><br><span class="line">    &gt;&gt;&gt; largest_factor(80) # factors are 1, 2, 4, 5, 8, 10, 16, 20, 40</span><br><span class="line">    40</span><br><span class="line">    &gt;&gt;&gt; largest_factor(13) # factor is 1 since 13 is prime</span><br><span class="line">    1</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    &quot;*** YOUR CODE HERE ***&quot;</span><br></pre></td></tr></table></figure>
<p>题目大意，找到比整数n小的最大的能整除n的数字</p>
<p>解题过程，直接循环，从1开始穷举，可以对循环条件除2或取根号2来减少循环次数</p>
<h3 id="Q5-If-Function-vs-Statement"><a href="#Q5-If-Function-vs-Statement" class="headerlink" title="Q5: If Function vs Statement"></a>Q5: If Function vs Statement</h3><p>Let’s try to write a function that does the same thing as an if statement.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def if_function(condition, true_result, false_result):</span><br><span class="line">    &quot;&quot;&quot;Return true_result if condition is a true value, and</span><br><span class="line">    false_result otherwise.</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; if_function(True, 2, 3)</span><br><span class="line">    2</span><br><span class="line">    &gt;&gt;&gt; if_function(False, 2, 3)</span><br><span class="line">    3</span><br><span class="line">    &gt;&gt;&gt; if_function(3==2, 3+2, 3-2)</span><br><span class="line">    1</span><br><span class="line">    &gt;&gt;&gt; if_function(3&gt;2, 3+2, 3-2)</span><br><span class="line">    5</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if condition:</span><br><span class="line">        return true_result</span><br><span class="line">    else:</span><br><span class="line">        return false_result</span><br></pre></td></tr></table></figure>
<p>Despite the doctests above, this function actually does not do the same thing as an if statement in all cases. To prove this fact, write functions cond, true_func, and false_func such that with_if_statement prints the number 47, but with_if_function prints both 42 and 47.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">def with_if_statement():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    &gt;&gt;&gt; result = with_if_statement()</span><br><span class="line">    47</span><br><span class="line">    &gt;&gt;&gt; print(result)</span><br><span class="line">    None</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if cond():</span><br><span class="line">        return true_func()</span><br><span class="line">    else:</span><br><span class="line">        return false_func()</span><br><span class="line"></span><br><span class="line">def with_if_function():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    &gt;&gt;&gt; result = with_if_function()</span><br><span class="line">    42</span><br><span class="line">    47</span><br><span class="line">    &gt;&gt;&gt; print(result)</span><br><span class="line">    None</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    return if_function(cond(), true_func(), false_func())</span><br><span class="line"></span><br><span class="line">def cond():</span><br><span class="line">    &quot;*** YOUR CODE HERE ***&quot;</span><br><span class="line"></span><br><span class="line">def true_func():</span><br><span class="line">    &quot;*** YOUR CODE HERE ***&quot;</span><br><span class="line"></span><br><span class="line">def false_func():</span><br><span class="line">    &quot;*** YOUR CODE HERE ***&quot;</span><br></pre></td></tr></table></figure>
<p>题目大意，通过编辑三个函数cond(),true_func(),false_func()，使得with_if_statement和with_if_fuction()产生预想的结果</p>
<p>解题过程，关键之关键在于了解到python中，将函数作为参数时，会先将函数运行，再将其结果作为参数返回，因此填上对应的数字，并调好条件cond就能成功解题</p>
<h3 id="Q6-Hailstone"><a href="#Q6-Hailstone" class="headerlink" title="Q6: Hailstone"></a>Q6: Hailstone</h3><p>Douglas Hofstadter’s Pulitzer-prize-winning book, Gödel, Escher, Bach, poses the following mathematical puzzle.</p>
<p>Pick a positive integer n as the start.<br>If n is even, divide it by 2.<br>If n is odd, multiply it by 3 and add 1.<br>Continue this process until n is 1.<br>The number n will travel up and down but eventually end at 1 (at least for all numbers that have ever been tried – nobody has ever proved that the sequence will terminate). Analogously, a hailstone travels up and down in the atmosphere before eventually landing on earth.</p>
<p>Breaking News (or at least the closest thing to that in math). There was a recent development in the hailstone conjecture last year that shows that almost all numbers will eventually get to 1 if you repeat this process. This isn’t a complete proof but a major breakthrough.</p>
<p>This sequence of values of n is often called a Hailstone sequence. Write a function that takes a single argument with formal parameter name n, prints out the hailstone sequence starting at n, and returns the number of steps in the sequence:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def hailstone(n):</span><br><span class="line">    &quot;&quot;&quot;Print the hailstone sequence starting at n and return its</span><br><span class="line">    length.</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; a = hailstone(10)</span><br><span class="line">    10</span><br><span class="line">    5</span><br><span class="line">    16</span><br><span class="line">    8</span><br><span class="line">    4</span><br><span class="line">    2</span><br><span class="line">    1</span><br><span class="line">    &gt;&gt;&gt; a</span><br><span class="line">    7</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    &quot;*** YOUR CODE HERE ***&quot;</span><br></pre></td></tr></table></figure>
<p>题目大意，有一种数学规律（尚未完全证明），对一个正整数，若其为偶数，则除2，若其为奇数，则乘3并加1，重复上述步骤，此数定终为1。现有n，输出n经上述规律到1的过程，并返回计算次数</p>
<p>解题过程，写循环，循环条件是数为1，每次循环输出该数，再设一个变量每次循环++即可</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>虽然题目不难，但仍发现了自己一些问题，比如审题不清，有一定的原因是题目是英语而非中文，不过都要适应嘛</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/02/29/[CS61A-Fall-2020]%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951%20Homework1%20%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF%E5%88%86%E4%BA%AB/" data-id="cm7j3ftgi0003uwag8h6z8yrh" data-title="【CS61A-Fall-2020】学习记录一 Homework1 题解思路分享" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CS61A/" rel="tag">CS61A</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/" rel="tag">Python</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-[Weekly Algorithm] 19算法周记之《代码随想录》图论（三）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/02/23/%5BWeekly%20Algorithm%5D%2019%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%9B%BE%E8%AE%BA%EF%BC%88%E4%B8%89%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2024-02-23T15:31:00.000Z" itemprop="datePublished">2024-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/02/23/%5BWeekly%20Algorithm%5D%2019%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%9B%BE%E8%AE%BA%EF%BC%88%E4%B8%89%EF%BC%89/">【Weekly Algorithm】算法周记之《代码随想录》图论（三）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h1><p>本周跟随《代码随想录》继续学习关于图论的知识，主要是关于并查集以及最小生成树的两个经典算法（prim和kruskal）。</p>
<p>并查集的作用在于快速区分不同的类别并补充内容。prim 则是从点的角度从图中划分出最小生成树，kruskal 是划分边来种最小生成树。</p>
<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><ul>
<li><h2 id="有向图的完全可达性"><a href="#有向图的完全可达性" class="headerlink" title="有向图的完全可达性"></a>有向图的完全可达性</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0105.%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%AE%8C%E5%85%A8%E5%8F%AF%E8%BE%BE%E6%80%A7.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1177">105. 有向图的完全可达性</a></p>
</li>
<li><p>问题：给一个有向图，但求中的1节点是否能到达其他节点。</p>
</li>
<li><p>方法：从 1 开始 dfs&#x2F;bfs 就可以，重点在于用邻接表存储</p>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void dfs(const vector&lt;list&lt;int&gt;&gt; grid, vector&lt;bool&gt; &amp;visited, int &amp;count, int node) &#123;</span><br><span class="line">    count++;</span><br><span class="line">    visited[node] = true;</span><br><span class="line">    // 遍历每个节点所链接的部分</span><br><span class="line">    for (const auto &amp;i : grid[node]) &#123;</span><br><span class="line">        if (visited[i]) continue;</span><br><span class="line">        dfs(grid, visited, count, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    </span><br><span class="line">    vector&lt;list&lt;int&gt;&gt; grid(n+1);</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">        int a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        grid[a].push_back(b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;bool&gt; visited(n+1, false);</span><br><span class="line">    int count = 0;</span><br><span class="line">    </span><br><span class="line">    dfs(grid, visited, count, 1);</span><br><span class="line">    </span><br><span class="line">    int result;</span><br><span class="line">    if (count == n) &#123;</span><br><span class="line">        result = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        result = -1;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    // 测试输出图</span><br><span class="line">    // for (int i = 0; i &lt; n+1; i++) &#123;</span><br><span class="line">    //     cout &lt;&lt; i &lt;&lt; &quot;: &quot;;</span><br><span class="line">    //     for (auto &amp;j : grid[i]) &#123;</span><br><span class="line">    //         cout &lt;&lt; j &lt;&lt; &quot; &quot;;</span><br><span class="line">    //     &#125;</span><br><span class="line">    //     cout &lt;&lt; endl;</span><br><span class="line">    // &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="岛屿的周长"><a href="#岛屿的周长" class="headerlink" title="岛屿的周长"></a>岛屿的周长</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0106.%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1178">106. 岛屿的周长</a></p>
</li>
<li><p>题意：二维数组中的岛屿没有内部水，求该一个岛屿的边缘周长。</p>
</li>
<li><p>方法：两个思路，一个是遍历岛屿，求每块的边界；第二个思路是求岛屿块数，4*块数 - 相邻区块的重叠边，该思路只要注意求相邻区块的方向不要重合，比如每个区块都只检查左上两个方向。</p>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 一格的四个方向</span><br><span class="line">int dr[4][2] = &#123;1, 0, -1, 0, 0, 1, 0, -1&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    </span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; grid(n, vector&lt;int&gt;(m, 0));</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 遍历统计边</span><br><span class="line">    int edge_num = 0;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            if (grid[i][j] == 0) continue;</span><br><span class="line">            </span><br><span class="line">            for (int k = 0; k &lt; 4; k++) &#123;</span><br><span class="line">                int nx = i + dr[k][0];</span><br><span class="line">                int ny = j + dr[k][1];</span><br><span class="line">                </span><br><span class="line">                if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m || grid[nx][ny] == 0) &#123;</span><br><span class="line">                    edge_num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; edge_num &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="寻找存在的路径"><a href="#寻找存在的路径" class="headerlink" title="寻找存在的路径"></a>寻找存在的路径</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0107.%E5%AF%BB%E6%89%BE%E5%AD%98%E5%9C%A8%E7%9A%84%E8%B7%AF%E5%BE%84.html">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1179">107. 寻找存在的路径</a></p>
</li>
<li><p>题意：给一个无向图和两个点，由于无向图不是连通，要判断两点是否连通</p>
</li>
<li><p>方法：用并查集，每次输入边就联系两点的并查集。</p>
</li>
<li><p>参考代码随想录思路的解法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int find(vector&lt;int&gt; &amp;father, int a) &#123;</span><br><span class="line">    return father[a] == a ? a : father[a] = find(father, father[a]);// 路径压缩</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    // n个点 m条边</span><br><span class="line">    vector&lt;int&gt; father(n+1, -1);</span><br><span class="line">    </span><br><span class="line">    // 初始化并查集</span><br><span class="line">    for (int i = 0; i &lt; n+1; i++) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        int a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        a = find(father, a);</span><br><span class="line">        b = find(father, b);</span><br><span class="line">        //cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">        if (a != b) father[a] = b;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // for (int i = 0; i &lt; n+1; i++) &#123;</span><br><span class="line">    //     cout &lt;&lt; father[i] &lt;&lt; endl;</span><br><span class="line">    // &#125;</span><br><span class="line">    </span><br><span class="line">    int source, destination;</span><br><span class="line">    cin &gt;&gt; source &gt;&gt; destination;</span><br><span class="line">    </span><br><span class="line">    // 本质上就是两个点是否属于统一个并查集（同一个无向连通图）</span><br><span class="line">    cout &lt;&lt; int(find(father, father[source])==find(father, father[destination])) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="冗余连接"><a href="#冗余连接" class="headerlink" title="冗余连接"></a>冗余连接</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0108.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1181">108. 冗余连接</a></p>
</li>
<li><p>题意：给一个无向图的构建，但要求返回最后一个连成环的边</p>
</li>
<li><p>方法：用并查集，一旦检测出一个边的两个点在同一个并查集，就返回这条边</p>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int find(vector&lt;int&gt; &amp;father, int a)&#123; // 查找并查集所属类</span><br><span class="line">    return father[a] == a ? a : father[a] = find(father, father[a]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool join(vector&lt;int&gt; &amp;father, int a, int b) &#123; // 尝试合并两个点</span><br><span class="line">    a = find(father, a);</span><br><span class="line">    b = find(father, b);</span><br><span class="line">    if (a == b) return false;</span><br><span class="line">    father[a] = b;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;int&gt; father(n, 0); // 并查集</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123; // 初始化</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        int a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        if (!join(father, a, b)) &#123;</span><br><span class="line">            cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="冗余连接II"><a href="#冗余连接II" class="headerlink" title="冗余连接II"></a>冗余连接II</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0109.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5II.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1182">109. 冗余连接II</a></p>
</li>
<li><p>题意：[[冗余连接]]的有向图版。</p>
</li>
<li><p>方法，由于无向图变成有向图，就不能无脑找那个并查集重复的那条边，这只能避免成环的情况，无法避免一个点有两个父节点的情况。</p>
</li>
<li><p>参考代码随想录思路的解法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">vector&lt;int&gt; father(1001, 0);</span><br><span class="line"></span><br><span class="line">// 并查集初始化</span><br><span class="line">void init() &#123;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) father[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 寻根</span><br><span class="line">int find(int u) &#123;</span><br><span class="line">    return father[u]==u ? u : father[u] = find(father[u]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 查看是否相同</span><br><span class="line">bool isSame(int p, int q) &#123;</span><br><span class="line">    return find(p) == find(q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 加入并查集</span><br><span class="line">void join(int p, int q) &#123;</span><br><span class="line">    p = find(p);</span><br><span class="line">    q = find(q);</span><br><span class="line">    if (p == q) return;</span><br><span class="line">    father[p] = q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在图里找到要删除的边</span><br><span class="line">// 原理是从前向后找到第一组同一个并查集的的一组点就行</span><br><span class="line">void deleteCircleEdge(const vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123;</span><br><span class="line">    init();</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        if (isSame(edges[i][0], edges[i][1])) &#123;</span><br><span class="line">            cout &lt;&lt; edges[i][0] &lt;&lt; &quot; &quot; &lt;&lt; edges[i][1] &lt;&lt; endl;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            join(edges[i][0], edges[i][1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 判断去除边后剩下能否成树</span><br><span class="line">bool isDelOk(const vector&lt;vector&lt;int&gt;&gt; edges, int del) &#123;</span><br><span class="line">    init();</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        if (i == del) continue;</span><br><span class="line">        if (isSame(edges[i][0], edges[i][1]))&#123; // 出现环说明删除到错的边了，换另一条即可</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        join(edges[i][0], edges[i][1]);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; edges; // 边的记录</span><br><span class="line">    vector&lt;int&gt; inDegree(n+1, 0); // 入度</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        int a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        edges.push_back(&#123;a,b&#125;);</span><br><span class="line">        inDegree[b]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 倒序添加入度为2的点对应的边</span><br><span class="line">    vector&lt;int&gt; vec;</span><br><span class="line">    for (int i = n-1; i &gt;= 0; i--) &#123;</span><br><span class="line">        if (inDegree[edges[i][1]] == 2) &#123;</span><br><span class="line">            vec.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 处理非成环的情况</span><br><span class="line">    if (vec.size() &gt; 0) &#123;</span><br><span class="line">        // 只有两种情况，倒数第一条或者倒数第二条</span><br><span class="line">        // 因为有可能倒数第一条取出后，会产生孤立点，所以去除另一条边</span><br><span class="line">        if (isDelOk(edges, vec[0])) &#123;</span><br><span class="line">            cout &lt;&lt; edges[vec[0]][0] &lt;&lt; &quot; &quot; &lt;&lt; edges[vec[0]][1] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            cout &lt;&lt; edges[vec[1]][0] &lt;&lt; &quot; &quot; &lt;&lt; edges[vec[1]][1] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 处理有向环</span><br><span class="line">    deleteCircleEdge(edges);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="最小生成树之prim"><a href="#最小生成树之prim" class="headerlink" title="最小生成树之prim"></a>最小生成树之prim</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0053.%E5%AF%BB%E5%AE%9D-prim.html#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1053">53. 寻宝（第七期模拟笔试）</a></p>
</li>
<li><p>题意：本质就是求最小生成树的值大小</p>
</li>
<li><p>方法：prim算法<br>分三步：  </p>
<ol>
<li>找到与最小生成树距离最近的节点（初始化就随便一个都行）</li>
<li>把节点加入最小生成树</li>
<li>根据加入节点，更新其他节点与最小生成树的距离</li>
</ol>
</li>
<li><p>但是具体实现还有很多细节，写在了注释中。</p>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;climits&gt;// INT_MAX</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int v, e;</span><br><span class="line">    cin &gt;&gt; v &gt;&gt; e;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; grid(v+1, vector&lt;int&gt;(v+1, 0));</span><br><span class="line">    for (int i = 0; i &lt; e; i++) &#123;</span><br><span class="line">        int x, y, k;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line">        grid[x][y] = k;</span><br><span class="line">        grid[y][x] = k;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; min_dist(v+1, 10001);// 题目最大值10000</span><br><span class="line">    vector&lt;bool&gt; visited(v+1, false);</span><br><span class="line">    // 找到构成最小生成树的v-1条边</span><br><span class="line">    for (int i = 1; i &lt; v; i++) &#123;</span><br><span class="line">        int min_val = INT_MAX;</span><br><span class="line">        int cur = -1;// 要加入最小生成树的点</span><br><span class="line">        </span><br><span class="line">        for (int j = 1; j &lt;= v; j++) &#123; // 遍历所有点</span><br><span class="line">            // 找一个不在树里面，且与最小生成树距离最小的点</span><br><span class="line">            if (!visited[j] &amp;&amp; min_dist[j] &lt; min_val) &#123;</span><br><span class="line">                min_val = min_dist[j];</span><br><span class="line">                cur = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 加入最小生成树的点</span><br><span class="line">        visited[cur] = true;</span><br><span class="line">        </span><br><span class="line">        // 遍历与加入点相连的其它点，更新与最小生成树的距离</span><br><span class="line">        for (int i = 1; i &lt;= v; i++) &#123;</span><br><span class="line">            if (visited[i]) continue; // 已在树内</span><br><span class="line">            if (grid[cur][i] == 0) continue; // 无连接</span><br><span class="line">            if (grid[cur][i] &lt; min_dist[i]) &#123;</span><br><span class="line">                min_dist[i] = grid[cur][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int result = 0;</span><br><span class="line">    for (int i = 2; i &lt;= v; i++) &#123; // 之所以i从2开始，是因为min_dist[1]不会赋值</span><br><span class="line">    // 从理解的角度，1一开始就在树内，所以没有计算距离（或是距离为0）</span><br><span class="line">        result += min_dist[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="最小生成树之kruskal"><a href="#最小生成树之kruskal" class="headerlink" title="最小生成树之kruskal"></a>最小生成树之kruskal</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0053.%E5%AF%BB%E5%AE%9D-Kruskal.html#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1053">53. 寻宝（第七期模拟笔试）</a></p>
</li>
<li><p>题目：与[[最小生成树之prim]]一样，但方法不同。</p>
</li>
<li><p>方法：kruskal看边，而prim看点。简单地说，kruskal会升序遍历边，不断加入不同并查集的边，最后得到最小生成树。</p>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;climits&gt;// INT_MAX</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef struct _Edge &#123;</span><br><span class="line">    int l;</span><br><span class="line">    int r;</span><br><span class="line">    int val;</span><br><span class="line">&#125;Edge;</span><br><span class="line"></span><br><span class="line">int n = 10001;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; father(n, 0);</span><br><span class="line"></span><br><span class="line">int find(int u) &#123;</span><br><span class="line">    return father[u]==u ? u : father[u] = find(father[u]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void join(int u, int v) &#123;</span><br><span class="line">    u = find(u);</span><br><span class="line">    v = find(v);</span><br><span class="line">    if (u == v) return;</span><br><span class="line">    father[u] = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isSame(int u, int v) &#123;</span><br><span class="line">    return find(u) == find(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    for (int i = 0; i &lt; 10001; i++) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;                                                     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int v, e;</span><br><span class="line">    cin &gt;&gt; v &gt;&gt; e;</span><br><span class="line">    </span><br><span class="line">    vector&lt;Edge&gt; edge;</span><br><span class="line">    </span><br><span class="line">    while(e--) &#123;</span><br><span class="line">        int l, r, val;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r &gt;&gt; val;</span><br><span class="line">        edge.push_back(&#123;l, r, val&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sort(edge.begin(), edge.end(), [](Edge &amp;e1, Edge &amp;e2) &#123;return e1.val &lt; e2.val;&#125;);</span><br><span class="line">    </span><br><span class="line">    init();</span><br><span class="line">    int result = 0;</span><br><span class="line">    </span><br><span class="line">    for (const auto &amp; line : edge) &#123;</span><br><span class="line">        int l = find(line.l);</span><br><span class="line">        int r = find(line.r);</span><br><span class="line">        if (l != r) &#123;</span><br><span class="line">            join(l, r);</span><br><span class="line">            result += line.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/02/23/[Weekly%20Algorithm]%2019%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%9B%BE%E8%AE%BA%EF%BC%88%E4%B8%89%EF%BC%89/" data-id="cm7j3ftgz001guwagdypn9qjh" data-title="【Weekly Algorithm】算法周记之《代码随想录》图论（三）" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-[Weekly Algorithm] 18算法周记之《代码随想录》图论（二）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/02/16/%5BWeekly%20Algorithm%5D%2018%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%9B%BE%E8%AE%BA%EF%BC%88%E4%BA%8C%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2024-02-16T14:11:00.000Z" itemprop="datePublished">2024-02-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/02/16/%5BWeekly%20Algorithm%5D%2018%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%9B%BE%E8%AE%BA%EF%BC%88%E4%BA%8C%EF%BC%89/">【Weekly Algorithm】算法周记之《代码随想录》图论（二）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h1><p>本周跟随《代码随想录》继续学习关于图论的知识，主要是学习岛屿，也就是 bfs&#x2F;dfs 的经典应用。同时还有[[字符串接龙]]这种新颖的图论题目，才知道各种字符串也能抽象为一个图。</p>
<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><ul>
<li><h2 id="岛屿数量广搜版"><a href="#岛屿数量广搜版" class="headerlink" title="岛屿数量广搜版"></a>岛屿数量广搜版</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0099.%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%95%B0%E9%87%8F%E5%B9%BF%E6%90%9C.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1171">99. 岛屿数量</a></p>
</li>
<li><p>直接说明区别和放代码好力，代码就是在[[岛屿数量深搜版]]的基础上做了一点更改，原本的搜索函数不断递归向深了探索，现在是用队列（栈也可，区别在于遍历顺序）来记录要遍历的区块，再按顺序处理</p>
</li>
<li><p>修改后的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int dir[4][2] = &#123;0, 1, 1, 0, -1, 0, 0, -1&#125;;</span><br><span class="line">void bfs(const vector&lt;vector&lt;int&gt;&gt; &amp;grid, vector&lt;vector&lt;bool&gt;&gt; &amp;visited, int x, int y) &#123;</span><br><span class="line">    queue&lt;pair&lt;int, int&gt;&gt; q;</span><br><span class="line">    q.push(make_pair(x, y));</span><br><span class="line">    while (!q.empty()) &#123;</span><br><span class="line">        int tmpx = q.front().first;</span><br><span class="line">        int tmpy = q.front().second;</span><br><span class="line">        q.pop();</span><br><span class="line">        for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">            int nextx = tmpx + dir[i][0];</span><br><span class="line">            int nexty = tmpy + dir[i][1];</span><br><span class="line">            if (nextx &lt; 0 || nextx &gt;= grid.size() || nexty &lt; 0 || nexty &gt;= grid[0].size()) continue;</span><br><span class="line">            if (!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == 1) &#123;</span><br><span class="line">                visited[nextx][nexty] = true;</span><br><span class="line">                q.push(make_pair(nextx, nexty));</span><br><span class="line">                // dfs(grid, visited, nextx, nexty);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; grid(n, vector&lt;int&gt;(m, 0));</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;bool&gt;&gt; visited(n, vector&lt;bool&gt;(m, false));</span><br><span class="line">    </span><br><span class="line">    int result = 0;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            if (!visited[i][j] &amp;&amp; grid[i][j] == 1) &#123;</span><br><span class="line">                visited[i][j] = true;</span><br><span class="line">                result++;</span><br><span class="line">                bfs(grid, visited, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="岛屿的最大面积"><a href="#岛屿的最大面积" class="headerlink" title="岛屿的最大面积"></a>岛屿的最大面积</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0100.%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1172">100. 岛屿的最大面积</a></p>
</li>
<li><p>题意：给一个二维数组，求其中纵横相连最大区块面积</p>
</li>
<li><p>方法：dfs&#x2F;bfs</p>
</li>
<li><p>从零手搓代码，重点在于visited的更新要及时，这也是易忘点<br>第一次把visited放再递归前，少了第一块的计算，故最后会多1<br>下面是最后修正的正确代码  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int result = 0;</span><br><span class="line"></span><br><span class="line">int dr[4][2] = &#123;1, 0, 0, 1, -1, 0, 0, -1&#125;;</span><br><span class="line"></span><br><span class="line">void dfs(const vector&lt;vector&lt;int&gt;&gt; &amp;grid, vector&lt;vector&lt;int&gt;&gt; &amp;visited, int &amp;cur_area, int x, int y) &#123;</span><br><span class="line">    cur_area++;</span><br><span class="line">    visited[x][y] = 1;</span><br><span class="line">    //cout &lt;&lt; &quot;visiting:&quot; &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">        int tmpx = x + dr[i][0];</span><br><span class="line">        int tmpy = y + dr[i][1];</span><br><span class="line">        if (tmpx &lt; 0 || tmpx &gt;= grid.size() || tmpy &lt; 0 || tmpy &gt;= grid[0].size()) continue;</span><br><span class="line">        if (grid[tmpx][tmpy] == 1 &amp;&amp; visited[tmpx][tmpy] == 0) &#123;</span><br><span class="line">            dfs(grid, visited, cur_area, tmpx, tmpy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; grid(n, vector&lt;int&gt;(m, 0));</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; visited(grid);</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            int cur_area = 0;</span><br><span class="line">            if (!(grid[i][j] == 1 &amp;&amp; visited[i][j] == 0)) continue;</span><br><span class="line">            dfs(grid, visited, cur_area, i, j);</span><br><span class="line">            if (cur_area &gt; result) result = cur_area;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="孤岛的总面积"><a href="#孤岛的总面积" class="headerlink" title="孤岛的总面积"></a>孤岛的总面积</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0101.%E5%AD%A4%E5%B2%9B%E7%9A%84%E6%80%BB%E9%9D%A2%E7%A7%AF.html">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1173">101. 孤岛的总面积</a></p>
</li>
<li><p>题意：求没有与边缘相连的纵横相连区块的总面积</p>
</li>
<li><p>方法：先对边缘的岛屿用dfs&#x2F;bfs，排除这些区块，然后再遍历中间的面积。</p>
</li>
<li><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int dr[4][2] = &#123;0, 1, 0, -1, 1, 0, -1, 0&#125;;</span><br><span class="line"></span><br><span class="line">void dfs(vector&lt;vector&lt;int&gt;&gt; &amp;grid, vector&lt;vector&lt;bool&gt;&gt; &amp;visited, int x, int y) &#123;</span><br><span class="line">    visited[x][y] = true;</span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">        int nextx = x + dr[i][0];</span><br><span class="line">        int nexty = y + dr[i][1];</span><br><span class="line">        if (nextx &lt; 0 || nextx &gt;= grid.size() || nexty &lt; 0 || nexty &gt;= grid[0].size()) continue;</span><br><span class="line">        if (!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == 1) &#123;</span><br><span class="line">            dfs(grid, visited, nextx, nexty);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; grid(n, vector&lt;int&gt;(m, 0));</span><br><span class="line">    vector&lt;vector&lt;bool&gt;&gt; visited(n, vector&lt;bool&gt;(m, false));</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        if (grid[i][0] == 1 &amp;&amp; !visited[i][0]) &#123;</span><br><span class="line">            dfs(grid, visited, i, 0);</span><br><span class="line">        &#125;</span><br><span class="line">        if (grid[i][m-1] &amp;&amp; !visited[i][m-1]) &#123;</span><br><span class="line">            dfs(grid, visited, i, m-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        if (grid[0][i] == 1 &amp;&amp; !visited[0][i]) &#123;</span><br><span class="line">            dfs(grid, visited, 0, i);</span><br><span class="line">        &#125;</span><br><span class="line">        if (grid[n-1][i] &amp;&amp; !visited[n-1][i]) &#123;</span><br><span class="line">            dfs(grid, visited, n-1, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int result = 0;</span><br><span class="line">    for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 1; j &lt; m; j++) &#123;</span><br><span class="line">            if (!visited[i][j] &amp;&amp; grid[i][j] == 1) &#123;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="沉没孤岛"><a href="#沉没孤岛" class="headerlink" title="沉没孤岛"></a>沉没孤岛</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0102.%E6%B2%89%E6%B2%A1%E5%AD%A4%E5%B2%9B.html">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1174">102. 沉没孤岛</a></p>
</li>
<li><p>题意：就是求孤岛之外的面积之和</p>
</li>
<li><p>方法：[[孤岛的总面积]]的小变式，只要在计算边缘区块时计算面积就行</p>
</li>
<li><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int dr[4][2] = &#123;0, 1, 0, -1, 1, 0, -1, 0&#125;;</span><br><span class="line"></span><br><span class="line">void dfs(vector&lt;vector&lt;int&gt;&gt; &amp;grid, vector&lt;vector&lt;bool&gt;&gt; &amp;visited, int x, int y) &#123;</span><br><span class="line">    visited[x][y] = true;</span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">        int nextx = x + dr[i][0];</span><br><span class="line">        int nexty = y + dr[i][1];</span><br><span class="line">        if (nextx &lt; 0 || nextx &gt;= grid.size() || nexty &lt; 0 || nexty &gt;= grid[0].size()) continue;</span><br><span class="line">        if (!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == 1) &#123;</span><br><span class="line">            dfs(grid, visited, nextx, nexty);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; grid(n, vector&lt;int&gt;(m, 0));</span><br><span class="line">    vector&lt;vector&lt;bool&gt;&gt; visited(n, vector&lt;bool&gt;(m, false));</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        if (grid[i][0] == 1 &amp;&amp; !visited[i][0]) &#123;</span><br><span class="line">            dfs(grid, visited, i, 0);</span><br><span class="line">        &#125;</span><br><span class="line">        if (grid[i][m-1] &amp;&amp; !visited[i][m-1]) &#123;</span><br><span class="line">            dfs(grid, visited, i, m-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        if (grid[0][i] == 1 &amp;&amp; !visited[0][i]) &#123;</span><br><span class="line">            dfs(grid, visited, 0, i);</span><br><span class="line">        &#125;</span><br><span class="line">        if (grid[n-1][i] &amp;&amp; !visited[n-1][i]) &#123;</span><br><span class="line">            dfs(grid, visited, n-1, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            if (visited[i][j] == true) &#123;</span><br><span class="line">                cout &lt;&lt; &quot;1 &quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                cout &lt;&lt; &quot;0 &quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="水流问题"><a href="#水流问题" class="headerlink" title="水流问题"></a>水流问题</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0103.%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98.html#%E4%BC%98%E5%8C%96">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1175">103. 水流问题</a></p>
</li>
<li><p>题意：给一个数组，找其中所有能够到达（左||上）&amp;&amp;（右||下）从高到低（同值也行）的格子</p>
</li>
<li><p>方法：普通思路是对每一个格子都做遍历，看是否能到两种边界。但是复杂度过高。反过来，从两种边界逆流遍历，再求两次遍历的交集即可获得格子</p>
</li>
<li><p>参考代码随想录思路的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n, m;</span><br><span class="line">int dir[4][2] = &#123;-1, 0, 0, -1, 1, 0, 0, 1&#125;;</span><br><span class="line">void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int x, int y) &#123;</span><br><span class="line">    if (visited[x][y]) return;</span><br><span class="line"></span><br><span class="line">    visited[x][y] = true;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">        int nextx = x + dir[i][0];</span><br><span class="line">        int nexty = y + dir[i][1];</span><br><span class="line">        if (nextx &lt; 0 || nextx &gt;= n || nexty &lt; 0 || nexty &gt;= m) continue;</span><br><span class="line">        if (grid[x][y] &gt; grid[nextx][nexty]) continue; // 注意：这里是从低向高遍历</span><br><span class="line"></span><br><span class="line">        dfs (grid, visited, nextx, nexty);</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; grid(n, vector&lt;int&gt;(m, 0));</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 逆流遍历,这些本质上就是visited</span><br><span class="line">    vector&lt;vector&lt;bool&gt;&gt; firstBoard(n, vector&lt;bool&gt;(m, false));</span><br><span class="line">    vector&lt;vector&lt;bool&gt;&gt; secondBoard(firstBoard);</span><br><span class="line">    </span><br><span class="line">    // 从第一组边界和第二组边界分别逆推</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        dfs(grid, firstBoard, i, 0);</span><br><span class="line">        dfs(grid, secondBoard, i, m-1);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        dfs(grid, firstBoard, 0, i);</span><br><span class="line">        dfs(grid, secondBoard, n-1, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 遍历并输出最终结果</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            if (firstBoard[i][j] &amp;&amp; secondBoard[i][j]) &#123;</span><br><span class="line">                cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="建造最大工岛"><a href="#建造最大工岛" class="headerlink" title="建造最大工岛"></a>建造最大工岛</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0104.%E5%BB%BA%E9%80%A0%E6%9C%80%E5%A4%A7%E5%B2%9B%E5%B1%BF.html#%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1176">104. 建造最大岛屿</a></p>
</li>
<li><p>题意：给一个二维数组，沿用上面的岛屿设定，不过本题可以最多填充一块陆地，求填充完最大的陆地面积</p>
</li>
<li><p>方法：普通的暴力思路是对每块海洋求四边的陆地和；优化后，先把所有陆地给遍历，求各陆地面积，避免暴力思路中的重复遍历。</p>
<p>实现的重点在于，考虑全陆地的情况，并且要考虑到四边的陆地可能是同一块陆地，所以要去重。  </p>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &lt;unordered_set&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n, m;</span><br><span class="line"></span><br><span class="line">int dr[4][2] = &#123;0, 1, 0, -1, 1, 0, -1, 0&#125;;</span><br><span class="line"></span><br><span class="line">void dfs(vector&lt;vector&lt;int&gt;&gt; &amp;grid, vector&lt;vector&lt;bool&gt;&gt; &amp;visited, int x, int y, int &amp;count, int mark) &#123;</span><br><span class="line">    // 加速返回</span><br><span class="line">    if (visited[x][y] || grid[x][y] == 0) return;</span><br><span class="line">    count++;</span><br><span class="line">    visited[x][y] = true;</span><br><span class="line">    grid[x][y] = mark;</span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">        int nextx = x + dr[i][0];</span><br><span class="line">        int nexty = y + dr[i][1];</span><br><span class="line">        if (nextx &lt; 0 || nextx &gt;= n || nexty &lt; 0 || nexty &gt;= m) continue;</span><br><span class="line">        if (grid[nextx][nexty] == 1 &amp;&amp; !visited[nextx][nexty]) &#123;</span><br><span class="line">            dfs(grid, visited, nextx, nexty, count, mark);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; grid(n, vector&lt;int&gt;(m, 0));</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;bool&gt;&gt; visited(n, vector&lt;bool&gt;(m, false));</span><br><span class="line">    unordered_map&lt;int, int&gt; gridNum;</span><br><span class="line">    </span><br><span class="line">    int flagNum = 2;</span><br><span class="line">    bool isAllGrid = true;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            if (grid[i][j] == 0) isAllGrid = false;</span><br><span class="line">            int count = 0;</span><br><span class="line">            if (!visited[i][j] &amp;&amp; grid[i][j] == 1) &#123;</span><br><span class="line">                dfs(grid, visited, i, j, count, flagNum);</span><br><span class="line">                gridNum[flagNum] = count;</span><br><span class="line">                //cout &lt;&lt; &quot;flagNum:&quot; &lt;&lt; flagNum &lt;&lt; &quot;; count:&quot; &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">                flagNum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (isAllGrid) &#123;</span><br><span class="line">        cout &lt;&lt; n*m &lt;&lt; endl;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    unordered_set&lt;int&gt; visitGrid;</span><br><span class="line">    int result = 0;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            if (grid[i][j] != 0) continue;</span><br><span class="line">            visitGrid.clear();</span><br><span class="line">            int area = 1;</span><br><span class="line">            //cout &lt;&lt; &quot;出发：&quot; &lt;&lt; i &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">            for (int k = 0; k &lt; 4; k++) &#123;</span><br><span class="line">                int nx = i + dr[k][0];</span><br><span class="line">                int ny = j + dr[k][1];</span><br><span class="line">                //cout &lt;&lt; &quot;查看：&quot; &lt;&lt; nx &lt;&lt; ny &lt;&lt; endl;</span><br><span class="line">                if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m || grid[nx][ny] == 0) continue;</span><br><span class="line">                if (visitGrid.count(grid[nx][ny])) continue;</span><br><span class="line">                area += gridNum[grid[nx][ny]];</span><br><span class="line">                //cout &lt;&lt; &quot;发现：&quot; &lt;&lt; grid[nx][ny] &lt;&lt; &quot;;gridNum:&quot; &lt;&lt; gridNum[grid[nx][ny]] &lt;&lt; &quot;;area:&quot; &lt;&lt; area &lt;&lt; endl;</span><br><span class="line">                visitGrid.insert(grid[nx][ny]);</span><br><span class="line">            &#125;</span><br><span class="line">            result = max(result, area);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="字符串接龙"><a href="#字符串接龙" class="headerlink" title="字符串接龙"></a>字符串接龙</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0110.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%A5%E9%BE%99.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1183">110. 字符串接龙</a></p>
</li>
<li><p>题意：给一个起始字符串和终止字符串，以及一系列字符串，求起始字符串每次更改一个字符，从这些字符串最少更改几步到终止字符串。</p>
</li>
<li><p>方法：看作从起始字符串开始的无向图，向周围bfs（bfs比dfs更方便找最短路径），也就是逐个尝试26字母。</p>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt; </span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;unordered_set&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string beginStr, endStr, str;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    unordered_set&lt;string&gt; strSet;</span><br><span class="line">    cin &gt;&gt; beginStr &gt;&gt; endStr;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; str;</span><br><span class="line">        strSet.insert(str);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 记录字符串是否访问，以及访问到字符串的路径长度</span><br><span class="line">    unordered_map&lt;string, int&gt; visitMap; </span><br><span class="line">    </span><br><span class="line">    // 为了bfs的队列</span><br><span class="line">    queue&lt;string&gt; que;</span><br><span class="line">    que.push(beginStr);</span><br><span class="line">    </span><br><span class="line">    // 起始的长度为1</span><br><span class="line">    visitMap.insert(make_pair(beginStr, 1));</span><br><span class="line">    </span><br><span class="line">    while(!que.empty()) &#123;</span><br><span class="line">        string word = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        int path = visitMap[word];</span><br><span class="line">        </span><br><span class="line">        // 对于word逐个字符尝试替换，然后匹配strSet</span><br><span class="line">        for (int i = 0; i &lt; word.size(); i++) &#123;</span><br><span class="line">            string newWord = word;</span><br><span class="line">            </span><br><span class="line">            // 遍历所有字母</span><br><span class="line">            for (int j = 0; j &lt; 26; j++) &#123;</span><br><span class="line">                newWord[i] = j + &#x27;a&#x27;;</span><br><span class="line">                // 到达重点，直接结束</span><br><span class="line">                if (newWord == endStr) &#123;</span><br><span class="line">                    cout &lt;&lt; path+1 &lt;&lt; endl;</span><br><span class="line">                    return 0;</span><br><span class="line">                &#125;</span><br><span class="line">                // 与字典匹配且没有匹配过</span><br><span class="line">                if (strSet.find(newWord) != strSet.end() &amp;&amp;</span><br><span class="line">                visitMap.find(newWord) == visitMap.end()) &#123;</span><br><span class="line">                    // 记录访问结果，并添加队列</span><br><span class="line">                    visitMap.insert(make_pair(newWord, path+1));</span><br><span class="line">                    que.push(newWord);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 无结果</span><br><span class="line">    cout &lt;&lt; 0 &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/02/16/[Weekly%20Algorithm]%2018%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%9B%BE%E8%AE%BA%EF%BC%88%E4%BA%8C%EF%BC%89/" data-id="cm7j3ftgz001euwag82ms6p5e" data-title="【Weekly Algorithm】算法周记之《代码随想录》图论（二）" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-[Weekly Algorithm] 17算法周记之《代码随想录》单调栈和图论（一）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/02/09/%5BWeekly%20Algorithm%5D%2017%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8D%95%E8%B0%83%E6%A0%88%E5%92%8C%E5%9B%BE%E8%AE%BA%EF%BC%88%E4%B8%80%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2024-02-09T11:12:00.000Z" itemprop="datePublished">2024-02-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/02/09/%5BWeekly%20Algorithm%5D%2017%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8D%95%E8%B0%83%E6%A0%88%E5%92%8C%E5%9B%BE%E8%AE%BA%EF%BC%88%E4%B8%80%EF%BC%89/">【Weekly Algorithm】算法周记之《代码随想录》单调栈和图论（一）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h1><p>本周跟随《代码随想录》学习关于单调栈的知识，同时开启图论。</p>
<p>单调栈通过保持一个栈从栈顶到栈底的递增或是递减序列，来解决找一个元素左&#x2F;右的“第一个”更大&#x2F;更小元素。</p>
<p>图论则是初窥dfs的门路，虽然道理一年前早在算法课学过考过，但现在也得复习才能捡回来。</p>
<h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><ul>
<li><h2 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a>每日温度</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0739.%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意：给一个整数数组，求每个数字右侧比该数字更大的间距</p>
</li>
<li><p>方法：暴力解法就是O(n^2)的遍历。更高效率的方法是使用单调栈，所谓的单调栈就是从栈顶到栈底递增或递减的，如此排列，就能方便找任意元素的左右第一个更大更小的元素。</p>
<p>比如本题是找右边更大的，那么遍历数组时，遇到更小或相等的元素就直接入栈，而遇到更大的元素就弹栈，直到触底或碰到大元素再入栈，其中弹栈的元素就能记录本元素的下标与当时元素下标之差。  </p>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) &#123;</span><br><span class="line">        vector&lt;int&gt; result(temperatures.size(), 0);</span><br><span class="line"></span><br><span class="line">        stack&lt;int&gt; st;</span><br><span class="line"></span><br><span class="line">        st.push(0);</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; temperatures.size(); i++) &#123;</span><br><span class="line">            if (temperatures[i] &lt;= temperatures[st.top()]) &#123;</span><br><span class="line">                st.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                while(!st.empty() &amp;&amp; temperatures[i] &gt; temperatures[st.top()]) &#123;</span><br><span class="line">                    result[st.top()] = i - st.top();</span><br><span class="line">                    st.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                st.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="下一个更大的元素I"><a href="#下一个更大的元素I" class="headerlink" title="下一个更大的元素I"></a>下一个更大的元素I</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0496.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0I.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-greater-element-i/">496. 下一个更大元素 I - 力扣（LeetCode）</a></p>
</li>
<li><p>题意：给两个整数数组，找一个数组在另一个数组对应元素的下一个更大元素的集合。</p>
</li>
<li><p>方法：用哈希建立两个数组元素和下标的对应，单调栈则实现元素的下一个更大的元素。</p>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">        // 按照代码随想录思路，用哈希表构建两数组之间的映射，然后得出nums2单调栈，由此就得到了结果</span><br><span class="line">        unordered_map&lt;int, int&gt; umap; // 从nums2数字到nums1对应数字下标的映射</span><br><span class="line">        for (int i = 0; i &lt; nums1.size(); i++) &#123;</span><br><span class="line">            umap[nums1[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 求nums2单调栈</span><br><span class="line">        // vector&lt;int&gt; next(nums2.size(), -1);</span><br><span class="line">        stack&lt;int&gt; st;</span><br><span class="line">        vector&lt;int&gt; result(nums1.size(), -1);</span><br><span class="line">        if (result.size() == 1) return result;</span><br><span class="line">        st.push(0);</span><br><span class="line"></span><br><span class="line">        for(int i = 1; i &lt; nums2.size(); i++) &#123;</span><br><span class="line">            if (nums2[i] &lt;= nums2[st.top()]) &#123;</span><br><span class="line">                st.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                while(!st.empty() &amp;&amp; nums2[i] &gt; nums2[st.top()]) &#123;</span><br><span class="line">                    // next[st.top()] = i - st.top();</span><br><span class="line">                    if (umap.count(nums2[st.top()]) &gt; 0) &#123;</span><br><span class="line">                        result[umap[nums2[st.top()]]] = nums2[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                    st.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                st.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="下一个更大的元素II"><a href="#下一个更大的元素II" class="headerlink" title="下一个更大的元素II"></a>下一个更大的元素II</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0503.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0II.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-greater-element-ii/description/">503. 下一个更大元素 II - 力扣（LeetCode）</a></p>
</li>
<li><p>题意：和[[下一个更大的元素I]]相似，但是下一个更大元素要看循环数组。</p>
</li>
<li><p>方法：解决循环以往就有把数组循环乘二的情况，但是这种处理方式对于空间稍显浪费，所以还有一种方式，就是循环时当作两倍的情况。</p>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; result(nums.size(), -1);</span><br><span class="line"></span><br><span class="line">        stack&lt;int&gt; st;</span><br><span class="line">        st.push(0);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; nums.size()*2; i++) &#123;</span><br><span class="line">            if (nums[i % nums.size()] &lt;= nums[st.top()]) &#123;</span><br><span class="line">                st.push(i % nums.size());</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                while(!st.empty() &amp;&amp; nums[i % nums.size()] &gt; nums[st.top()]) &#123;</span><br><span class="line">                    result[st.top()] = nums[i % nums.size()];</span><br><span class="line">                    st.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                st.push(i % nums.size());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0042.%E6%8E%A5%E9%9B%A8%E6%B0%B4.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意，给一个高度数组，每个数字代表柱子高度，求下完雨后，柱子之间积水量</p>
</li>
<li><p>方法，暴力解法，按行或列求，以按列为例，对每一列求其左右最高柱子高度，取最小值，与该列高度差为该列水量。优化方法是用双指针，分别从两侧向另一侧遍历，求每个柱子一侧方向的最高柱子，这样就避免了暴力方法中重复求两侧柱子高度的浪费；</p>
<p>重点在于单调栈方法，按行求，单调栈保持递增（栈顶到栈底），具体处理方法写在注释中  </p>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int trap(vector&lt;int&gt;&amp; height) &#123;</span><br><span class="line">        stack&lt;int&gt; st;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        st.push(0);</span><br><span class="line">        for (int i = 1; i &lt; height.size(); i++) &#123;</span><br><span class="line">            // 三种情况</span><br><span class="line">            // 第一种，后续柱子高度低于栈顶，则直接入栈</span><br><span class="line">            if (height[i] &lt; height[st.top()]) &#123;</span><br><span class="line">                st.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">            // 第二种，后续柱子高度与栈顶一致，则更新栈顶，坐标保留靠右的</span><br><span class="line">            // 因为如果右侧有凹陷，计算积水的左侧左边起始是从靠右的柱子开始计算</span><br><span class="line">            else if (height[i] == height[st.top()]) &#123;</span><br><span class="line">                st.pop();</span><br><span class="line">                st.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">            // 第三种，后续柱子比栈顶高，开始计算积水</span><br><span class="line">            // 总得来说，就是计算i，栈顶和栈顶前一个柱子三个柱子之间的积水</span><br><span class="line">            // 高度上，取左右两柱子的最小值，宽度上，就计算左右柱子的间隔就好</span><br><span class="line">            // 上述步骤循环，直至新柱子小于栈顶位置再入栈（或者栈空）</span><br><span class="line">            // 计算完成后，左侧柱子在栈顶位置，还有计算价值，毕竟说不定后续用作底部柱子使用</span><br><span class="line">            else &#123;</span><br><span class="line">                while(!st.empty() &amp;&amp; height[i] &gt; height[st.top()]) &#123;</span><br><span class="line">                    int bottom = height[st.top()];</span><br><span class="line">                    st.pop();</span><br><span class="line">                    if (!st.empty()) &#123; // 防止遇到没有左侧柱子的情况</span><br><span class="line">                        int h = min(height[i], height[st.top()]) - bottom;</span><br><span class="line">                        int w = i - st.top() - 1;</span><br><span class="line">                        sum += h*w;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                st.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="柱状图中最大的矩形"><a href="#柱状图中最大的矩形" class="headerlink" title="柱状图中最大的矩形"></a>柱状图中最大的矩形</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0084.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-rectangle-in-histogram/submissions/597563485/">84. 柱状图中最大的矩形 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意：给一个柱状图（数组表示）求其中最大矩形面积</p>
</li>
<li><p>方法：实际上与[[接雨水]]相似，但是单调栈方向相反，[[接雨水]]栈顶到栈底递增，如此就能对于每个柱子找到旁边更大的柱子；这里则是递减，找到更小的柱子，以两侧小柱子为下标区间，乘以基准柱子高度，就是一块矩形面积</p>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;</span><br><span class="line">        heights.insert(heights.begin(), 0);</span><br><span class="line">        heights.push_back(0);</span><br><span class="line">        stack&lt;int&gt; st;// 存储下标</span><br><span class="line">        int result = 0;</span><br><span class="line">        </span><br><span class="line">        st.push(0);</span><br><span class="line">        for (int i = 1; i &lt; heights.size(); i++) &#123;</span><br><span class="line">            if (heights[st.top()] &lt; heights[i]) &#123;</span><br><span class="line">                st.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (heights[st.top()] == heights[i]) &#123;</span><br><span class="line">                st.pop();</span><br><span class="line">                st.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                while(!st.empty() &amp;&amp; heights[st.top()] &gt; heights[i]) &#123;</span><br><span class="line">                    int mid = st.top();</span><br><span class="line">                    st.pop();</span><br><span class="line">                    if (!st.empty()) &#123;</span><br><span class="line">                        int left = st.top();</span><br><span class="line">                        int right = i;</span><br><span class="line">                        int w = right - left - 1;</span><br><span class="line">                        int h = heights[mid];</span><br><span class="line">                        result = max(result, h * w);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                st.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><ul>
<li><h2 id="所有可达路径"><a href="#所有可达路径" class="headerlink" title="所有可达路径"></a>所有可达路径</h2></li>
<li><a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0098.%E6%89%80%E6%9C%89%E5%8F%AF%E8%BE%BE%E8%B7%AF%E5%BE%84.html#%E6%9C%AC%E9%A2%98%E4%BB%A3%E7%A0%81">代码随想录</a></li>
<li><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1170">98. 所有可达路径</a></li>
<li>题意：给一个无环有向图，要求一个初次节点到末尾节点的所有路径</li>
<li>方法：dfs，重点在于具体的实现方法，注意邻接矩阵的vector长度，是n+1，因为题目的编号是1-n。还有题目的输出示例格式要求。</li>
<li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">vector&lt;int&gt; path;</span><br><span class="line"></span><br><span class="line">void dfs(vector&lt;vector&lt;int&gt;&gt; &amp;g, int vis, int end) &#123;</span><br><span class="line">    if (vis == end) &#123;</span><br><span class="line">        result.push_back(path);</span><br><span class="line">        // cout &lt;&lt; &quot;path:&quot; &lt;&lt; endl;;</span><br><span class="line">        // for (int i = 0; i &lt; path.size(); i++) &#123;</span><br><span class="line">        //     cout &lt;&lt; path[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">        // &#125;</span><br><span class="line">        // cout &lt;&lt; endl;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= end; i++) &#123;</span><br><span class="line">        if (g[vis][i] == 1) &#123;</span><br><span class="line">            path.push_back(i);</span><br><span class="line">            dfs(g, i, end);</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    </span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    // 用邻接矩阵来存储看看</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; g(n+1, vector&lt;int&gt;(n+1, 0));</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        int s, t;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">        g[s][t] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    path.push_back(1);</span><br><span class="line">    dfs(g, 1, n);</span><br><span class="line">    </span><br><span class="line">    if (result.size() == 0) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; result.size(); i++) &#123;</span><br><span class="line">        vector&lt;int&gt; &amp;t = result[i];</span><br><span class="line">        for (int j = 0; j &lt; t.size()-1; j++) &#123;</span><br><span class="line">            cout &lt;&lt; t[j] &lt;&lt; &quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; t[t.size()-1] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="岛屿数量深搜版"><a href="#岛屿数量深搜版" class="headerlink" title="岛屿数量深搜版"></a>岛屿数量深搜版</h2></li>
<li><a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0099.%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%95%B0%E9%87%8F%E6%B7%B1%E6%90%9C.html#%E6%80%9D%E8%B7%AF">代码随想录</a></li>
<li><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1171">99. 岛屿数量</a></li>
<li>题意：给一个二维数组，数组中横纵相连视为一个岛，求岛屿数量</li>
<li>方法：dfs，模板题，重点在于注意数组的存储</li>
<li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int dir[4][2] = &#123;0, 1, 1, 0, -1, 0, 0, -1&#125;;</span><br><span class="line">void dfs(const vector&lt;vector&lt;int&gt;&gt; &amp;grid, vector&lt;vector&lt;bool&gt;&gt; &amp;visited, int x, int y) &#123;</span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">        int nextx = x + dir[i][0];</span><br><span class="line">        int nexty = y + dir[i][1];</span><br><span class="line">        if (nextx &lt; 0 || nextx &gt;= grid.size() || nexty &lt; 0 || nexty &gt;= grid[0].size()) continue;</span><br><span class="line">        if (!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == 1) &#123;</span><br><span class="line">            visited[nextx][nexty] = true;</span><br><span class="line">            dfs(grid, visited, nextx, nexty);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; grid(n, vector&lt;int&gt;(m, 0));</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;bool&gt;&gt; visited(n, vector&lt;bool&gt;(m, false));</span><br><span class="line">    </span><br><span class="line">    int result = 0;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            if (!visited[i][j] &amp;&amp; grid[i][j] == 1) &#123;</span><br><span class="line">                visited[i][j] = true;</span><br><span class="line">                result++;</span><br><span class="line">                dfs(grid, visited, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/02/09/[Weekly%20Algorithm]%2017%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8D%95%E8%B0%83%E6%A0%88%E5%92%8C%E5%9B%BE%E8%AE%BA%EF%BC%88%E4%B8%80%EF%BC%89/" data-id="cm7j3ftgy001buwag2eoca4jr" data-title="【Weekly Algorithm】算法周记之《代码随想录》单调栈和图论（一）" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-[Weekly Algorithm] 16算法周记之《代码随想录》动态规划（七）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/19/%5BWeekly%20Algorithm%5D%2016%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%83%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2024-01-19T12:12:00.000Z" itemprop="datePublished">2024-01-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/19/%5BWeekly%20Algorithm%5D%2016%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%83%EF%BC%89/">【Weekly Algorithm】算法周记之《代码随想录》动态规划（七）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h1><p>本周跟随《代码随想录》继续推进动态规划的相关学习，本周主要学习子序列相关内容，其中的编辑距离在网络搜索引擎的期末考试见过。但通过本次学习，逐渐感受到在算法，或者说计算机的世界中，很多事情往往会通过抽象来变得简洁从而易于处理。</p>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><ul>
<li><h2 id="最长重复子数组"><a href="#最长重复子数组" class="headerlink" title="最长重复子数组"></a>最长重复子数组</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0718.%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/">718. 最长重复子数组 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意：给两个数组，问两个数组中最长重复的子数组长度是什么</p>
</li>
<li><p>方法：用二维dp，dp[i][j] 代表第一个数组 i-1 为尾部和第二个数组 j-1 处为尾部，最长重复子数组长度。<br>递推公式，当 num1[i-1]&#x3D;&#x3D;num2[j-1]，即可 dp[i][j] &#x3D; dp[i-1][j-1]+1;<br>初始化，都为0<br>遍历顺序，无所谓，不过从前向后就可<br>举例……  </p>
</li>
<li><p>参考代码随想录思路的解法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findLength(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(nums1.size()+1, vector&lt;int&gt;(nums2.size()+1, 0));</span><br><span class="line">        </span><br><span class="line">        int max_len = 0;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; nums1.size()+1; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; nums2.size()+1; j++) &#123;</span><br><span class="line">                if(nums1[i-1] == nums2[j-1]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-1][j-1] + 1;</span><br><span class="line">                    if (dp[i][j] &gt; max_len) max_len = dp[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return max_len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>优化一下，用滚动数组，注意每次从后向前遍历，以及刷0  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findLength(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">        // vector&lt;vector&lt;int&gt;&gt; dp(nums1.size()+1, vector&lt;int&gt;(nums2.size()+1, 0));</span><br><span class="line">        vector&lt;int&gt; dp(nums2.size()+1, 0);</span><br><span class="line">        </span><br><span class="line">        int max_len = 0;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; nums1.size()+1; i++) &#123;</span><br><span class="line">            for (int j = nums2.size(); j &gt; 0; j--) &#123;</span><br><span class="line">                if(nums1[i-1] == nums2[j-1]) &#123;</span><br><span class="line">                    dp[j] = dp[j-1] + 1;</span><br><span class="line">                    if (dp[j] &gt; max_len) max_len = dp[j];</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    dp[j] = 0; // 需要刷零避免前两层的记录影响</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return max_len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/1143.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-subsequence/description/">1143. 最长公共子序列 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意，给两个字符串，给出两串的最长公共子序列的长度</p>
</li>
<li><p>方法：与[[最长重复子数组]]相近，不过本题不要求连续，所以递推公式除了上一个相同+1之外，还保存两个子序列可能的最长情况。</p>
</li>
<li><p>参考代码随想录的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int longestCommonSubsequence(string text1, string text2) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(text1.size()+1, vector&lt;int&gt;(text2.size()+1, 0));</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; text1.size()+1; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; text2.size()+1; j++) &#123;</span><br><span class="line">                if (text1[i-1] == text2[j-1]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-1][j-1]+1;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // for (int i = 0; i &lt; text1.size()+1; i++) &#123;</span><br><span class="line">        //     for (int j = 0; j &lt; text2.size()+1; j++) &#123;</span><br><span class="line">        //         cout &lt;&lt; dp[i][j] &lt;&lt; &quot; &quot;;</span><br><span class="line">        //     &#125;</span><br><span class="line">        //     cout &lt;&lt; endl;</span><br><span class="line">        // &#125;</span><br><span class="line"></span><br><span class="line">        return dp[text1.size()][text2.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="不相交的线"><a href="#不相交的线" class="headerlink" title="不相交的线"></a>不相交的线</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/1035.%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/uncrossed-lines/">1035. 不相交的线 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意：两个整型数组，相同数字可以两两相连，但是线不能交错。求最大连线数。</p>
</li>
<li><p>方法：换了个题意的[[最长公共子序列]]，除了题目，其余都一样，其余省略。</p>
</li>
<li><h2 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/description/">53. 最大子数组和 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意：给一个数组，找个其中子序列之和最大的和。</p>
</li>
<li><p>方法：<br>dp[i] 是到下标为 i 为尾部的子序列最大和数值<br>递推公式比较有意思，两种情况，一个是延续之前的最大和 dp[i] &#x3D; dp[i-1]+num[i];或者不延续，从 i 处新开 dp[i] &#x3D; num[i]，两种情况取较大数值即可。<br>初始化，dp[0] 取 num[0],其它的初始化不重要，毕竟都会被覆盖。<br>遍历顺序：从前向后。<br>举例：……  </p>
</li>
<li><p>参考代码随想录思路的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(nums.size(), 0);</span><br><span class="line">        dp[0] = nums[0];</span><br><span class="line">        int result = dp[0];</span><br><span class="line">        for (int i = 1; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            dp[i] = max(dp[i-1]+nums[i], nums[i]);</span><br><span class="line">            if (dp[i] &gt; result) &#123;</span><br><span class="line">                result = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        //     cout &lt;&lt; dp[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">        // &#125;</span><br><span class="line">        // cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a>判断子序列</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0392.%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/is-subsequence/submissions/595432953/">392. 判断子序列 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意：给两个字符串序列，判断一个字符串是否为另一个字符串的子序。</p>
</li>
<li><p>方法：其实[[最长公共子序列]]类似，只是说判断公共字符串的长度是否为子串长度相等，而且递推公式中，如果两个字符不相等，稍微更改，只会继承本字符的匹配情况，因为明确表示了该字符串是否为另一字符串的子串，不能反过来。</p>
</li>
<li><p>参考代码随想录思路的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSubsequence(string s, string t) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(s.size()+1, vector&lt;int&gt;( t.size()+1, 0));</span><br><span class="line">        // dp[i][j] 字符串s[i-1] 和 t[j-1] 为止最长子序列长度</span><br><span class="line">        // 初始化 第一行和第一列都为 0 即可</span><br><span class="line">        // 递推公式，当两个字符相等时，dp[i][j]=dp[i-1][j-1]+1;不同时，dp[i][j]则取dp[i][j-1];相当于匹配t失败，延续之前匹配结果（要么是匹配上的情况，要么是0，也就是断匹配了</span><br><span class="line">        for(int i = 1; i &lt;= s.size(); i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= t.size(); j++) &#123;</span><br><span class="line">                if (s[i-1] == t[j-1]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-1][j-1] + 1;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j-1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return (dp[s.size()][t.size()] == s.size()) ? true : false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="不同子序列"><a href="#不同子序列" class="headerlink" title="不同子序列"></a>不同子序列</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/distinct-subsequences/">115. 不同的子序列 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意，判断一个字符串和另一个字符串的几种不同子序列相同（这里的子序列由字符串删除字符获得），求不同子序列的数量。</p>
</li>
<li><p>方法，是编辑距离的简单版，只考虑删除字符的情况，如果对应字符相等，就取上个字符的匹配情况<br><img src="/../assets/image_1737950806585_0.png" alt="image.png"><br>dp[i][j]是s[i]到t[j]匹配时，已有匹配到的数量，这个数量指的是可能出现的前缀数量，如果字符匹配成功，就继承上一个；如果之前有重复字符，则会叠加  </p>
</li>
<li><p>参考代码随想录思路的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numDistinct(string s, string t) &#123;</span><br><span class="line">        vector&lt;vector&lt;uint64_t&gt;&gt; dp(s.size()+1, vector&lt;uint64_t&gt;(t.size()+1, 0));</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; s.size(); i++) &#123;</span><br><span class="line">            dp[i][0] = 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt;= s.size(); i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= t.size(); j++) &#123;</span><br><span class="line">                if (s[i-1] == t[j-1]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    dp[i][j] = dp[i-1][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[s.size()][t.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="两个字符串的删除操作"><a href="#两个字符串的删除操作" class="headerlink" title="两个字符串的删除操作"></a>两个字符串的删除操作</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0583.%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-operation-for-two-strings/">583. 两个字符串的删除操作 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意：给两个字符串，请给出多少次删除（一次删除任意字符串的一个字符）能使两个字符串相等。</p>
</li>
<li><p>方法：</p>
<ol>
<li>dp[i][j] 对于一个字符串的前 i-1 个字符和另一个字符串的前 j-1 个字符相同需要删除次数</li>
<li>递推公式，当字符相同时，dp[i][j] &#x3D; dp[i-1][j-1]；也就是说对于这两个位置的字符不需要删除。当字符不相同时，dp[i][j] &#x3D; min(dp[i-1][j]+1, dp[i][j-1]+1);也就是删除其中个字符串中的字符，那可能说，要是两个字符都要删除呢？这个状态包含于上一次内，也就是说两个删除一个字符情况也就是删除两个字符。</li>
<li>初始化，第一行第一列，分别是一个字符串与空字符串相等需要的删除次数，也就是删完，取字符串长度。</li>
<li>遍历顺序，从前向后，前上到下，普通顺序</li>
<li>举例……</li>
</ol>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minDistance(string word1, string word2) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(word1.size()+1,vector&lt;int&gt;(word2.size()+1, 0));</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; word1.size()+1; i++) &#123;</span><br><span class="line">            dp[i][0] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int j = 0; j &lt; word2.size()+1; j++) &#123;</span><br><span class="line">            dp[0][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; word1.size()+1; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; word2.size()+1; j++) &#123;</span><br><span class="line">                if (word1[i-1] == word2[j-1]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-1][j-1];</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    dp[i][j] = min(dp[i-1][j]+1, dp[i][j-1]+1);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[word1.size()][word2.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0072.%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/edit-distance/description/">72. 编辑距离 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意，给两个字符串，要求编辑距离（也就是对任意字符串增删换使其相同的次数），增一个字符，删一个字符，换一个字符的操作个数。</p>
</li>
<li><p>方法，[[两个字符串的删除操作]]的进阶，现在不只是删除，还有增加字符和替换的操作，但是，增加字符，其实可以等效为另一个字符串删除那个要增加的字符。而替换操作，可以理解为两边字符串同时删除，但只算一次操作(dp[i][j]&#x3D;dp[i-1][j-1]+1)，除了这个递推公式加上一条，其余相同。</p>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minDistance(string word1, string word2) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(word1.size()+1, vector&lt;int&gt;(word2.size()+1, 0));</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; word1.size()+1; i++) &#123;</span><br><span class="line">            dp[i][0] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int j = 0; j &lt; word2.size()+1; j++) &#123;</span><br><span class="line">            dp[0][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; word1.size()+1; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; word2.size()+1; j++) &#123;</span><br><span class="line">                if (word1[i-1] == word2[j-1]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-1][j-1];</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    dp[i][j] = min(&#123;dp[i-1][j-1], dp[i-1][j], dp[i][j-1]&#125;)+1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[word1.size()][word2.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a>回文子串</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0647.%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindromic-substrings/description/">647. 回文子串 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意，给一个字符串，统计其中回文字符串的个数</p>
</li>
<li><p>方法，如果按照之前思路dp[i]代表到下标 i 回文字符串个数的话，各个状态间无联系无规律。故用下面的 dp 定义。<br>除了 dp 定义有改变，还有遍历顺序与以往不太一样，由于递推公式的关系。<br>具体内容在注释中  </p>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int countSubstrings(string s) &#123;</span><br><span class="line">        vector&lt;vector&lt;bool&gt;&gt; dp(s.size(), vector&lt;bool&gt;(s.size(), false));</span><br><span class="line">        // 这里的 dp[i][j] 是字符串 i 到 j（闭区间）是否为回文字符串、</span><br><span class="line">        // 初始化默认全部为 false</span><br><span class="line"></span><br><span class="line">        // 先看递推公式，当 s[i] != s[j] dp[i][j] = false;</span><br><span class="line">        // 复杂的是 s[i] == s[j]时，如果 i==j，那么 dp[i][j] = true，因为”a“算回文字符串</span><br><span class="line">        // 如果j==i+1，那么也是true，“aa”这种情况中也算回文字符串</span><br><span class="line">        // 如果 上述都不是，那么 dp[i][j] = dp[i+1][j-1] ，i到j是否为回文字符串取决于 i+1到j-1是否为回文字符串</span><br><span class="line"></span><br><span class="line">        // 由于递推公式有 dp[i][j] = dp[i+1][j-1],那么要先遍历 i 较大的情况以及 j 较小的情况</span><br><span class="line"></span><br><span class="line">        for(int i = s.size()-1; i &gt;= 0; i--) &#123;</span><br><span class="line">            for (int j = i; j &lt; s.size(); j++) &#123;</span><br><span class="line">                if (s[i] != s[j]) &#123;</span><br><span class="line">                    dp[i][j] = false;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (i == j) &#123;</span><br><span class="line">                    dp[i][j] = true;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (j == i + 1) &#123;</span><br><span class="line">                    dp[i][j] = true;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    dp[i][j] = dp[i+1][j-1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int count = 0;</span><br><span class="line">        for (int i = 0; i &lt; s.size(); i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; s.size(); j++) &#123;</span><br><span class="line">                if (dp[i][j] == true) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                //cout &lt;&lt; dp[i][j] &lt;&lt; &quot; &quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            //cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0516.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-subsequence/description/">516. 最长回文子序列 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意：找出字符串上，最长回文子序列长度（可删字符）</p>
</li>
<li><p>方法：详情写在注释中，值得注意的是，dp是闭区间</p>
</li>
<li><p>参考代码随想录思路的解法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int longestPalindromeSubseq(string s) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(s.size(), vector&lt;int&gt;(s.size(), 0));</span><br><span class="line">        // dp[i][j]代表了 s[i]到s[j] 最长回文子序列的长度</span><br><span class="line"></span><br><span class="line">        // 在 s[i] == s[j] 时，dp[i][j] = dp[i+1][j-1]+2</span><br><span class="line">        // 不相等时， 则从两个方向取大值，dp[i][j] = max(dp[i][j-1], dp[i+1][j]);</span><br><span class="line"></span><br><span class="line">        // 初始化时，所有相等得先赋值1</span><br><span class="line">        for (int i = 0; i &lt; s.size(); i++) dp[i][i] = 1;</span><br><span class="line"></span><br><span class="line">        for (int i = s.size()-1; i &gt;= 0; i--) &#123;</span><br><span class="line">            for (int j = i+1; j &lt; s.size(); j++) &#123;</span><br><span class="line">                if (s[i] == s[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i+1][j-1] + 2;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    dp[i][j] = max(dp[i][j-1], dp[i+1][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[0][s.size()-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/19/[Weekly%20Algorithm]%2016%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%83%EF%BC%89/" data-id="cm7j3ftgy0019uwag4fqs3yfc" data-title="【Weekly Algorithm】算法周记之《代码随想录》动态规划（七）" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-【陆爻齐】为三台笔记本重装系统过程记录与反思——解决无法进入PE，运行内存不足等问题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/16/%E3%80%90%E9%99%86%E7%88%BB%E9%BD%90%E3%80%91%E4%B8%BA%E4%B8%89%E5%8F%B0%E7%AC%94%E8%AE%B0%E6%9C%AC%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95%E4%B8%8E%E5%8F%8D%E6%80%9D%E2%80%94%E2%80%94%E8%A7%A3%E5%86%B3%E6%97%A0%E6%B3%95%E8%BF%9B%E5%85%A5PE%EF%BC%8C%E8%BF%90%E8%A1%8C%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E7%AD%89%E9%97%AE%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2024-01-16T09:02:00.000Z" itemprop="datePublished">2024-01-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/16/%E3%80%90%E9%99%86%E7%88%BB%E9%BD%90%E3%80%91%E4%B8%BA%E4%B8%89%E5%8F%B0%E7%AC%94%E8%AE%B0%E6%9C%AC%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95%E4%B8%8E%E5%8F%8D%E6%80%9D%E2%80%94%E2%80%94%E8%A7%A3%E5%86%B3%E6%97%A0%E6%B3%95%E8%BF%9B%E5%85%A5PE%EF%BC%8C%E8%BF%90%E8%A1%8C%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E7%AD%89%E9%97%AE%E9%A2%98/">【陆爻齐】为三台笔记本重装系统过程记录与反思——解决无法进入PE，运行内存不足等问题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大家早上中午晚上好，这里是第一次像这样写文章的陆爻齐。姑且不管什么格式，推广，吸引眼球乱七八糟的，做好记录再说。</p>
<p>本来吧，重装系统真没啥可记录的，但中间遇到的些许问题还是最好记录下来，备后面使用。  </p>
<p>#正文</p>
<p>装备：待重装系统的老旧电脑*3 装了微PE工具箱的u盘*1 能上网正常使用的电脑*1  </p>
<p>重装系统的参考教程：硬件茶谈的视频【装机教程】超详细WIN10系统安装教程，官方ISO直装与PE两种方法教程，UEFI+GUID分区与Legacy+MBR分区</p>
<p>接下来是三段难度依次递增的重装系统过程（：</p>
<p>##（1）联想笔记本 4G运行内存 原win10系统  </p>
<p>该笔记本因不明原因，缺失某系统文件导致不断反复开机的流程而不进入系统。经过PE辅助装机问题全部解决，无异常。</p>
<p>重新安装Window7，为了方便使用，硬盘只划分一个分区，重新启动后就已可以让原主正常使用。  </p>
<p>##（2）联想笔记本 1G运行内存 149G储存容量的固态硬盘 原XP系统  </p>
<p>该笔记本因360和各种“下崽器”，卡顿不堪，抢救其中的图片与视频后，正常将硬盘格式化并安装WindowsXP系统。  </p>
<p>重装过程中也出现问题，XP的ISO不能像win7，win10的一样，挂载后直接运行setup.exe即可，所以借助PE自带的WinNTsetup软件中安装XP的功能，选中挂载的ISO和要安装的系统盘即可。</p>
<p>这次重装系统遇到的问题在于使得XP系统能够正常使用，毕竟纯净的XP系统，既不能识别u盘，又不能直接上网。  </p>
<p>首先要解决的不能识别u盘的问题，既然重装系统前能正常识别，说明问题不在XP系统本身。经上网查询，问题大概率为没有打KB955704补丁，故在系统之家下载补丁，并通过PE将其转移并使用，问题解决。</p>
<p>然后顺便在景元论坛发现XP补丁合集，遂放入u盘收藏并应用于重装XP中。  </p>
<p>接着通过u盘转移winrar和xp_activate32来解决无法解压rar和激活XP的问题。</p>
<p>还有无法上网的问题，经查询，很可能是没有安装驱动，故在u盘里放了个驱动总裁，使用后问题也顺利解决。</p>
<p>##（3）戴尔笔记本 512M运行内存 80G储存容量的机械硬盘 原XP系统</p>
<p>这次问题主要集中在重装系统本身，刚开始PE无法进入，XP系统又无法自己打开ISO进行系统安装，一筹莫展。</p>
<p>刚开始的思路是，修复该笔记本各种dll缺失，启动微软自己的安装系统，但即便用DirectX修复后仍然无法解决，故转换思路。</p>
<p>经思考与查询，决定将PE更换为32位，然后成功进入PE。</p>
<p>然后发现0.5G的运行内存不能使用分区助手，分区精灵来分区，于是只能用系统自带分区来实现。</p>
<p>值得注意的是，给系统盘拓展卷时，会提示基本磁盘变为动态磁盘，不可作为系统盘。要解决这个问题需要先删除该盘所有分区，再将该磁盘变为基本磁盘，然后才新建简单卷。</p>
<p>接着通过WinNTSetup成功安装XP。</p>
<p>接下来进入下一个问题，拔掉u盘重启后，电脑显示no bootable device。</p>
<p>出现该问题有可能是硬盘连接断开，故在bios检查，发现硬盘仍正常连接，排除该原因。</p>
<p>接着考虑是引导程序出问题，故重新进入PE启动引导修复工具，在提示重新引导完成后重启电脑，但仍出现一样结果。</p>
<p>此时又进入一筹莫展之境地，经上网查询后，尝试以下步骤。</p>
<ol>
<li><p>进入PE，并运行cmd</p>
</li>
<li><p>diskpart</p>
</li>
<li><p>list disk</p>
</li>
<li><p>select disk 0（这里的数字0代表系统盘）</p>
</li>
<li><p>list partition</p>
</li>
<li><p>select partition 0（这里的数字0代表分区中装载系统的分区）</p>
</li>
<li><p>active</p>
</li>
</ol>
<p>如果最后一步无报错，说明系统分区成功激活，重启即可。</p>
<p>上述步骤出自知乎，我的电脑出现了no bootable device，怎么解决?</p>
<p>然后问题解决，成功进入XP安装，其余同（2）  </p>
<p>#总结  </p>
<p>重装系统其实不算难，难的是旧电脑遗留各种问题需要克服，运行内存不足，无法进入pe等，希望本文能给予后人一点参考，少踩坑，多休息。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/16/%E3%80%90%E9%99%86%E7%88%BB%E9%BD%90%E3%80%91%E4%B8%BA%E4%B8%89%E5%8F%B0%E7%AC%94%E8%AE%B0%E6%9C%AC%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95%E4%B8%8E%E5%8F%8D%E6%80%9D%E2%80%94%E2%80%94%E8%A7%A3%E5%86%B3%E6%97%A0%E6%B3%95%E8%BF%9B%E5%85%A5PE%EF%BC%8C%E8%BF%90%E8%A1%8C%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E7%AD%89%E9%97%AE%E9%A2%98/" data-id="cm7j3ftha0029uwagelnm7hgo" data-title="【陆爻齐】为三台笔记本重装系统过程记录与反思——解决无法进入PE，运行内存不足等问题" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-[Weekly Algorithm] 15算法周记之《代码随想录》动态规划（六）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/12/%5BWeekly%20Algorithm%5D%2015%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E5%85%AD%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2024-01-12T02:06:00.000Z" itemprop="datePublished">2024-01-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/12/%5BWeekly%20Algorithm%5D%2015%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E5%85%AD%EF%BC%89/">【Weekly Algorithm】算法周记之《代码随想录》动态规划（六）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h1><p>本周跟随《代码随想录》继续推进动态规划的相关学习，本周主要学习完买卖股票相关内容，并初步探索子序列的部分。</p>
<p>买卖股票的题有明显的状态转换，但子序列就没那么明显。</p>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><ul>
<li><h2 id="买卖股票的最佳时机II"><a href="#买卖股票的最佳时机II" class="headerlink" title="买卖股票的最佳时机II"></a>买卖股票的最佳时机II</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">122. 买卖股票的最佳时机 II - 力扣（LeetCode）</a></p>
</li>
<li><p>题意，在[[买卖股票的最佳时机]]的基础上，要求可以多次购买股票，但同一时段只能持有一支股票，也就是再卖出上一支股票前，不允许购入下一支股票。</p>
</li>
<li><p>方法，与[[买卖股票的最佳时机]]的差别，在于考虑购入当前股票时，是在上一支股票考虑购入和卖出的两个情况中取最大，并非直接取历史最便宜股票和当前股票对比。</p>
</li>
<li><p>参考代码随想录思路解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        // dp[i][0] 考虑第i支股票时，考虑买入的情况；dp[i][1] 考虑第i支股票时，卖出的情况</span><br><span class="line">        int len = prices.size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(len, vector&lt;int&gt;(2, 0));</span><br><span class="line">        dp[0][0] -= prices[0];</span><br><span class="line">        dp[0][1] = 0;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][0] = max(dp[i-1][0], dp[i-1][1]-prices[i]);</span><br><span class="line">            dp[i][1] = max(dp[i-1][1], dp[i-1][0]+prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[len-1][1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="买卖股票的最佳时机III"><a href="#买卖股票的最佳时机III" class="headerlink" title="买卖股票的最佳时机III"></a>买卖股票的最佳时机III</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0123.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III - 力扣（LeetCode）</a></p>
</li>
<li><p>题意，在[[买卖股票的最佳时机II]]基础上，要求最多只能进行两次股票的购入和卖出。</p>
</li>
<li><p>方法，可以想想此前两题的 dp，dp[i] 代表第 i 天，后面是状态，有两状态就是持有和卖出。换到此题就是状态更多了，故本题可设 5 个状态，0 代表不操作（可省略），1 代表第一次持有（不代表一定购入，可能是之前的购入），2代表第一次卖出，3 是第二次持有，4 是第二次卖出。后面的状态均依赖于自己与前一个状态。</p>
<ol>
<li>dp[i][0-4]，意思如上</li>
<li>递推公式，对于持有的状态，dp[i][1] &#x3D; max(dp[i-1][0]-price[i],dp[i-1][1])，就是在不购买的基础上购买当日股票和采用之前购买股票的抉择；对于卖出状态，dp[i][2] &#x3D; max(dp[i-1][1]+price[i], dp[i-1][2]); 就是在前一日购买股票的基础上，售出当日股票与延续此前卖出的抉择；</li>
<li>初始化，dp[0][0] &#x3D; 0, 不作为当然为 0，dp[0][1] &#x3D; -1 * price[0]; 购入股票成本, dp[0][2] &#x3D; 0，马上卖出即无收益；dp[0][3] &#x3D; -1 * price[0]，当日连续第二次买入; dp[0][4] &#x3D; 0; 当日连续第二次卖出。</li>
<li>遍历方向，从前向后</li>
<li>举例……</li>
</ol>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        // 分五个状态，0 是无操作，1 是第一次持有，2 是第一次卖出，3是第二次持有，4是第二次卖出</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(prices.size(), vector&lt;int&gt;(5, 0));</span><br><span class="line">        dp[0][1] -= prices[0];</span><br><span class="line">        dp[0][3] -= prices[0];</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            dp[i][1] = max(dp[i-1][0]-prices[i], dp[i-1][1]);</span><br><span class="line">            dp[i][2] = max(dp[i-1][1]+prices[i], dp[i-1][2]);</span><br><span class="line">            dp[i][3] = max(dp[i-1][2]-prices[i], dp[i-1][3]);</span><br><span class="line">            dp[i][4] = max(dp[i-1][3]+prices[i], dp[i-1][4]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[prices.size()-1][4];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="买卖股票的最佳时机IV"><a href="#买卖股票的最佳时机IV" class="headerlink" title="买卖股票的最佳时机IV"></a>买卖股票的最佳时机IV</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0188.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV - 力扣（LeetCode）</a></p>
</li>
<li><p>题意，在[[买卖股票的最佳时机III]]基础上，将购买股票的次数由 2 次，拓展为变量 k 次</p>
</li>
<li><p>方法，将dp数组拓展为 price.size() 个 2<em>k+1 的 vector，总共有 2</em>k+1 个状态，其余的思想与方法，同[[买卖股票的最佳时机III]]。</p>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        // dp[i][0] 为不操作，dp[i][2*k-1] 为第k笔交易持有, dp[i][2*k] 为第k笔交易卖出，k&gt;=1</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(prices.size(), vector&lt;int&gt;(2*k+1, 0));</span><br><span class="line"></span><br><span class="line">        // 初始化，对于奇数只是单纯买第一天的负价格，而偶数则是一买就卖的 0</span><br><span class="line">        for (int i = 1; i &lt; 2 * k; i+=2) &#123;</span><br><span class="line">            dp[0][i] -= prices[0];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 对往后每一行奇偶，分别是前一笔交易与上一天同笔交易的比较</span><br><span class="line">        for (int i = 1; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; 2*k+1; j+=2) &#123;</span><br><span class="line">                dp[i][j] = max(dp[i-1][j], dp[i-1][j-1]-prices[i]);</span><br><span class="line">                dp[i][j+1] = max(dp[i-1][j+1], dp[i-1][j]+prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[prices.size()-1][2*k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="买卖股票的最佳时机含冷冻期"><a href="#买卖股票的最佳时机含冷冻期" class="headerlink" title="买卖股票的最佳时机含冷冻期"></a>买卖股票的最佳时机含冷冻期</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0309.%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/">309. 买卖股票的最佳时机含冷冻期 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意，在 [[买卖股票的最佳时机II]] 可多次买卖股票的基础上，加入冷冻期，即在卖出股票的一天后，才能再买入股票。</p>
</li>
<li><p>方法，引入四种状态，买入，今日卖出，保持卖出，冷冻期。<br>买入状态可能有前一日的买入状态、保持卖出、冷冻期推出；<br>今日卖出只会由前一日买入状态卖出今日价格得出；<br>冷冻期保存前一日的今日卖出状态；<br>保持卖出则由前一日的保持卖出、冷冻期推出；  </p>
<p>dp[i][j] 则是 i 天的第 j 个状态<br>递推公式由上述的文字推出<br>初始化则是第一日的买入状态为价格负数，其余为零<br>遍历方向从前到后<br>举例……  </p>
</li>
<li><p>参考代码随想录思想的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        int n = prices.size();</span><br><span class="line">        if (n==0) return 0;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt;dp(n, vector&lt;int&gt;(4, 0));</span><br><span class="line">        // dp 有四种状态 1 买入；2 今日卖出；3 保持卖出； 4 冷静期</span><br><span class="line">        // 3 可能为 2 或 4 的延续</span><br><span class="line">        dp[0][0] -= prices[0];</span><br><span class="line">        for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][0] = max(dp[i-1][0], max(dp[i-1][2] - prices[i], dp[i-1][3] - prices[i]));</span><br><span class="line">            dp[i][1] = dp[i-1][0] + prices[i];</span><br><span class="line">            dp[i][2] = max(dp[i-1][2], dp[i-1][3]);</span><br><span class="line">            dp[i][3] = dp[i-1][1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return max(dp[n-1][1], max(dp[n-1][2], dp[n-1][3]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="买卖股票的最佳时机含手续费"><a href="#买卖股票的最佳时机含手续费" class="headerlink" title="买卖股票的最佳时机含手续费"></a>买卖股票的最佳时机含手续费</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0714.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/">714. 买卖股票的最佳时机含手续费 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意，在[[买卖股票的最佳时机II]]可多次交易的基础上，添加手续费，即每次交易后需扣除一定手续费。</p>
</li>
<li><p>方法，与[[买卖股票的最佳时机II]]的唯一差别在于递推公式，将卖出的部分添加手续费即可。</p>
<p>不过，陆爻齐由于太久没碰相关部分，想自己从零推出来，于是整合了三个状态，写下下面的代码  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123;</span><br><span class="line">        // 我觉着有三种状态</span><br><span class="line">        // 第一是直接买入，第二是今日卖出</span><br><span class="line">        // 与之前只会多次交易的题相比，多了个手续费，减一下就行了</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(prices.size(), vector&lt;int&gt;(3, 0));</span><br><span class="line"></span><br><span class="line">        // 递推公式的话，买入就直接取当日价格负数减下去，卖出则取前一日买入加上这一日卖出</span><br><span class="line">        // 初始化，除买入，取0</span><br><span class="line">        dp[0][0] -= prices[0];</span><br><span class="line">        for (int i = 1; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            dp[i][0] = max(dp[i-1][0], dp[i-1][2]-prices[i]);</span><br><span class="line">            dp[i][1] = dp[i-1][0] + prices[i] - fee;</span><br><span class="line">            dp[i][2] = max(dp[i-1][2], dp[i][1]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // for (int i = 0; i &lt; prices.size(); i++) &#123;</span><br><span class="line">        //     cout &lt;&lt; dp[i][0] &lt;&lt; &quot; &quot; &lt;&lt; dp[i][1] &lt;&lt; &quot; &quot; &lt;&lt; dp[i][2] &lt;&lt; endl;</span><br><span class="line">        // &#125;</span><br><span class="line"></span><br><span class="line">        return max(dp[prices.size()-1][1], dp[prices.size()-1][2]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>看完发现，第三个状态确实可以与第二个状态合并，要追求简洁的情况下，每个状态应是由过去的部分推导出来的，如果有状态与现有状态有关，则可考虑适当合并  </p>
<p>于是可以优化成下面的代码，与代码随想录思路相近了  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123;</span><br><span class="line">        // 我觉着有三种状态</span><br><span class="line">        // 第一是直接买入，第二是今日卖出</span><br><span class="line">        // 与之前只会多次交易的题相比，多了个手续费，减一下就行了</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(prices.size(), vector&lt;int&gt;(2, 0));</span><br><span class="line"></span><br><span class="line">        // 递推公式的话，买入就直接取当日价格负数减下去，卖出则取前一日买入加上这一日卖出</span><br><span class="line">        // 初始化，除买入，取0</span><br><span class="line">        dp[0][0] -= prices[0];</span><br><span class="line">        for (int i = 1; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            dp[i][0] = max(dp[i-1][0], dp[i-1][1]-prices[i]);</span><br><span class="line">            dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i] - fee);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // for (int i = 0; i &lt; prices.size(); i++) &#123;</span><br><span class="line">        //     cout &lt;&lt; dp[i][0] &lt;&lt; &quot; &quot; &lt;&lt; dp[i][1] &lt;&lt; &quot; &quot; &lt;&lt; dp[i][2] &lt;&lt; endl;</span><br><span class="line">        // &#125;</span><br><span class="line"></span><br><span class="line">        return dp[prices.size()-1][1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0300.%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97.html">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/description/">300. 最长递增子序列 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意：给一个数组，求其中最长递增子序列的长度，该子序列可由删除数组中元素得出。</p>
</li>
<li><p>方法：用 dp[i] 表示下标 i 之前的最长递增子序列长度，通过循环得出。<br>递推公式：dp[i] &#x3D; max(dp[i], dp[j]+1); j遍历 0 到 i 的元素，该元素数值小于 i 的元素<br>初始化，均初始化为 1，长度至少为 1；<br>遍历顺序：从前往后，毕竟是递增<br>举例：……  </p>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(nums.size(), 1);</span><br><span class="line">        // dp[i]为地址为 i 的最长子序列长度</span><br><span class="line">        int max_len = 1;</span><br><span class="line">        // 外循环遍历数组</span><br><span class="line">        for (int i = 1; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            // 内循环取到已有的最长子序列长度</span><br><span class="line">            for (int j = 0; j &lt;= i; j++) &#123;</span><br><span class="line">                if (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    dp[i] = max(dp[i], dp[j]+1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (dp[i] &gt; max_len) max_len = dp[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return max_len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="最长连续递增序列"><a href="#最长连续递增序列" class="headerlink" title="最长连续递增序列"></a>最长连续递增序列</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0674.%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97.html">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">674. 最长连续递增序列 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意：与[[非递减子序列]]相比，要求子序列得是连续的，中间数据不能删。</p>
</li>
<li><p>方法，不需要代码随想录的思路参考，自己都能分析出来。<br>dp[i] 是下标 i 为末尾的最长连续递增序列长度<br>递推公式为 dp[i] &#x3D; dp[i-1]+1; 前提是 dp[i] &gt; dp[i-1]<br>初始化 全初始化为1<br>遍历方向从前向后<br>举例……  </p>
</li>
<li><p>解法（与代码随想录思路相近）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(nums.size(), 1); // dp[i] 展示前面某一点到下标 i，最长连续递增子序列长度</span><br><span class="line">        int max_len = 1;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            if (nums[i]&gt;nums[i-1]) &#123;</span><br><span class="line">                dp[i] = dp[i-1]+1;</span><br><span class="line">                if (dp[i] &gt; max_len) max_len = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return max_len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/12/[Weekly%20Algorithm]%2015%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E5%85%AD%EF%BC%89/" data-id="cm7j3ftgx0016uwag3u5cfx0u" data-title="【Weekly Algorithm】算法周记之《代码随想录》动态规划（六）" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; 上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CINTA/" rel="tag">CINTA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CS61A/" rel="tag">CS61A</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Conda/" rel="tag">Conda</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JLU/" rel="tag">JLU</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%92%AD%E5%AE%A2%E7%AC%94%E8%AE%B0/" rel="tag">播客笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag">数据结构与算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/" rel="tag">方法论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" rel="tag">深度学习</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algorithm/" style="font-size: 20px;">Algorithm</a> <a href="/tags/CINTA/" style="font-size: 10px;">CINTA</a> <a href="/tags/CS61A/" style="font-size: 17.14px;">CS61A</a> <a href="/tags/Conda/" style="font-size: 10px;">Conda</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/JLU/" style="font-size: 15.71px;">JLU</a> <a href="/tags/Python/" style="font-size: 18.57px;">Python</a> <a href="/tags/%E6%92%AD%E5%AE%A2%E7%AC%94%E8%AE%B0/" style="font-size: 11.43px;">播客笔记</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size: 14.29px;">数据结构与算法</a> <a href="/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/" style="font-size: 11.43px;">方法论</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 11.43px;">机器学习</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 12.86px;">杂谈</a> <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">深度学习</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/12/">十二月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">十一月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">十月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">九月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">八月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">七月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">六月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">五月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">三月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">二月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">一月 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/12/15/%5BWeekly%20Algorithm%5D%2014%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%94%EF%BC%89/">【Weekly Algorithm】算法周记之《代码随想录》动态规划（五）</a>
          </li>
        
          <li>
            <a href="/2024/12/08/%5BWeekly%20Algorithm%5D%2013%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E5%9B%9B%EF%BC%89/">【Weekly Algorithm】算法周记之《代码随想录》动态规划（四）</a>
          </li>
        
          <li>
            <a href="/2024/12/01/%5BWeekly%20Algorithm%5D%2012%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%89%EF%BC%89/">【Weekly Algorithm】算法周记之《代码随想录》动态规划（三）</a>
          </li>
        
          <li>
            <a href="/2024/11/24/%5BWeekly%20Algorithm%5D%2011%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%8C%EF%BC%89/">【Weekly Algorithm】算法周记之《代码随想录》动态规划（二）</a>
          </li>
        
          <li>
            <a href="/2024/11/17/%5BWeekly%20Algorithm%5D%2010%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89/">【Weekly Algorithm】算法周记之《代码随想录》动态规划（一）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 陆爻齐-LuYaoQi<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
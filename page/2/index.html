<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>LuYaoQi&#39;s Blogs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="normal wants to be special">
<meta property="og:type" content="website">
<meta property="og:title" content="LuYaoQi&#39;s Blogs">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="LuYaoQi&#39;s Blogs">
<meta property="og:description" content="normal wants to be special">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="陆爻齐-LuYaoQi">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="LuYaoQi's Blogs" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">LuYaoQi&#39;s Blogs</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Hello my World</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-[Weekly Algorithm] 3算法周记之《代码随想录》哈希表" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/29/%5BWeekly%20Algorithm%5D%203%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%93%88%E5%B8%8C%E8%A1%A8/" class="article-date">
  <time class="dt-published" datetime="2024-09-29T15:59:00.000Z" itemprop="datePublished">2024-09-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/29/%5BWeekly%20Algorithm%5D%203%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%93%88%E5%B8%8C%E8%A1%A8/">【Weekly Algorithm】 算法周记之《代码随想录》哈希表</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h1><p>本周跟随《代码随想录》学习哈希表部分，较深入地了解了哈希表的相关算法题，结合数组、set、map完成题目，并利用双指针解决部分题目。</p>
<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="简评"><a href="#简评" class="headerlink" title="简评"></a>简评</h2><p>究其本质而言，就是数组，但可以通过给元素编码得其索引，以 O(1) 的效率访存，最适合检测该元素是否存在。</p>
<h2 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h2><ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html">代码随想录 (programmercarl.com)</a></li>
<li>即检测一个字符串是否为另一个字符串的字母打散重组的单词</li>
<li>字符可以通过 ASCII 码表来存储，遍历某个字符串，对应字符++，再遍历另一个对应字符–，最后所有字符都为 0 即为字母异位词</li>
<li></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isAnagram(string s, string t) &#123;</span><br><span class="line">        // 记录每个字符对应次数，相当于哈希表</span><br><span class="line">        int word_rec[26] = &#123;0&#125;;</span><br><span class="line">        // 遍历某个字符串，记录对应字符出现次数</span><br><span class="line">        for (auto c : s) &#123;</span><br><span class="line">            word_rec[get_index(c)]++;</span><br><span class="line">        &#125;</span><br><span class="line">        // 遍历另一个字符串，把对应字符出现与上个字符串抵消</span><br><span class="line">        for (auto c : t) &#123;</span><br><span class="line">            word_rec[get_index(c)]--;</span><br><span class="line">        &#125;</span><br><span class="line">        // 若有字符没抵消干净，说明不是字母异位词</span><br><span class="line">        for (auto i : word_rec) &#123;</span><br><span class="line">            if (i != 0) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inline int get_index(char c) &#123;</span><br><span class="line">        return int(c)-97;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录 (programmercarl.com)</a></p>
</li>
<li><p>本题与 [[有效的字母异位词]]，有点类似，不过检测的元素从字符变成数字，而且需要输出重合的部分</p>
</li>
<li><p>大致有两思路</p>
<ol>
<li>陆爻齐想到，用 unordered_map 先把某一个数组中有的数字记 1，随后遍历另一数组时，把当前 map 里有且值为 1 的部分改值到 2 并放到数组里；</li>
<li>代码随想录用两个 set，其中一个用来存储某个数组唯一的所有元素，另一个存放结果，由于 set 会保证元素唯一，一旦找到交集就可以无脑 insert 进去</li>
</ol>
</li>
<li><p>这里选择记录陆爻齐的思路</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">        unordered_map&lt;int,int&gt; num_rec;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        // 遍历某个数组，记录其中存在数字</span><br><span class="line">        for (auto c : nums1) &#123;</span><br><span class="line">            if (num_rec.find(c) == num_rec.end()) &#123;</span><br><span class="line">                num_rec[c] = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 遍历另一个数组，记录交集数字加入结果</span><br><span class="line">        for (auto c : nums2) &#123;</span><br><span class="line">            if (num_rec.find(c) != num_rec.end() &amp;&amp; num_rec[c] == 1) &#123;</span><br><span class="line">                num_rec[c]++;</span><br><span class="line">                res.push_back(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h2><ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0202.%E5%BF%AB%E4%B9%90%E6%95%B0.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></li>
<li>该题就是一个数字游戏，寻找一个整数是否存在一个其各元素平方和为 1 的情况，可能会无限循环</li>
<li>解决方法就是创建一个哈希表，把过程中产生的数字记录，若有重复，则陷入死循环，否则到了 1，则为快乐数</li>
<li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isHappy(int n) &#123;</span><br><span class="line">        // 记录过程中产生的数</span><br><span class="line">        unordered_map&lt;int, int&gt; record;</span><br><span class="line">        // map 中判断是否记录过的方法</span><br><span class="line">        while (record.find(n) == record.end()) &#123;</span><br><span class="line">            // 做记录</span><br><span class="line">            record[n] = 0;</span><br><span class="line">            n = get_happy(n);</span><br><span class="line">            // 得到快乐数的情况</span><br><span class="line">            if (n == 1) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            //cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 递归获取各位平方和</span><br><span class="line">    int get_happy(int n) &#123;</span><br><span class="line">        if (n &gt;= 10) &#123;</span><br><span class="line">            return (n % 10) * (n % 10) + get_happy(n / 10);</span><br><span class="line">        &#125;</span><br><span class="line">        return n * n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html">代码随想录 (programmercarl.com)</a></li>
<li>该题给予了一个整数数组和目标数字，要求找到数组中一组两数和为目标值的下标</li>
<li>暴力解法为 O(n^2) 遍历两层数组，而运用哈希值就能快很多，通过 map，可以把遍历过的数字作为索引，其对应下标作为值存入 map 中，如此在得到数组中的一个数字时，就计算其与目标差值，在 map 中查找差值是否存在，存在则找到解，不存在则存入当前正在遍历的数字及其下标。</li>
<li></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        map&lt;int,int&gt; record; // 记录已遍历数字，索引为数值，值为下标</span><br><span class="line">        vector&lt;int&gt; result; // 要返回的结果</span><br><span class="line">        int index = 0; // 下标记录</span><br><span class="line"></span><br><span class="line">        // 遍历每个数</span><br><span class="line">        for (auto c : nums) &#123;</span><br><span class="line">            int cur = target - c; // 与目标值所差值</span><br><span class="line">            if (record.find(cur) != record.end()) &#123; // 若差值已遍历，则可调出凑出结果</span><br><span class="line">                result.push_back(record[cur]);</span><br><span class="line">                result.push_back(index);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123; // 否则记录当前值及其下标</span><br><span class="line">                record[c] = index;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            index++; // 更新下标</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="四数相加"><a href="#四数相加" class="headerlink" title="四数相加||"></a>四数相加||</h2><ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0454.%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II.html">代码随想录 (programmercarl.com)</a></li>
<li>与[[两数之和]]类似，不过这次有四个数组，要求找到四个数组各取一数之和为 0 的元组个数</li>
<li>方法是，把前两数组之和放 map，和值为 key，出现次数为 value，然后遍历后两数组和，对于其负数若 map 中有，则结果多一个该负数在 map 对应的 value 值</li>
<li></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int fourSumCount(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3, vector&lt;int&gt;&amp; nums4) &#123;</span><br><span class="line">        unordered_map&lt;int, int&gt; num_record; // 记录前两者和的情况和次数</span><br><span class="line">        int result = 0; // 记录结果元组个数</span><br><span class="line"></span><br><span class="line">        // 遍历前两数组，记录和</span><br><span class="line">        for (auto i : nums1) &#123;</span><br><span class="line">            for (auto j : nums2) &#123;</span><br><span class="line">                num_record[i + j]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 遍历后两数组和，检查是否有满足和为0的一对</span><br><span class="line">        for (auto i : nums3) &#123;</span><br><span class="line">            for (auto j : nums4) &#123;</span><br><span class="line">                if (num_record.find(-1 * (i + j)) != num_record.end()) &#123;</span><br><span class="line">                    result += num_record[-1 * (i + j)];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="赎金信"><a href="#赎金信" class="headerlink" title="赎金信"></a>赎金信</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0383.%E8%B5%8E%E9%87%91%E4%BF%A1.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></p>
</li>
<li><p>本题的意思与此前的 [[有效的字母异位词]]，很相近，不过 [[有效的字母异位词]] 需要两个字符串可以互相组成，而本题只需要字符串 a 能由字符串 b 组成即可</p>
</li>
<li><p>方法反而简单，可以用 map 记录字母对应次数，但由于本题目已说明字母串中皆为小写字母，所以通过 ASCII 码转换下标记录数组的效率更高，更简单</p>
</li>
<li><p>陆爻齐的思路是增加一个整形数字记录所需字母的总个数，一旦字符串 b 中出现所需字母，且所需字母的需要个数非零，则该数字减一，最后秩序检查该数字是否为零即可得知题意是否满足</p>
<p>代码随想录更直接些，先统计字符串b的字母，再用 a 的减去，若出现小于零的位，则说明有没有满足的字母存在  </p>
</li>
<li><p>陆爻齐的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int need_num = 0;   // 记录需要字母的总个数</span><br><span class="line">    int word_record[26] = &#123;0&#125;; // 记录需要字母的个数</span><br><span class="line"></span><br><span class="line">    bool canConstruct(string ransomNote, string magazine) &#123;</span><br><span class="line">        // 记录需要字母个数</span><br><span class="line">        for (auto c : ransomNote) &#123;</span><br><span class="line">            add_rec(get_char_num(c));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 削减需要字母个数</span><br><span class="line">        for (auto c : magazine) &#123;</span><br><span class="line">            cut_rec(get_char_num(c));</span><br><span class="line">        &#125;</span><br><span class="line">        // 若仍有需要字符未消减干净，则不满足题目条件</span><br><span class="line">        if (need_num &gt; 0)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 记录需要的字母及其数量</span><br><span class="line">    void add_rec(int index) &#123;</span><br><span class="line">        word_record[index]++;</span><br><span class="line">        need_num++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 削减magazine有的字符，但只有是需要的情况下才削减数量</span><br><span class="line">    void cut_rec(int index) &#123;</span><br><span class="line">        if (word_record[index] &gt; 0) &#123;</span><br><span class="line">            word_record[index]--;</span><br><span class="line">            need_num--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取字母对应的下标</span><br><span class="line">    inline int get_char_num(char c) &#123;</span><br><span class="line">        return int(c - 97);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>代码随想录的解法  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool canConstruct(string ransomNote, string magazine) &#123;</span><br><span class="line">        int record[26] = &#123;0&#125;;</span><br><span class="line">        //add</span><br><span class="line">        if (ransomNote.size() &gt; magazine.size()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; magazine.length(); i++) &#123;</span><br><span class="line">            // 通过record数据记录 magazine里各个字符出现次数</span><br><span class="line">            record[magazine[i]-&#x27;a&#x27;] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 0; j &lt; ransomNote.length(); j++) &#123;</span><br><span class="line">            // 遍历ransomNote，在record里对应的字符个数做--操作</span><br><span class="line">            record[ransomNote[j]-&#x27;a&#x27;]--;</span><br><span class="line">            // 如果小于零说明ransomNote里出现的字符，magazine没有</span><br><span class="line">            if(record[ransomNote[j]-&#x27;a&#x27;] &lt; 0) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></p>
</li>
<li><p>即在一个数组中，找到下标互不重复且三个值不重复的所有三数之和为零的三元组</p>
</li>
<li><p>看起来与[[两数之和]]相近，可以把前两数之和放 map，最后一个数匹配，但由于题目要求返回不重三元组，所以去重将是大难题</p>
</li>
<li><p>所以本题采用双指针，先把数组排好序，用 i 确认第一个数 a，再用left 和 right 从 a 的右侧两旁逼近答案</p>
<p>思路不难，但去重难  </p>
<p>首先是 a 的去重，由于排好序了，只要让 a 与前一个值不同，就可以遍历到不同的 a；那么可以让 a 与后面一个不同吗？不能，因为可能有{1，1，-2} 这样的情况，若让 a 与后一个不同，那么由于前两个 1，该答案会被排除。  </p>
<p>然后是 b 和 c 的去重，由于排好序，在取到一个可用值后，让 left 和 right 各向中心去重  </p>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int size = nums.size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">        sort(nums.begin(), nums.end());// 先排好序</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line"></span><br><span class="line">            // 若最小的数都为正数，那么三数之和不可能为零</span><br><span class="line">            if (nums[i] &gt; 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 对第一个 a 的去重，若前一个与当前相等，那么有三数之和为零的话一定重用，没的话三数之和定不为零</span><br><span class="line">            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 双指针遍历</span><br><span class="line">            int left = i+1, right = size - 1;</span><br><span class="line">            while (left &lt; right) &#123;</span><br><span class="line">                int sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                // 若三数之和小了，让 left 变大</span><br><span class="line">                if (sum &lt; 0) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                // 大了，就让 right 变小</span><br><span class="line">                else if(sum &gt; 0) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    result.push_back(vector&lt;int&gt;&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line"></span><br><span class="line">                    // 对于 left 和 right 的去重</span><br><span class="line">                    while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    while(right &gt; left &amp;&amp; nums[right] == nums[right - 1]) &#123;</span><br><span class="line">                        right--;    </span><br><span class="line">                    &#125;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h2><ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></li>
<li>本地算[[三数之和]]的拓展，习得这个拓展套路，便可解决类似的“五数之和”等</li>
<li>与 [[四数相加||]] 不同，该题要在与 [[三数之和]] 的一个数组下，找到四数之和为 target 的四元组</li>
<li>注意 target 可能为负，所以剪枝不能大于target就剪就差不多了罢</li>
<li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">            vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">            sort(nums.begin(), nums.end()); // 确保数组有序</span><br><span class="line">            int size = nums.size();</span><br><span class="line">            for (int k = 0; k &lt; size; k++) &#123; // 第一个数</span><br><span class="line">                if (nums[k] &gt;= 0 &amp;&amp; nums[k] &gt; target) &#123; //第一层剪枝，若往后只会更大则剪</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (k &gt; 0 &amp;&amp; nums[k-1] == nums[k]) &#123; // 第一层去重</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                for (int i = k + 1; i &lt; size; i++) &#123;</span><br><span class="line">                    int i_k_sum = nums[i] + nums[k];</span><br><span class="line">                    if (i_k_sum &gt;= 0 &amp;&amp; i_k_sum &gt; target) &#123; // 第二层剪枝</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (i &gt; k + 1 &amp;&amp; nums[i - 1] == nums[i]) &#123; //第二层去重</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    int left = i + 1, right = size - 1;</span><br><span class="line"></span><br><span class="line">                    while (left &lt; right) &#123;</span><br><span class="line">                        if ((long long)i_k_sum + nums[left] + nums[right] &gt; target) &#123; </span><br><span class="line">                            right--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else if((long long)i_k_sum + nums[left] + nums[right] &lt; target) &#123;</span><br><span class="line">                            left++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            result.push_back(vector&lt;int&gt;&#123;nums[k], nums[i], nums[left], nums[right]&#125;);</span><br><span class="line"></span><br><span class="line">                            while(left &lt; right &amp;&amp; nums[left] == nums[left+1]) &#123;</span><br><span class="line">                                left++;</span><br><span class="line">                            &#125;</span><br><span class="line">                            while(left &lt; right &amp;&amp; nums[right] == nums[right-1]) &#123;</span><br><span class="line">                                right--;</span><br><span class="line">                            &#125;</span><br><span class="line">                            left++;</span><br><span class="line">                            right--;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/29/[Weekly%20Algorithm]%203%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%93%88%E5%B8%8C%E8%A1%A8/" data-id="cm7j3jecf001m10ag485y7769" data-title="【Weekly Algorithm】 算法周记之《代码随想录》哈希表" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-[Weekly Algorithm] 2算法周记之《代码随想录》链表" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/22/%5BWeekly%20Algorithm%5D%202%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E9%93%BE%E8%A1%A8/" class="article-date">
  <time class="dt-published" datetime="2024-09-22T07:35:00.000Z" itemprop="datePublished">2024-09-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/22/%5BWeekly%20Algorithm%5D%202%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E9%93%BE%E8%A1%A8/">【Weekly Algorithm】 算法周记之《代码随想录》链表</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h1><p>本周跟随《代码随想录》学习链表部分，较深入地了解了链表的相关算法题，并利用双指针解决部分题目。</p>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a>移除链表元素</h2><ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录 (programmercarl.com)</a></li>
<li>由于链表结构特殊，移除操作需要对指针操作，稍微复杂点</li>
<li>比较方便的方法是，用一个虚拟的指针头，将这个链表的删除操作转化为统一的链表中元素的移除</li>
<li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* removeElements(ListNode* head, int val) &#123;</span><br><span class="line">        ListNode* vir_head = new ListNode(0);</span><br><span class="line">        vir_head-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        // 用虚拟头统一操作</span><br><span class="line">        ListNode*p = vir_head;</span><br><span class="line"></span><br><span class="line">        while(p-&gt;next != nullptr) &#123;</span><br><span class="line">            // 下个符合就删</span><br><span class="line">            if (p-&gt;next-&gt;val == val) &#123;</span><br><span class="line">                ListNode *tmp = p-&gt;next;</span><br><span class="line">                p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">                delete tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            // 没删 next 的情况再更新到 next，若刚删了 next 且 null，会在循环那里停下来</span><br><span class="line">            else &#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return vir_head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h2><ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0707.%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></li>
<li>考察很综合，增删查改</li>
<li>TODO 独立单链表实现一次</li>
<li>TODO 双链表独立实现一次</li>
<li></li>
<li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _link &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct _link *next = nullptr;</span><br><span class="line">    //struct _link *pre = nullptr;</span><br><span class="line"></span><br><span class="line">    _link(int num) &#123;</span><br><span class="line">        val = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;link_node;</span><br><span class="line"></span><br><span class="line">class MyLinkedList &#123;</span><br><span class="line">public:</span><br><span class="line">    int size = 0;</span><br><span class="line">    link_node * head;</span><br><span class="line"></span><br><span class="line">    MyLinkedList() &#123;</span><br><span class="line">        this-&gt;size = 0;</span><br><span class="line">        head = new link_node(0);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int get(int index) &#123;</span><br><span class="line">        if (index &gt;= size || index &lt; 0) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        link_node *p = head-&gt;next;</span><br><span class="line">        for (int i = 0; i &lt; index; i++) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return p-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void addAtHead(int val) &#123;</span><br><span class="line">        link_node *p = new link_node(val);</span><br><span class="line">        p-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next = p;</span><br><span class="line">        this-&gt;size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void addAtTail(int val) &#123;</span><br><span class="line">        link_node *p = new link_node(val);</span><br><span class="line">        link_node *cur = head;</span><br><span class="line">        while(cur-&gt;next != nullptr) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = p;</span><br><span class="line">        this-&gt;size++;</span><br><span class="line">        </span><br><span class="line">        //addAtIndex(this-&gt;size, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void addAtIndex(int index, int val) &#123;</span><br><span class="line">        if(index &gt; this-&gt;size) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (index &lt; 0) &#123;</span><br><span class="line">            index = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        link_node *p = head;</span><br><span class="line">        for (int i = 0; i &lt; index; i++) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        link_node *new_node = new link_node(val);</span><br><span class="line">        new_node-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = new_node;</span><br><span class="line">        this-&gt;size++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void deleteAtIndex(int index) &#123;</span><br><span class="line">        if (index &gt;= this-&gt;size || index &lt; 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        link_node *p = head;</span><br><span class="line">        for (int i = 0; i &lt; index; i++) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;  </span><br><span class="line">        link_node *q = p-&gt;next;</span><br><span class="line">        p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">        delete  q;</span><br><span class="line">        this-&gt;size--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your MyLinkedList object will be instantiated and called as such:</span><br><span class="line"> * MyLinkedList* obj = new MyLinkedList();</span><br><span class="line"> * int param_1 = obj-&gt;get(index);</span><br><span class="line"> * obj-&gt;addAtHead(val);</span><br><span class="line"> * obj-&gt;addAtTail(val);</span><br><span class="line"> * obj-&gt;addAtIndex(index,val);</span><br><span class="line"> * obj-&gt;deleteAtIndex(index);</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html">代码随想录 (programmercarl.com)</a></p>
</li>
<li><p>本题要求，将一个单链表顺序翻转过来</p>
</li>
<li><p>有递归法、双指针法，时间复杂度皆为O（n），双指针空间复杂度O（1），递归O（n）</p>
</li>
<li><p>双指针法如下</p>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        ListNode *pre = nullptr;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        ListNode *tmp = nullptr;// 存储 cur 的下个节点</span><br><span class="line">        while(cur != nullptr) &#123;</span><br><span class="line">            tmp = cur-&gt;next; // 先存下个要操作的节点</span><br><span class="line">            cur-&gt;next = pre;// 翻转当前节点</span><br><span class="line">            pre = cur; // 整体右移一个</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h2><ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0024.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html">代码随想录 (programmercarl.com)</a></li>
</ul>
</li>
<li><p>该题就是要求把链表中每两个元素的顺序调换</p>
</li>
<li><p>方法就是选定锚点，然后以锚点后两个交换</p>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* swapPairs(ListNode* head) &#123;</span><br><span class="line">        // 建个哨兵以统一后面的交换进程</span><br><span class="line">        ListNode *setinel = new ListNode(0);</span><br><span class="line">        setinel-&gt;next = head;</span><br><span class="line">        ListNode *cur = setinel;</span><br><span class="line">        // 以cur为基准，交换后两个结点</span><br><span class="line">        while(cur-&gt;next != nullptr &amp;&amp; cur-&gt;next-&gt;next != nullptr) &#123;</span><br><span class="line">            ListNode *tmp1 = cur-&gt;next;</span><br><span class="line">            ListNode *tmp2 = cur-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">            // 先连接到后面，剩下两个随意换</span><br><span class="line">            tmp1-&gt;next = tmp2-&gt;next;</span><br><span class="line">            tmp2-&gt;next = tmp1;</span><br><span class="line">            cur-&gt;next = tmp2;</span><br><span class="line"></span><br><span class="line">            // 向右移动两节点</span><br><span class="line">            cur = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 由于head可能变了，传setinel回去</span><br><span class="line">        return setinel-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h2><ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.html">代码随想录 (programmercarl.com)</a></li>
</ul>
</li>
<li><p>题意易见</p>
</li>
<li><p>一次遍历解决的方法是，用双指针，快指针先走N步，再两指针一起走，最后删除慢指针后面那个。</p>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;</span><br><span class="line">        // 哨兵节点统一处理</span><br><span class="line">        ListNode *sentinel = new ListNode(0);</span><br><span class="line">        sentinel-&gt;next = head;</span><br><span class="line">        ListNode *right = sentinel, *left = sentinel;</span><br><span class="line">        // 先走N步</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            right = right-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 一起走</span><br><span class="line">        while(right-&gt;next != nullptr) &#123;</span><br><span class="line">            right = right-&gt;next;</span><br><span class="line">            left = left-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 删慢指针后面那个</span><br><span class="line">        ListNode *tmp = left-&gt;next;</span><br><span class="line">        left-&gt;next = tmp-&gt;next;</span><br><span class="line">        delete tmp;</span><br><span class="line">        return sentinel-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h2><ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4.html">代码随想录 (programmercarl.com)</a></li>
</ul>
</li>
<li><p>即有两条长短不一的链表，在后面某一点交会到一条，找到交汇的那个点</p>
</li>
<li><p>方法即是先找到两个链表的长度，然后让长短两条各有一指针从相同位置同时检测两指针是否相等，毕竟前面的长短不一的部分不可能交汇</p>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span><br><span class="line">        int len_a = 0, len_b = 0;</span><br><span class="line">        ListNode *cur_a = headA, *cur_b = headB;</span><br><span class="line"></span><br><span class="line">        // 分别测量 a 和 b 的长度</span><br><span class="line">        while(cur_a != nullptr) &#123;</span><br><span class="line">            cur_a = cur_a-&gt;next;</span><br><span class="line">            len_a++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while(cur_b != nullptr) &#123;</span><br><span class="line">            cur_b = cur_b-&gt;next;</span><br><span class="line">            len_b++;</span><br><span class="line">        &#125;</span><br><span class="line">        cur_a = headA;</span><br><span class="line">        cur_b = headB;</span><br><span class="line"></span><br><span class="line">        int len_dif = abs(len_a - len_b);</span><br><span class="line"></span><br><span class="line">        // 保证 a 是较长的一端</span><br><span class="line">        if (len_a &lt; len_b) &#123;</span><br><span class="line">            swap(cur_a, cur_b);</span><br><span class="line">            swap(len_a, len_b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 对齐 a 和 b</span><br><span class="line">        for (int i = 0; i &lt; len_dif; i++) &#123;</span><br><span class="line">            cur_a = cur_a-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 逐一检查是否相等</span><br><span class="line">        while(cur_a != nullptr) &#123;</span><br><span class="line">            if (cur_a == cur_b) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            cur_a = cur_a-&gt;next;</span><br><span class="line">            cur_b = cur_b-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return cur_a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表||"></a>环形链表||</h2><ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html">代码随想录 (programmercarl.com)</a></li>
</ul>
</li>
<li><p>即链表后面可能有个环，要求返回入环点</p>
</li>
<li><p>两个问题，一、有没有环；二、入环点怎么找</p>
</li>
<li><p>有没有环的问题，可以通过简单的双指针解决，即快指针走两步，慢指针走一步，若是有环，一定在某点相遇。倘若慢指针刚入环，无论快指针在环走多少，此时设快指针到慢指针距离 x，每次行动距离减一，迟早相遇。</p>
</li>
<li><p>接着是入环点的问题，接下来就是数学为主的时间，设 head 到入环点距离 x，入环点到相遇点距离 y，相遇点到入环点距离 z，慢指针就走了 x+y，快指针走了 x+n* (y+z) +y （毕竟可能走了几圈），快指针移速为慢指针两倍，可列式子 2*(x+y) &#x3D;  x+n* (y+z) +y，消减得 x &#x3D; n(y+z) - y，变换得 x &#x3D; (n-1)(y+z) + z，一看从相遇点开始走 z 步（可能加上好几圈）以及从头开始走的不就可以在入环点相遇了嘛。</p>
<p>假设 n&#x3D;1，x&#x3D;&#x3D;z，两边直接相遇；n&#x3D;2，相遇点处的指针多走一圈，也能相遇  </p>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *detectCycle(ListNode *head) &#123;</span><br><span class="line">        ListNode *fast = head, *slow = head;</span><br><span class="line"></span><br><span class="line">        // 探明是否有环</span><br><span class="line">        while(fast != nullptr &amp;&amp; fast-&gt;next != nullptr) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            if (fast == slow) &#123;</span><br><span class="line">                // 从交汇点与起点同时走，交汇于入环点</span><br><span class="line">                slow = head;</span><br><span class="line">                while (fast != slow) &#123;</span><br><span class="line">                    fast = fast-&gt;next;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                return fast;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nullptr;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/22/[Weekly%20Algorithm]%202%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E9%93%BE%E8%A1%A8/" data-id="cm7j3jece001l10agb9o1fiks" data-title="【Weekly Algorithm】 算法周记之《代码随想录》链表" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-[Conda] miniconda 使用手册" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/16/%5BConda%5D%20miniconda%20%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/" class="article-date">
  <time class="dt-published" datetime="2024-09-16T06:14:00.000Z" itemprop="datePublished">2024-09-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/16/%5BConda%5D%20miniconda%20%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/">【Conda】 miniconda 使用手册</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是陆爻齐平时经常使用 conda 的一些记录，且作为复习笔记罢</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="创建环境"><a href="#创建环境" class="headerlink" title="创建环境"></a>创建环境</h2><p><code>conda create -n name python=3.9.*</code><br>这条语句的意思是创建名字为 name，python 版本为 3.9 中最新的版本的环境，-n 后面跟名字，python 也可先不确定，但还没试过后面安 python。</p>
<h2 id="查看环境"><a href="#查看环境" class="headerlink" title="查看环境"></a>查看环境</h2><p><code>conda env list</code><br>会列出所有已有的虚拟环境</p>
<h2 id="删除环境"><a href="#删除环境" class="headerlink" title="删除环境"></a>删除环境</h2><p><code>conda remove -n name --all</code><br>删除名字为 name 的环境</p>
<h2 id="克隆环境"><a href="#克隆环境" class="headerlink" title="克隆环境"></a>克隆环境</h2><p><code>conda create -n name --clone other</code><br>将名为 other 的环境复制到新环境 name 中</p>
<h2 id="更改存储和环境的地方"><a href="#更改存储和环境的地方" class="headerlink" title="更改存储和环境的地方"></a>更改存储和环境的地方</h2><p><a target="_blank" rel="noopener" href="https://www.autodl.com/docs/miniconda/#:~:text=%E5%8F%96%E6%B6%88%E8%AE%BE%E7%BD%AE%E5%AE%89%E8%A3%85%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%88%B0%E6%95%B0%E6%8D%AE%E7%9B%98,%E7%BC%96%E8%BE%91%2Froot%2F.condarc%E6%96%87%E4%BB%B6%EF%BC%8C%E5%88%A0%E9%99%A4%E5%AF%B9%E5%BA%94%E7%9A%84%E8%B7%AF%E5%BE%84%E6%89%80%E5%9C%A8%E8%A1%8C%E5%8D%B3%E5%8F%AF">参考网址</a><br>执行以下命令设置将虚拟环境安装到&#x2F;root&#x2F;autodl-tmp&#x2F;conda&#x2F;envs， 包缓存到&#x2F;root&#x2F;autodl-tmp&#x2F;conda&#x2F;pkgs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /root/autodl-tmp/conda/pkgs</span><br><span class="line">conda config --add pkgs_dirs /root/autodl-tmp/conda/pkgs</span><br><span class="line"></span><br><span class="line">mkdir -p /root/autodl-tmp/conda/envs</span><br><span class="line">conda config --add envs_dirs /root/autodl-tmp/conda/envs</span><br></pre></td></tr></table></figure>

<h2 id="打包环境"><a href="#打包环境" class="headerlink" title="打包环境"></a>打包环境</h2><p>参考<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/540615230">知乎文章</a></p>
<p>构建环境的操作系统必须与目标的操作系统匹配。这意味着在Windows上构建的环境不能重新定位到Linux。</p>
<h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 把虚拟环境 my_env 打包为 my_env.tar.gz</span><br><span class="line">conda pack -n my_env</span><br><span class="line"></span><br><span class="line"># -o 参数指定打包路径和名称，把虚拟环境 my_env 打包为 out_name.tar.gz</span><br><span class="line">conda pack -n my_env -o out_name.tar.gz</span><br><span class="line"></span><br><span class="line"># 把某个特定路径的虚拟环境打包为 my_env.tar.gz</span><br><span class="line">conda pack -p /explicit/path/to/my_env</span><br></pre></td></tr></table></figure>

<h3 id="解压使用"><a href="#解压使用" class="headerlink" title="解压使用"></a>解压使用</h3><h4 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 创建目录 `my_env`，并将环境解压至该目录</span><br><span class="line">mkdir -p my_env</span><br><span class="line">tar -xzf my_env.tar.gz -C my_env</span><br><span class="line"></span><br><span class="line"># 使用python而不激活或修复前缀。</span><br><span class="line"># 大多数 python 库可以正常工作，但需要处理前缀的部分将失败。</span><br><span class="line">./my_env/bin/python</span><br><span class="line"></span><br><span class="line"># 激活环境，同时这步操作会将路径 `my_env/bin` 添加到环境变量 path</span><br><span class="line">source my_env/bin/activate</span><br><span class="line"></span><br><span class="line"># 在环境中运行python</span><br><span class="line">(my_env) $ python</span><br><span class="line"></span><br><span class="line"># 从激活环境中清除前缀。</span><br><span class="line"># 请注意，也可以在不激活环境的情况下运行此命令</span><br><span class="line"># 只要机器上已经安装了某个版本的python。</span><br><span class="line">(my_env) $ conda-unpack</span><br><span class="line"></span><br><span class="line"># 此时，环境与您在此路径直接使用 conda 安装的环境完全相同。</span><br><span class="line"># 所有脚本都应该工作正常。</span><br><span class="line">(my_env) $ ipython --version</span><br><span class="line"></span><br><span class="line"># 停用环境以将其从环境变量 path 中删除</span><br><span class="line">(my_env) $ source my_env/bin/deactivate</span><br></pre></td></tr></table></figure>
<h4 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h4><p>新建 <code>my_env</code> 文件夹，将打包的 my_env.tar.gz 文件解压到该文件夹中。</p>
<p>使用 cmd 打开路径 <code>my_env</code> 所在路径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 进入项目路径</span><br><span class="line">cd C:\my_env</span><br><span class="line"></span><br><span class="line"># 激活环境 </span><br><span class="line">.\Scripts\activate.bat</span><br><span class="line"></span><br><span class="line"># 从激活环境中清除前缀。</span><br><span class="line">.\Scripts\conda-unpack.exe</span><br><span class="line"></span><br><span class="line"># 退出环境</span><br><span class="line">.\Scripts\deactivate.bat</span><br></pre></td></tr></table></figure>

<h2 id="修复无法激活环境的问题"><a href="#修复无法激活环境的问题" class="headerlink" title="修复无法激活环境的问题"></a>修复无法激活环境的问题</h2><p>问题发生情景：在 activate 环境时，报错如 <code>UnicodeDecodeError: &#39;gbk&#39; codec can&#39;t decode byte 0xae in position 790: illegal multibyte sequence Unexpected cygpath error (&#39;NoneType&#39; object has no attribute &#39;strip&#39;)</code></p>
<p>问题排查过程：经解读报错和查阅资料发现，该问题是由于 conda 在启动环境的过程中，读取到了非正常字符。想到最近安装了微信开发者工具，让环境变量的 Path 中出现了中文，故删除对应的环境路径，再启动环境就正常了</p>
<p>总结：环境变量 Path 中出现的中文让 conda 激活环境失败</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/16/[Conda]%20miniconda%20%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/" data-id="cm7j3jec1000b10agbv24gyuh" data-title="【Conda】 miniconda 使用手册" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Conda/" rel="tag">Conda</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-[Weekly Algorithm] 1算法周记之《代码随想录》数组" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/15/%5BWeekly%20Algorithm%5D%201%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E6%95%B0%E7%BB%84/" class="article-date">
  <time class="dt-published" datetime="2024-09-15T04:03:00.000Z" itemprop="datePublished">2024-09-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/15/%5BWeekly%20Algorithm%5D%201%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E6%95%B0%E7%BB%84/">【Weekly Algorithm】 算法周记之《代码随想录》数组</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h1><p>前两周跟随《代码随想录》，对数组的部分做学习，具体而言，学习了二分查找、前缀和、双指针、滑动窗口的方法，来解决相关数组问题。</p>
<p>也学到要坚持循环不变原则，即有些原则在循环中应保持不变，以统一后续操作，方便完成循环，具体可查看螺旋矩阵的部分。</p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="正例"><a href="#正例" class="headerlink" title="正例"></a>正例</h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E6%80%BB%E7%BB%93">代码随想录 (programmercarl.com)</a></p>
</li>
<li><p>二分查找重点是搞清楚边界，下面是左闭右开的写法</p>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int func(vector&lt;int&gt; nums, int target) &#123;</span><br><span class="line">	int left = 0, right = nums.size(), middle;</span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">    	middle = (left + right) / 2;</span><br><span class="line">        if (nums[middle] &gt; target) right = middle;</span><br><span class="line">        else if (nums[middle] &lt; target) left = middle + 1;</span><br><span class="line">        else return middle;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>左闭右开，即 num[left] 在搜索范围内（可能为 target），num[right] 刚好不在，所以中间更新时也有所区别，left 得是 middle + 1，因为 middle 处已确认不是 target</p>
</li>
<li><p>倘若考虑闭区间，将 while 改 <code>while (left &lt;= right)</code>, right 改 <code>right = nums.size() - 1</code>，<code>right = middle - 1</code>即可</p>
</li>
</ul>
<h3 id="补充例题"><a href="#补充例题" class="headerlink" title="补充例题"></a>补充例题</h3><h4 id="leetcode-查找数组中元素的第一个和最后一个位置"><a href="#leetcode-查找数组中元素的第一个和最后一个位置" class="headerlink" title="leetcode_查找数组中元素的第一个和最后一个位置"></a>leetcode_查找数组中元素的第一个和最后一个位置</h4><ul>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0034.%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE.html">代码随想录</a></p>
</li>
<li><p>首先，可以用两次二分法确认元素的左右边界</p>
<p>最重要的是，分清查找后的三种情况  </p>
<ol>
<li>元素大小在数组外，自然不在数组中，比如数组中最大的是9，target 是 12；</li>
<li>元素大小在数组内，但不在数组中，比如target 是 5，但数组为……4，6……；</li>
<li>元素在数组中</li>
</ol>
</li>
</ul>
<p>如此一来，可以设置变量，检测二分法找边界时，是否有更新边界，两次二分法有一次没有更新边界的情况，都说明元素大小在数组外  </p>
<p>当两次都更新了边界，就可以看看给出的边界是否时target，不是的话属于第二种情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int left = searchLeft(nums, target), right = searchRight(nums, target);</span><br><span class="line">        vector&lt;int&gt;result(2);</span><br><span class="line">        // 处理数在外的的情况</span><br><span class="line">        if (left == -2 || right == -2) &#123;</span><br><span class="line">            result[0] = -1; result[1] = -1;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        // 处理数在不在其中但大小在中间的情况</span><br><span class="line">        else if (nums[left] != target) &#123;</span><br><span class="line">            result[0] = -1; result[1] = -1;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        // 处理数在其中的情况</span><br><span class="line">        result[0] = left, result[1] = right - 1;</span><br><span class="line">        return result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    // 找到左边界的二分法</span><br><span class="line">    int searchLeft(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int left = 0, right = nums.size(), middle = 0;</span><br><span class="line">        int leftBoarder = -2;</span><br><span class="line"></span><br><span class="line">        while (left &lt; right) &#123;</span><br><span class="line">            middle = (left + right) / 2;</span><br><span class="line">            if (nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + 1; </span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                right = middle;</span><br><span class="line">                leftBoarder = right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //cout &lt;&lt; leftBoarder &lt;&lt; endl;</span><br><span class="line">        return leftBoarder;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    // 找到右边界的二分法</span><br><span class="line">    int searchRight(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int left = 0, right = nums.size(), middle = 0;</span><br><span class="line">        int rightBoarder = -2;</span><br><span class="line"></span><br><span class="line">        while (left &lt; right) &#123;</span><br><span class="line">            middle = (left + right) / 2;</span><br><span class="line">            if (nums[middle] &lt;= target) &#123;</span><br><span class="line">                left = middle + 1;</span><br><span class="line">                rightBoarder = left;</span><br><span class="line">            &#125; </span><br><span class="line">            else right = middle; </span><br><span class="line">        &#125;</span><br><span class="line">        //cout &lt;&lt; rightBoarder &lt;&lt; endl;</span><br><span class="line">        return rightBoarder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="leetcode-x的平方根"><a href="#leetcode-x的平方根" class="headerlink" title="leetcode_x的平方根"></a>leetcode_x的平方根</h4><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sqrtx/description/">69. x 的平方根 - 力扣（LeetCode）</a></li>
<li>即找到平方为 x 的平方根的整数部分</li>
<li>毕竟就是算术平方根，就用二分法逼近即可，注意 middle * middle 可能超 int，用 long long 就行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int mySqrt(int x) &#123;</span><br><span class="line">        int result = 0, left = 0, right = x + 1; </span><br><span class="line">        unsigned long long middle = 0;</span><br><span class="line">		// 二分试那个数平方恰小于等于的</span><br><span class="line">        while(left &lt; right) &#123;</span><br><span class="line">            middle = (left + right) / 2;</span><br><span class="line">            if (middle * middle &gt; x) &#123;</span><br><span class="line">                right = middle;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                left = middle + 1;</span><br><span class="line">                result = middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="leetcode-有效的完全平方数"><a href="#leetcode-有效的完全平方数" class="headerlink" title="leetcode_有效的完全平方数"></a>leetcode_有效的完全平方数</h4><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-perfect-square/description/">367. 有效的完全平方数 - 力扣（LeetCode）</a></li>
<li>即判断当前数是否为完全平方数，二分法找个平方为该数即可</li>
<li>与上个平方类似，不多说， [[leetcode_x的平方根]]</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPerfectSquare(int num) &#123;</span><br><span class="line">        unsigned long long left = 0, right = num, middle = 0;</span><br><span class="line">        // 二分法试出那个平方为 num 的数</span><br><span class="line">        while (left &lt;= right) &#123;</span><br><span class="line">            middle = (left + right) / 2;</span><br><span class="line">            if (middle * middle &gt; num) &#123;</span><br><span class="line">                right = middle - 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (middle * middle &lt; num) &#123;</span><br><span class="line">                left = middle + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h2><h3 id="正例-1"><a href="#正例-1" class="headerlink" title="正例"></a>正例</h3><ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录 (programmercarl.com)</a></li>
<li>暴力解法<br>即每次遇到要删除的元素，就把数组后面每一位向左覆盖一位  </li>
<li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;</span><br><span class="line">        int size = nums.size();</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            if (nums[i] == val) &#123;</span><br><span class="line">                for (int j = i; j &lt; size - 1; j++) &#123;</span><br><span class="line">                    nums[j] = nums[j + 1];</span><br><span class="line">                &#125;</span><br><span class="line">                size--;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>双指针法<br>快指针去找元素，慢指针是新数组的元素  </li>
<li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;</span><br><span class="line">        int fast_p = 0, slow_p = 0;</span><br><span class="line">        int size = nums.size();</span><br><span class="line">        for (fast_p = 0; fast_p &lt; size; fast_p++) &#123;</span><br><span class="line">            if (nums[fast_p] != val) &#123;</span><br><span class="line">                nums[slow_p++] = nums[fast_p];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return slow_p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="补充例题-1"><a href="#补充例题-1" class="headerlink" title="补充例题"></a>补充例题</h3><h4 id="leetcode-重复删除有序数组中的重复项"><a href="#leetcode-重复删除有序数组中的重复项" class="headerlink" title="leetcode_重复删除有序数组中的重复项"></a>leetcode_重复删除有序数组中的重复项</h4><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项 - 力扣（LeetCode）</a></li>
<li>即数组去重</li>
<li>双指针秒了</li>
<li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int size = nums.size(), slow = 0, fast = 0;</span><br><span class="line">        int counter = 1;</span><br><span class="line">        for (fast = 1; fast &lt; size; fast++) &#123;</span><br><span class="line">        	// 不同的情况做个覆盖</span><br><span class="line">            if (nums[slow] != nums[fast]) &#123;</span><br><span class="line">                nums[++slow] = nums[fast];</span><br><span class="line">                counter++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="leetcode-移动零"><a href="#leetcode-移动零" class="headerlink" title="leetcode_移动零"></a>leetcode_移动零</h4><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/move-zeroes/description/">283. 移动零 - 力扣（LeetCode）</a></li>
<li>即保持非零数字顺序，零全放右侧</li>
<li>双指针解决，记得有个 swap 函数可用于向量就方便些，简单地说，就是让快指针去找非零数，然后替换到慢指针所在的地方，若快指针遇到零就不换，跳过就是。</li>
<li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int size = nums.size();</span><br><span class="line">        int slow = 0, fast = 0;</span><br><span class="line">        for (fast = 0; fast &lt; size; fast++) &#123;</span><br><span class="line">        	// 快指针不为 0 时，快慢指针换值并使慢指针右移</span><br><span class="line">            if (nums[fast] != 0) &#123;</span><br><span class="line">                swap(nums[slow++], nums[fast]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="leetcode-比较含退格的字符串"><a href="#leetcode-比较含退格的字符串" class="headerlink" title="leetcode_比较含退格的字符串"></a>leetcode_比较含退格的字符串</h4><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/backspace-string-compare/description/">844. 比较含退格的字符串 - 力扣（LeetCode）</a></li>
</ul>
</li>
<li>该题思路挺多，不过还得是双指针</li>
<li>可以用栈来改两个字符串，陆爻齐选择用双指针来改两字符串，也就是用慢指针确认前面的字符是什么，快指针去找要放在字符串的字符，换到慢指针处，与移动零的区别是，遇到 ‘#’ 时，慢指针应向左一格，让下次的字符覆盖上个字符。</li>
<li>也有思路从后向前双指针同时比较（退格键的左侧不重要，右侧可确定）</li>
<li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool backspaceCompare(string s, string t) &#123;</span><br><span class="line">        work(s);</span><br><span class="line">        work(t);</span><br><span class="line">        return s==t;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    // 使字符串变成处理完退格字符后的字符串</span><br><span class="line">    void work(string &amp;s) &#123;</span><br><span class="line">        int size = s.size(), slow = 0, fast = 0;</span><br><span class="line">        for (fast = 0; fast &lt; size; fast++) &#123;</span><br><span class="line">            if (s[fast] != &#x27;#&#x27;) &#123;</span><br><span class="line">                s[slow++] = s[fast];</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                if (slow &gt; 0) &#123;</span><br><span class="line">                    slow--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s = s.substr(0, slow);</span><br><span class="line">        //cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="leetcode-有序数组的平方"><a href="#leetcode-有序数组的平方" class="headerlink" title="leetcode_有序数组的平方"></a>leetcode_有序数组的平方</h4><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/squares-of-a-sorted-array/solutions/2806253/xiang-xiang-shuang-zhi-zhen-cong-da-dao-blda6/">977. 有序数组的平方 - 力扣（LeetCode）</a></li>
<li>即将非递减的数组（含负数），各位平方后再以非递减序列排成数组</li>
<li>从两侧向中间检测，也是双指针罢</li>
<li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int left = 0, size = nums.size(), right = size - 1;</span><br><span class="line">        vector&lt;int&gt; result(size);</span><br><span class="line">        for (int i = size - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        	// 左右比较，选大者放后面，循环至尽</span><br><span class="line">            if (nums[left] * nums[left]&gt; nums[right] * nums[right]) &#123;</span><br><span class="line">                result[i] = nums[left] * nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                result[i] = nums[right] * nums[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><h3 id="正例-2"><a href="#正例-2" class="headerlink" title="正例"></a>正例</h3><ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></li>
<li>滑动窗口可以视为双指针的特殊形态，以 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">长度最小的子数组</a> 为例</li>
<li>该题要求一个数组中连续元素和大于 target 的最小长度是多少</li>
<li>暴力解法可以用两个 for 循环嵌套，一个相当于起始，一个相当于终止，穷举出所有可能，不过时间复杂度为 O(n^2)</li>
<li>那么接下来就是 O(n) 的滑动窗口啦，该方法用 for 循环遍历终止位置，当快指针已遍历的数值满足需求时，记录长度，同时慢指针也向右移动至不满足要求，此时快指针再向右移动找下一个满足需求的情况</li>
<li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int size = nums.size(), sum = 0, least_len = INT32_MAX, i = 0, sub_len;</span><br><span class="line">        for (int j = 0; j &lt; size; j++) &#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            while (sum &gt;= target) &#123;</span><br><span class="line">                sub_len = j - i + 1;</span><br><span class="line">                if (least_len &gt; sub_len) &#123;</span><br><span class="line">                    least_len = sub_len;</span><br><span class="line">                &#125;</span><br><span class="line">                sum -= nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return (least_len == INT32_MAX) ? 0 : least_len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="补充例子"><a href="#补充例子" class="headerlink" title="补充例子"></a>补充例子</h3><h4 id="leetcode-水果成篮"><a href="#leetcode-水果成篮" class="headerlink" title="leetcode_水果成篮"></a>leetcode_水果成篮</h4><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fruit-into-baskets/">904. 水果成篮 - 力扣（LeetCode）</a></li>
<li>该题就是求数组中最长的连续两数字序列长度</li>
<li>要点是运用哈希表来做查重记录工作</li>
<li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int totalFruit(vector&lt;int&gt;&amp; fruits) &#123;</span><br><span class="line">        unordered_map&lt;int,int&gt; cns;</span><br><span class="line">        int size = fruits.size();</span><br><span class="line">        int left = 0;</span><br><span class="line">        int max_len = 0;</span><br><span class="line">        for (int right = 0; right &lt; size; right++) &#123;</span><br><span class="line">        	// 记录第一次遇到该数字</span><br><span class="line">            if (cns.find(fruits[right]) == cns.end()) &#123;</span><br><span class="line">                //cns.insert(&#123;fruits[right], 1&#125;);</span><br><span class="line">                cns[fruits[right]] = 1;</span><br><span class="line">            &#125;</span><br><span class="line">            // 重复计数</span><br><span class="line">            else &#123;</span><br><span class="line">                cns[fruits[right]]++;</span><br><span class="line">            &#125;</span><br><span class="line">			</span><br><span class="line">            // 当种类超过 2，开始去除一个</span><br><span class="line">            while (cns.size() &gt; 2) &#123;</span><br><span class="line">                cns[fruits[left]]--;</span><br><span class="line">                if (cns[fruits[left]] == 0) &#123;</span><br><span class="line">                    cns.erase(fruits[left]);</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">			</span><br><span class="line">            // 更新值</span><br><span class="line">            max_len = max(max_len, right - left + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return max_len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="leetcode-最小覆盖子串"><a href="#leetcode-最小覆盖子串" class="headerlink" title="leetcode_最小覆盖子串"></a>leetcode_最小覆盖子串</h4><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串 - 力扣（LeetCode）</a></li>
<li>该题就是在字符串 s 上，找涵盖字符串 t 所有字符的最小字符子串</li>
<li>只好用两字典存已有字符和目标字符，其余还是沿用滑动窗口，不过效率很低</li>
<li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    unordered_map&lt;char, int&gt; cns, target;</span><br><span class="line">    string minWindow(string s, string t) &#123;</span><br><span class="line">        string result = &quot;&quot;;</span><br><span class="line">        int min_len = INT32_MAX, start_ind = 0;</span><br><span class="line"></span><br><span class="line">        // 初始化 target 和 cns</span><br><span class="line">        for(auto it : t) &#123;</span><br><span class="line">            target[it]++;</span><br><span class="line">            cns[it] = 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int left = 0, right = 0;</span><br><span class="line">        int size = s.size();</span><br><span class="line"></span><br><span class="line">        for (right = 0; right &lt; size; right++) &#123;</span><br><span class="line">            if (cns.find(s[right]) != cns.end()) &#123;</span><br><span class="line">                cns[s[right]]++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 满足就调整左边窗口</span><br><span class="line">            while (check()) &#123;</span><br><span class="line">                if (right - left + 1 &lt; min_len) &#123;</span><br><span class="line">                    //cout &lt;&lt; &quot;left &quot; &lt;&lt; left &lt;&lt; &quot;;&quot; &lt;&lt; &quot;right &quot; &lt;&lt; right &lt;&lt; endl;</span><br><span class="line">                    start_ind = left;</span><br><span class="line">                    min_len = right - left + 1;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                if (cns.find(s[left]) != cns.end()) &#123;</span><br><span class="line">                    cns[s[left]]--;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 排除无结果的错误</span><br><span class="line">        if (min_len == INT32_MAX) &#123;</span><br><span class="line">            min_len = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        result = s.substr(start_ind, min_len);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 检查已有条件是否满足</span><br><span class="line">    bool check() &#123;</span><br><span class="line">        for (auto &amp;it : cns) &#123;</span><br><span class="line">            if (it.second &lt; target[it.first]) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h2><h3 id="正例-3"><a href="#正例-3" class="headerlink" title="正例"></a>正例</h3><ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></li>
<li>即将数组以某种特定方式赋值排列</li>
<li>没有特定的方法，重点是坚持循环不变原则，即有些处理时统一方法，比如螺旋矩阵换方向赋值时，可坚持左闭右开的原则赋值</li>
<li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res = vector(n, vector&lt;int&gt;(n, 0));</span><br><span class="line">        int loop = n / 2; // 主循环次数</span><br><span class="line">        int middle = n / 2; // 记录矩阵中间的值</span><br><span class="line">        int startx = 0, starty = 0; // 记录每次循环的起点/终点</span><br><span class="line">        int set_num = 1; // 每次放入的数字</span><br><span class="line">        int off_set = 1; // 控制每循环填数个数</span><br><span class="line">        int i, j;</span><br><span class="line"></span><br><span class="line">        while(loop-- &gt;= 0) &#123;</span><br><span class="line">            i = startx, j = starty;</span><br><span class="line">            // 左上到右上</span><br><span class="line">            for (;j &lt; n - off_set; j++) &#123;</span><br><span class="line">                res[i][j] = set_num++;</span><br><span class="line">            &#125;</span><br><span class="line">            // 右上到右下</span><br><span class="line">            for (;i &lt; n - off_set; i++) &#123;</span><br><span class="line">                res[i][j] = set_num++;</span><br><span class="line">            &#125;</span><br><span class="line">            // 右下到左下</span><br><span class="line">            for (;j &gt; starty; j--) &#123;</span><br><span class="line">                res[i][j] = set_num++;</span><br><span class="line">            &#125;</span><br><span class="line">            // 左下到左上</span><br><span class="line">            for (;i &gt; startx; i--) &#123;</span><br><span class="line">                res[i][j] = set_num++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line">            off_set++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 对奇数矩阵补中间</span><br><span class="line">        if (n % 2 != 0) &#123;</span><br><span class="line">            res[middle][middle] = set_num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="补充例子-1"><a href="#补充例子-1" class="headerlink" title="补充例子"></a>补充例子</h3><h4 id="leetcode-螺旋遍历二维数组"><a href="#leetcode-螺旋遍历二维数组" class="headerlink" title="leetcode_螺旋遍历二维数组"></a>leetcode_螺旋遍历二维数组</h4><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix/description/">54. 螺旋矩阵 - 力扣（LeetCode）</a></li>
<li>该题要将一个 m*n 的矩阵顺时针输出其中的内容</li>
<li>代码随想录没解，暂时也没想到那个思路的延申</li>
<li>可借鉴思路是，每次按向右，向下，向左，向上四次输出到头，每个方向走完，判断下下个方向是否还有路，无则马上退出</li>
<li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        int m = matrix.size(), n = matrix[0].size();</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        </span><br><span class="line">        int u = 0, d = m - 1; // 上下</span><br><span class="line">        int l = 0, r = n - 1; // 左右</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            for (int i = l; i &lt; r + 1; i++) &#123;</span><br><span class="line">                res.push_back(matrix[u][i]); // 向右</span><br><span class="line">            &#125;</span><br><span class="line">            if (++u &gt; d) break;// 上边界大于下边界</span><br><span class="line">            for (int i = u; i &lt; d + 1; i++) &#123;</span><br><span class="line">                res.push_back(matrix[i][r]); // 向下</span><br><span class="line">            &#125;</span><br><span class="line">            if (--r &lt; l) break; // 右边界左于左边界</span><br><span class="line">            for (int i = r; i &gt; l - 1; i--) &#123;</span><br><span class="line">                res.push_back(matrix[d][i]); // 向左</span><br><span class="line">            &#125;</span><br><span class="line">            if (--d &lt; u) break; // 下边界高于上边界</span><br><span class="line">            for (int i = d; i &gt; u - 1; i--) &#123;</span><br><span class="line">                res.push_back(matrix[i][l]); // 向上</span><br><span class="line">            &#125;</span><br><span class="line">            if (++l &gt; r) break; // 左边界右于右边界</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="区间和"><a href="#区间和" class="headerlink" title="区间和"></a>区间和</h2><h3 id="正例-4"><a href="#正例-4" class="headerlink" title="正例"></a>正例</h3><ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></li>
<li><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1070">58. 区间和（第九期模拟笔试） (kamacoder.com)</a></li>
<li>就是要短时间内多次求一个数组上一段区间的数之和</li>
<li>要用到前缀和，也就是在初始化数组时，用另一个数组存当前下标之前所有数字的和（每次存新数就更新累加和即可）</li>
<li>最后求区间和时，用前缀和数组的右下标减左下标即可</li>
<li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int count = 0,left = 0, right = 0;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;count);</span><br><span class="line">    vector&lt;int&gt; num(count), pre_sum(count);</span><br><span class="line">    int store_sum = 0;</span><br><span class="line">    </span><br><span class="line">    // 记录数组同时计算前缀和</span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;num[i]);</span><br><span class="line">        store_sum += num[i];</span><br><span class="line">        pre_sum[i] = store_sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 持续接收左右下标至输入结束</span><br><span class="line">    while(~scanf(&quot;%d %d&quot;, &amp;left, &amp;right)) &#123;</span><br><span class="line">        if (left == 0) &#123;</span><br><span class="line">            printf(&quot;%d\n&quot;,pre_sum[right]);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, pre_sum[right] - pre_sum[left-1]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="补充例子-2"><a href="#补充例子-2" class="headerlink" title="补充例子"></a>补充例子</h3><h4 id="开发商购买土地"><a href="#开发商购买土地" class="headerlink" title="开发商购买土地"></a>开发商购买土地</h4><ul>
<li><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1044">44. 开发商购买土地（第五期模拟笔试） (kamacoder.com)</a></li>
<li>给一个 m*n 的数组，可能对每行每列横切&#x2F;竖切，求两边差值最小值</li>
<li>可前缀和记录横向或者竖向的前缀和，然后就可方便大量计算差值</li>
<li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int m, n;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; block(n, vector&lt;int&gt;(m, 0));</span><br><span class="line">    vector&lt;int&gt; horizontal(n, 0);</span><br><span class="line">    vector&lt;int&gt; vertical(m, 0);</span><br><span class="line">    int result = INT32_MAX;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    </span><br><span class="line">    // 初始化，顺便把横向前缀和求完</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; block[i][j];</span><br><span class="line">            horizontal[i] += block[i][j];</span><br><span class="line">            sum += block[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 计算垂直前缀和</span><br><span class="line">    for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            vertical[j] += block[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int horizontal_cut = 0;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        horizontal_cut += horizontal[i];</span><br><span class="line">        result = min(result, abs(sum - horizontal_cut - horizontal_cut));// （sum - horizontal_cut）是一个公司的子区域价值，horizontal_cut是另一公司的子区域价值</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int vertical_cut = 0;</span><br><span class="line">    for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">        vertical_cut += vertical[j];</span><br><span class="line">        result = min(result, abs(sum - vertical_cut - vertical_cut));</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/15/[Weekly%20Algorithm]%201%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E6%95%B0%E7%BB%84/" data-id="cm7j3jece001j10ageobw14nn" data-title="【Weekly Algorithm】 算法周记之《代码随想录》数组" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-[CS61A-Fall-2020]学习记录7 Homework2 题解思路分享" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/28/%5BCS61A-Fall-2020%5D%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%957%20Homework2%20%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF%E5%88%86%E4%BA%AB/" class="article-date">
  <time class="dt-published" datetime="2024-08-28T07:22:00.000Z" itemprop="datePublished">2024-08-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/28/%5BCS61A-Fall-2020%5D%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%957%20Homework2%20%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF%E5%88%86%E4%BA%AB/">【CS61A-Fall-2020】学习记录七 Homework2 题解思路分享</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>观前提示，笔者写的代码答案放在 <a target="_blank" rel="noopener" href="https://github.com/HSLix/CS61A-Fall-2020">GitHub仓库</a> 中，此处仅记录过程与心得。</p>
<p>此外，请最好在尝试独立完成该任务后再看本文，否则就很可能失去了体验本项目精华的机会</p>
<h2 id="Higher-Order-Functions"><a href="#Higher-Order-Functions" class="headerlink" title="Higher-Order Functions"></a>Higher-Order Functions</h2><h3 id="Q1-Product"><a href="#Q1-Product" class="headerlink" title="Q1: Product"></a>Q1: Product</h3><p>Write a function called product that returns the product of the first n terms of a sequence. Specifically, product takes in an integer n and term, a single-argument function that determines a sequence. (That is, term(i) gives the ith term of the sequence.) product(n, term) should return term(1) * … * term(n).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def product(n, term):</span><br><span class="line">    &quot;&quot;&quot;Return the product of the first n terms in a sequence.</span><br><span class="line"></span><br><span class="line">    n: a positive integer</span><br><span class="line">    term:  a function that takes one argument to produce the term</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; product(3, identity)  # 1 * 2 * 3</span><br><span class="line">    6</span><br><span class="line">    &gt;&gt;&gt; product(5, identity)  # 1 * 2 * 3 * 4 * 5</span><br><span class="line">    120</span><br><span class="line">    &gt;&gt;&gt; product(3, square)    # 1^2 * 2^2 * 3^2</span><br><span class="line">    36</span><br><span class="line">    &gt;&gt;&gt; product(5, square)    # 1^2 * 2^2 * 3^2 * 4^2 * 5^2</span><br><span class="line">    14400</span><br><span class="line">    &gt;&gt;&gt; product(3, increment) # (1+1) * (2+1) * (3+1)</span><br><span class="line">    24</span><br><span class="line">    &gt;&gt;&gt; product(3, triple)    # 1*3 * 2*3 * 3*3</span><br><span class="line">    162</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    &quot;*** YOUR CODE HERE ***&quot;</span><br></pre></td></tr></table></figure>

<h3 id="A1"><a href="#A1" class="headerlink" title="A1"></a>A1</h3><p>题目大意是，用一个函数，计算从 1-n 经 term 函数处理之积</p>
<p>嘛，用循环可以轻松解决，不过陆爻齐用了递归</p>
<h3 id="Q2-Accumulate"><a href="#Q2-Accumulate" class="headerlink" title="Q2: Accumulate"></a>Q2: Accumulate</h3><p>Let’s take a look at how product is an instance of a more general function called accumulate, which we would like to implement:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def accumulate(fuse, start, n, term):</span><br><span class="line">    &quot;&quot;&quot;Return the result of fusing together the first n terms in a sequence </span><br><span class="line">    and start.  The terms to be fused are term(1), term(2), ..., term(n). </span><br><span class="line">    The function fuse is a two-argument commutative &amp; associative function.</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5</span><br><span class="line">    15</span><br><span class="line">    &gt;&gt;&gt; accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5</span><br><span class="line">    26</span><br><span class="line">    &gt;&gt;&gt; accumulate(add, 11, 0, identity) # 11 (fuse is never used)</span><br><span class="line">    11</span><br><span class="line">    &gt;&gt;&gt; accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2</span><br><span class="line">    25</span><br><span class="line">    &gt;&gt;&gt; accumulate(mul, 2, 3, square)    # 2 * 1^2 * 2^2 * 3^2</span><br><span class="line">    72</span><br><span class="line">    &gt;&gt;&gt; # 2 + (1^2 + 1) + (2^2 + 1) + (3^2 + 1)</span><br><span class="line">    &gt;&gt;&gt; accumulate(lambda x, y: x + y + 1, 2, 3, square)</span><br><span class="line">    19</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    &quot;*** YOUR CODE HERE ***&quot;</span><br></pre></td></tr></table></figure>

<p>accumulate has the following parameters:</p>
<p>fuse: a two-argument function that specifies how the current term is fused with the previously accumulated terms<br>start: value at which to start the accumulation<br>n: a non-negative integer indicating the number of terms to fuse<br>term: a single-argument function; term(i) is the ith term of the sequence<br>Implement accumulate, which fuses the first n terms of the sequence defined by term with the start value using the fuse function.</p>
<p>For example, the result of accumulate(add, 11, 3, square) is</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add(11,  add(square(1), add(square(2),  square(3)))) =</span><br><span class="line">    11 +     square(1) +    square(2) + square(3)    =</span><br><span class="line">    11 +     1         +    4         + 9            = 25</span><br></pre></td></tr></table></figure>
<p>Assume that fuse is commutative, fuse(a, b) &#x3D;&#x3D; fuse(b, a), and associative, fuse(fuse(a, b), c) &#x3D;&#x3D; fuse(a, fuse(b, c)).</p>
<p>Then, implement summation (from lecture) and product as one-line calls to accumulate.</p>
<p>Important: Both summation_using_accumulate and product_using_accumulate should be implemented with a single line of code starting with return.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">def summation_using_accumulate(n, term):</span><br><span class="line">    &quot;&quot;&quot;Returns the sum: term(1) + ... + term(n), using accumulate.</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; summation_using_accumulate(5, square) # square(0) + square(1) + ... + square(4) + square(5)</span><br><span class="line">    55</span><br><span class="line">    &gt;&gt;&gt; summation_using_accumulate(5, triple) # triple(0) + triple(1) + ... + triple(4) + triple(5)</span><br><span class="line">    45</span><br><span class="line">    &gt;&gt;&gt; # This test checks that the body of the function is just a return statement.</span><br><span class="line">    &gt;&gt;&gt; import inspect, ast</span><br><span class="line">    &gt;&gt;&gt; [type(x).__name__ for x in ast.parse(inspect.getsource(summation_using_accumulate)).body[0].body]</span><br><span class="line">    [&#x27;Expr&#x27;, &#x27;Return&#x27;]</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    return ____</span><br><span class="line"></span><br><span class="line">def product_using_accumulate(n, term):</span><br><span class="line">    &quot;&quot;&quot;Returns the product: term(1) * ... * term(n), using accumulate.</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; product_using_accumulate(4, square) # square(1) * square(2) * square(3) * square()</span><br><span class="line">    576</span><br><span class="line">    &gt;&gt;&gt; product_using_accumulate(6, triple) # triple(1) * triple(2) * ... * triple(5) * triple(6)</span><br><span class="line">    524880</span><br><span class="line">    &gt;&gt;&gt; # This test checks that the body of the function is just a return statement.</span><br><span class="line">    &gt;&gt;&gt; import inspect, ast</span><br><span class="line">    &gt;&gt;&gt; [type(x).__name__ for x in ast.parse(inspect.getsource(product_using_accumulate)).body[0].body]</span><br><span class="line">    [&#x27;Expr&#x27;, &#x27;Return&#x27;]</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    return ____</span><br></pre></td></tr></table></figure>
<h3 id="A2"><a href="#A2" class="headerlink" title="A2"></a>A2</h3><p>题目大意，是先完成 accumulate 函数，这是一个用 fuse 处理 start、term(1) … term(n) 之间的函数，再用 accumulate 函数实现两个衍生的函数。</p>
<p>没什么难点，想说的话同 A1</p>
<h3 id="Q3-Make-Repeater"><a href="#Q3-Make-Repeater" class="headerlink" title="Q3: Make Repeater"></a>Q3: Make Repeater</h3><p>Implement the function make_repeater which takes a one-argument function f and a positive integer n. It returns a one-argument function, where make_repeater(f, n)(x) returns the value of f(f(…f(x)…)) in which f is applied n times to x. For example, make_repeater(square, 3)(5) squares 5 three times and returns 390625, just like square(square(square(5))).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def make_repeater(f, n):</span><br><span class="line">    &quot;&quot;&quot;Returns the function that computes the nth application of f.</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; add_three = make_repeater(increment, 3)</span><br><span class="line">    &gt;&gt;&gt; add_three(5)</span><br><span class="line">    8</span><br><span class="line">    &gt;&gt;&gt; make_repeater(triple, 5)(1) # 3 * (3 * (3 * (3 * (3 * 1))))</span><br><span class="line">    243</span><br><span class="line">    &gt;&gt;&gt; make_repeater(square, 2)(5) # square(square(5))</span><br><span class="line">    625</span><br><span class="line">    &gt;&gt;&gt; make_repeater(square, 3)(5) # square(square(square(5)))</span><br><span class="line">    390625</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    &quot;*** YOUR CODE HERE ***&quot;</span><br></pre></td></tr></table></figure>
<h3 id="A3"><a href="#A3" class="headerlink" title="A3"></a>A3</h3><p>题目大意是，写一个函数，传入一个单参函数和数字 n，分别是处理参数的方式和次数，返回一个可传一个参数的函数。</p>
<p>实现方式就是内部定个函数，把传入数字，用 f 执行 n 次即可，也不难</p>
<h2 id="Recursion"><a href="#Recursion" class="headerlink" title="Recursion"></a>Recursion</h2><h3 id="Q4-Digit-Distance"><a href="#Q4-Digit-Distance" class="headerlink" title="Q4: Digit Distance"></a>Q4: Digit Distance</h3><p>For a given integer, the digit distance is the sum of the absolute differences between consecutive digits. For example:</p>
<p>The digit distance of 6 is 0.<br>The digit distance of 61 is 5, as the absolute value of 6 - 1 is 5.<br>The digit distance of 71253 is 12 (6 + 1 + 3 + 2).<br>Write a function that determines the digit distance of a given positive integer. You must use recursion or the tests will fail.</p>
<p>Hint: There are multiple valid ways of solving this problem! If you’re stuck, try writing out an iterative solution first, and then convert your iterative solution into a recursive one.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def digit_distance(n):</span><br><span class="line">    &quot;&quot;&quot;Determines the digit distance of n.</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; digit_distance(3)</span><br><span class="line">    0</span><br><span class="line">    &gt;&gt;&gt; digit_distance(777)</span><br><span class="line">    0</span><br><span class="line">    &gt;&gt;&gt; digit_distance(314)</span><br><span class="line">    5</span><br><span class="line">    &gt;&gt;&gt; digit_distance(31415926535)</span><br><span class="line">    32</span><br><span class="line">    &gt;&gt;&gt; digit_distance(3464660003)</span><br><span class="line">    16</span><br><span class="line">    &gt;&gt;&gt; from construct_check import check</span><br><span class="line">    &gt;&gt;&gt; # ban all loops</span><br><span class="line">    &gt;&gt;&gt; check(HW_SOURCE_FILE, &#x27;digit_distance&#x27;,</span><br><span class="line">    ...       [&#x27;For&#x27;, &#x27;While&#x27;])</span><br><span class="line">    True</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    &quot;*** YOUR CODE HERE ***&quot;</span><br></pre></td></tr></table></figure>
<h3 id="A4"><a href="#A4" class="headerlink" title="A4"></a>A4</h3><p>题目大意是，计算一个数字各位差绝对值之和，且不准用循环的方式。</p>
<p>陆爻齐的思路是，每次取第一位和第二位数字差的绝对值加上 n 整除 10 后的数字，如此便可计算出各位差绝对值，与参考答案不谋而合捏。</p>
<h3 id="Q5-Interleaved-Sum"><a href="#Q5-Interleaved-Sum" class="headerlink" title="Q5: Interleaved Sum"></a>Q5: Interleaved Sum</h3><p>Write a function interleaved_sum, which takes in a number n and two one-argument functions: odd_func and even_func. It applies odd_func to every odd number and even_func to every even number from 1 to n inclusive and returns the sum.</p>
<p>For example, executing interleaved_sum(5, lambda x: x, lambda x: x * x) returns 1 + 2<em>2 + 3 + 4</em>4 + 5 &#x3D; 29.</p>
<p>Important: Implement this function without using any loops or directly testing if a number is odd or even – aka modulos (%) are not allowed! Instead of directly checking whether a number is even or odd, start with 1, which you know is an odd number.</p>
<p>Hint: Introduce an inner helper function that takes an odd number k and computes an interleaved sum from k to n (including n).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">def interleaved_sum(n, odd_func, even_func):</span><br><span class="line">    &quot;&quot;&quot;Compute the sum odd_func(1) + even_func(2) + odd_func(3) + ..., up</span><br><span class="line">    to n.</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; identity = lambda x: x</span><br><span class="line">    &gt;&gt;&gt; square = lambda x: x * x</span><br><span class="line">    &gt;&gt;&gt; triple = lambda x: x * 3</span><br><span class="line">    &gt;&gt;&gt; interleaved_sum(5, identity, square) # 1   + 2*2 + 3   + 4*4 + 5</span><br><span class="line">    29</span><br><span class="line">    &gt;&gt;&gt; interleaved_sum(5, square, identity) # 1*1 + 2   + 3*3 + 4   + 5*5</span><br><span class="line">    41</span><br><span class="line">    &gt;&gt;&gt; interleaved_sum(4, triple, square)   # 1*3 + 2*2 + 3*3 + 4*4</span><br><span class="line">    32</span><br><span class="line">    &gt;&gt;&gt; interleaved_sum(4, square, triple)   # 1*1 + 2*3 + 3*3 + 4*3</span><br><span class="line">    28</span><br><span class="line">    &gt;&gt;&gt; from construct_check import check</span><br><span class="line">    &gt;&gt;&gt; check(HW_SOURCE_FILE, &#x27;interleaved_sum&#x27;, [&#x27;While&#x27;, &#x27;For&#x27;, &#x27;Mod&#x27;]) # ban loops and %</span><br><span class="line">    True</span><br><span class="line">    &gt;&gt;&gt; check(HW_SOURCE_FILE, &#x27;interleaved_sum&#x27;, [&#x27;BitAnd&#x27;, &#x27;BitOr&#x27;, &#x27;BitXor&#x27;]) # ban bitwise operators, don&#x27;t worry about these if you don&#x27;t know what they are</span><br><span class="line">    True</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    &quot;*** YOUR CODE HERE ***&quot;</span><br></pre></td></tr></table></figure>
<h3 id="A5"><a href="#A5" class="headerlink" title="A5"></a>A5</h3><p>题目大意，交错和，即对奇偶数各用奇偶的函数处理，再相加得和，不准使用循环和 %，以及位运算来禁止直接判断数字奇偶。</p>
<p>此题，陆爻齐用了取巧的办法越过了检查，仍然直接判断奇偶，即用递归判断，n 次递归，用另一个变量 1&#x2F;0，以得出奇偶，下面是看了参考答案总结的思路。</p>
<p>不知 n 的奇偶，但可以从 1 推到 n，于是可写个内部函数，计算 1 2 ……，两位两位地计算和，递归，最后返回结果即可</p>
<h3 id="Q6-Count-Coins"><a href="#Q6-Count-Coins" class="headerlink" title="Q6: Count Coins"></a>Q6: Count Coins</h3><p>Given a positive integer total, a set of coins makes change for total if the sum of the values of the coins is total. Here we will use standard US Coin values: 1, 5, 10, 25. For example, the following sets make change for 15:</p>
<p>15 1-cent coins<br>10 1-cent, 1 5-cent coins<br>5 1-cent, 2 5-cent coins<br>5 1-cent, 1 10-cent coins<br>3 5-cent coins<br>1 5-cent, 1 10-cent coin<br>Thus, there are 6 ways to make change for 15. Write a recursive function count_coins that takes a positive integer total and returns the number of ways to make change for total using coins.</p>
<p>You can use either of the functions given to you:</p>
<p>next_larger_coin will return the next larger coin denomination from the input, i.e. next_larger_coin(5) is 10.<br>next_smaller_coin will return the next smaller coin denomination from the input, i.e. next_smaller_coin(5) is 1.<br>Either function will return None if the next coin value does not exist<br>There are two main ways in which you can approach this problem. One way uses next_larger_coin, and another uses next_smaller_coin. It is up to you which one you want to use!</p>
<p>Important: Use recursion; the tests will fail if you use loops.</p>
<p>Hint: Refer to the implementation of count_partitions for an example of how to count the ways to sum up to a final value with smaller parts. If you need to keep track of more than one value across recursive calls, consider writing a helper function.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">def next_larger_coin(coin):</span><br><span class="line">    &quot;&quot;&quot;Returns the next larger coin in order.</span><br><span class="line">    &gt;&gt;&gt; next_larger_coin(1)</span><br><span class="line">    5</span><br><span class="line">    &gt;&gt;&gt; next_larger_coin(5)</span><br><span class="line">    10</span><br><span class="line">    &gt;&gt;&gt; next_larger_coin(10)</span><br><span class="line">    25</span><br><span class="line">    &gt;&gt;&gt; next_larger_coin(2) # Other values return None</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if coin == 1:</span><br><span class="line">        return 5</span><br><span class="line">    elif coin == 5:</span><br><span class="line">        return 10</span><br><span class="line">    elif coin == 10:</span><br><span class="line">        return 25</span><br><span class="line"></span><br><span class="line">def next_smaller_coin(coin):</span><br><span class="line">    &quot;&quot;&quot;Returns the next smaller coin in order.</span><br><span class="line">    &gt;&gt;&gt; next_smaller_coin(25)</span><br><span class="line">    10</span><br><span class="line">    &gt;&gt;&gt; next_smaller_coin(10)</span><br><span class="line">    5</span><br><span class="line">    &gt;&gt;&gt; next_smaller_coin(5)</span><br><span class="line">    1</span><br><span class="line">    &gt;&gt;&gt; next_smaller_coin(2) # Other values return None</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if coin == 25:</span><br><span class="line">        return 10</span><br><span class="line">    elif coin == 10:</span><br><span class="line">        return 5</span><br><span class="line">    elif coin == 5:</span><br><span class="line">        return 1</span><br><span class="line"></span><br><span class="line">def count_coins(total):</span><br><span class="line">    &quot;&quot;&quot;Return the number of ways to make change using coins of value of 1, 5, 10, 25.</span><br><span class="line">    &gt;&gt;&gt; count_coins(15)</span><br><span class="line">    6</span><br><span class="line">    &gt;&gt;&gt; count_coins(10)</span><br><span class="line">    4</span><br><span class="line">    &gt;&gt;&gt; count_coins(20)</span><br><span class="line">    9</span><br><span class="line">    &gt;&gt;&gt; count_coins(100) # How many ways to make change for a dollar?</span><br><span class="line">    242</span><br><span class="line">    &gt;&gt;&gt; count_coins(200)</span><br><span class="line">    1463</span><br><span class="line">    &gt;&gt;&gt; from construct_check import check</span><br><span class="line">    &gt;&gt;&gt; # ban iteration</span><br><span class="line">    &gt;&gt;&gt; check(HW_SOURCE_FILE, &#x27;count_coins&#x27;, [&#x27;While&#x27;, &#x27;For&#x27;])</span><br><span class="line">    True</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    &quot;*** YOUR CODE HERE ***&quot;</span><br></pre></td></tr></table></figure>
<h3 id="A6"><a href="#A6" class="headerlink" title="A6"></a>A6</h3><p>题目大意，就是将给定的数字划分成 1、5、10、25 的组合，给出组合个数，不可使用循环。可借助已写好的 next_larger_coin 等函数</p>
<p>此题可这么看，从一个数字向下蔓延分支，可大致分两类，一类是尝试用当前数字减去一次额度，一类是额度变化（变大变小都可），如此递归下去各种路线都可计算到。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Q5 和 Q6 都挺有思考的趣味，递归很早就学了，但体会递归的魅力，还是在此</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/28/[CS61A-Fall-2020]%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%957%20Homework2%20%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF%E5%88%86%E4%BA%AB/" data-id="cm7j3jec3000e10agh4at5rc3" data-title="【CS61A-Fall-2020】学习记录七 Homework2 题解思路分享" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CS61A/" rel="tag">CS61A</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/" rel="tag">Python</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-[CS61A-Fall-2020]学习记录6 Lab2 题解思路分享" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/13/%5BCS61A-Fall-2020%5D%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%956%20Lab2%20%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF%E5%88%86%E4%BA%AB/" class="article-date">
  <time class="dt-published" datetime="2024-08-13T12:08:00.000Z" itemprop="datePublished">2024-08-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/13/%5BCS61A-Fall-2020%5D%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%956%20Lab2%20%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF%E5%88%86%E4%BA%AB/">【CS61A-Fall-2020】学习记录六 Lab2 题解思路分享</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>观前提示，笔者写的代码答案放在 <a target="_blank" rel="noopener" href="https://github.com/HSLix/CS61A-Fall-2020">GitHub仓库</a> 中，此处仅记录过程与心得。</p>
<p>此外，请最好在尝试独立完成该任务后再看本文，否则就很可能失去了体验本项目精华的机会</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="Q1-WWPD-Lambda-the-Free"><a href="#Q1-WWPD-Lambda-the-Free" class="headerlink" title="Q1: WWPD: Lambda the Free"></a>Q1: WWPD: Lambda the Free</h3><p>有两个问题有点意思。</p>
<h4 id="lambda-与参数"><a href="#lambda-与参数" class="headerlink" title="lambda 与参数"></a>lambda 与参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; b = lambda x: lambda: x  # Lambdas can return other lambdas!</span><br><span class="line">&gt;&gt;&gt; c = b(88)</span><br><span class="line">&gt;&gt;&gt; c</span><br><span class="line">______</span><br></pre></td></tr></table></figure>
<p>该问题看似只是普通的 lambda 中传 x，c 还传入了 x 参数值为 88</p>
<p>所以答案是 88 吗？</p>
<p>当然不是，这个问题结合下面这个问题就很显然了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; c()</span><br><span class="line">______</span><br></pre></td></tr></table></figure>
<p>那么想清楚这个问题的关键，就在于能否分辨 c 和 c() 的含义。</p>
<p>把 88 代入 c 的 lambda 式子，可以换成</p>
<p>c &#x3D; lambda : 88</p>
<p>本质上，c 其实还是个 lambda 式子，只不过无参数，所以直接调用 c 不会得到 88，还得象征性地传入无参数调用才行。</p>
<h4 id="print-与-lambda"><a href="#print-与-lambda" class="headerlink" title="print 与 lambda"></a>print 与 lambda</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print_lambda = lambda z: print(z)  # When is the return expression of a lambda expression executed?</span><br><span class="line">&gt;&gt;&gt; one_thousand = print_lambda(1000)</span><br><span class="line">______</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; one_thousand</span><br><span class="line">______</span><br></pre></td></tr></table></figure>

<p>这个 print_lambda 只是一个把传入参数直接 print 出来的函数罢了，那么第一个空当然是 1000 啦。</p>
<p>嗯嗯，对，不过重点是第二个空的答案，这个 print_lambda 到底把什么赋予给 one_thousand 了？</p>
<p>有同学会说，不是 1000 吗？</p>
<p>不是哟，之所以第一个空会是 1000，是因为在赋值的过程前，先执行尽右侧函数时，print 的。</p>
<p>排除了 1000，这又不是 Function（print_lambda 才是 Function，代入了参数后就不是啦），不是 Error，排除了所有可能，只能是 None 了。</p>
<p>想想也是，print 也没有返回，None 也是理所应当。</p>
<h3 id="Q2-WWPD-Higher-Order-Functions"><a href="#Q2-WWPD-Higher-Order-Functions" class="headerlink" title="Q2: WWPD: Higher Order Functions"></a>Q2: WWPD: Higher Order Functions</h3><p>值得注意的就一个点</p>
<p>如果有 return 而无变量承接，那 return * 就会相当于 print(*)。</p>
<h3 id="Q3-Lambdas-and-Currying"><a href="#Q3-Lambdas-and-Currying" class="headerlink" title="Q3: Lambdas and Currying"></a>Q3: Lambdas and Currying</h3><p>需要通过多个 () 调用，说明内部有几层 def。</p>
<h3 id="Q4-Count-van-Count"><a href="#Q4-Count-van-Count" class="headerlink" title="Q4: Count van Count"></a>Q4: Count van Count</h3><p>要仔细看好，在测试里面，输入的 condition 的输入参数情况如何，输出如何。</p>
<h3 id="Q5-Make-Adder"><a href="#Q5-Make-Adder" class="headerlink" title="Q5: Make Adder"></a>Q5: Make Adder</h3><p>不难，题目也说了，不会就放这个 <a target="_blank" rel="noopener" href="https://pythontutor.com/cp/composingprograms.html#mode=edit">视觉化网站</a> 看看结果</p>
<h3 id="Q6-Lambda-the-Environment-Diagram"><a href="#Q6-Lambda-the-Environment-Diagram" class="headerlink" title="Q6: Lambda the Environment Diagram"></a>Q6: Lambda the Environment Diagram</h3><p>同 Q5</p>
<h3 id="Q7-Composite-Identity-Function"><a href="#Q7-Composite-Identity-Function" class="headerlink" title="Q7: Composite Identity Function"></a>Q7: Composite Identity Function</h3><p>本质就是让你写个函数，返回对于 n ，先 f 后 g 与 先 g 后 f 是否相等，同时用上题目里的 compose1 函数。</p>
<h3 id="Q8-I-Heard-You-Liked-Functions…Q8"><a href="#Q8-I-Heard-You-Liked-Functions…Q8" class="headerlink" title="Q8: I Heard You Liked Functions…Q8"></a>Q8: I Heard You Liked Functions…Q8</h3><p>这个问题有点意思，题目本质是要求给个函数，可以自定义循环对一个数字按顺序循环执行的次数和数字大小。</p>
<p>陆爻齐的思路是，先写一个可以根据循环次数，返回应该执行函数的函数，比如 i &#x3D;&#x3D; 1 时，返回 f1，i &#x3D;&#x3D; 4 时，也返回 f1 这样。暂且叫 get_todo。</p>
<p>然后写个循环，i &lt;&#x3D; n，对数字 num，代入执行 n 次 get_todo(i) 函数，结束。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>听完课可以锻炼英语听力，同时也对这个 higher order function 有了更深的感触，期待后续课程：）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/13/[CS61A-Fall-2020]%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%956%20Lab2%20%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF%E5%88%86%E4%BA%AB/" data-id="cm7j3jec0000910ag0jfnfhyf" data-title="【CS61A-Fall-2020】学习记录六 Lab2 题解思路分享" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CS61A/" rel="tag">CS61A</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/" rel="tag">Python</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-【播客笔记】 《爱的艺术》我要如何学会爱，尤其是，学会爱自己 纵横四海" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/03/%E3%80%90%E6%92%AD%E5%AE%A2%E7%AC%94%E8%AE%B0%E3%80%91%20%E3%80%8A%E7%88%B1%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E6%88%91%E8%A6%81%E5%A6%82%E4%BD%95%E5%AD%A6%E4%BC%9A%E7%88%B1%EF%BC%8C%E5%B0%A4%E5%85%B6%E6%98%AF%EF%BC%8C%E5%AD%A6%E4%BC%9A%E7%88%B1%E8%87%AA%E5%B7%B1%20%E7%BA%B5%E6%A8%AA%E5%9B%9B%E6%B5%B7/" class="article-date">
  <time class="dt-published" datetime="2024-08-03T06:03:00.000Z" itemprop="datePublished">2024-08-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/03/%E3%80%90%E6%92%AD%E5%AE%A2%E7%AC%94%E8%AE%B0%E3%80%91%20%E3%80%8A%E7%88%B1%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E6%88%91%E8%A6%81%E5%A6%82%E4%BD%95%E5%AD%A6%E4%BC%9A%E7%88%B1%EF%BC%8C%E5%B0%A4%E5%85%B6%E6%98%AF%EF%BC%8C%E5%AD%A6%E4%BC%9A%E7%88%B1%E8%87%AA%E5%B7%B1%20%E7%BA%B5%E6%A8%AA%E5%9B%9B%E6%B5%B7/">【播客笔记】《爱的艺术》我要如何学会爱，尤其是，学会爱自己 纵横四海</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是陆爻齐收听了 <strong>纵横四海</strong> 的播客 <strong>《爱的艺术》我要如何学会爱，尤其是，学会爱自己 纵横四海</strong>，做的一点笔记</p>
<p>也就是对播客里一些内容的总结、思考和理解，权当作记录罢</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="爱的定义"><a href="#爱的定义" class="headerlink" title="爱的定义"></a>爱的定义</h3><p>爱是一种行动（activity），并不能用“激情”带来的生理性好感来完全指代，并非天定，而是用行动维护、培养出来的责任。</p>
<p>这种行动，必须是自发的。</p>
<p>倘若一名丈夫被妻子说了后，马上做了几件家务讨其欢心，后又疏懒，说一下动一下，则不算爱的行动；</p>
<p>若是该丈夫在认识到自己的疏忽后，在日常中主动分担部分家务，这个属于爱的行动。</p>
<h3 id="爱的意义"><a href="#爱的意义" class="headerlink" title="爱的意义"></a>爱的意义</h3><p>消除人生孤离感的“终极武器”。</p>
<p>作者认为，人生于家，成年断亲后，需要填补这份离开亲人的孤离感。有人沉迷酒色，用过度放纵自己，刺激感官麻木自己；有人趋同他人，在与小集团同化中寻求认同。</p>
<p>而爱，正是消除孤离感的良方妙药。</p>
<p>不拘泥于男女，亲人，人人皆可有爱，从细节处关心即可。</p>
<h3 id="爱的实质"><a href="#爱的实质" class="headerlink" title="爱的实质"></a>爱的实质</h3><p>提供创造性的互助</p>
<p>来个一个不算恰当、意会即可的例子</p>
<p>老师辅导时，最喜欢看到的情形是，学生经过主动思考，讲述自己的探索历程，遇到困难尝试客服，经讨论交流和老师一起探寻得到结果；</p>
<p>与之相对，最令老师头疼的是，毫无思考，只来问老师此题怎解，从头到尾跟着老师思路，不能创造性的吸收知识，而是被动地塞入，老师便会感到枯燥乏味。</p>
<p>总得来说，互相给予创造力便是。</p>
<p>再拿情侣为例</p>
<p>有人认为热恋期的“激情”才是爱，这段蜜月一过便分道扬镳，因为他无法从对方那里找到所谓的“新鲜感”。</p>
<p>如果两人相爱，互相在日常中关心对方，记住对方的喜好，近日安排，时不时安排小礼物、小惊喜，无数个这样感动的瞬间，是否能连成一生呢？（还在 go）</p>
<h3 id="爱的实践"><a href="#爱的实践" class="headerlink" title="爱的实践"></a>爱的实践</h3><p>自爱，就是关心自己的健康，不但身体，还有心理。平日是否过于忙碌，疏于放松；平日是否过于愤慨，没有发泄。适当安排假期或许不错，但这算奢望罢。</p>
<p>男女&#x2F;亲人之爱，是否设身处地为人着想，是否从小处都有关心对方，行动帮助对方。</p>
<h2 id="一点总结"><a href="#一点总结" class="headerlink" title="一点总结"></a>一点总结</h2><p>让陆爻齐对于爱确实有了一些新的想法，找到伴侣不应只是等待，爱是行动，培养出来的。</p>
<p>不过现阶段还是提升自己更为重要，这些经验或许大四闲暇就能用上呢。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/03/%E3%80%90%E6%92%AD%E5%AE%A2%E7%AC%94%E8%AE%B0%E3%80%91%20%E3%80%8A%E7%88%B1%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E6%88%91%E8%A6%81%E5%A6%82%E4%BD%95%E5%AD%A6%E4%BC%9A%E7%88%B1%EF%BC%8C%E5%B0%A4%E5%85%B6%E6%98%AF%EF%BC%8C%E5%AD%A6%E4%BC%9A%E7%88%B1%E8%87%AA%E5%B7%B1%20%E7%BA%B5%E6%A8%AA%E5%9B%9B%E6%B5%B7/" data-id="cm7j3jeco002510agesvdcplg" data-title="【播客笔记】《爱的艺术》我要如何学会爱，尤其是，学会爱自己 纵横四海" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%92%AD%E5%AE%A2%E7%AC%94%E8%AE%B0/" rel="tag">播客笔记</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/19/hello-world/" class="article-date">
  <time class="dt-published" datetime="2024-07-19T14:00:00.000Z" itemprop="datePublished">2024-07-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/07/19/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>这是陆爻齐用 github page 和 hexo 搭建的自己的博客！</p>
<p>是参考了 <a target="_blank" rel="noopener" href="https://0xffff.one/d/544">0xffff</a>、<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1dt4y1Q7UE/?share_source=copy_web&vd_source=1423ba210b588816e333b03a9060d0b0">b站视频教程</a> 和 <a target="_blank" rel="noopener" href="https://hexo.fluid-dev.com/docs/guide/#%E6%96%87%E7%AB%A0%E6%8E%92%E5%BA%8F">fluid 使用手册</a> 慢慢开始完善的</p>
<p>陆爻齐后续也写一篇 blog 来总结下博客的配置好了</p>
<p>总之，先把博客园的文章按时间顺序慢慢搬过来好了</p>
<p>Hello，World！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/19/hello-world/" data-id="cm7j3jecm001x10aghff1c8ua" data-title="Hello World" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-【播客笔记】《我们为什么会受骗》强烈建议每个女生看完这本书再去恋爱！ 纵横四海" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/19/%E3%80%90%E6%92%AD%E5%AE%A2%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8A%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%8F%97%E9%AA%97%E3%80%8B%E5%BC%BA%E7%83%88%E5%BB%BA%E8%AE%AE%E6%AF%8F%E4%B8%AA%E5%A5%B3%E7%94%9F%E7%9C%8B%E5%AE%8C%E8%BF%99%E6%9C%AC%E4%B9%A6%E5%86%8D%E5%8E%BB%E6%81%8B%E7%88%B1%EF%BC%81%20%E7%BA%B5%E6%A8%AA%E5%9B%9B%E6%B5%B7/" class="article-date">
  <time class="dt-published" datetime="2024-07-19T08:05:00.000Z" itemprop="datePublished">2024-07-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/07/19/%E3%80%90%E6%92%AD%E5%AE%A2%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8A%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%8F%97%E9%AA%97%E3%80%8B%E5%BC%BA%E7%83%88%E5%BB%BA%E8%AE%AE%E6%AF%8F%E4%B8%AA%E5%A5%B3%E7%94%9F%E7%9C%8B%E5%AE%8C%E8%BF%99%E6%9C%AC%E4%B9%A6%E5%86%8D%E5%8E%BB%E6%81%8B%E7%88%B1%EF%BC%81%20%E7%BA%B5%E6%A8%AA%E5%9B%9B%E6%B5%B7/">【播客笔记】《我们为什么会受骗》强烈建议每个女生看完这本书再去恋爱！ 纵横四海</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是陆爻齐收听了 <strong>纵横四海</strong> 的播客 <strong>《我们为什么会受骗》强烈建议每个女生看完这本书再去恋爱！</strong>，做的一点笔记</p>
<p>也就是一些内容的总结和思考理解，权当作记录罢</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="被骗者与骗者"><a href="#被骗者与骗者" class="headerlink" title="被骗者与骗者"></a>被骗者与骗者</h3><p>有两点比较重要</p>
<ol>
<li>人往往是很感性化的，难以理性地处理每件事</li>
<li>骗者之所以能得手，很可能是因为其自身生理特性，以及社会环境的滋养</li>
</ol>
<p>对于第一点，主持人是以自己出售二手家居为例子说明，原本认为麻烦不想自己做打包发邮件，后因与一个顾客聊天而改变主意。</p>
<p>还介绍了一种现象，即一个人当接收了过多的信息，会本能地放弃选择，进入容易被操控的状态。这点很容易理解，高考是选择题怎么都不会，就开始放弃用理智选择了，“三长一短选最短”……</p>
<p>而第二点有两个小点</p>
<ol>
<li>生理特性，主持人介绍骗者的脑部很可能与普通人有差别，比如缺少共情能力，使其不会因欺骗他人而产生内疚等道德约束；接近黑暗三角人格（自恋、心理变态、马基雅维利主义）什么的</li>
<li>社会环境，不是因为环境“坏”，恰恰是因为环境“好”，当大多数人都互相信任时，欺骗者往往可以从中轻松获利</li>
</ol>
<h3 id="有趣的打断效应"><a href="#有趣的打断效应" class="headerlink" title="有趣的打断效应"></a>有趣的打断效应</h3><p>名字是瞎编的，但理论确实存在。例子便是金牌销售员的一个策略，在顾客对一件商品的购买踌躇不定时，不断用言语打断思考，用“此外，该商品还有***好处”之类的话，阻止顾客深入思考，往往能促进购买</p>
<h3 id="被骗的必要条件"><a href="#被骗的必要条件" class="headerlink" title="被骗的必要条件"></a>被骗的必要条件</h3><ol>
<li>渴望某项事务</li>
<li>相信某项事务的发生</li>
<li>坚定自己不会受骗</li>
</ol>
<p>以普通父母被骗买保健药品为例，父母退休后清闲又有点空虚，听到周围亲戚、同事、朋友逝去的消息，渴望健康，满足条件一；</p>
<p>接触骗者，建立信任关系，开始逐渐相信保健药品的功效，相信购买并使用保健药品能得到健康，满足条件二；</p>
<p>面对子女的劝说，摆出“我是你爸，不用你教”坚定自己没有受骗，拒绝事实，这与和骗者的信任关系产生冲突引发“认知失调”，容易受到操控，满足条件三；</p>
<p>不过这只是个简陋的经典模型，实际上的骗局大致会像下一个小节一样</p>
<h3 id="欺骗“万用术”流程"><a href="#欺骗“万用术”流程" class="headerlink" title="欺骗“万用术”流程"></a>欺骗“万用术”流程</h3><ol>
<li>搜寻猎物，很难有一种能骗所有人的骗局，骗者往往是搜集到足够的情报，找到最适合的猎物，量身制定骗局才下手；</li>
<li>建立情感交流，如第一部分所说，人往往是感性的，一旦产生情感交流，就能够提升骗者的信任关系，并泄露更多情报；<br>而骗者实现该步骤并不会太困难，毕竟第一步就已经找好猎物，并有猎物的大量情报，而猎物一无所知，只会认为面前的人很懂自己，是命运的“挚友”。</li>
<li>讲故事，比如经典的“卖茶女”，讲述自己困苦的经历博取同情，随后请求经济帮助，无经验者确实容易中招；</li>
<li>一般来说，在上一步就能收网，但还可以继续等待受骗者加码，这一点陆爻齐也难以理解但也存在；<br>比如一个人被骗转去 20000 元救急，过了一个月没声响，开始模糊认为自己被骗了，产生痛苦的感情且渴望弥补，此时骗者突然联系过来，用看似合适的理由稳住受骗者，随后进一步索取钱财还是什么的就另说了</li>
</ol>
<h3 id="防骗手段"><a href="#防骗手段" class="headerlink" title="防骗手段"></a>防骗手段</h3><p>难，因为这是与本能对抗，简单的说就是，不满足受骗的必要条件，从而避免被选为猎物</p>
<p>其中主持人认为，相信某项事务的发生 相对容易处理，可以通过日常熏陶自己谨慎行事改善；对于父母，只能不断反复强调，熏陶。</p>
<p>陆爻齐认为，还是欲望被利用的问题，“贪”，所以陆爻齐对于别人的建议回想两件事</p>
<ol>
<li>这么好的东西，为什么你自己不搞，告诉我让我搞呢？</li>
<li>你是与这件事有什么关系，站在什么立场说的话？（既得利益者……）</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/19/%E3%80%90%E6%92%AD%E5%AE%A2%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8A%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%8F%97%E9%AA%97%E3%80%8B%E5%BC%BA%E7%83%88%E5%BB%BA%E8%AE%AE%E6%AF%8F%E4%B8%AA%E5%A5%B3%E7%94%9F%E7%9C%8B%E5%AE%8C%E8%BF%99%E6%9C%AC%E4%B9%A6%E5%86%8D%E5%8E%BB%E6%81%8B%E7%88%B1%EF%BC%81%20%E7%BA%B5%E6%A8%AA%E5%9B%9B%E6%B5%B7/" data-id="cm7j3jecn001z10ag4bh68tpe" data-title="【播客笔记】《我们为什么会受骗》强烈建议每个女生看完这本书再去恋爱！ 纵横四海" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%92%AD%E5%AE%A2%E7%AC%94%E8%AE%B0/" rel="tag">播客笔记</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-[CS61A-Fall-2020]学习记录5 Project1 The Game of Hog 中有意思的点" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/18/%5BCS61A-Fall-2020%5D%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%955%20Project1%20The%20Game%20of%20Hog%20%E4%B8%AD%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E7%82%B9/" class="article-date">
  <time class="dt-published" datetime="2024-07-17T16:58:00.000Z" itemprop="datePublished">2024-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/07/18/%5BCS61A-Fall-2020%5D%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%955%20Project1%20The%20Game%20of%20Hog%20%E4%B8%AD%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E7%82%B9/">【CS61A-Fall-2020】学习记录五 Project1 The Game of Hog 中有意思的点</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>观前提示，笔者写的代码答案放在 <a target="_blank" rel="noopener" href="https://github.com/HSLix/CS61A-Fall-2020">GitHub仓库</a> 中，此处仅记录过程与心得。</p>
<p>此外，请最好在尝试独立完成该任务后再看本文，否则就很可能失去了体验本项目精华的机会</p>
<h2 id="函数参数前的"><a href="#函数参数前的" class="headerlink" title="函数参数前的*"></a>函数参数前的*</h2><p>在项目原文件中的dice.py 里的 make_test_dice函数采用这样的方式传参</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def make_test_dice(*outcomes):</span><br><span class="line">  # 省略内容</span><br><span class="line">  pass</span><br></pre></td></tr></table></figure>

<p>我记得python中没像c那样的指针，于是查询资料，小结如下<br>函数参数前一颗*会识别为元组，两颗则识别为字典</p>
<p>比如我要是传 make_test_dice(1, 2, 4, 3)，outcomes就是元组(1, 2, 4, 3)</p>
<p>举一个稍微复合一点点的例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def foo(a, b=10, *args, **kwargs):</span><br><span class="line">    print (a)</span><br><span class="line">    print (b)</span><br><span class="line">    print (args)</span><br><span class="line">    print (kwargs)</span><br><span class="line"></span><br><span class="line">foo(1, 2, 3, 4, e=5, f=6, g=7)</span><br></pre></td></tr></table></figure>

<p>上述例子来自菜鸟教程，运行结果为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">(3, 4)</span><br><span class="line">&#123;&#x27;e&#x27;: 5, &#x27;f&#x27;: 6, &#x27;g&#x27;:7&#125;</span><br></pre></td></tr></table></figure>

<p>可发现除了定好的a、b，c和d都纳入元组中，而efg有&#x3D;赋值，作为字典看待</p>
<p>上面的例子都发生在定义函数参数列表，如果在调用时有*说明什么呢？</p>
<p>再看一个例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def func(num1, num2):</span><br><span class="line">  print(num1, num2)</span><br><span class="line"></span><br><span class="line">num = [1, 2]</span><br><span class="line">func(*num)</span><br></pre></td></tr></table></figure>

<p>运行结果为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2</span><br></pre></td></tr></table></figure>

<p>一个参数变两，*在这里起到了解压参数列表的作用<br>但笔者尚未想到该功能应用的方便之处</p>
<h2 id="Higher-Order-Function-高阶函数"><a href="#Higher-Order-Function-高阶函数" class="headerlink" title="Higher Order Function 高阶函数"></a>Higher Order Function 高阶函数</h2><p>这是一个让陆爻齐觉得十分精妙的功能，以函数为参数并返回函数，从 C 初学者的角度来说，太抽象了</p>
<p>就是在 Problem 7 的答案代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">def announce_highest(who, last_score=0, running_high=0):</span><br><span class="line">    &quot;&quot;&quot;Return a commentary function that announces when WHO&#x27;s score</span><br><span class="line">    increases by more than ever before in the game.</span><br><span class="line"></span><br><span class="line">    NOTE: the following game is not possible under the rules, it&#x27;s just</span><br><span class="line">    an example for the sake of the doctest</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; f0 = announce_highest(1) # Only announce Player 1 score gains</span><br><span class="line">    &gt;&gt;&gt; f1 = f0(12, 0)</span><br><span class="line">    &gt;&gt;&gt; f2 = f1(12, 9)</span><br><span class="line">    9 point(s)! The most yet for Player 1</span><br><span class="line">    &gt;&gt;&gt; f3 = f2(20, 9)</span><br><span class="line">    &gt;&gt;&gt; f4 = f3(20, 30)</span><br><span class="line">    21 point(s)! The most yet for Player 1</span><br><span class="line">    &gt;&gt;&gt; f5 = f4(20, 47) # Player 1 gets 17 points; not enough for a new high</span><br><span class="line">    &gt;&gt;&gt; f6 = f5(21, 47)</span><br><span class="line">    &gt;&gt;&gt; f7 = f6(21, 77)</span><br><span class="line">    30 point(s)! The most yet for Player 1</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    assert who == 0 or who == 1, &#x27;The who argument should indicate a player.&#x27;</span><br><span class="line">    # BEGIN PROBLEM 7</span><br><span class="line">    &quot;*** YOUR CODE HERE ***&quot;</span><br><span class="line">    def say(new_score_0, new_score_1, last_running_high = running_high):</span><br><span class="line">        if who == 0:</span><br><span class="line">            new_score = new_score_0</span><br><span class="line">            new_running_high = new_score_0 - last_score</span><br><span class="line">        else:</span><br><span class="line">            new_score = new_score_1</span><br><span class="line">            new_running_high = new_score_1 - last_score</span><br><span class="line"></span><br><span class="line">        if new_running_high &gt; last_running_high:</span><br><span class="line">            last_running_high = new_running_high</span><br><span class="line">            print(str(new_running_high),&quot;point(s)! The most yet for Player &quot; + str(who))</span><br><span class="line">        </span><br><span class="line">        new_run_high = last_running_high</span><br><span class="line">        </span><br><span class="line">        return announce_highest(who, new_score, new_run_high)</span><br><span class="line">        </span><br><span class="line">    return say</span><br><span class="line">    # END PROBLEM 7</span><br></pre></td></tr></table></figure>

<p>这段代码就是记录玩家 1 或 2 分数变化的幅度，并在最大幅度记录更新时 print 的函数。</p>
<p>传统函数（指 C&#x2F;C++ 这种）要实现这种记录更新，必须在外部存储，用类或者其它外部变量什么的，因为函数一旦执行完毕，内部空间将全部释放。</p>
<p>下面对该代码做点拆解，忽略 say 的内容、断言、测试和注释，可看成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">def announce_highest(who, last_score=0, running_high=0):</span><br><span class="line">    # BEGIN PROBLEM 7</span><br><span class="line">    &quot;*** YOUR CODE HERE ***&quot;</span><br><span class="line">    def say(new_score_0, new_score_1, last_running_high = running_high):</span><br><span class="line">        pass</span><br><span class="line">        </span><br><span class="line">    return say</span><br><span class="line">    # END PROBLEM 7</span><br></pre></td></tr></table></figure>

<p>可见，调用 announce_highest 的本质是获取到一个 say 函数，每次调用 say 函数，我们都期待它能检测是否要更新记录，而不断地更新最大幅度，则要不断地获取并调用 say 函数，那让 say 返回获取 say 函数的函数就解决了这个问题，即下面代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">def announce_highest(who, last_score=0, running_high=0):</span><br><span class="line">    # BEGIN PROBLEM 7</span><br><span class="line">    &quot;*** YOUR CODE HERE ***&quot;</span><br><span class="line">    def say(new_score_0, new_score_1, last_running_high = running_high):</span><br><span class="line"> </span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">        return announce_highest(who, new_score, new_run_high)</span><br><span class="line">        </span><br><span class="line">    return say</span><br><span class="line">    # END PROBLEM 7</span><br></pre></td></tr></table></figure>

<p>再看测试代码就清晰多了</p>
<p><code>&gt;&gt;&gt; f0 = announce_highest(1) # Only announce Player 1 score gains</code> 这里的 f0 实际上是 who 为 1 时的 say 函数</p>
<p><code>&gt;&gt;&gt; f1 = f0(12, 0)</code> f1 的本质是代入 new_score_0 &#x3D; 12 和 new_score_1 &#x3D; 0 的 say 函数执行后，返回的新的 say 函数。你问 announce_highest 去哪了？announce_highest 也返回的 say 函数，只是没有参数代入的 say 函数而已</p>
<p>其它测试语句以上述类推</p>
<p>后面在 <a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/higher-order-functions-in-python/">geek for geek</a> 进行了更深入的学习，发现此前在 LALC 用的迭代器就是高阶函数的运用</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/18/[CS61A-Fall-2020]%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%955%20Project1%20The%20Game%20of%20Hog%20%E4%B8%AD%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E7%82%B9/" data-id="cm7j3jec0000810agezuh0v1z" data-title="【CS61A-Fall-2020】学习记录五 Project1 The Game of Hog 中有意思的点" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CS61A/" rel="tag">CS61A</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/" rel="tag">Python</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-[Datawhale AI 夏令营] 机器学习 Task1 体验记录 思考 补充" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/11/%5BDatawhale%20AI%20%E5%A4%8F%E4%BB%A4%E8%90%A5%5D%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20Task1%20%E4%BD%93%E9%AA%8C%E8%AE%B0%E5%BD%95%20%E6%80%9D%E8%80%83%20%E8%A1%A5%E5%85%85/" class="article-date">
  <time class="dt-published" datetime="2024-07-11T14:43:00.000Z" itemprop="datePublished">2024-07-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/07/11/%5BDatawhale%20AI%20%E5%A4%8F%E4%BB%A4%E8%90%A5%5D%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20Task1%20%E4%BD%93%E9%AA%8C%E8%AE%B0%E5%BD%95%20%E6%80%9D%E8%80%83%20%E8%A1%A5%E5%85%85/">【Datawhale AI 夏令营】 机器学习 Task1 体验记录 思考 补充</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>首先感谢 Datawhale 组织这个活动，让我有机会入门机器学习。</p>
<p>嘛，不过这个 Task1 只要跟着速通手册运行给定程序，再拿结果去提交，体验下过程而已，于我而言，更为宝贵的地方是后续的“加餐”，也就是分析题目，精读代码的部分</p>
<h1 id="“加餐”小结"><a href="#“加餐”小结" class="headerlink" title="“加餐”小结"></a>“加餐”小结</h1><h2 id="分析题目"><a href="#分析题目" class="headerlink" title="分析题目"></a>分析题目</h2><p>赛题任务是：通过多个房屋历史电力消耗数据等信息，预测房屋对应电力的消耗。</p>
<p>这是所谓的“时间序列问题”，简单地说就是分析数据和预测趋势。</p>
<p>说起来，大一的课程设计也简单做过所谓的“酒吧销量预测”功能，当时是采用“线性回归”来着。</p>
<p>而要解决这样的问题，就大致有建立传统时间序列模型、机器学习模型、深度学习模型的方法。</p>
<p>这三种方法各有利弊，按适合处理数据集规模大小和预测能力升序，按解释性和计算资源降序。</p>
<h2 id="分析代码"><a href="#分析代码" class="headerlink" title="分析代码"></a>分析代码</h2><p>先贴出代码好了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 1. 导入需要用到的相关库</span><br><span class="line"># 导入 pandas 库，用于数据处理和分析</span><br><span class="line">import pandas as pd</span><br><span class="line"># 导入 numpy 库，用于科学计算和多维数组操作</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># 2. 读取训练集和测试集</span><br><span class="line"># 使用 read_csv() 函数从文件中读取训练集数据，文件名为 &#x27;train.csv&#x27;</span><br><span class="line">train = pd.read_csv(&#x27;train.csv&#x27;)</span><br><span class="line"># 使用 read_csv() 函数从文件中读取测试集数据，文件名为 &#x27;train.csv&#x27;</span><br><span class="line">test = pd.read_csv(&#x27;test.csv&#x27;)</span><br><span class="line"></span><br><span class="line"># 3. 计算训练数据最近11-20单位时间内对应id的目标均值</span><br><span class="line"></span><br><span class="line">target_mean = train[train[&#x27;dt&#x27;]&lt;=20].groupby([&#x27;id&#x27;])[&#x27;target&#x27;].mean().reset_index()</span><br><span class="line"></span><br><span class="line"># 4. 将target_mean作为测试集结果进行合并</span><br><span class="line">test = test.merge(target_mean, on=[&#x27;id&#x27;], how=&#x27;left&#x27;)</span><br><span class="line"></span><br><span class="line"># 5. 保存结果文件到本地</span><br><span class="line">test[[&#x27;id&#x27;,&#x27;dt&#x27;,&#x27;target&#x27;]].to_csv(&#x27;submit.csv&#x27;, index=None)</span><br></pre></td></tr></table></figure>

<p>如果只是想了解思路，那么看完速通手册，大致读读注释即可，不过陆爻齐喜欢再深入一点点。</p>
<p>比如，为啥只要11-20天数据，1-20不行吗，reset_index()是什么函数？</p>
<p>要理解处理数据的方式，可以看看数据本身的样子，不过这里吐槽下，我还是第一次见到 WPS 会说太大了，受不了：）</p>
<p><img src="https://img2024.cnblogs.com/blog/3207177/202407/3207177-20240711214834025-1250283106.png" alt="WPS说太大了"></p>
<p>回到正题，来看看这数据集究竟长啥样</p>
<p><img src="https://img2024.cnblogs.com/blog/3207177/202407/3207177-20240711215329507-2023937455.png" alt="train pic 1"></p>
<p>……………………………………………………</p>
<p><img src="https://img2024.cnblogs.com/blog/3207177/202407/3207177-20240711215338956-1671382801.png" alt="train pic 2"></p>
<p>显然，图中 id 是房子编号，dt 是日期，type 是房子类型（暂且用不到），target 是用电量。</p>
<p>所以，代码<code>target_mean = train[train[&#39;dt&#39;]&lt;=20].groupby([&#39;id&#39;])[&#39;target&#39;].mean().reset_index()</code>翻译为自然语言，就是：以 id 为分组标识（想起了 mysql ），选择其中日期 dt 小于等于 20 的数据，计算均值并重置索引。</p>
<p>重置索引的具体解释，可以参考 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/keye/p/11229863.html">这篇文章</a>。</p>
<p>如此，target_mean 相当于下面数据</p>
<p>id          target<br>00037f39cf  39.6543<br>……</p>
<p>而代码<code>test = test.merge(target_mean, on=[&#39;id&#39;], how=&#39;left&#39;)</code>则将上面刚得的 target_mean 与 test 左外连接。</p>
<p>先看看test长啥样好了</p>
<p><img src="https://img2024.cnblogs.com/blog/3207177/202407/3207177-20240711222938772-1741838916.png" alt="test"></p>
<p>图片不用多加解释，其实所谓的左外连接（又想起 mysql 了），就是把 test 以 id 为组，连到右边的 target_mean，离散数学的映射中算是“满射”</p>
<p>举个栗子，test 中，id 00037f39cf 有十条，区别只有 id 1-10，而target_mean 中，id 00037f39cf 只有一条数据，也就是上面的</p>
<p>id          target<br>00037f39cf  39.6543</p>
<p>于是按 id 连接，将相同 id 对应进行连接，也就是在 test 的基础上，把 target_mean 同 id 那条数据中，除 id 自己外的属性，连接到 test 上，如</p>
<p>id          dt     type     target<br>00037f39cf  1      2        39.6543<br>00037f39cf  2      2        39.6543<br>00037f39cf  3      2        39.6543<br>……</p>
<p>最后一条代码，即只保留该数据的id dt target，保存为新的表格 csv 文件，也就是那个 submit.csv。</p>
<p><img src="https://img2024.cnblogs.com/blog/3207177/202407/3207177-20240711223939047-1629152698.png" alt="submit example"></p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Task1 本身操作很简单，要理解也不难，对于陆爻齐这样稍微有点基础知识也算有趣，后续推荐的 Pandas 学习的第十章也是时序预测（笑，期待 Task2。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/11/[Datawhale%20AI%20%E5%A4%8F%E4%BB%A4%E8%90%A5]%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20Task1%20%E4%BD%93%E9%AA%8C%E8%AE%B0%E5%BD%95%20%E6%80%9D%E8%80%83%20%E8%A1%A5%E5%85%85/" data-id="cm7j3jec2000c10ag075o8tzn" data-title="【Datawhale AI 夏令营】 机器学习 Task1 体验记录 思考 补充" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-[CINTA] 具体数论与代数阅读笔记——第一章 整数和二进制（含加、乘、除）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/09/%5BCINTA%5D%20%E5%85%B7%E4%BD%93%E6%95%B0%E8%AE%BA%E4%B8%8E%E4%BB%A3%E6%95%B0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%95%B4%E6%95%B0%E5%92%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%EF%BC%88%E5%90%AB%E5%8A%A0%E3%80%81%E4%B9%98%E3%80%81%E9%99%A4%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2024-07-09T15:39:00.000Z" itemprop="datePublished">2024-07-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/07/09/%5BCINTA%5D%20%E5%85%B7%E4%BD%93%E6%95%B0%E8%AE%BA%E4%B8%8E%E4%BB%A3%E6%95%B0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%95%B4%E6%95%B0%E5%92%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%EF%BC%88%E5%90%AB%E5%8A%A0%E3%80%81%E4%B9%98%E3%80%81%E9%99%A4%EF%BC%89/">【CINTA】 具体数论与代数阅读笔记——第一章 整数和二进制（含加、乘、除）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这本书说自己是计算机专业数学入门之入门,成为读者攻读其他经典著作的垫脚石，但个人以为足矣替换掉本校内不知所云的、抽象的、让学生考完后马上全忘的那些课程。本书的 GitHub 仓库在<a target="_blank" rel="noopener" href="https://github.com/lbwang/CINTA-cn">这里</a>。</p>
<p>该笔记并非单纯的整理归纳，而是记录陆爻齐在书中找到的对自己很有感触的部分。</p>
<p>闲话少说，下面是笔记正文。</p>
<h1 id="第一章-整数与二进制"><a href="#第一章-整数与二进制" class="headerlink" title="第一章 整数与二进制"></a>第一章 整数与二进制</h1><h2 id="1-1-二进制"><a href="#1-1-二进制" class="headerlink" title="1.1 二进制"></a>1.1 二进制</h2><h3 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h3><p>首先，有两条基本的性质</p>
<ol>
<li>偶数二进制最末尾的比特是 0;奇数二进制最末尾的比特是 1；</li>
<li>在一个二进制数末尾增加一个 0 等同于在十进制中对这个数乘 2。<br>反过来说,对一个十进制数进行乘 2 操作等同于对其二进制表达左移一个比特。</li>
</ol>
<p>显然，比如 2 的二进制表示为 0010，3 为 0011， 4即 2*2 为0100。</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>随后提出<strong>思考</strong>：请问,你认为对一个十进制数进行除 2 等于对其二进制表达右移一个比特吗?</p>
<p>陆爻齐的回答是：是的，对 3，出 2 得 1.5，0011 右移一个比特得 0001.1，正好为 1.5。对 2， 除 2 得 1，0010 右移一个比特得 0001，正好为1。</p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>接着在基于“考虑任意自然数 n,所谓 2 的 n 次方 (2^n) 只是不断对 1 乘 n 次 2”给出了两条性质<br>3、给定任意自然数 n, 十进制数 2^n 的二进制数表达就是在 1 后加 n 个 0；<br>4、给定任意自然数 n, 十进制数 2^n − 1 的二进制数表达就是 n 个 1；</p>
<p>结合一点例子就能认同，4 是 2 的 2 次方，即 1 后加 2 个 0，即 0100。1 是 2 的 0 次方，为 1 后加 0 个 0，即 0001。4 减 1 得 3，0011，就是 2 的 1 次方和 0 次方相加所得， 0011 &#x3D; 0010 + 0001；2^2 - 1 &#x3D; 2^1 + 2^0。</p>
<h3 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h3><p>接下来是作者给的<strong>思考</strong>，请将以上计算过程的结论归纳成一个定理,并证明。你可以使用任何的证明方法。<br>请问,以上“硬”算的方法能否推广为一种证明方法?</p>
<p>陆爻齐认为，可以归纳为，对任意自然数 n+1（n&gt;&#x3D;0)，有$2^{(n+1)} &#x3D; \sum_0^n 2^n$</p>
<h3 id="位置计数法"><a href="#位置计数法" class="headerlink" title="位置计数法"></a>位置计数法</h3><p>如此，便引入了位置计数法，即对任意整数 b，有 $b&#x3D;\sum_{i&#x3D;0}^{n-1}b_i2^i$，其中$b_i\in{0,1}$</p>
<p>显然，取 10，即 1010，可以视为 $1010 &#x3D; 1<em>2^3 + 0</em>2^2 + 1<em>2^1 + 0</em>2^0$，换句话 10 &#x3D; 1<em>8 + 0</em>4 + 1<em>2 + 0</em>1。</p>
<h2 id="加法与乘法"><a href="#加法与乘法" class="headerlink" title="加法与乘法"></a>加法与乘法</h2><h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><p>加法，大家都能想到 a+b，但要是不准用 + 呢？</p>
<p>于是有下面这个加法的算法，C++ 实现如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 输入：两个整数a和b的和</span><br><span class="line">// 输出：a与b的和</span><br><span class="line">int add (int a, int b) &#123;</span><br><span class="line">    // cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    if (b == 0) return a;</span><br><span class="line">    return add(a^b, (a&amp;b)&lt;&lt;1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作者想表达计算机的本质是bit的异或、与及移位操作。</p>
<h3 id="思考-2"><a href="#思考-2" class="headerlink" title="思考"></a>思考</h3><p>这里又是<strong>思考</strong>：要理解这个加法算法只需要地正确回答出以下三个问题:</p>
<ol>
<li>a ∧ b 得到的是什么?</li>
<li>(b&amp;a) &lt;&lt; 1 得到的是什么?</li>
<li>该算法为什么会终止?</li>
</ol>
<p>陆爻齐的回答是，</p>
<ol>
<li>a ^ b 得到的是 a 和 b 相加后，移位之后且还没计算进位的部分。异或操作是 10 和 01 得 1，11 或 00 得 0，1 与 0 相加，那位不用进位，留 1；而 0 + 0 或 1 + 1，则会在原地留 0，这正好符合异或操作的结果。</li>
<li>(b&amp;a) &lt;&lt; 1 得到进位的部分，a&amp;b 的与操作就可以得到 1 + 1 的位，&lt;&lt; 1 是移位操作，根据上文，二进制乘 2，靠后面加个 0， 故向左移一位。</li>
<li>算法之所以会终止，是因为从右向左，每次执行完进位操作一定能保证该位以右不会有可进位的位，如设第 1 位要进位，那么进位后第一位就确认为 1 或 0，但进位后可能导致下一位需要进位，若此时第二位要进位，那么就处理进位并确认第二位为 1 或 0，以此类推，处理至尽。因处理的数字是有限位数字，故算法一定能终止。</li>
</ol>
<h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><p>作者介绍了一种朴素乘法，即 a*b 的本质，是 b 个 a 相加。下面作者以此为例，从正确性、效率、优化三个角度分析该算法。</p>
<p>显然，这种不断加的乘法时间复杂度为O（n）。</p>
<p>然后是重点，递归版的“简单乘法”，C++ 实现如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int multiply(int a, int b) &#123;</span><br><span class="line">    // cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    if (b == 0) return 0;</span><br><span class="line"></span><br><span class="line">    if (is_even(b)) &#123;</span><br><span class="line">        return 2 * multiply(a, b &gt;&gt; 1);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        return 2 * multiply(a, b &gt;&gt; 1) + a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这个程序可以这么理解，返 0 不用说，如果 b 是偶数，比如 0b100 是 8，a 随便取个数，比如 3，即 0b11，用 100 * 11 相当于 2 * （10 * 11），也等于 2 * （ 2 * （ 1 * 11）），最后省个 1，也就加个 a，综上。</p>
<p>换个复杂点的例子，让 b 为 1010，那就可以看为 (1<em>2^4 + 0</em>2^3 + 1<em>2^2 + 0</em>2^1) * 3 。</p>
<p>同时作者还补充，在附录 A 有更高效的乘法实现。</p>
<h2 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h2><h3 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h3><p>首先得有个除法定理，对任意给定的整数 a 和 b,其中 b &gt; 0,存在唯一的整数对 q(商)和 r(余数)，使得 a &#x3D; qb + r 且 0 ≤ r &lt; b。</p>
<p>然后，介绍了下良序原则和单射、满射、一一映射等概念，不过感觉在下面没啥用。</p>
<p>然后是除法的实现，朴素除法与朴素乘法类似，是不断减去除数，至被除数比除数小时，相减次数为“商”，剩下的被除数为“余数”。</p>
<h3 id="简单除法"><a href="#简单除法" class="headerlink" title="简单除法"></a>简单除法</h3><p>而简单除法的 C++ 实现如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">std::pair&lt;int, int&gt; m_divide(int a, int b) &#123;</span><br><span class="line">    // cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    if (a == 0) &#123;</span><br><span class="line">        return pair&lt;int, int&gt;(0, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::pair&lt;int, int&gt; result = m_divide(a &gt;&gt; 1, b);</span><br><span class="line"></span><br><span class="line">    result.first &lt;&lt;= 1; result.second &lt;&lt;= 1;</span><br><span class="line"></span><br><span class="line">    if (a &amp; 1) &#123;</span><br><span class="line">        result.second += 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (result.second &gt;= b) &#123;</span><br><span class="line">        result.first += 1;</span><br><span class="line">        result.second -= b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>某种程度就是那个简单除法的逆运算捏，但我觉得我也不是那么明白，只能感受到，这是在不断对背除数除二，然后从左至右确认“商”，最后消除还不明白如何产生的误差来确认“余数”。</p>
<h1 id="第一章-习题"><a href="#第一章-习题" class="headerlink" title="第一章 习题"></a>第一章 习题</h1><p>嘛，又不是正式上课，就选两道做做罢</p>
<h2 id="1-判断奇偶的函数，c语言实现"><a href="#1-判断奇偶的函数，c语言实现" class="headerlink" title="1 判断奇偶的函数，c语言实现"></a>1 判断奇偶的函数，c语言实现</h2><p>判断奇数<br><code>int func (int a) &#123;   if (a &amp; 1) return True;   return False; &#125;</code><br>判断偶数<br><code>int func (int a) &#123;   if (a &amp; 1) return False;   return True; &#125;</code></p>
<p>思想是，奇数的二进制表示中，最右位总为 1，只要 &amp; 上 1，就只会保留最右位，1 则奇数，0 则偶数。</p>
<h2 id="2-判断-v-是否为-2-的某次方"><a href="#2-判断-v-是否为-2-的某次方" class="headerlink" title="2 判断 v 是否为 2 的某次方"></a>2 判断 v 是否为 2 的某次方</h2><p>两个思路</p>
<ol>
<li>若 v 为 2 的某次方，必表现为 100……0 的形式，那么用 while 循环从右至左判断，是否只有最后（最左）为 1 则是；</li>
<li>若 v 为 2 的某次方，必在减 1 后，为 111……11 的形式，那么用相同位数的 111……11 与之异或，若最后得 0，则是；</li>
</ol>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>CINTA 第一章下来，我想我还是更优先看看 CSAPP 或许更好些，不过其中部分内容真是有意思，从二进制的角度看待加、乘、除，别有一番风味。另外也庆幸不是学校的专业课，不然又是一门备考时令人头疼的科目力</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/09/[CINTA]%20%E5%85%B7%E4%BD%93%E6%95%B0%E8%AE%BA%E4%B8%8E%E4%BB%A3%E6%95%B0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%95%B4%E6%95%B0%E5%92%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%EF%BC%88%E5%90%AB%E5%8A%A0%E3%80%81%E4%B9%98%E3%80%81%E9%99%A4%EF%BC%89/" data-id="cm7j3jebm000010ag53ar4tkp" data-title="【CINTA】 具体数论与代数阅读笔记——第一章 整数和二进制（含加、乘、除）" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CINTA/" rel="tag">CINTA</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-[JLU] 数据结构与算法上机题解思路分享-课程设计第三次和第四次上机 吉林大学" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/04/%5BJLU%5D%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF%E5%88%86%E4%BA%AB-%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%92%8C%E7%AC%AC%E5%9B%9B%E6%AC%A1%E4%B8%8A%E6%9C%BA%20%E5%90%89%E6%9E%97%E5%A4%A7%E5%AD%A6/" class="article-date">
  <time class="dt-published" datetime="2024-07-04T04:00:00.000Z" itemprop="datePublished">2024-07-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/07/04/%5BJLU%5D%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF%E5%88%86%E4%BA%AB-%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%92%8C%E7%AC%AC%E5%9B%9B%E6%AC%A1%E4%B8%8A%E6%9C%BA%20%E5%90%89%E6%9E%97%E5%A4%A7%E5%AD%A6/">【JLU】 数据结构与算法上机题解思路分享-课程设计第三次和第四次上机 吉林大学</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>首先</strong>，请务必自己尽全力尝试实现题目，直接看成品代码，思维就被拘束了，也很容易被查重。</p>
<p>这里只是思路解析的博客，代码仓库在 <a target="_blank" rel="noopener" href="https://github.com/HSLix/JLU_Data_Structures_Record.git">JLU_Data_Structures_Record</a></p>
<p>希望你能在这里找到你想要的:)</p>
<h1 id="第三次上机"><a href="#第三次上机" class="headerlink" title="第三次上机"></a>第三次上机</h1><hr>
<h2 id="A-手撕BST"><a href="#A-手撕BST" class="headerlink" title="A 手撕BST"></a>A 手撕BST</h2><p>分数 50<br>作者 朱允刚<br>单位 吉林大学<br>对一棵初始为空的二叉查找树（Binary Search Tree, BST）进行若干插入或删除操作，请输出最后的二叉查找树。</p>
<p>bst.png</p>
<p>输入格式:<br>输入第一行为一个整数 T，表示操作数目。随后 T 行，每行为Insert K（表示插入关键词为K的结点，若树中已有关键词为K的结点，则不插入）或Remove K（表示删除关键词为K的结点，若树中无关键词为K的结点，则不删除），其中K为整数。 T 不超过2×10^5，树高不超过10^4。</p>
<p>输出格式:<br>输出经上述操作后得到的二叉查找树的中根序列和先根序列，序列中每个整数后一个空格，两个序列之间用空行间隔。</p>
<p>输入样例:<br>16<br>Insert 17<br>Insert 31<br>Insert 13<br>Insert 11<br>Insert 20<br>Insert 35<br>Insert 25<br>Insert 8<br>Insert 4<br>Insert 11<br>Insert 24<br>Insert 40<br>Insert 27<br>Insert 9<br>Remove 17<br>Remove 13</p>
<p>输出样例:<br>4 8 9 11 20 24 25 27 31 35 40 </p>
<p>20 11 8 4 9 31 25 24 27 35 40 </p>
<p>代码长度限制<br>16 KB<br>时间限制<br>500 ms<br>内存限制<br>64 MB<br>栈限制<br>8192 KB</p>
<hr>
<p>二叉查找树的插入和查找都不算难，但删除需要注意的是，如果要删的节点有两个子节点，则将该节点的右子树中最小的节点与之交换，并执行从右子树中删除该最小点的任务。其余与普通的二叉树一样操作。</p>
<hr>
<h2 id="B-手撕AVL树（基础版）"><a href="#B-手撕AVL树（基础版）" class="headerlink" title="B 手撕AVL树（基础版）"></a>B 手撕AVL树（基础版）</h2><p>分数 50<br>作者 朱允刚<br>单位 吉林大学<br>对一棵初始为空的高度平衡树（AVL树）进行若干插入或删除操作，请输出最后得到的AVL树。</p>
<p>备注：<br>（1）当有多种旋转方案时，优先选择旋转次数少的方案。<br>（2）70%的测试点只包含插入操作，如果你只实现插入操作，也能获得70%的分数。</p>
<p>输入格式:<br>输入第一行为一个整数 T，表示操作数目。随后 T 行，每行为Insert K（表示插入关键词为K的结点，若树中已有关键词为K的结点，则不插入）或Remove K（表示删除关键词为K的结点，若树中无关键词为K的结点，则不删除），其中K为整数。 T 不超过2×10<br>5<br> 。</p>
<p>输出格式:<br>输出经上述操作后得到的高度平衡树的中根序列和先根序列，序列中每个整数后一个空格，两个序列之间用空行间隔。</p>
<p>输入样例:<br>16<br>Insert 17<br>Insert 31<br>Insert 13<br>Insert 11<br>Insert 20<br>Insert 35<br>Insert 25<br>Insert 8<br>Insert 4<br>Insert 11<br>Insert 24<br>Insert 40<br>Insert 27<br>Insert 9<br>Remove 17<br>Remove 13<br>输出样例:<br>4 8 9 11 20 24 25 27 31 35 40 </p>
<p>20 8 4 11 9 31 25 24 27 35 40<br>代码长度限制<br>16 KB<br>时间限制<br>100 ms<br>内存限制<br>64 MB<br>栈限制<br>8192 KB</p>
<hr>
<p>二叉平衡树的插入和删除也是思维不复杂，但实现很麻烦的东西，我只能说，为了使程序的逻辑尽可能清晰，尽量把功能打包成函数，比如一个节点的高度什么的</p>
<hr>
<h2 id="C-手撕红黑树"><a href="#C-手撕红黑树" class="headerlink" title="C 手撕红黑树"></a>C 手撕红黑树</h2><p>分数 50<br>作者 朱允刚<br>单位 吉林大学<br>对一棵初始为空的红黑树（Red-Black Tree, RBT）进行若干插入或删除操作，请输出最后的红黑树。</p>
<p>rbt.png</p>
<p>备注：<br>（1）当有多种旋转方案时，优先选择旋转次数少的方案。<br>（2）70%的测试点只包含插入操作，如果你只实现插入操作，也能获得70%的分数。</p>
<p>输入格式:<br>输入第一行为一个整数 T，表示操作数目。随后 T 行，每行为Insert K（表示插入关键词为K的结点，若树中已有关键词为K的结点，则不插入）或Remove K（表示删除关键词为K的结点，若树中无关键词为K的结点，则不删除），其中K为整数。 T 不超过2×10<br>5<br> 。</p>
<p>输出格式:<br>输出经上述操作后得到的红黑树的中根序列和先根序列，序列中对于每个结点输出其关键词和颜色（红色用R表示，黑色用B表示），每个元素后一个空格，两个序列之间用空行间隔。</p>
<p>输入样例:<br>5<br>Insert 8<br>Insert 9<br>Insert 3<br>Insert 4<br>Insert 5</p>
<p>输出样例:<br>3 R 4 B 5 R 8 B 9 B </p>
<p>8 B 4 B 3 R 5 R 9 B </p>
<p>代码长度限制<br>16 KB<br>时间限制<br>100 ms<br>内存限制<br>64 MB<br>栈限制<br>8192 KB</p>
<hr>
<p>红黑树这题，也差一个点没过，故不作思路解析</p>
<hr>
<h1 id="第四次上机"><a href="#第四次上机" class="headerlink" title="第四次上机"></a>第四次上机</h1><hr>
<h2 id="A-手撕STL-sort（进阶版）"><a href="#A-手撕STL-sort（进阶版）" class="headerlink" title="A 手撕STL sort（进阶版）"></a>A 手撕STL sort（进阶版）</h2><p>分数 100<br>作者 朱允刚<br>单位 吉林大学<br>事实上，STL的sort函数在上一题（基础版）的基础上，还采用了下列优化手段，以进一步提升快速排序算法的效率。</p>
<p>（3）“三数取中”选基准元素。不是选取第一个元素作为基准元素，而是在当前子数组中选取3个元素，取中间大的那个元素作为基准元素。从而保证选出的基准元素不是子数组的最小元素，也不是最大元素，避免Partition分到子数组最边上，以降低最坏情况发生的概率。<br>为确保本题答案唯一，本算法的实现请以教材为准，即普林斯顿大学Sedgewick教授给出的方法：若当前子数组是R[m]…R[n]，选取R[m]、R[(m+n)&#x2F;2]和R[n]的中位数作为基准元素。先将R[(m+n)&#x2F;2]与R[m+1]交换；若R[m+1]比R[n]大，交换二者；若R[m]比R[n]大，交换二者；若R[m+1]比R[m]大，交换二者。</p>
<p>（4）尾递归转为循环。即将传统快速排序代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void QuickSort(int R[],int m,int n)&#123;</span><br><span class="line">   if(n - m + 1 &gt; threshold)&#123;</span><br><span class="line">        int j = Partition(R, m, n); </span><br><span class="line">        QuickSort(R, m, j-1);  //递归处理左区间</span><br><span class="line">        QuickSort(R, j+1, n);  //递归处理右区间，尾递归</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转换为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void QuickSort(int R[],int m,int n)&#123;</span><br><span class="line">   while(n - m + 1 &gt; threshold)&#123;    //注意此处不是if，而是while</span><br><span class="line">        int j = Partition(R, m, n); </span><br><span class="line">        QuickSort(R, m, j-1);  //递归处理左区间</span><br><span class="line">        m = j+1;  //通过while循环处理右区间，从而消除尾递归</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即先递归处理左区间，后循环处理右区间，从而消除一个尾递归，以减少递归调用带来的时空消耗。<br>这里需注意，尾递归转循环后，转入堆排序的时机不仅仅是递归深度达到2logn，而是递归深度和while循环迭代的次数加一起达到2logn时转入堆排序。</p>
<p>（5）优先处理短区间。在上述策略（4）的基础上进一步改进，不是按固定次序处理左右子区间（每次都先处理左区间、后处理右区间），而是先（通过递归）处理左右两个子区间中“较短的那个区间”，然后再（通过循环）处理两个子区间中“较长的那个区间”。从而使每次递归处理的子数组长度至少缩减一半，使最坏情况下递归深度（算法最坏情况空间复杂度）为logn。</p>
<p>（6）三路分划（3-Way Partition）。当重复元素很多时，传统快速排序效率较低。可修改Partition操作，不是把当前数组划分为两部分，而是三部分：小于基准元素K的元素放在左边，等于K的元素放在中间，大于K的元素在右边。接下来仅需对小于K的左半部分子数组和大于K的右半部分子数组进行排序。中间等于K的所有元素都已就位，无需处理。<br>为确保本题答案唯一，此处请采用如下做法：若当前子数组是R[m]…R[n]，可设置3个指针，前指针i，中指针j，后指针k。初始时i和j指向第一个元素，k指向最后一个元素；指针j从左往右扫描数组：</p>
<p>若R[j]小于基准元素，交换R[j]和R[i], i++, j++；<br>若R[j]大于基准元素，交换R[j]和R[k], k–；<br>若R[j]等于基准元素，j++；<br>通过指针j的遍历，使小于基准元素的元素换到当前子数组左侧，大于基准元素的元素换到右侧。当j扫描完当前子数组后，R[m]…R[i-1]即小于基准元素的元素，R[i]…R[k]即等于基准元素的元素，R[k+1]…R[n]即大于基准元素的元素。</p>
<p>在本题中，请你在之前实现的STL sort()初级版的基础上，进一步实现上述优化策略。</p>
<p>提示：本题只需把原来的Partition改为3-way Partition，并使用“三数取中”法选择基准元素。<br>在快速排序函数里，改为“尾递归转循环 + 先处理短区间”。你可以在Visual Studio里对sort函数右键点击“转到定义”，查看VS中STL的sort()实现细节<br>vstudio sort转到定义图片.jpg</p>
<p>函数接口定义：<br>void sort(int *R, int n);<br>功能为对整数R[1]…R[n]递增排序。</p>
<p>裁判测试程序样例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int threshold;</span><br><span class="line"></span><br><span class="line">// 请在这里补充你的代码，即你所实现的sort函数</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,i;</span><br><span class="line">    int a[50010];</span><br><span class="line">    scanf(&quot;%d %d&quot;, &amp;n, &amp;threshold);</span><br><span class="line">    for (i = 1; i &lt;= n; i++)</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    sort(a,n);</span><br><span class="line">    </span><br><span class="line">    printf(&quot;Final:&quot;);</span><br><span class="line">    for (i = 1; i &lt;= n; i++)</span><br><span class="line">        printf(&quot;%d &quot;,a[i]);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>备注：提交代码时，只需提交sort函数以及你自定义的其他函数，不用提交#include或者main函数等内容。</p>
<p>输入格式:<br>输入第一行为2个正整数n和threshold，n为待排序的元素个数，不超过50000，threshold为改用插入排序的阈值，不超过20，含义如上所述。第二行为n个空格间隔的整数。本题中读入数据的操作无需你来实现，而由框架程序完成。</p>
<p>输出格式:<br>输出第一行为以depth_limit:开头的整数，表示转为堆排序的递归深度，即⌊2log<br>2n⌋。从第二行开始，输出对某子数组转为堆排序后，该子数组初始建堆的结果，每个元素后一个空格，每个堆占一行，以Heap:开头。注意，可能不止一个堆。接下来下一行，输出n个整数，每个整数后一个空格，为快速排序所有递归退出后，插入排序执行前的数组元素，以Intermediate:开头。最后一行为n整数，每个整数后一个空格，表示排序后的数组，以Final:开头（最后一行由框架程序完成，无需你来输出）。</p>
<p>输入样例1：<br>10 2<br>10 9 8 7 6 5 4 3 2 1</p>
<p>输出样例1：<br>depth_limit:6<br>Intermediate:1 2 3 5 4 6 7 8 9 10<br>Final:1 2 3 4 5 6 7 8 9 10 </p>
<p>输入样例2：<br>60 2<br>66 61 92 22 50 80 39 2 25 60 49 17 37 19 24 57 40 82 11 52 45 0 33 78 32 25 19 42 92 50 39 87 74 87 56 79 63 63 80 83 50 3 87 2 91 77 87 10 59 23 25 6 49 85 9 95 60 16 28 1<br>输出样例2：<br>depth_limit:11<br>Intermediate:1 0 2 2 3 6 9 10 11 16 17 19 19 22 23 24 25 25 25 32 28 33 37 39 39 40 42 45 49 49 50 50 50 52 56 57 59 60 60 61 63 63 66 74 77 78 79 80 80 82 83 85 87 87 87 87 91 92 92 95<br>Final:0 1 2 2 3 6 9 10 11 16 17 19 19 22 23 24 25 25 25 28 32 33 37 39 39 40 42 45 49 49 50 50 50 52 56 57 59 60 60 61 63 63 66 74 77 78 79 80 80 82 83 85 87 87 87 87 91 92 92 95 </p>
<p>代码长度限制<br>16 KB<br>时间限制<br>100 ms<br>内存限制<br>64 MB</p>
<hr>
<p>此题基于课程设计第二次上机A题，而且改进方法都在题目里，是在不行，朱老师的ppt里有来着？</p>
<hr>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>好像又没啥可结的，总之就这样罢</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/04/[JLU]%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF%E5%88%86%E4%BA%AB-%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%92%8C%E7%AC%AC%E5%9B%9B%E6%AC%A1%E4%B8%8A%E6%9C%BA%20%E5%90%89%E6%9E%97%E5%A4%A7%E5%AD%A6/" data-id="cm7j3jec8000u10ag48qgd8vj" data-title="【JLU】 数据结构与算法上机题解思路分享-课程设计第三次和第四次上机 吉林大学" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JLU/" rel="tag">JLU</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag">数据结构与算法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-[JLU] 数据结构与算法上机题解思路分享-课程设计第一次与第二次上机 吉林大学" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/03/%5BJLU%5D%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF%E5%88%86%E4%BA%AB-%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%B8%8E%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%B8%8A%E6%9C%BA%20%E5%90%89%E6%9E%97%E5%A4%A7%E5%AD%A6/" class="article-date">
  <time class="dt-published" datetime="2024-07-03T14:58:00.000Z" itemprop="datePublished">2024-07-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/07/03/%5BJLU%5D%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF%E5%88%86%E4%BA%AB-%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%B8%8E%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%B8%8A%E6%9C%BA%20%E5%90%89%E6%9E%97%E5%A4%A7%E5%AD%A6/">【JLU】 数据结构与算法上机题解思路分享-课程设计第一次与第二次上机 吉林大学</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>首先</strong>，请务必自己尽全力尝试实现题目，直接看成品代码，思维就被拘束了，也很容易被查重。</p>
<p>这里只是思路解析的博客，代码仓库在 <a target="_blank" rel="noopener" href="https://github.com/HSLix/JLU_Data_Structures_Record.git">JLU_Data_Structures_Record</a></p>
<p>希望你能在这里找到你想要的:)</p>
<h1 id="第一次上机"><a href="#第一次上机" class="headerlink" title="第一次上机"></a>第一次上机</h1><hr>
<h2 id="A-网络布线"><a href="#A-网络布线" class="headerlink" title="A 网络布线"></a>A 网络布线</h2><p>分数 50<br>作者 朱允刚<br>单位 吉林大学<br>2024年亚洲杯足球赛刚刚落下帷幕，赛前人们普遍预测：本届比赛中日韩是最强的，冠军也会从日韩中产生……随着东道主卡塔尔队的夺冠，这一预言未能成真。</p>
<p>但我们这里要研究的是另一个问题，亚洲杯赛期间需要保证运动员公寓网络畅通，以使运动员都能正常上网。</p>
<p>假定公寓楼内有n个房间，编号为0…n−1，每个房间都需要网络连接。房间 i 有网络，当且仅当满足如下2个条件之一：</p>
<p>（1）房间 i 安装了路由器（成本为 ri&gt;0）</p>
<p>（2）房间 i 和房间 j 有网线连接且房间 j 有网络（在房间 i 和房间 j 之间布置网线的成本为 fij&gt;0）</p>
<p>假定你是赛事组委会的网络工程师，请编写程序设计一个网络布线方案（哪些房间安装路由器，哪些房间之间布置网线），使得所有房间都有网络，且总成本最小。</p>
<p>例如下图包含7个房间和10个可能的连接，安装路由器的成本为括号内数字，房间之间布置网线的成本为边的权值。其解决方案为右下图，即在房间1和4安装路由器，并进行图中的网线布置。总成本为120。</p>
<p>img.png</p>
<p>输入格式:<br>输入第一行为两个正整数n和e；n为房间数，不超过600；e为可能的连接数，不超过2×10^5。接下来一行为n个空格间隔的正整数，第i个整数(i≥0)表示在房间i安装路由器的成本。接下来e行，每行为3个非负整数i、j、f，表示在房间i和房间j之间布置网线的成本为f。</p>
<p>输出格式:<br>输出为一个整数，表示最优网络布线方案的成本。</p>
<p>输入样例:<br>7 10<br>60 10 35 55 40 70 70<br>0 1 20<br>0 4 75<br>0 3 45<br>1 3 50<br>1 2 15<br>2 6 5<br>5 6 45<br>4 5 5<br>3 5 25<br>3 6 65</p>
<p>输出样例:<br>120</p>
<p>提示:<br>可引入一个虚拟顶点，将该顶点与其他所有顶点用边相连，边权等于那些顶点的权值。进而形成一个新图，对新图求最小支撑树。注意本题顶点编号从0开始。<br>image.png<br>image.png</p>
<p>代码长度限制<br>16 KB<br>时间限制<br>60 ms<br>内存限制<br>64 MB<br>栈限制<br>8</p>
<hr>
<p>思路都在提示里，唯一能补充的就是构造最小支撑树的算法，有Kruskal或Prim，本质就是在不产生回路的情况下，从最小边或某一点为角度切入，不断选取权值最小的边，并通过栈或队列存储下次可能检查的边或点</p>
<hr>
<h2 id="B-社交网络"><a href="#B-社交网络" class="headerlink" title="B 社交网络"></a>B 社交网络</h2><p>分数 50<br>作者 朱允刚<br>单位 吉林大学<br>可以将n个QQ用户间的好友关系建模为一个包含n个顶点的无向图，顶点编号为1至n，每个顶点对应一个用户，若2个用户i和j是QQ好友，则在顶点i和j之间连接一条边，并根据用户间的亲密度对该边附以一个权值c<br>ij。在该图中，可以利用两个顶点间的最短路径长度衡量两个用户的关系密切程度，也可以利用经过一个顶点的最短路径数目来衡量一个用户在关系网络中的影响力，具体地，我们定义用户k在QQ关系网络中的“影响力”为：</p>
<p>333.png</p>
<p>其中Nij 为顶点i到j的最短路径数目，Nijk 为顶点i到j的所有最短路径中经过顶点k的最短路径数目（上述二值可能超出int型范围，请使用long long类型）。Dij 表示i到j的最短路径长度。</p>
<p>现给定一个如上描述的无向图，请编写程序，计算每个顶点的“影响力”，假定给定的图是连通的。</p>
<p>输入格式:<br>输入第一行为两个正整数n和e，分别表示图的顶点数和边数，接下来e行表示每条边的信息，每行为3个正整数a、b、c，其中a和b表示该边的端点编号，c表示权值。各边并非按端点编号顺序排列。</p>
<p>n≤100，e≤5000，c≤1000，任意两点间的最短路径数目≤10<br>10</p>
<p>输出格式:<br>输出为n行，每行一个实数，精确到小数点后3位，第i行为顶点i的影响力。</p>
<p>输入样例:<br>4 4<br>3 2 6<br>4 3 1<br>1 3 9<br>4 1 1</p>
<p>输出样例:<br>0.000<br>0.000<br>30.000<br>20.000</p>
<p>解释:<br>对于顶点1：边2-3、3-4、2-4的最短路径均不经过顶点1，故顶点1的影响力为0.</p>
<p>对于顶点3：<br>顶点1到2的最短路径共1条，长度为8，经过点3，顶点2到4的最短路径共1条，长度为7，经过点3，顶点1到4的最短路径共1条，但不经过点3。<br>故f(3)&#x3D;D 12 ∗1+D 24 ∗1+D 14 ∗0+D 21 ∗1+D 42 ∗1+D 41 ∗0&#x3D;8+7+0+8+7+0&#x3D;30.000</p>
<p>提示:<br>若顶点a到顶点b有x条路径，点b到点c有y条路径，则a经过b到达c的路径有x*y条。</p>
<p>代码长度限制<br>16 KB<br>时间限制<br>50 ms<br>内存限制<br>64 MB<br>栈限制<br>8192 KB</p>
<hr>
<p>该程序的本质要求需要所有点到其余点的最短路径，以计算得出所谓的“影响力”。那么就有迪杰斯特拉算法和Floyd算法给选择。通常来说，点少边多适合Floyd，点多边少适合迪杰斯特拉算法。</p>
<p>陆爻齐在本题采用Floyd算法，得出所有的最短路径，然后遍历所有路径来统计影响力即可。</p>
<hr>
<h1 id="第二次上机"><a href="#第二次上机" class="headerlink" title="第二次上机"></a>第二次上机</h1><hr>
<h2 id="A-手撕STL-sort（基础版）"><a href="#A-手撕STL-sort（基础版）" class="headerlink" title="A 手撕STL sort（基础版）"></a>A 手撕STL sort（基础版）</h2><p>分数 40<br>作者 朱允刚<br>单位 吉林大学<br>C++ STL是Standard Template Library的简称，即标准模板库。简单来说，STL将常用的数据结构与算法进行了封装，用户需要时可以直接调用，不用重新开发。排序算法sort( )是STL包含的一个重要算法。</p>
<p>STL中的sort()函数基于快速排序算法实现，众所众知，快速排序是目前已知平均情况下最快的排序算法，被IEEE评选为20世纪十大算法之一，但其最坏情况下时间复杂度会退化为O(n 2 )。STL中的sort()对传统快速排序做了巧妙的改进，使其最坏情况下时间复杂度也能维持在O(nlogn)，它是如何实现的呢？</p>
<p>（1）快速排序算法最坏情况下时间复杂度退化为O(n 2 )的主要原因是，每次划分（Partition）操作时，都分在子数组的最边上，导致递归深度恶化为O(n)层。而STL的sort()在Partition操作有恶化倾向时，能够自我侦测，转而改为堆排序，使效率维持在堆排序的O(nlogn)。其具体方法是：侦测快速排序的递归深度，当递归深度达到⌊2log 2 n⌋&#x3D;O(logn)层时，强行停止递归，转而对当前处理的子数组进行堆排序。</p>
<p>（2）此外，传统的快速排序在数据量很小时，为极小的子数组产生许多的递归调用，得不偿失。为此，STL的sort()进行了优化，在小数据量的情况下改用插入排序。具体做法是：当递归处理的子数组长度（子数组包含的元素个数）小于等于某个阈值threshold 时，停止处理并退出本层递归，使当前子数组停留在“接近排序但尚未完成”的状态，最后待所有递归都退出后，再对整个序列进行一次插入排序（注意不是对当前处理的子数组进行插入排序，而是在快速排序的所有递归完全退出后，对整个数组统一进行一次插入排序）。实验表明，此种策略有着良好的效率，因为插入排序在面对“接近有序”的序列时拥有良好的性能。</p>
<p>在本题中，请你按照上述思路，自己实现STL的sort()函数。</p>
<p>备注：Partition操作选取第1个元素作为基准元素。Partition操作的不同实现可能导致不同的输出结果，为保证输出结果唯一，该操作的实现请以教材为准，即Hoare提出快速排序算法时最早给出的Partition实现</p>
<p>函数接口定义：<br>void sort(int *R, int n);<br>功能为对整数R[1]…R[n]递增排序。</p>
<p>裁判测试程序样例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int threshold;</span><br><span class="line"></span><br><span class="line">//请在这里补充你的代码，即你所实现的sort函数</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,i;</span><br><span class="line">    int a[50010];</span><br><span class="line">    scanf(&quot;%d %d&quot;, &amp;n, &amp;threshold);</span><br><span class="line">    for (i = 1; i &lt;= n; i++)</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    sort(a,n);</span><br><span class="line">    </span><br><span class="line">    printf(&quot;Final:&quot;);</span><br><span class="line">    for (i = 1; i &lt;= n; i++)</span><br><span class="line">        printf(&quot;%d &quot;,a[i]);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>备注：提交代码时，只需提交sort函数以及你自定义的其他函数，不用提交#include或者main函数等内容。</p>
<p>输入格式:<br>输入第一行为2个正整数n和threshold，n为待排序的元素个数，不超过50000，threshold为改用插入排序的阈值，不超过20，含义如上所述。第二行为n个空格间隔的整数。本题中读入数据的操作无需你来实现，而由框架程序完成。</p>
<p>输出格式:<br>输出第一行为以depth_limit:开头的整数，表示转为堆排序的递归深度，即⌊2log 2 n⌋。从第二行开始，输出对某子数组转为堆排序后，该子数组初始建堆的结果，每个元素后一个空格，每个堆占一行，以Heap:开头。注意，可能不止一个堆。接下来下一行，输出n个整数，每个整数后一个空格，为快速排序所有递归退出后，插入排序执行前的数组元素，以Intermediate:开头。最后一行为n整数，每个整数后一个空格，表示排序后的数组，以Final:开头（最后一行由框架程序完成，无需你来输出）。</p>
<p>输入样例1：<br>10 2<br>10 9 8 7 6 5 4 3 2 1</p>
<p>输出样例1：<br>depth_limit:6<br>Heap:7 6 5 4<br>Intermediate:1 2 3 4 5 6 7 8 9 10<br>Final:1 2 3 4 5 6 7 8 9 10 </p>
<p>输入样例2：<br>60 2<br>66 61 92 22 50 80 39 2 25 60 49 17 37 19 24 57 40 82 11 52 45 0 33 78 32 25 19 42 92 50 39 87 74 87 56 79 63 63 80 83 50 3 87 2 91 77 87 10 59 23 25 6 49 85 9 95 60 16 28 1 </p>
<p>输出样例2：<br>depth_limit:11<br>Heap:24 19 23 19 17 22<br>Intermediate:1 0 2 2 3 6 10 9 11 16 17 19 19 22 23 24 25 25 25 28 32 33 37 39 39 42 40 45 49 49 50 50 50 52 56 57 59 60 60 61 63 63 66 77 74 78 79 80 80 82 83 85 87 87 87 87 91 92 92 95<br>Final:0 1 2 2 3 6 9 10 11 16 17 19 19 22 23 24 25 25 25 28 32 33 37 39 39 40 42 45 49 49 50 50 50 52 56 57 59 60 60 61 63 63 66 74 77 78 79 80 80 82 83 85 87 87 87 87 91 92 92 95 </p>
<p>代码长度限制<br>16 KB<br>时间限制<br>100 ms<br>内存限制<br>64 MB</p>
<hr>
<p>这题思维上并无难点，堆排序，插入排序，快速排序都是基础要掌握的排序方式，但由于要检查一些中间输出，会限定得很死。</p>
<p>简要说下陆爻齐程序的大致思路好了，排序大体分两块，快排和插排，毕竟堆排是在快排中可能进入的，插排是快排完成后才开始的。快排的每层都会检测深度是否足够转化为堆排或是否要退出等待插排。至于快排的细节，如题所说，以教材相关内容为准吧，是在不行再看看老师ppt</p>
<hr>
<h2 id="B-排序"><a href="#B-排序" class="headerlink" title="B 排序"></a>B 排序</h2><p>分数 10<br>作者 朱允刚<br>单位 吉林大学<br>请编写程序对不超过50000个整数递增排序。<br>备注：本题不允许使用STL sort()或qsort()等现成的排序库函数。</p>
<p>输入格式:<br>输入第一行一个正整数n，表示待排序的元素个数。第二行为n个整数，表示待排序的元素。n不超过50000。</p>
<p>输出格式:<br>输出为一行，表示排序结果，每个整数后一个空格。</p>
<p>输入样例:<br>5<br>5 4 3 2 1</p>
<p>输出样例:<br>1 2 3 4 5 </p>
<p>代码长度限制<br>16 KB<br>时间限制<br>5000 ms<br>内存限制<br>64 MB<br>栈限制<br>8192 KB</p>
<hr>
<p>时间上限制很松，冒泡应该也行，其实把上道题写好的排序拉下来也行。</p>
<hr>
<h2 id="C-智能提示"><a href="#C-智能提示" class="headerlink" title="C 智能提示"></a>C 智能提示</h2><p>分数 30<br>作者 朱允刚<br>单位 吉林大学<br>百度、谷歌等搜索引擎，以及输入法等各种软件通常包含这样一个功能，当用户在输入框输入信息时，软件会提供一种“智能提示”。对用户所输入的信息，自动补全、列出可能的完整单词，提示给用户，以方便用户输入，提升用户体验。</p>
<p>pic.jpg</p>
<p>这个功能是如何实现的呢？一种典型的实现方式是，在系统后台维护一个字典，当用户输入字符时，在字典中查找以用户当前输入的字符串为前缀的全部单词，选取其中历史使用率最高的若干单词作为候选词，建议给用户。</p>
<p>请编写程序实现上述功能。</p>
<p>备注：这里约定一个字符串不能称为自己的前缀。若用户输入的字符串恰好是字典中的一个单词，则该单词不必向用户建议。</p>
<p>输入格式:<br>输入第一行为3个正整数n、m、k。n为字典中单词个数。m为用户查询数，即用户输入的单词个数。对于用户输入的每个字符串，程序需要返回字典中以该字符串为前缀的、历史使用频率最高的k个单词。接下来n行，表示字典信息，每行为1个整数和1个字符串，整数表示单词的历史使用频率，字符串表示单词，请注意，单词包含的每个字符为a-z的小写字母或0-9的数字，即数字也可能构成字典中的单词。字典内的单词并非按使用频率有序存放。接下来m行，表示用户的查询，每行为一个a-z的小写字母或0-9的数字组成的字符串，表示用户的查询。另外请注意，由于字典往往是在用户历史数据的基础上加工而得，所以字典中可能出现重复单词，若某个单词在字典中出现多次，则其历史使用频率以最高者为准。 (n ≤ 10000, m ≤ 20000, k ≤ 10, 每个单词长度不超过20，单词历史使用频率小于2<br>31<br> )</p>
<p>输出格式:<br>对于用户输入的每个字符串，按使用频率降序输出字典中以该字符串为前缀的、历史使用频率最高的k个单词，每个占1行。若多个单词历史使用频率相同，则字典序靠前的单词排名靠前。若单词中包含数字，则字典序以ACSII码判定，即0&lt;1&lt;2&lt;…&lt;9&lt;a&lt;b&lt;c&lt;…&lt;z。若字典中满足输出条件的单词个数大于0小于k，则有多少就输出多少个。若字典中没有满足输出条件的单词，则输出“no suggestion”。针对用户每个查询所输出的信息，用空行间隔。</p>
<p>输入样例:<br>20 3 4<br>1827187200	the<br>1595609600	to<br>1107331800	that<br>401542500	this<br>334039800	they<br>282026500	their<br>250991700	them<br>196118888	these<br>150877900	than<br>144968100	time<br>125563600	then<br>109336600	two<br>196120000	there<br>87862100	those<br>79292500	through<br>75885600	the<br>71578000	think<br>67462300	2<br>65648600	tx356<br>57087700	though<br>th<br>xxx<br>the<br>输出样例:<br>the<br>that<br>this<br>they</p>
<p>no suggestion</p>
<p>they<br>their<br>them<br>there</p>
<p>代码长度限制<br>16 KB<br>时间限制<br>800 ms<br>内存限制<br>64 MB<br>栈限制<br>8192 KB</p>
<h2 id="D-智能提示（时间限制更严格）"><a href="#D-智能提示（时间限制更严格）" class="headerlink" title="D 智能提示（时间限制更严格）"></a>D 智能提示（时间限制更严格）</h2><p>分数 20<br>作者 朱允刚<br>单位 吉林大学<br>题目内容与前一题完全一致，但时间限制更为严格，若上题程序效率足够高，可直接将代码提交至本题。</p>
<p>备注：本题的测试点其实就是上一题的测试点4、5。如果上一题测试点4、5能在60ms内通过，本题就可以通过了。</p>
<p>输入格式:<br>与前一题相同。</p>
<p>输出格式:<br>与前一题相同。</p>
<p>输入样例:<br>与前一题相同。<br>输出样例:<br>与前一题相同。<br>代码长度限制<br>16 KB<br>时间限制<br>60 ms<br>内存限制<br>64 MB<br>栈限制<br>8192 KB</p>
<hr>
<p>CD两题一起讲，毕竟D就是C更严格时间限制罢了。</p>
<p>该题实际上是想学生建立字典树，并做一点改良，先从字典树简单说说好了，就如同此前的树一般，只不过树里面存的是单个字母，从树的根，也就是最“上面”的顶点往“下”走到叶子节点，途径字母组成单词，这便是字典树。</p>
<p>只要建立了字典树，并输出指定节点的所有叶子节点，就算是解决了C题。</p>
<p>那么如何解决D题呢？两个思路</p>
<p>其一是减少输入输出所消耗的时间，常用C++打OI的同学可能疑惑，已经给cin、cout加速了，还要继续优化吗？要的，陆爻齐最后用了scanf和printf才过，所以要把所有cout换printf和cin换scanf；</p>
<p>其二是优化中间步骤，其实我们细想下，在字典树的建立，查找对应点和搜寻点对应所有叶子节点哪个最复杂、很可能消耗最多时间呢？当然是搜寻叶子节点，毕竟同样的单词前缀，可对应的单词几乎无穷无尽。但其实，如果在建立字典树的时候，我们就把一个单词放进节点里，最后直接从该节点读取词，岂不美哉</p>
<p>有同学读完并实践完上述两点，发现还不够，就来说：陆爻齐，你骗人，还不行。确实，还差点，最后一点在于每个节点所存储的词可能太多了，要找出10个历史频率最高，同历史频率，字典序最低的词，还需要在每次把词放节点里时做下排序。这里可以用sort排序配合自己写的比较函数，这部分内容不会建议google一下或者bing一下。</p>
<hr>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>数据结构课程设计的前两次上机主要考察了图、排序和字典树，字典树的这两题很有趣，除了比较费时间、费精力、费脑子外挺好的：）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/03/[JLU]%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF%E5%88%86%E4%BA%AB-%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%B8%8E%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%B8%8A%E6%9C%BA%20%E5%90%89%E6%9E%97%E5%A4%A7%E5%AD%A6/" data-id="cm7j3jec8000t10agb1rt9ojs" data-title="【JLU】 数据结构与算法上机题解思路分享-课程设计第一次与第二次上机 吉林大学" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JLU/" rel="tag">JLU</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag">数据结构与算法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-[JLU] 数据结构与算法上机题解思路分享-第三次上机 吉林大学" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/02/%5BJLU%5D%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF%E5%88%86%E4%BA%AB-%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%B8%8A%E6%9C%BA%20%E5%90%89%E6%9E%97%E5%A4%A7%E5%AD%A6/" class="article-date">
  <time class="dt-published" datetime="2024-07-02T15:27:00.000Z" itemprop="datePublished">2024-07-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/07/02/%5BJLU%5D%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF%E5%88%86%E4%BA%AB-%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%B8%8A%E6%9C%BA%20%E5%90%89%E6%9E%97%E5%A4%A7%E5%AD%A6/">【JLU】 数据结构与算法上机题解思路分享-第三次上机 吉林大学</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>首先</strong>，请务必自己尽全力尝试实现题目，直接看成品代码，思维就被拘束了，也很容易被查重。</p>
<p>这里只是思路解析的博客，代码仓库在 <a target="_blank" rel="noopener" href="https://github.com/HSLix/JLU_Data_Structures_Record.git">JLU_Data_Structures_Record</a></p>
<p>希望你能在这里找到你想要的:)</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="A-图的创建"><a href="#A-图的创建" class="headerlink" title="A 图的创建"></a>A 图的创建</h2><p>分数 10<br>作者 朱允刚<br>单位 吉林大学<br>请编写程序创建一个有向图。有向图中包含n个顶点，编号为0至n-1。</p>
<p>输入格式:<br>输入第一行为两个正整数n和e，分别表示图的顶点数和边数，其中n不超过20000，e不超过20000。接下来e行表示每条边的信息，每行为3个非负整数a、b、c，其中a和b表示该边的端点编号，c表示权值。各边并非按端点编号顺序排列。</p>
<p>输出格式:<br>按顶点编号递增顺序输出每个顶点引出的边，每个顶点占一行，若某顶点没有引出边，则不输出。每行表示一个顶点引出的所有边，格式为a:(a,b,w)……，表示有向边a-&gt;b的权值为w，a引出的多条边按编号b的递增序排列。</p>
<p>输入样例:<br>7 7<br>0 1 5<br>0 3 7<br>0 6 6<br>1 2 4<br>2 5 1<br>3 5 3<br>6 5 4</p>
<p>输出样例:<br>0:(0,1,5)(0,3,7)(0,6,6)<br>1:(1,2,4)<br>2:(2,5,1)<br>3:(3,5,3)<br>6:(6,5,4)</p>
<p>代码长度限制<br>16 KB<br>时间限制<br>500 ms<br>内存限制<br>20 MB</p>
<hr>
<p>该题只是图的创建，众所周知，图可以用邻接矩阵或邻接链表实现，这里采用了邻接链表，只要记录边和权值即可。</p>
<hr>
<h2 id="B-图的删边操作"><a href="#B-图的删边操作" class="headerlink" title="B 图的删边操作"></a>B 图的删边操作</h2><p>分数 10<br>作者 朱允刚<br>单位 吉林大学<br>请编写程序对给定的有向图删除若干条边。有向图中包含n个顶点，编号为0至n-1。</p>
<p>输入格式:<br>输入第一行为两个正整数n和e，分别表示图的顶点数和边数，其中n不超过20000，e不超过1000。接下来e行表示每条边的信息，每行为3个非负整数a、b、c，其中a和b表示该边的端点编号，c表示权值。各边并非按端点编号顺序排列。随后一行为一个整数k，表示删除的边的条数，接下来k行，每行为2个非负整数a、b，表示待删除的边为a-&gt;b。保证删除的边一定在原图中。</p>
<p>输出格式:<br>输出执行删边操作之后的图。每行表示一个顶点引出的所有边，格式为a:(a,b,w)……，表示有向边a-&gt;b的权值为w，a引出的多条边按编号b的递增序排列。若某顶点没有引出边，则不输出。</p>
<p>输入样例:<br>7 7<br>0 1 5<br>0 3 7<br>0 6 6<br>1 2 4<br>2 5 1<br>3 5 3<br>6 5 4<br>2<br>2 5<br>0 1</p>
<p>输出样例:<br>0:(0,3,7)(0,6,6)<br>1:(1,2,4)<br>3:(3,5,3)<br>6:(6,5,4)</p>
<p>代码长度限制<br>16 KB<br>时间限制<br>200 ms<br>内存限制<br>64 MB</p>
<hr>
<p>图的创建同上图，这里的删边如果是邻接链表注意要删除时，确保不要一删就删了多个就行</p>
<hr>
<h2 id="C-图深度优先遍历"><a href="#C-图深度优先遍历" class="headerlink" title="C 图深度优先遍历"></a>C 图深度优先遍历</h2><p>分数 10<br>作者 朱允刚<br>单位 吉林大学<br>编写程序对给定的有向图（不一定连通）进行深度优先遍历，图中包含n个顶点，编号为0至n-1。本题限定在深度优先遍历过程中，如果同时出现多个待访问的顶点，则优先选择编号最小的一个进行访问，以顶点0为遍历起点。</p>
<p>输入格式:<br>输入第一行为两个整数n和e，分别表示图的顶点数和边数，其中n不超过20000，e不超过50。接下来e行表示每条边的信息，每行为两个整数a、b，表示该边的端点编号，但各边并非按端点编号顺序排列。</p>
<p>输出格式:<br>输出为一行整数，每个整数后一个空格，即该有向图的深度优先遍历结点序列。</p>
<p>输入样例1:<br>3 3<br>0 1<br>1 2<br>0 2<br>输出样例1:<br>0 1 2<br>输入样例2:<br>4 4<br>0 2<br>0 1<br>1 2<br>3 0<br>输出样例2:<br>0 1 2 3<br>代码长度限制<br>16 KB<br>时间限制<br>50 ms<br>内存限制<br>64 MB</p>
<hr>
<p>创建图后，进行DFS就行了，没啥讲的</p>
<p>要不简单讲下DFS或BFS好了，就是从一个点入手，搜寻该点所连的所有点并加入数组中，无论栈或队列，记录然后提出一点，继续搜寻，加入记录，往复至无点可寻。</p>
<p>嘛，突然想起，如果前这几道题都用邻接矩阵，或许实现就简单很多了</p>
<hr>
<h2 id="D-单源最短路径"><a href="#D-单源最短路径" class="headerlink" title="D 单源最短路径"></a>D 单源最短路径</h2><p>分数 30<br>作者 朱允刚<br>单位 吉林大学<br>请编写程序求给定正权有向图的单源最短路径长度。图中包含n个顶点，编号为0至n-1，以顶点0作为源点。</p>
<p>输入格式:<br>输入第一行为两个正整数n和e，分别表示图的顶点数和边数，其中n不超过20000，e不超过1000。接下来e行表示每条边的信息，每行为3个非负整数a、b、c，其中a和b表示该边的端点编号，c表示权值。各边并非按端点编号顺序排列。</p>
<p>输出格式:<br>输出为一行整数，为按顶点编号顺序排列的源点0到各顶点的最短路径长度（不含源点到源点），每个整数后一个空格。如源点到某顶点无最短路径，则不输出该条路径长度。</p>
<p>输入样例:<br>4 4<br>0 1 1<br>0 3 1<br>1 3 1<br>2 0 1<br>输出样例:<br>1 1<br>代码长度限制<br>16 KB<br>时间限制<br>100 ms<br>内存限制<br>20 MB</p>
<hr>
<p>就是迪杰斯特拉算法的使用，没有什么可以引申的</p>
<hr>
<h2 id="E-双十一"><a href="#E-双十一" class="headerlink" title="E 双十一"></a>E 双十一</h2><p>分数 20<br>作者 朱允刚<br>单位 吉林大学<br>双十一期间，某著名电商平台“东东”为应对销售高峰，准备在n个城市中再增加一个自营仓库，其要求是该仓库设在n个城市中的某个城市，且距离其他所有城市的最短距离之和最小。请编写程序帮助“东东”找出设立仓库的地点。假定n个城市编号为0至n-1，它们之间至少有一个城市与其他所有城市可及。</p>
<p>输入格式:<br>输入包含多组数据。每组数据第一行为两个正整数n和e，均不超过100。n表示城市数。接下来e行表示两个城市间的距离信息，每行为3个非负整数a、b、c，其中a和b表示两个城市编号，c表示城市间的距离。</p>
<p>提示：可使用EOF判断输入结束。</p>
<p>输出格式:<br>输出为一个整数，表示建立仓库的城市编号，如多个城市满足要求，则输出编号最小者。</p>
<p>输入样例:<br>6 5<br>0 1 1<br>0 2 1<br>0 3 1<br>0 4 1<br>0 5 1<br>4 5<br>0 1 1<br>0 2 5<br>1 2 2<br>1 3 4<br>2 3 1</p>
<p>输出样例:<br>0<br>1</p>
<p>代码长度限制<br>16 KB<br>时间限制<br>50 ms<br>内存限制<br>64 MB</p>
<hr>
<p>该题的本质是找到一个到其它点距离之和最小的点，理所当然地应该使用Prim算法，求出各个点到其它所有点距离之和最短。</p>
<hr>
<h2 id="F-任务拓扑排序"><a href="#F-任务拓扑排序" class="headerlink" title="F 任务拓扑排序"></a>F 任务拓扑排序</h2><p>分数 30<br>作者 朱允刚<br>单位 吉林大学<br>一个工程被分解成n个子任务，编号为0至n-1。要完成整个工程需要完成所有的子任务。其中一些子任务必须先于另外一些子任务被完成。给定各子任务之间的先后关系，请编写程序给出一个合理的任务完成顺序，若工程不可行，程序亦能识别。</p>
<p>输入格式:<br>输入第一行为两个整数n和e，均不超过100。n表示子任务数。接下来e行，表示已知的两个子任务间的先后关系，每行为两个整数a和b，表示任务a必须先于任务b完成。</p>
<p>输出格式:<br>若工程不可行（一些子任务以自己为先决条件），输出“unworkable project”；若工程可行，输出为1行整数，每个整数后一个空格，为n个子任务的编号，表示子任务的完成顺序，如果有多种可能的顺序，则输出字典序最小者。</p>
<p>注：字典序，即对象在字典中的顺序。对于两个数字序列，从第一个数字开始比较，当某一个位置的数字不同时，该位置数字较小的序列，字典序较小，例如1 2 3 9比1 2 4 5小，1 2 8 9比1 2 10 3小。</p>
<p>输入样例1:<br>3 2<br>0 1<br>1 2<br>输出样例1:<br>0 1 2<br>输入样例2:<br>3 3<br>0 1<br>1 2<br>2 0<br>输出样例2:<br>unworkable project<br>代码长度限制<br>16 KB<br>时间限制<br>50 ms<br>内存限制<br>64 MB</p>
<hr>
<p>拓扑排序，内容也是书上有的，简单说，就是从没有指着的点开始，把这个点弹出，并把点所连的点被连的标记数–，然后再从标记数0的点挑个点重复过程。</p>
<p>还有个字典序，无论字母、数字，是不是从前往后一个个比较，比如返回a &lt; b，true则a字典序比b小。</p>
<hr>
<h2 id="G-关键路径"><a href="#G-关键路径" class="headerlink" title="G 关键路径"></a>G 关键路径</h2><p>分数 30<br>作者 朱允刚<br>单位 吉林大学<br>假定一个工程由若干子任务构成，使用一个包含n个顶点、e条边的AOE网表示该工程，顶点编号为1至n，有向边表示该工程的每个子任务，边的权值表示完成该子任务所需的时间，假定网中只含一个源点和一个汇点。请编写程序求出该工程的所有关键活动，并计算完成该工程所需的最短时间。</p>
<p>输入格式:<br>每个测试点包含多组测试数据。每组数据第一行为2个整数n和e，均不超过200，分别表示AOE网的顶点数和边数。接下来e行表示每条边的信息，每行为3个正整数a、b、c，其中a和b表示该边的端点编号，c表示权值。各边并不一定按端点编号顺序排列，且各顶点并不一定按拓扑序排列。</p>
<p>输出格式:<br>对每组数据，若工程不可行（AOE网中存在环），输出“unworkable project”；若工程可行，则输出第一行为完成工程所需的最短时间，并从第2行开始输出关键活动，每个关键活动占一行，格式为i-&gt;j，其中i和j表示关键活动所在边的端点编号。各关键活动输出顺序为：按i的递增顺序输出，若多个关键活动的i值相同，则按j的递增顺序输出。</p>
<p>输入样例:<br>4 4<br>1 2 6<br>1 3 4<br>2 4 1<br>3 4 1</p>
<p>输出样例:<br>7<br>1-&gt;2<br>2-&gt;4</p>
<p>代码长度限制<br>16 KB<br>时间限制<br>100 ms<br>内存限制<br>64 MB</p>
<hr>
<p>简单的说，是计算最早完成时间与最晚完成时间相等的点，输出即可。</p>
<p>回头来看，这就是动态规划啊</p>
<hr>
<h2 id="H-联盟数目"><a href="#H-联盟数目" class="headerlink" title="H 联盟数目"></a>H 联盟数目</h2><p>分数 20<br>作者 朱允刚<br>单位 吉林大学<br>艾迪是一家集团公司的老板，该集团包含n家公司，为了管理公司，艾迪会时常通过网络向各公司发送消息。各公司间的网络是单向的，每个公司都有一个分发列表，表示其能向哪些公司直接传达消息。例如A公司的分发列表为B、C，表示A可将消息直接传送给B和C（由于网络是单向的，B或C不一定能向A传送消息），这样艾迪若想向A、B、C公司发送消息，则只需向A发送消息即可，随后A可将消息传送到B和C。</p>
<p>为了便于管理各公司，艾迪打算将n家公司分成若干组，每组称为一个区域联盟，每组满足如下条件：组内的任意公司消息互相可达。即对于组内任意公司u和v，u可将消息传送到v（可由u直接传送到v，也可通过组内其他公司中转传送到v），v也可将消息传送到u。可以认为一个公司可以将消息传送给自己，即一个公司可以自成一组。</p>
<p>艾迪希望组的数量尽可能少，即在满足上述条件的情况下，每组包含的公司数目尽可能多。</p>
<p>现给定每个公司的分发列表，请编写程序告知艾迪，他的集团最少能分成多少组。</p>
<p>输入格式:<br>第一行包含一个整数T (1≤T≤100)表示数据组数。对于每组数据，第一行为一个整数n (2≤n≤100)，表示公司数目，公司编号为1到n。随后n行，第i行包含若干整数，表示第i个公司的分发列表，每行以0结尾。</p>
<p>输出格式:<br>对于每组数据，输出一行，为一个整数，表示组数。</p>
<p>输入样例:<br>3<br>5<br>2 4 3 0<br>4 5 0<br>0<br>0<br>1 0<br>3<br>2 0<br>0<br>2 1 0<br>3<br>2 0<br>3 0<br>0</p>
<p>输出样例:<br>3<br>3<br>3</p>
<p>代码长度限制<br>16 KB<br>时间限制<br>100 ms<br>内存限制<br>64 MB</p>
<hr>
<p>这个点相对前面比较偏，实际上是要找到尽可能大的连通组，采用WarShall算法，找到各个组的最大闭包。</p>
<hr>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本次上机简答考察了图的基本使用，创建、遍历、删除等，然后又加了点场景考察迪杰斯特拉算法和普利姆算法，最后搞了应该比较难反应过来的WarShall算法，算是把书上的内容过了一遍力，加油罢</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/02/[JLU]%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF%E5%88%86%E4%BA%AB-%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%B8%8A%E6%9C%BA%20%E5%90%89%E6%9E%97%E5%A4%A7%E5%AD%A6/" data-id="cm7j3jec6000l10agc6ofcvi8" data-title="【JLU】 数据结构与算法上机题解思路分享-第三次上机 吉林大学" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JLU/" rel="tag">JLU</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag">数据结构与算法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-[JLU] 数据结构与算法上机题解思路分享-第二次上机 吉林大学" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/01/%5BJLU%5D%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF%E5%88%86%E4%BA%AB-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%B8%8A%E6%9C%BA%20%E5%90%89%E6%9E%97%E5%A4%A7%E5%AD%A6/" class="article-date">
  <time class="dt-published" datetime="2024-07-01T14:05:00.000Z" itemprop="datePublished">2024-07-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/07/01/%5BJLU%5D%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF%E5%88%86%E4%BA%AB-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%B8%8A%E6%9C%BA%20%E5%90%89%E6%9E%97%E5%A4%A7%E5%AD%A6/">【JLU】 数据结构与算法上机题解思路分享-第二次上机 吉林大学</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>首先</strong>，请务必自己尽全力尝试实现题目，直接看成品代码，思维就被拘束了，也很容易被查重。</p>
<p>这里只是思路解析的博客，代码仓库在 <a target="_blank" rel="noopener" href="https://github.com/HSLix/JLU_Data_Structures_Record.git">JLU_Data_Structures_Record</a></p>
<p>希望你能在这里找到你想要的:)</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><hr>
<h2 id="A-二叉树的创建与遍历"><a href="#A-二叉树的创建与遍历" class="headerlink" title="A 二叉树的创建与遍历"></a>A 二叉树的创建与遍历</h2><p>分数 10<br>作者 朱允刚<br>单位 吉林大学<br>通过带空指针信息的先根序列（亦称先序序列）创建二叉树，并进行先根（先序）、中根（中序）、后根（后序）遍历。二叉树结点数据域值为不等于0的整数（可能是正数也可能是负数），空指针用0表示，例如1 5 8 0 0 0 6 0 0表示如下图的二叉树。</p>
<p>输入格式:<br>输入为一组用空格间隔的整数，表示带空指针信息的二叉树先根序列。其中空指针信息用0表示。二叉树结点个数不超过150000，高度不超过6000。输入数据保证二叉树各结点数据值互不相等。</p>
<p>输出格式:<br>输出为3行整数，每个整数后一个空格。第1行为该二叉树的先根序列，第2行为中根序列，第3行为后根序列。</p>
<p>输入样例:<br>1 5 8 0 0 0 6 0 0<br>输出样例:<br>1 5 8 6<br>8 5 1 6<br>8 5 6 1<br>代码长度限制<br>16 KB<br>时间限制<br>200 ms<br>内存限制<br>20 MB</p>
<hr>
<p>这道题没什么好解析的，从先根序列造二叉树，可以采用递归的方法，0则结束，否则就以该值创节点，并进入左节点的函数和右节点的函数。</p>
<hr>
<h2 id="B-二叉树查找结点及父结点"><a href="#B-二叉树查找结点及父结点" class="headerlink" title="B 二叉树查找结点及父结点"></a>B 二叉树查找结点及父结点</h2><p>分数 10<br>作者 朱允刚<br>单位 吉林大学<br>编写程序在二叉树中查找给定结点及父结点。二叉树结点的数据域值不等于0的整数。</p>
<p>输入格式:<br>输入第1行为一组用空格间隔的整数，表示带空指针信息的二叉树先根序列，其中空指针用0表示。例如1 5 8 0 0 0 6 0 0表示如下图的二叉树。第2行为整数m，表示查询个数。接下来m行，每行为一个不等于0的整数K，表示要查找的结点的数据值。m不超过100，二叉树结点个数不超过150000，高度不超过6000。输入数据保证二叉树各结点数据值互不相等。</p>
<p>输出格式:<br>输出为m行，每行1个整数，表示被查找结点K的父结点数据值，若二叉树中无结点K或结点K无父结点，则输出0。</p>
<p>输入样例:<br>1 5 8 0 0 0 6 0 0<br>3<br>8<br>1<br>6<br>输出样例:<br>5<br>0<br>1<br>代码长度限制<br>16 KB<br>时间限制<br>300 ms<br>内存限制<br>20 MB</p>
<hr>
<p>造树的函数可以复用上一题，本体考察的查找，更没有啥可以说的，你可以任选先、中、后三种顺序都可以</p>
<hr>
<h2 id="C-二叉树删除子树"><a href="#C-二叉树删除子树" class="headerlink" title="C 二叉树删除子树"></a>C 二叉树删除子树</h2><p>分数 10<br>作者 朱允刚<br>单位 吉林大学<br>编写程序对给定二叉树执行若干次删除子树操作，输出每次删除子树后剩余二叉树的中根序列。二叉树结点的数据域值为不等于0的整数。每次删除操作是在上一次删除操作后剩下的二叉树上执行。</p>
<p>输入格式:<br>输入第1行为一组用空格间隔的整数，表示带空指针信息的二叉树先根序列，其中空指针信息用0表示。例如1 5 8 0 0 0 6 0 0表示如下图的二叉树。第2行为整数m，表示要进行的删除操作次数。接下来m行，每行一个不等于0的整数K，表示要删除以K为根的子树。m不超过100，二叉树结点个数不超过5000。输入数据保证各结点数据值互不相等，且删除子树后二叉树不为空。</p>
<p>输出格式:<br>输出为m行，每行为一组整数，表示执行删除操作后剩余二叉树的中根序列（中根序列中每个整数后一个空格）。若要删除的子树不在当前二叉树中，则该行输出0（0后无空格）。</p>
<p>输入样例:<br>1 5 8 0 0 0 6 0 0<br>3<br>5<br>8<br>6<br>输出样例:<br>1 6<br>0<br>1<br>代码长度限制<br>16 KB<br>时间限制<br>100 ms<br>内存限制<br>10 MB</p>
<hr>
<p>此题可以分解为两部分，第一部分是找到要删的点，第二部分是执行删除。寻找部分就是第二题，那么我们实际上可以专注于如何执行二叉树的删除了。</p>
<p>那么什么是删除呢？可表现为其父节点对应指针为空，那么空间要不要释放呢？随你喜欢，毕竟答案检验是遍历，与内存无关：）所以把父节点对应指针置空即可。</p>
<p>整体的构造是递归，若没找到则向两子树找，找到就删除对应子树，没找到回报个0</p>
<hr>
<h2 id="D-重建二叉树"><a href="#D-重建二叉树" class="headerlink" title="D 重建二叉树"></a>D 重建二叉树</h2><p>分数 30<br>作者 朱允刚<br>单位 吉林大学<br>给定非空二叉树的中根序列和后根序列，请编写程序创建该二叉树，计算其高度和先根序列；如给定的中根和后根序列不合法，则亦能识别。</p>
<p>输入格式:<br>输入包含多组数据（不超过10组），每组为两行字符串，第一行表示某二叉树的后根序列，第二行表示其中根序列。结点的值均为A-Z的大写字母，故二叉树结点个数不超过26，且保证输入的两个序列都是结点的全排列，但不一定是合法的中根和后根序列。输入保证不是空二叉树。</p>
<p>输出格式:<br>对于每组数据，如果输入的序列不合法（不是同一棵树的中根序列和后根序列），则输出INVALID；若输入序列合法，输出为两行，第一行为一个整数，表示该二叉树的高度，第二行为一个字符串，表示该二叉树的先根序列。</p>
<p>输入样例1:<br>CEFDBHGA<br>CBEDFAGH<br>CBEDFAGH<br>CEFDBHGA<br>BCA<br>CAB</p>
<p>输出样例1:<br>3<br>ABCDEFGH<br>INVALID<br>INVALID</p>
<p>代码长度限制<br>16 KB<br>时间限制<br>50 ms<br>内存限制<br>64 MB</p>
<hr>
<p>本题也是书上有的内容此处就简单叙述下要点，中根和后根序列分别给了不同的信息，后根的最后一个表示该树的中点，也就是最上面那个，根据中点就可以从中根序列中找到该树的左子树有什么点，右子树有什么点。</p>
<p>而这样的分割可以不断递归，毕竟一个二叉树的左子树也是二叉树，只要不断地将子树的中后序列分割出来，总有左右子树只剩一点或者无点的情况，然后再不断组装回去，最后就得到了二叉树</p>
<hr>
<h2 id="E-二叉树路径和"><a href="#E-二叉树路径和" class="headerlink" title="E 二叉树路径和"></a>E 二叉树路径和</h2><p>分数 20<br>作者 朱允刚<br>单位 吉林大学<br>编写程序找出二叉树中和最大的路径，二叉树结点为不等于0的整数。本题的“路径”限定为以根结点为起点，以叶结点为终点的路径。路径的和，即该路径所包含的所有结点的数据值之和。</p>
<p>输入格式:<br>输入为一组用空格间隔的整数，个数不超过100个，表示带空指针信息的二叉树先根序列。</p>
<p>输出格式:<br>输出为两行，第一行为该二叉树路径和的最大值，第二行为一组整数，每个整数后一个空格，即该最大路径包含的结点值（按从根的叶的顺序），如果存在多条满足条件路径，则输出最左边一条。</p>
<p>输入样例1:<br>1 2 0 0 3 0 0<br>输出样例1:<br>4<br>1 3<br>输入样例2:<br>-1 2 0 0 3 0 0<br>输出样例2:<br>2<br>-1 3<br>代码长度限制<br>16 KB<br>时间限制<br>50 ms<br>内存限制<br>64 MB</p>
<hr>
<p>像这种寻找一条最优路的方法，基础办法有深度优先算法DFS或广度优先算法BFS。</p>
<p>以DFS为例，大致就是用栈（其实就是一个数组加指针）来记录路径，然后遍历一遍二叉树，以DFS或BFS的方式，到底时与已有路径记录比较，保留更大的</p>
<hr>
<h2 id="F-哈夫曼树编码"><a href="#F-哈夫曼树编码" class="headerlink" title="F 哈夫曼树编码"></a>F 哈夫曼树编码</h2><p>此题不做分享，毕竟陆爻齐也差一个点，没资格说话</p>
<hr>
<h2 id="G-S遍历"><a href="#G-S遍历" class="headerlink" title="G S遍历"></a>G S遍历</h2><p>分数 30<br>作者 朱允刚<br>单位 吉林大学<br>二叉树的“S遍历”定义为从根结点开始，先自右向左遍历，然后下一层自左向右遍历，再下一层自右向左遍历，以此类推…。例如下图所示二叉树的S遍历序列为1 2 3 6 5 4 7 8。现给定一棵非空二叉树，结点数据域值为互不相等且不等于0的正整数，同时给定两个正整数a和b，请编写程序输出结点a和b间的S遍历序列。</p>
<p>555.jpg</p>
<p>输入格式:<br>输入第一行为1组用空格间隔的正整数，表示带空指针信息的二叉树先根序列，二叉树结点个数不超过150000，高度不超过5000。第二行为两个正整数a和b，含义如题目所述，保证a和b一定在二叉树中，且在S遍历序列中a在b的前边。</p>
<p>输出格式:<br>输出为一行整数，每个整数后一个空格，表示数据值为a和b的两个结点间的S遍历序列。</p>
<p>输入样例1:<br>1 2 4 0 0 0 3 5 7 0 0 8 0 0 6 0 0<br>1 8<br>输出样例1:<br>1 2 3 6 5 4 7 8<br>输入样例2:<br>1 2 0 4 0 7 0 0 3 5 0 0 6 8 20 0 0 21 0 0 0<br>6 8<br>输出样例2:<br>6 5 4 7 8<br>输入样例3:<br>1 2 0 3 4 5 0 0 6 0 0 0 7 0 8 9 10 0 0 11 0 0 0<br>1 11<br>输出样例3:<br>1 2 7 8 3 4 9 11<br>输入样例4:<br>2 4 3 0 0 8 0 0 10 5 7 9 0 0 1 0 0 17 0 0 6 0 0<br>2 9<br>输出样例4:<br>2 4 10 6 5 8 3 7 17 1 9<br>数据规模:<br>测试点0-2、5-9：结点个数≤50，树高≤20<br>测试点3：4500≤结点个数≤5500，4000≤树高≤5000<br>测试点4：130000≤结点个数≤150000，10≤树高≤20</p>
<p>代码长度限制<br>16 KB<br>时间限制<br>100 ms<br>内存限制<br>20 MB</p>
<hr>
<p>此题看似是一个十分繁琐的搜索，但其实就是考察对于基本数据结构栈和队列的用法。</p>
<p>陆爻齐采用了栈来解决该问题，也就是用两个栈，分别存储向左和向右遍历时存储的点，然后向左向右分别用不同的顺序把点加进栈，模拟出所谓的S型</p>
<hr>
<h2 id="H-衣服挂游戏"><a href="#H-衣服挂游戏" class="headerlink" title="H 衣服挂游戏"></a>H 衣服挂游戏</h2><p>分数 20<br>作者 朱允刚<br>单位 吉林大学<br>有n个衣服挂，编号为1至n，初始时按顺序挂在一个晾衣杆上，每个衣挂自成一列（即相当于有n列，每列只含一个衣挂）。</p>
<p>1.jpg</p>
<p>爸爸让艾迪做如下操作“x y”，表示将衣挂x所在的列放在衣挂y所在的列下面，即把x所在列的第一个衣挂，挂在y所在列的最下面的衣挂下面，如果x和y已在同一列里，则忽略该操作。例如上图执行操作“3 5”后，得到下图：</p>
<p>2.jpg</p>
<p>再执行操作“3 2”后，得到下图：</p>
<p>3.jpg</p>
<p>爸爸给出一系列指令，请编写程序，输出艾迪完成爸爸的所有操作后，每个衣挂所在的列的第一个衣挂的编号。</p>
<p>输入格式:<br>每个测试点包含多组测试数据，第一行1个整数 T ，表示测试数据组数。对于每组数据，第一行两个整数 n 和 m，分别表示衣挂个数和操作次数。接下来 m 行，每行两个整数x和y，表示爸爸让艾迪执行的一个操作。T≤5，1≤n, m≤30000，1≤x, y≤n。</p>
<p>输出格式:<br>输出为T 行，每行为 n个整数a1 a2 … an ，每个整数后一个空格，ai(1≤i≤n)表示衣挂i所在列的第一个衣挂的编号。</p>
<p>输入样例:<br>2<br>4 2<br>2 1<br>4 3<br>5 4<br>1 2<br>2 3<br>4 5<br>1 3</p>
<p>输出样例:<br>1 1 3 3<br>3 3 3 5 5 </p>
<p>代码长度限制<br>16 KB<br>时间限制<br>80 ms<br>内存限制<br>64 MB</p>
<hr>
<p>该题的本质是考察并查集的创建和使用，像这种很喜欢溯源的，并查集往往都能比较好的解决。</p>
<p>再简单说下陆爻齐认为的并查集吧，并查集往往用数组实现，用下标表示其编号，而存储的数字则为其父亲的编号，也就是父节点的下标。</p>
<p>题中正好n个衣架，编号1-n，正好对应数组，把x挂y上，完全可以把x上的数字改成y；这是x无父节点的情况，若x有父节点，当然先要追溯到其曾曾祖父，把老人家挂y上。</p>
<hr>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这次上机主要考查了二叉树的创建、查找、删除等，还有并查集的使用，利用上机题巩固所学不失为一种好方法：）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/01/[JLU]%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF%E5%88%86%E4%BA%AB-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%B8%8A%E6%9C%BA%20%E5%90%89%E6%9E%97%E5%A4%A7%E5%AD%A6/" data-id="cm7j3jec6000o10aghgyahy21" data-title="【JLU】 数据结构与算法上机题解思路分享-第二次上机 吉林大学" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JLU/" rel="tag">JLU</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag">数据结构与算法</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CINTA/" rel="tag">CINTA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CS61A/" rel="tag">CS61A</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Conda/" rel="tag">Conda</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JLU/" rel="tag">JLU</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%92%AD%E5%AE%A2%E7%AC%94%E8%AE%B0/" rel="tag">播客笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag">数据结构与算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/" rel="tag">方法论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" rel="tag">深度学习</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algorithm/" style="font-size: 20px;">Algorithm</a> <a href="/tags/CINTA/" style="font-size: 10px;">CINTA</a> <a href="/tags/CS61A/" style="font-size: 17.14px;">CS61A</a> <a href="/tags/Conda/" style="font-size: 10px;">Conda</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/JLU/" style="font-size: 15.71px;">JLU</a> <a href="/tags/Python/" style="font-size: 18.57px;">Python</a> <a href="/tags/%E6%92%AD%E5%AE%A2%E7%AC%94%E8%AE%B0/" style="font-size: 11.43px;">播客笔记</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size: 14.29px;">数据结构与算法</a> <a href="/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/" style="font-size: 11.43px;">方法论</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 11.43px;">机器学习</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 12.86px;">杂谈</a> <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">深度学习</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/02/">二月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/01/">一月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/12/">十二月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">十一月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">十月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">九月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">八月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">七月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">六月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">五月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">三月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">二月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">一月 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/02/23/%5BWeekly%20Algorithm%5D%2019%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%9B%BE%E8%AE%BA%EF%BC%88%E4%B8%89%EF%BC%89/">【Weekly Algorithm】算法周记之《代码随想录》图论（三）</a>
          </li>
        
          <li>
            <a href="/2025/02/16/%5BWeekly%20Algorithm%5D%2018%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%9B%BE%E8%AE%BA%EF%BC%88%E4%BA%8C%EF%BC%89/">【Weekly Algorithm】算法周记之《代码随想录》图论（二）</a>
          </li>
        
          <li>
            <a href="/2025/02/09/%5BWeekly%20Algorithm%5D%2017%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8D%95%E8%B0%83%E6%A0%88%E5%92%8C%E5%9B%BE%E8%AE%BA%EF%BC%88%E4%B8%80%EF%BC%89/">【Weekly Algorithm】算法周记之《代码随想录》单调栈和图论（一）</a>
          </li>
        
          <li>
            <a href="/2025/01/19/%5BWeekly%20Algorithm%5D%2016%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%83%EF%BC%89/">【Weekly Algorithm】算法周记之《代码随想录》动态规划（七）</a>
          </li>
        
          <li>
            <a href="/2025/01/12/%5BWeekly%20Algorithm%5D%2015%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E5%85%AD%EF%BC%89/">【Weekly Algorithm】算法周记之《代码随想录》动态规划（六）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 陆爻齐-LuYaoQi<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>【Weekly Algorithm】算法周记之《代码随想录》动态规划（一） | LuYaoQi&#39;s Blogs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="学习小结本周跟随《代码随想录》开始学习动态规划的相关题目，从基础的斐波那契数到爬楼梯，再到 01 背包问题，慢慢熟悉动态规划的五步法。《代码随想录》还提醒，调试重点是检查递推公式是否举例，检查打印 dp 数组是否和自己设想一致。  分析 dp 数组及其下标含义 确定递推公式 确定 dp 数组初始化 确定遍历顺序 举例分析 dp 数组是否如所想迭代  此外除了寻常的二维数组动态规划，也尝试做滚动数组">
<meta property="og:type" content="article">
<meta property="og:title" content="【Weekly Algorithm】算法周记之《代码随想录》动态规划（一）">
<meta property="og:url" content="http://example.com/2024/11/17/[Weekly%20Algorithm]%2010%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89/index.html">
<meta property="og:site_name" content="LuYaoQi&#39;s Blogs">
<meta property="og:description" content="学习小结本周跟随《代码随想录》开始学习动态规划的相关题目，从基础的斐波那契数到爬楼梯，再到 01 背包问题，慢慢熟悉动态规划的五步法。《代码随想录》还提醒，调试重点是检查递推公式是否举例，检查打印 dp 数组是否和自己设想一致。  分析 dp 数组及其下标含义 确定递推公式 确定 dp 数组初始化 确定遍历顺序 举例分析 dp 数组是否如所想迭代  此外除了寻常的二维数组动态规划，也尝试做滚动数组">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/assets/image_1731631111478_0.png">
<meta property="og:image" content="http://example.com/assets/image_1731631134171_0.png">
<meta property="article:published_time" content="2024-11-17T03:50:00.000Z">
<meta property="article:modified_time" content="2025-02-24T13:13:19.967Z">
<meta property="article:author" content="陆爻齐-LuYaoQi">
<meta property="article:tag" content="Algorithm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/assets/image_1731631111478_0.png">
  
    <link rel="alternate" href="/atom.xml" title="LuYaoQi's Blogs" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">LuYaoQi&#39;s Blogs</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Hello my World</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-[Weekly Algorithm] 10算法周记之《代码随想录》动态规划（一）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/17/%5BWeekly%20Algorithm%5D%2010%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2024-11-17T03:50:00.000Z" itemprop="datePublished">2024-11-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      【Weekly Algorithm】算法周记之《代码随想录》动态规划（一）
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h1><p>本周跟随《代码随想录》开始学习动态规划的相关题目，从基础的斐波那契数到爬楼梯，再到 01 背包问题，慢慢熟悉动态规划的五步法。<br>《代码随想录》还提醒，调试重点是检查递推公式是否举例，检查打印 dp 数组是否和自己设想一致。</p>
<ol>
<li>分析 dp 数组及其下标含义</li>
<li>确定递推公式</li>
<li>确定 dp 数组初始化</li>
<li>确定遍历顺序</li>
<li>举例分析 dp 数组是否如所想迭代</li>
</ol>
<p>此外除了寻常的二维数组动态规划，也尝试做滚动数组的练习。</p>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><ul>
<li><h2 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a>斐波那契数</h2></li>
<li><p>题意，给一个数字 n，求斐波那契数中的第 n 个数</p>
</li>
<li><p>方法，虽然就算不看代码随想录也能轻易写出，但简单题的重点在于熟悉套路方法，下面按五步分析</p>
<ol>
<li>确定 dp 数组及其下标含义，这里的 dp[i] 代表斐波那契数中的第 i 个数</li>
<li>确认递推公式，题目给出 <code>dp[i]=dp[i-1]+dp[i-2]</code></li>
<li>dp 数组初始化，题目也给出<code>dp[0]=0;dp[1]=1;</code></li>
<li>确定遍历顺序，从递推公式可见，就是从前向后（0-n）遍历</li>
<li>举例推导 dp 公式，0 1 1 2 3 5 8 13 21 ……</li>
</ol>
</li>
<li><p>陆爻齐的解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int fib(int n) &#123;</span><br><span class="line">        if (n &lt;= 1) return n;</span><br><span class="line">        int dp[n+1]; // dp数组为斐波那契数列的存储</span><br><span class="line">        dp[0] = 0; // 初始化dp数组</span><br><span class="line">        dp[1] = 1;</span><br><span class="line">        for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i-1] + dp[i-2]; // 递推公式</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/description/">70. 爬楼梯 - 力扣（LeetCode）</a></p>
</li>
<li><p>题目，设定你一次能爬 1 或 2 层台阶，给你 n 个台阶，求上去的方式数量</p>
</li>
<li><p>方法，简单举例可见，上第 3 层台阶是根据第 1 层台阶和第 2 层台阶的状态决定的，那么就按五步法</p>
<ol>
<li>确认 dp 数组及其下标含义，这里的 dp[i] 表示上到第 i 个台阶的方法；</li>
<li>确认递推公式，从上面简单举例可见，dp[i]&#x3D;dp[i-1]+dp[i-2];也就是从 i-1 上一阶和 i-2 上两阶，若 i-2 上一阶就到 i-1 而不是 i 了；</li>
<li>dp 数组初始化，由于题目也没说 0 层的初始化，那么直接初始化 dp[1]&#x3D;1;dp[2]&#x3D;2;应当是无异议的；</li>
<li>确认遍历顺序，爬楼梯也是从前往后的  </li>
<li>举例推导 dp 数组， 1 2 3 5 8 13 ……</li>
</ol>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int climbStairs(int n) &#123;</span><br><span class="line">        int dp[n+1]; // 爬到第 i 楼梯的方法数</span><br><span class="line">        if (n &lt;= 2) return n;</span><br><span class="line">        dp[1]=1;</span><br><span class="line">        dp[2]=2;</span><br><span class="line">        for (int i = 3; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i-1] + dp[i-2]; // 递推式</span><br><span class="line">        &#125; </span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="使用最小花费爬楼梯"><a href="#使用最小花费爬楼梯" class="headerlink" title="使用最小花费爬楼梯"></a>使用最小花费爬楼梯</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0746.%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意，类似[[爬楼梯]]，但从一级楼梯向上爬一或二级都会消耗体力值，要求爬到顶的最小花费</p>
</li>
<li><p>方法，五步法</p>
<ol>
<li>确认 dp 数组及其下标含义，dp[i] 是到达第 i 阶的最小体力花费</li>
<li>确认递推公式，dp[i] &#x3D; min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])</li>
<li>确认初始化，由于上第一级或第二级不需要体力值，dp[0]&#x3D;0;dp[1]&#x3D;1;</li>
<li>确定遍历顺序，爬楼梯从前往后</li>
<li>举例，……</li>
</ol>
</li>
<li><p>参考代码随想录思路解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123;</span><br><span class="line">        int dp[cost.size()+1]; // dp[i]到达第i阶所需最小体力</span><br><span class="line">        dp[0] = 0; dp[1] = 0; // 初始化，第一步不用体力</span><br><span class="line">        for (int i = 2; i &lt; cost.size()+1; i++) &#123; // 遍历顺序从前到后</span><br><span class="line">            dp[i] = min(dp[i-2]+cost[i-2], dp[i-1]+cost[i-1]); // 递推公式，可从下两阶上两阶或下一阶上一阶</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[cost.size()];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0062.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/description/">62. 不同路径 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意，有一个 [m][n] 的数组，问题从左上角只能向右或向下移动，右下角有几条路径</p>
</li>
<li><p>方法，五步法</p>
<ol>
<li><p>确认 dp 数组及其下标含义，dp[i][j] 表示到达 i，j 的路径和</p>
</li>
<li><p>确认递推式，由于一个格子可由上或左来，故 dp[i][j] &#x3D; dp[i-1][j]+dp[i][j-1];  </p>
</li>
<li><p>确认初始化，陆爻齐在递推过程中判别了边界，所以只初始化 dp[0][0]&#x3D;1; 不过要是不想在中间做判别，可以把边缘初始化了在递推，即 dp[0][<em>]&#x3D;0;dp[</em>][0]&#x3D;0;（这里的 * 泛指数字）</p>
</li>
<li><p>确认遍历顺序，从上向下，从左向右</p>
</li>
<li><p>举例……</p>
</li>
</ol>
</li>
<li><p>陆爻齐的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePaths(int m, int n) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp = vector(m,vector&lt;int&gt;(n, 0)); // dp[i][j] 代表从左上角到 i，j 的路径数</span><br><span class="line">        dp[0][0] = 1; // 由于递推是取上和左路径和，故得取 1</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123; // 从上往下</span><br><span class="line">            for (int j = 0; j &lt; n; j++) &#123; // 从左往右</span><br><span class="line">                if (i &gt; 0) &#123;</span><br><span class="line">                    dp[i][j] += dp[i-1][j];</span><br><span class="line">                &#125;</span><br><span class="line">                if (j &gt; 0) &#123;</span><br><span class="line">                    dp[i][j] += dp[i][j-1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m-1][n-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>参考滚动数组的改进，即二维数组转一维数组  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePaths(int m, int n) &#123;</span><br><span class="line">        vector&lt;int&gt; dp = vector&lt;int&gt;(n, 0); // dp[j] 代表从左上角第 i 轮循环到 i，j 的路径数</span><br><span class="line">        dp[0] = 1; // 由于递推是取上和左路径和，故得取 1</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123; // 从上往下</span><br><span class="line">            for (int j = 0; j &lt; n; j++) &#123; // 从左往右</span><br><span class="line">                if (j &gt; 0) &#123;</span><br><span class="line">                    dp[j] += dp[j-1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>代码随想录的解法  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePaths(int m, int n) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0));</span><br><span class="line">        for (int i = 0; i &lt; m; i++) dp[i][0] = 1;</span><br><span class="line">        for (int j = 0; j &lt; n; j++) dp[0][j] = 1;</span><br><span class="line">        for (int i = 1; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m - 1][n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="不同路径II"><a href="#不同路径II" class="headerlink" title="不同路径II"></a>不同路径II</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0063.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths-ii/description/">63. 不同路径 II - 力扣（LeetCode）</a></p>
</li>
<li><p>题意，与[[不同路径]]类似，不过数组中可能有障碍物</p>
</li>
<li><p>方法，也类似，不过对于障碍物的那一格，就设置为零</p>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123;</span><br><span class="line">        int m = obstacleGrid.size();</span><br><span class="line">        int n = obstacleGrid[0].size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n,0)); // dp[i][j] 为从 0，0 到 i，j 的路径数和</span><br><span class="line">        </span><br><span class="line">        for (int i = 0; i &lt; m &amp;&amp; obstacleGrid[i][0] == 0; i++) &#123;</span><br><span class="line">            dp[i][0] = 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int j = 0; j &lt; n &amp;&amp; obstacleGrid[0][j] == 0; j++) &#123;</span><br><span class="line">            dp[0][j] = 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; n; j++) &#123;</span><br><span class="line">                if (obstacleGrid[i][j] == 1) continue; // 障碍物处路线为 0</span><br><span class="line">                dp[i][j] += dp[i-1][j] + dp[i][j-1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m-1][n-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a>整数拆分</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0343.%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/integer-break/description/">343. 整数拆分 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意，给一个正整数，求其拆分为多个(大于等于2)正整数的最大乘积</p>
</li>
<li><p>方法，</p>
<ol>
<li>确认 dp[i] 的含义，为对 i 拆分多个正整数的最大乘积</li>
<li>确认递推式，dp[i] &#x3D; max(j * (i-j), j * dp[i-j], dp[i])，一是普通情况，拆分两数，三是原本值，二则是利用历史乘积，为拆分多个值的乘积</li>
<li>确认初始化，dp[0], dp[1] &#x3D; 0, 0; dp[2] &#x3D; 1；起码拆两数</li>
<li>遍历顺序，从前往后，虽然前面这些都是前-&gt;后，不过后面有些就不是了</li>
<li>举例……</li>
</ol>
</li>
<li><p>参考代码随想录思路的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int integerBreak(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(n+1, 0); // dp[i] 表示对 i 拆分后的最大乘积</span><br><span class="line">        dp[0] = 0; dp[1] = 0; // 这两没法拆两正整数</span><br><span class="line">        dp[2] = 1;</span><br><span class="line"></span><br><span class="line">        for (int i = 3; i &lt;= n; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= i/2; j++) &#123;</span><br><span class="line">                // 第一个是拆分为 2 个，第二个是拆分为大于 2 个的情况的乘积</span><br><span class="line">                dp[i] = max(j * (i-j), max(j * dp[i-j], dp[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a>不同的二叉搜索树</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0096.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树 - 力扣（LeetCode）</a></p>
</li>
<li><p>问题，给你数字 n，要求返回 n 个节点能组成的二叉搜索树个数</p>
</li>
<li><p>方法，一开始难以下手，总之先看看例子，n &#x3D; 0时，无节点算一个；n&#x3D;1时，也算一个；n&#x3D;2时，算两个，如下图所示<br><img src="/../assets/image_1731631111478_0.png" alt="image.png"><br>n&#x3D;3时，有五个，如下图所示<br><img src="/../assets/image_1731631134171_0.png" alt="image.png"><br>可见，n &#x3D; 3中，其实可分三类，左边两个为一类，是左子树 0 节点，右子树 2 节点，2 * 1 有 2 种； 中间一类，左子树和右子树各 1 节点，有 1 * 1 共 1 种； 右侧一类，左子树 2 节点，右子树 0 节点，有 2 * 1 共 2 种。一共五种。  </p>
</li>
<li><p>五步法：</p>
<ol>
<li>dp[i] 是 i 个节点组成的二叉搜索树的种类数</li>
<li>递推公式： dp[i] +&#x3D; dp[j-1]*dp[i-j]; 右边 i-1 个点，符合题意，毕竟固定有个点放根，不参与左右子树的方案</li>
<li>初始化，0 个节点二叉搜索树有 1 个，dp[0] &#x3D; 1;</li>
<li>遍历顺序，从前往后</li>
<li>举例 ……</li>
</ol>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numTrees(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(n+1, 0); // dp[i] 是 i 个节点组成的二叉搜索树的种类数</span><br><span class="line">        dp[0] = 1; // 0个节点算二叉搜索树、</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= i; j++) &#123;</span><br><span class="line">                dp[i] += dp[j-1] * dp[i-j]; // 左子树方案数 * 右子树方案数</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="01-背包理论"><a href="#01-背包理论" class="headerlink" title="01 背包理论"></a>01 背包理论</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1046">46. 携带研究材料（第六期模拟笔试）</a></p>
</li>
<li><p>题意，01 背包通常不会直接考，更多时候是把情景题转化为 01 背包问题，正如研究材料中，研究材料价值和重量也对应 01 背包</p>
</li>
<li><p>方法，</p>
<ol>
<li>确认 dp数组以及下标含义，dp[i][j] 的意思是当背包大小为 j，从0-i下标材料任选组合价值最大的值</li>
<li>确认递推公式, 若剩余重量不足 dp[i][j] &#x3D; dp[i-1][j] ,剩余重量充足就是 dp[i][j] &#x3D; max(dp[i-1][j], dp[i-1][j-weigh[i]]+val[i])，也就是不加入当前物品的最大价值和加入当前物品的价值与剩余重量最大价值之和相比较。</li>
<li>初始化，第一行和第一列都下应先为 0，再判断第一个物品在第一行是否能放入</li>
<li>遍历顺序，先遍历物品，其中遍历背包容量</li>
<li>举例……</li>
</ol>
</li>
<li><p>但此题还有一点，那就是滚动数组的解法，可以将二维数组转为一维数组，降低空间复杂度，具体可继续按上述五步法</p>
<ol>
<li>确定 dp 数组及其下标含义，dp[j] 的意思是背包空间为 j 时的最大价值容量</li>
<li>递推公式，由于压缩后，每层遍历相当于新值与原坐标的数值比较，dp[j] &#x3D; max(dp[j], dp[j-weigh[i]] + val[i])</li>
<li>初始化，dp[*]&#x3D;0,毕竟可从第一个物品开始做起</li>
<li>遍历顺序，这是该方法重点，必须在遍历空间时倒序，也就是 j 的值必须先取大值到小，从数组的角度，就是从右向左。原因是，每个值的更新可能与其更小坐标相关，如果先更新了小坐标，那么就会影响到大坐标的更新。</li>
<li>举例……</li>
</ol>
</li>
<li><p>参考代码随想录思路的二维数组解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // init</span><br><span class="line">    int m, n; // 材料个数和背包大小</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    vector&lt;int&gt; weigh(m);// 分别是所占空间和价值</span><br><span class="line">    vector&lt;int&gt; val(m);</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; weigh[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; val[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n+1, 0)); </span><br><span class="line">    // dp[i][j] 为当背包大小为 j，从0-i下标材料任选组合价值最大的值</span><br><span class="line">    // dp[0][*]和dp[*][0]皆已初始化为0，还差第一个材料的初始化</span><br><span class="line">    for (int i = 0; i &lt;= n; i++) &#123;</span><br><span class="line">        if (i &gt;= weigh[0]) dp[0][i] = val[0];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 递推顺序，物品中遍历背包容量（本题反过来貌似也可）</span><br><span class="line">    for (int i = 1; i &lt; m; i++) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= n; j++) &#123;</span><br><span class="line">            if (j &lt; weigh[i]) dp[i][j] = dp[i-1][j];</span><br><span class="line">            else dp[i][j] = max(dp[i-1][j], dp[i-1][j-weigh[i]] + val[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n+1;j++) &#123;</span><br><span class="line">            cout &lt;&lt; dp[i][j] &lt;&lt; &quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    */</span><br><span class="line">    cout &lt;&lt; dp[m-1][n] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>滚动数组的解法  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // init</span><br><span class="line">    int m, n; // 材料个数和背包大小</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    vector&lt;int&gt; weigh(m);// 分别是所占空间和价值</span><br><span class="line">    vector&lt;int&gt; val(m);</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; weigh[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; val[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; dp(n+1, 0); </span><br><span class="line">    // dp[j] 为当背包大小为 j，从0-i下标材料任选组合价值最大的值</span><br><span class="line">    // dp[*]皆已初始化为0</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    // 递推顺序，物品中遍历背包容量（本题反过来貌似也可）</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        for (int j = n; j &gt; 0; j--) &#123;</span><br><span class="line">            if (j &gt;= weigh[i]) dp[j] = max(dp[j] ,dp[j-weigh[i]] + val[i]);</span><br><span class="line">            /*</span><br><span class="line">            for (int j = 0; j &lt; n+1;j++) &#123;</span><br><span class="line">                cout &lt;&lt; dp[j] &lt;&lt; &quot; &quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">            */</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; dp[n] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/11/17/[Weekly%20Algorithm]%2010%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89/" data-id="cm7j3ftgu000wuwag6b863i9n" data-title="【Weekly Algorithm】算法周记之《代码随想录》动态规划（一）" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/11/24/%5BWeekly%20Algorithm%5D%2011%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%8C%EF%BC%89/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          【Weekly Algorithm】算法周记之《代码随想录》动态规划（二）
        
      </div>
    </a>
  
  
    <a href="/2024/11/10/%5BWeekly%20Algorithm%5D%209%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%9B%9E%E6%BA%AF%EF%BC%88%E4%BA%8C%EF%BC%89/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">【Weekly Algorithm】算法周记之《代码随想录》回溯（二）</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CINTA/" rel="tag">CINTA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CS61A/" rel="tag">CS61A</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Conda/" rel="tag">Conda</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JLU/" rel="tag">JLU</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%92%AD%E5%AE%A2%E7%AC%94%E8%AE%B0/" rel="tag">播客笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag">数据结构与算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/" rel="tag">方法论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" rel="tag">深度学习</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algorithm/" style="font-size: 20px;">Algorithm</a> <a href="/tags/CINTA/" style="font-size: 10px;">CINTA</a> <a href="/tags/CS61A/" style="font-size: 17.14px;">CS61A</a> <a href="/tags/Conda/" style="font-size: 10px;">Conda</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/JLU/" style="font-size: 15.71px;">JLU</a> <a href="/tags/Python/" style="font-size: 18.57px;">Python</a> <a href="/tags/%E6%92%AD%E5%AE%A2%E7%AC%94%E8%AE%B0/" style="font-size: 11.43px;">播客笔记</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size: 14.29px;">数据结构与算法</a> <a href="/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/" style="font-size: 11.43px;">方法论</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 11.43px;">机器学习</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 12.86px;">杂谈</a> <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">深度学习</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/12/">十二月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">十一月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">十月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">九月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">八月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">七月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">六月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">五月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">三月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">二月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">一月 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/12/15/%5BWeekly%20Algorithm%5D%2014%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%94%EF%BC%89/">【Weekly Algorithm】算法周记之《代码随想录》动态规划（五）</a>
          </li>
        
          <li>
            <a href="/2024/12/08/%5BWeekly%20Algorithm%5D%2013%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E5%9B%9B%EF%BC%89/">【Weekly Algorithm】算法周记之《代码随想录》动态规划（四）</a>
          </li>
        
          <li>
            <a href="/2024/12/01/%5BWeekly%20Algorithm%5D%2012%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%89%EF%BC%89/">【Weekly Algorithm】算法周记之《代码随想录》动态规划（三）</a>
          </li>
        
          <li>
            <a href="/2024/11/24/%5BWeekly%20Algorithm%5D%2011%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%8C%EF%BC%89/">【Weekly Algorithm】算法周记之《代码随想录》动态规划（二）</a>
          </li>
        
          <li>
            <a href="/2024/11/17/%5BWeekly%20Algorithm%5D%2010%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89/">【Weekly Algorithm】算法周记之《代码随想录》动态规划（一）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 陆爻齐-LuYaoQi<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
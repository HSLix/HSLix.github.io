<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【Leetcode Daily】3152特殊数组II</title>
      <link href="/posts/9b3f7b4e.html"/>
      <url>/posts/9b3f7b4e.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/special-array-ii/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个整型数组，和一个二维整型数组，将二维数组的每个元素视为区间，要求每个区间内的数组，是否每一对相邻元素都是奇偶性不同的数字。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>基本前缀和的思路，可以参考 <a href="/posts/42905a7b.html" title="【Leetcode Daily】303区域和检索-数组不可变">【Leetcode Daily】303区域和检索-数组不可变</a></p></li><li><p>虽然明知是前缀和，但如何把题目抽象为前缀和能解答的形式还是需要多多学习的。</p></li><li><p>比如本题，可以将相邻数字奇偶性是否相同直接化为布尔值存储，如果相同则记 1，不同则记 0，然后求前缀和。这样子，如果区间两侧的值相同，说明区间中的奇偶性都是不同的。</p></li><li><p>值得说道的是，在 Python 中（3.10以上），可以通过 pairwise 函数来遍历数组内的每个数对。</p><blockquote><p><a href="https://leetcode.cn/problems/special-array-ii/solutions/2782830/qian-zhui-he-wei-yun-suan-pythonjavacgo-3pvya/">https://leetcode.cn/problems/special-array-ii/solutions/2782830/qian-zhui-he-wei-yun-suan-pythonjavacgo-3pvya/</a></p></blockquote></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isArraySpecial</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], queries: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">bool</span>]:</span><br><span class="line">        s = <span class="built_in">list</span>(accumulate((x%<span class="number">2</span>==y%<span class="number">2</span> <span class="keyword">for</span> x, y <span class="keyword">in</span> pairwise(nums)), initial=<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> [s[q[<span class="number">0</span>]]==s[q[<span class="number">1</span>]] <span class="keyword">for</span> q <span class="keyword">in</span> queries]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】2559统计范围内的元音字符串数</title>
      <link href="/posts/f8886c5e.html"/>
      <url>/posts/f8886c5e.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/count-vowel-strings-in-ranges/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个字符串和一个二维整数数组，二维数组内每个元素有两个数值，代表一个区间，要求返回每个区间内开头和结尾都是元音字母的数量。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>基本前缀和的思路，可以参考 <a href="/posts/42905a7b.html" title="【Leetcode Daily】303区域和检索-数组不可变">【Leetcode Daily】303区域和检索-数组不可变</a></p></li><li><p>除了题目，几乎与昨日的题目一模一样（<a href="/posts/4f49bf51.html" title="【Leetcode Daily】3427变长子数组求和">【Leetcode Daily】3427变长子数组求和</a>），故不做赘述。</p></li><li><p>只补充一点感受，还真是有点不习惯这个 accumulate 函数，还是得慢慢适应这种有各种方便函数调用的 Python ~（蛇堕*n）</p><blockquote><p><a href="https://leetcode.cn/problems/count-vowel-strings-in-ranges/solutions/2093978/suan-fa-xiao-ke-tang-qian-zhui-he-by-end-n0mx/">https://leetcode.cn/problems/count-vowel-strings-in-ranges/solutions/2093978/suan-fa-xiao-ke-tang-qian-zhui-he-by-end-n0mx/</a></p></blockquote></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">vowelStrings</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>], queries: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># s = list(accumulate([w[0] in [&#x27;a&#x27;, &#x27;e&#x27;, &#x27;i&#x27;, &#x27;o&#x27;, &#x27;u&#x27;] and w[-1] in [&#x27;a&#x27;, &#x27;e&#x27;, &#x27;i&#x27;, &#x27;o&#x27;, &#x27;u&#x27;] for w in words], initial=0))</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># return [s[q[1]+1]-s[q[0]] for q in queries]</span></span><br><span class="line">        </span><br><span class="line">        rec = [<span class="number">0</span>] * (<span class="built_in">len</span>(words)+<span class="number">1</span>)</span><br><span class="line">        ans = [<span class="number">0</span>] * <span class="built_in">len</span>(queries)</span><br><span class="line">        even_char = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, word <span class="keyword">in</span> <span class="built_in">enumerate</span>(words):</span><br><span class="line">            rec[i+<span class="number">1</span>] += rec[i] + (<span class="number">1</span> <span class="keyword">if</span> word[<span class="number">0</span>] <span class="keyword">in</span> even_char <span class="keyword">and</span> word[-<span class="number">1</span>] <span class="keyword">in</span> even_char <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(queries):</span><br><span class="line">            ans[i] = rec[x[<span class="number">1</span>]+<span class="number">1</span>]-rec[x[<span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">        </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】3427变长子数组求和</title>
      <link href="/posts/4f49bf51.html"/>
      <url>/posts/4f49bf51.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/sum-of-variable-length-subarrays/description/">题目链接</a>。</p></li><li><p>简单地说，就是给了一个整型数组，对其中的每一个元素，都要根据一个要求创建一个子数组，而题目要求则要返回这些所有子数组的数值和。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>前缀和的思路，可以参考 <a href="/posts/42905a7b.html" title="【Leetcode Daily】303区域和检索-数组不可变">【Leetcode Daily】303区域和检索-数组不可变</a></p></li><li><p>由于题目子数组和求得的方式，可以通过前缀和方便完成，所以采用这种方法。</p></li><li><p>重要的是，终于搞清楚了 Python 中 accumulate 函数到底是怎么形成的。对于 [1, 2, 3] 这样的列表，accumulate([1, 2, 3]) 会产生 [1, 3, 6]，也就是前缀和，但是通过增加参数 initial 的值可以改变初始前缀和值（该参数默认为 None），比如 accumulate([1, 2, 3], initial&#x3D;0)，会在初始的地方增加一个 0，变成 [0, 1, 3, 6]；accumulate([1, 2, 3], initial&#x3D;1)，就是 [1, 2, 4, 7]。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subarraySum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        pre = <span class="built_in">list</span>(accumulate(nums, initial=<span class="literal">None</span>))</span><br><span class="line">        <span class="comment"># pre = list(accumulate(nums, initial=0))</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        pre.insert(<span class="number">0</span>, <span class="number">0</span>) <span class="comment"># 补充没有的 0</span></span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            ans += pre[i+<span class="number">1</span>] - pre[<span class="built_in">max</span>(<span class="number">0</span>, i-nums[i])] </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】303区域和检索-数组不可变</title>
      <link href="/posts/42905a7b.html"/>
      <url>/posts/42905a7b.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/range-sum-query-immutable/">题目链接</a>。</p></li><li><p>简单地说，就是要求实现一个类，这个类能够返回数组中任意一个闭区间的数值和。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>这是前缀和的模板题，所谓前缀和的计算，正如其名，就是把数组从左往右一个个数值累加并记录。</p><blockquote><p><a href="https://leetcode.cn/problems/range-sum-query-immutable/solutions/2693498/qian-zhui-he-ji-qi-kuo-zhan-fu-ti-dan-py-vaar/">https://leetcode.cn/problems/range-sum-query-immutable/solutions/2693498/qian-zhui-he-ji-qi-kuo-zhan-fu-ti-dan-py-vaar/</a></p></blockquote></li><li><p>实现方式很简单，但是有一点需要特别注意，就是留出第一位的 0.如果采用第一位就放第一位的数值，那么就需要特别处理闭区间左部为 0 的情况，但是如果第一位置零，第二位放第一个数值，第三位放前两个数值，这样子下去，取区间和就只要调整一下下标加一即可。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">        s = [<span class="number">0</span>] * (<span class="built_in">len</span>(nums)+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i,x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            s[i+<span class="number">1</span>] = s[i] + x</span><br><span class="line">        <span class="variable language_">self</span>.s = s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumRange</span>(<span class="params">self, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.s[right+<span class="number">1</span>]-<span class="variable language_">self</span>.s[left]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = NumArray(nums)</span></span><br><span class="line"><span class="comment"># param_1 = obj.sumRange(left,right)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Introduction to Mathematical Thinking】Lecture-3-implies</title>
      <link href="/posts/ecd93791.html"/>
      <url>/posts/ecd93791.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>该课程可以在 <a href="https://www.coursera.org/learn/mathematical-thinking">coursera</a> 网站上免费学习，<a href="https://www.coursera.org/learn/mathematical-thinking">具体课程的链接就点这里跳转</a>。</p></li><li><p>陆爻齐不太指望学完这门课就能让自己走向人生巅峰（笑，只是对于像这种方法论类型的比较感兴趣，而且也是一个很好的锻炼英语的机会 ：）</p></li></ul><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><ul><li><p>本节的内容是介绍了 implies，或者应该叫包含、蕴含。</p></li><li><p>举个例子来说明比较好，A⇒B，表示 A 蕴含 B，这里的 A 和 B 分别代表一个表达式。</p></li><li><p>注意，A 和 B 不一定要有“因果关系”，比如<code>“他很好看”⇒“1+3=4”</code>这种也算蕴含，而且还是正确的（原因后面会补充）。</p></li></ul><h2 id="蕴含的-True-和-False"><a href="#蕴含的-True-和-False" class="headerlink" title="蕴含的 True 和 False"></a>蕴含的 True 和 False</h2><ul><li><p>和上一节一样，这个逻辑符号的式子也有 True 和 False 的结果，虽然结论是中学学过的，但为什么这样还是值得记录一下。</p></li><li><p>A⇒B，A 是前因（先前假设），B 是后果，如果两者都为真，那么结果就是真吧，像是<code>N&gt;7 ⇒ N^2&gt;40</code>。</p></li><li><p>但是如果 A 和 B 毫无关联会怎样呢？<code>1+2=3  -1&lt;0</code>这两条都为真，却毫无关联。规定为真，这样做的原因是无论式子是否具有意义，都能有一个定义，避免了未知状态的情况。</p></li><li><p>小结一下就可以说是，<code>A⇒B</code>为真时，而且 A 也为真时，要求 B 为真。</p></li><li><p>那么，什么时候<code>A⇒B</code>为假呢？只要不满足刚刚这一条即可，如果 B 为假，A 为真，就不满足<code>A⇒B</code>为真时的要求，那么就是假啦。</p></li><li><p>到此为止，已经讨论了<code>A⇒B</code>为真或者假的情况，但是这两种情况中的 A 都为真，如果 A 为假呢？</p></li><li><p>这里就会从 <code>A⇏B</code>入手，A 不包含 B，从上面的结论知道，如果 A 为真，B 为假，这个式子就为真。那么除此之外的情况，都为假。所以当 A 为假，A蕴含B的式子都为真。</p></li></ul><table><thead><tr><th>A</th><th>B</th><th>A⇒B</th></tr></thead><tbody><tr><td>T</td><td>T</td><td>T</td></tr><tr><td>T</td><td>F</td><td>F</td></tr><tr><td>F</td><td>T</td><td>T</td></tr><tr><td>F</td><td>F</td><td>T</td></tr></tbody></table><h2 id="蕴含的变形"><a href="#蕴含的变形" class="headerlink" title="蕴含的变形"></a>蕴含的变形</h2><ul><li>从作业任务中可以学到，<code>A⇒B</code>与<code>¬A∨B</code>的真假表结果一致，<code>A⇏B</code>和<code>A∧¬B</code>也是。这种我记得在离散当结论记来着。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Introduction to Mathematical Thinking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】447回旋镖的数量</title>
      <link href="/posts/adfdba1.html"/>
      <url>/posts/adfdba1.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/number-of-boomerangs/">题目链接</a>。</p></li><li><p>简单地说，就是给一个数组，找到其中所有三元组的数量。要求三元组之中，（假定顺序为 i，j，k），那么 i 和 k 的欧氏距离 i 和 j 的欧氏距离相等。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>基本的枚举思路可以参考<a href="/posts/29412f7f.html" title="【Leetcode Daily】2909元素和最小的山形三元组">【Leetcode Daily】2909元素和最小的山形三元组</a>。</p></li><li><p>和之前的题思路不同，此题需要在每次循环枚举 i 时都维护一个哈希表，该哈希表为各元素与 i 的欧氏距离。一旦遍历到曾经与自己距离相同的元素，结果则多加了两个。（之所以是两个，是因为三元组中的 j 和 k 可以互换位置。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numberOfBoomerangs</span>(<span class="params">self, points: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> xi, yi <span class="keyword">in</span> points:</span><br><span class="line">            rec = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">            <span class="keyword">for</span> xj, yj <span class="keyword">in</span> points:</span><br><span class="line">                disij = (xi - xj)**<span class="number">2</span> + (yi - yj)**<span class="number">2</span></span><br><span class="line">                ans += rec[disij] * <span class="number">2</span></span><br><span class="line">                rec[disij] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】2874有序三元组中的最大值II</title>
      <link href="/posts/752fb474.html"/>
      <url>/posts/752fb474.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/maximum-value-of-an-ordered-triplet-ii/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个数组，找到其中值最大的三元组，三元组要求下标 i &lt; j &lt; k，值计算公式为(nums[i]-nums[j])*nums[k]。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>基本的枚举思路可以参考<a href="/posts/29412f7f.html" title="【Leetcode Daily】2909元素和最小的山形三元组">【Leetcode Daily】2909元素和最小的山形三元组</a>。</p></li><li><p>从值的计算可以轻松得知，要是得值尽可能的大，nums[i] 和 nums[k] 都要尽可能大，而 nums[j] 要尽可能小。</p></li><li><p>于是就可以预处理数组，找到每个位置上下标往右的最大值，这样在遍历过程中就能以 O(1) 的复杂度获取到能用的最大的 nums[k] 值。接着在遍历过程中顺便记录最大值当作 nums[i] 用即可。</p></li><li><p>类似思路更完整的解析已在历史题说过，故上面只是简单叙述思路。历史题目：<a href="/posts/29412f7f.html" title="【Leetcode Daily】2909元素和最小的山形三元组">【Leetcode Daily】2909元素和最小的山形三元组</a>。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumTripletValue</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 可以看到，前面要求尽可能大，后面也尽可能大，或许能先处理后缀</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        suf = [<span class="number">0</span>] * n</span><br><span class="line">        suf[-<span class="number">1</span>] = nums[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>, <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            suf[i] = <span class="built_in">max</span>(suf[i+<span class="number">1</span>], nums[i])</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># print(suf)</span></span><br><span class="line"></span><br><span class="line">        max_pre_num = nums[<span class="number">0</span>]</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n-<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># print(f&quot;(&#123;max_pre_num&#125;-&#123;nums[i]&#125;)*&#123;suf[i+1]&#125;&quot;)</span></span><br><span class="line">            ans = <span class="built_in">max</span>((max_pre_num-nums[i])*suf[i+<span class="number">1</span>], ans)</span><br><span class="line">            max_pre_num = <span class="built_in">max</span>(max_pre_num, nums[i])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】3128直角三角形</title>
      <link href="/posts/3909f3d2.html"/>
      <url>/posts/3909f3d2.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/right-triangles/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个二维数组，数字只会是 0 或 1，求其中直角三角形的数目，直角三角形的三个元素要求以直角中心处为核心，横向和纵向有 1 即可。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>基本的枚举思路可以参考<a href="/posts/29412f7f.html" title="【Leetcode Daily】2909元素和最小的山形三元组">【Leetcode Daily】2909元素和最小的山形三元组</a>。</p></li><li><p>重点在于元素不必相邻，所以只要统计好每行和每列 1 的数量，遍历直角三角形核心，每次遇到 1，结果就可以加上该处行列剩余的 1 数量相乘的值。</p><blockquote><p><a href="https://leetcode.cn/problems/right-triangles/solutions/2758892/cheng-fa-yuan-li-pythonjavacgo-by-endles-7469/">https://leetcode.cn/problems/right-triangles/solutions/2758892/cheng-fa-yuan-li-pythonjavacgo-by-endles-7469/</a></p></blockquote></li><li><p>本题学到的最大的点在于 zip 函数的使用，在 cpp 中总是烦恼难以并行遍历，只能通过下标管理的窘况通过 zip 函数就能解决。</p></li><li></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numberOfRightTriangles</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        col_sum = [<span class="built_in">sum</span>(col) - <span class="number">1</span> <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">zip</span>(*grid)] <span class="comment"># 先将 grid 按行分开，然后用 zip 将每行的相同次序元素组合，形成遍历列的效果</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> grid:</span><br><span class="line">            row_sum = <span class="built_in">sum</span>(row)-<span class="number">1</span></span><br><span class="line">            ans += row_sum * <span class="built_in">sum</span>(c <span class="keyword">for</span> x, c <span class="keyword">in</span> <span class="built_in">zip</span>(row, col_sum) <span class="keyword">if</span> x)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="comment"># class Solution:</span></span><br><span class="line"><span class="comment">#     def numberOfRightTriangles(self, grid: List[List[int]]) -&gt; int:</span></span><br><span class="line"><span class="comment">#         col_sum = [sum(col) - 1 for col in zip(*grid)] </span></span><br><span class="line"><span class="comment">#         ans = 0</span></span><br><span class="line"><span class="comment">#         for row in grid:</span></span><br><span class="line"><span class="comment">#             row_sum = sum(row)-1</span></span><br><span class="line"><span class="comment">#             for x, c in zip(row, col_sum):</span></span><br><span class="line"><span class="comment">#                 if x==1:</span></span><br><span class="line"><span class="comment">#                     ans += row_sum * c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#         return ans</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】1930长度为3的不同回文子序列</title>
      <link href="/posts/36d76ee9.html"/>
      <url>/posts/36d76ee9.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/unique-length-3-palindromic-subsequences/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个字符串，找出其中所有的不同的回文子序列，这些子序列要求长度为 3，回文是正序和倒序内容一致，子序列是由原序列删除字符组成。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>基本的枚举思路可以参考<a href="/posts/29412f7f.html" title="【Leetcode Daily】2909元素和最小的山形三元组">【Leetcode Daily】2909元素和最小的山形三元组</a>。</p></li><li><p>通过基本思路可知，可以分别用哈希表处理中间下标的左侧与右侧，剩下的内容在于如何对三元组去重（题目要求<strong>不同</strong>），大致可以分成三种。</p></li><li><p>第一种，采用 set 或者直接存储字符串的哈希表来去重，顾名思义，只要确保对应字符串的唯一，当然可以实现记录不同的回文字符串。</p></li><li><p>第二种，采用二维数组，由于第一位和第三位的字母相同，所以可以让中间的字母一维，另外的字母放二维，这样的二维数组执行效率大大高于第一种方法。</p></li><li><p>第三种，采用位运算去重，就是在第二种方法上，通过位运算去掉二维，具体是这样实现的。已知字母无非就26位，那么对于每一个中间字母的情况，下面都算是有 26 个分支情况，方法二另开的26个位置放值 1 或 0，但这些位置仍然算整数（如果不是 Python，就能直接说算 4 字节，但 Python 是动态），比单个位要大。如果每一个字母，用一个长度为 26 位的二进制数来表示，空间占用定会大大减小。</p><blockquote><p><a href="https://leetcode.cn/problems/unique-length-3-palindromic-subsequences/solutions/869697/mei-ju-zhong-jian-zi-fu-ran-hou-gen-ju-q-186d/comments/2471709/">https://leetcode.cn/problems/unique-length-3-palindromic-subsequences/solutions/869697/mei-ju-zhong-jian-zi-fu-ran-hou-gen-ju-q-186d/comments/2471709/</a></p></blockquote></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解法三，巧用位运算</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countPalindromicSubsequence</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        suf = Counter(s)</span><br><span class="line">        pre = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        rec = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">26</span>)] <span class="comment"># 一维数组，初始 0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            suf[c] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> letter <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">97</span>, <span class="number">123</span>):</span><br><span class="line">                tmp = <span class="built_in">chr</span>(letter)</span><br><span class="line">                <span class="keyword">if</span> pre[tmp] <span class="keyword">and</span> suf[tmp]:</span><br><span class="line">                    rec[<span class="built_in">ord</span>(c)-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] |= (<span class="number">1</span> &lt;&lt; (letter - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)))</span><br><span class="line">            pre[c] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> mask <span class="keyword">in</span> rec:</span><br><span class="line">            ans += <span class="built_in">bin</span>(mask).count(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解法二，通过二维数组去重</span></span><br><span class="line"><span class="comment"># class Solution:</span></span><br><span class="line"><span class="comment">#     def countPalindromicSubsequence(self, s: str) -&gt; int:</span></span><br><span class="line"><span class="comment">#         suf = Counter(s)</span></span><br><span class="line"><span class="comment">#         pre = defaultdict(int)</span></span><br><span class="line"><span class="comment">#         rec = [[0 for _ in range(0, 26)] for _ in range(0, 26)] # 二维数组，初始 0</span></span><br><span class="line"><span class="comment">#         ans = 0</span></span><br><span class="line"><span class="comment">#         for c in s:</span></span><br><span class="line"><span class="comment">#             suf[c] -= 1</span></span><br><span class="line"><span class="comment">#             for letter in range(97, 123):</span></span><br><span class="line"><span class="comment">#                 tmp = chr(letter)</span></span><br><span class="line"><span class="comment">#                 if pre[tmp] and suf[tmp] and rec[ord(c)-ord(&#x27;a&#x27;)][letter - ord(&#x27;a&#x27;)] == 0:</span></span><br><span class="line"><span class="comment">#                     ans += 1</span></span><br><span class="line"><span class="comment">#                     rec[ord(c)-ord(&#x27;a&#x27;)][letter - ord(&#x27;a&#x27;)] += 1</span></span><br><span class="line"><span class="comment">#             pre[c] += 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#         return ans</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解法一，通过 set 或者其它去重方法实现</span></span><br><span class="line"><span class="comment"># class Solution:</span></span><br><span class="line"><span class="comment">#     def countPalindromicSubsequence(self, s: str) -&gt; int:</span></span><br><span class="line"><span class="comment">#         suf = Counter(s)</span></span><br><span class="line"><span class="comment">#         pre = defaultdict(int)</span></span><br><span class="line"><span class="comment">#         rec = defaultdict(int)</span></span><br><span class="line"><span class="comment">#         ans = 0</span></span><br><span class="line"><span class="comment">#         for c in s:</span></span><br><span class="line"><span class="comment">#             suf[c] -= 1</span></span><br><span class="line"><span class="comment">#             for letter in range(97, 123):</span></span><br><span class="line"><span class="comment">#                 tmp = chr(letter)</span></span><br><span class="line"><span class="comment">#                 if pre[tmp] * suf[tmp] &gt; 0 and rec[tmp + c + tmp] == 0:</span></span><br><span class="line"><span class="comment">#                     ans += 1</span></span><br><span class="line"><span class="comment">#                     rec[tmp + c + tmp] += 1</span></span><br><span class="line"><span class="comment">#             pre[c] += 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#         return ans</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】3583统计特殊三元组</title>
      <link href="/posts/93ac98b.html"/>
      <url>/posts/93ac98b.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/count-special-triplets/">题目链接</a>。</p></li><li><p>简单地说，就是找出一个数组中的某一种三元组的数量，该三元组要求中间的值为两边值的一半。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>尝试了一下普通的枚举思路，即遍历右侧，看有无相同值以及一半值。但是这样的算法，无法处理[0, 0, 0]的情况，因为 0 的一半还是 0。</p></li><li><p>因此重点的学习部分在于，用怎样的思路来对数组进行预处理。</p><blockquote><p><a href="https://leetcode.cn/problems/count-special-triplets/solutions/3700554/mei-ju-zhong-jian-qian-hou-zhui-fen-jie-5uad8/">https://leetcode.cn/problems/count-special-triplets/solutions/3700554/mei-ju-zhong-jian-qian-hou-zhui-fen-jie-5uad8/</a></p></blockquote></li><li><p>回顾上一次学习枚举中间基本思路(<a href="/posts/29412f7f.html" title="【Leetcode Daily】2909元素和最小的山形三元组">【Leetcode Daily】2909元素和最小的山形三元组</a>)，是对每一位都记录了最小的那个值。</p></li><li><p>但是可以稍微魔改一下，用哈希表记录数组中每个值的频次，并且去除掉已遍历的值，那不就是右侧的情况嘛。同时遍历过程中顺便用另一个哈希表记录左侧情况，如此一来，就完成了枚举中间的思路。</p></li><li><p>以及，由于 Python 没有数值溢出这种东西，所以取余操作可以放最后进行，这一点真是方便不少。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">specialTriplets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        suf = Counter(nums)</span><br><span class="line">        pre = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        MOD = <span class="number">1_000_000_007</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            suf[i] -= <span class="number">1</span> </span><br><span class="line">            res += suf[i*<span class="number">2</span>] * pre[i*<span class="number">2</span>]</span><br><span class="line">            pre[i] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res % MOD</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】2909元素和最小的山形三元组</title>
      <link href="/posts/29412f7f.html"/>
      <url>/posts/29412f7f.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/minimum-sum-of-mountain-triplets-ii/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个整型数组，现在定义一个山形三元组，由数组中三个不同的数字组成，要求这三个数的位置上中间的数大于两边的数。如果存在这么山形三元组，那么就求元素和最小的那个三元组的元素和。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>这是枚举中间类型的第一题，所以将会详细介绍为什么这么做，以及怎么做。</p><blockquote><p><a href="https://leetcode.cn/problems/minimum-sum-of-mountain-triplets-ii/solutions/2493548/mei-ju-numsj-qian-hou-zhui-fen-jie-pytho-tskf/">https://leetcode.cn/problems/minimum-sum-of-mountain-triplets-ii/solutions/2493548/mei-ju-numsj-qian-hou-zhui-fen-jie-pytho-tskf/</a></p></blockquote></li><li><p>首先，为什么要<strong>枚举中间</strong>。可以看到，题目有三个下标等我们求，如果直接暴力，那么时间复杂度就是 O(n^3)，非常大。枚举中间可以简化时间复杂度到 O(n)（反正会少）。</p></li><li><p>可不可以枚举左边或者右边呢？应该可以，但大部分情况下没有中间简单。比如要求 i &lt; j &lt; k，如果枚举 j，就不需要考虑 i 和 k 的关系，因为如果 i &lt; j 和 j &lt; k 都满足了，i &lt; k 也会顺便满足。</p></li><li><p>那么怎么实现同时考虑三个的枚举呢？此前我们是采用哈希表解决一个变量，同时遍历另一个变量，那么我们只要再做预处理，使得第三个变量也能O(1)解决即可。</p></li><li><p>以本题为例，需要枚举中间的同时，保证两旁的数字比中间小即可，那么如果能通过预处理，知道每个下标位置往右最小的值，那么不就搞定第三个了嘛。</p></li><li><p>那么第一个变量也可以用这个方法吗？可以，但没必要，因为遍历的过程中，可以维护一个变量，记录当前遍历位置以左的最小值。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimumSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        suf = [<span class="number">0</span>] * n</span><br><span class="line">        suf[-<span class="number">1</span>] = nums[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>, <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;suf[i+<span class="number">1</span>]&#125;</span> and <span class="subst">&#123;nums[i]&#125;</span>&quot;</span>)</span><br><span class="line">            suf[i] = <span class="built_in">min</span>(suf[i+<span class="number">1</span>], nums[i])</span><br><span class="line">        </span><br><span class="line">        ans = inf</span><br><span class="line">        pre = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> pre &lt; nums[i] &gt; suf[i+<span class="number">1</span>]:</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, pre + nums[i] + suf[i+<span class="number">1</span>])</span><br><span class="line">            pre = <span class="built_in">min</span>(pre, nums[i])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans <span class="keyword">if</span> ans != inf <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一起来学Python基础|LearnBasicPythonTogether</title>
      <link href="/posts/299d5f4e.html"/>
      <url>/posts/299d5f4e.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>发现 Python 写起来比 C++ 爽多了，以后写 Leetcode 和其他程序，只要对性能和应用场景没有特殊要求，就只用 Python 啦！（<del>蛇堕力，悲</del>）</p></li><li><p>总之，下面的内容是对学习了 《Python编程-从入门到实践》 基础部分的小结，不是那种事无巨细的笔记，而是学习中印象比较深刻的部分。（也就是对于本人比较新的部分）</p></li><li><p>原计划每章写一个博客来记录，发现大部分内容已经在 C++ 那边烂熟于心，只要补充 Python 特色的实现方式和小部分新特性就好。</p></li><li><p>由于下面内容可能涉及<strong>练习的剧透</strong>，所以想要尽可能地发挥这本书的学习效用的话，建议自行学习完成再看本文。</p></li></ul><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><ul><li><p>首先，这是练习存放的<a href="https://github.com/HSLix/PythonCrashCrouse_PractiseRecord/tree/main">对应仓库地址</a></p></li><li><p>如果仔细看的话，会发现练习不全，因为有些练习陆爻齐觉着与其它练习考察重复，或者他们是陆爻齐已经十分熟悉的内容。</p></li></ul><h2 id="字符串去除前后空格"><a href="#字符串去除前后空格" class="headerlink" title="字符串去除前后空格"></a>字符串去除前后空格</h2><ul><li>很多时候，我们有去除字符串前面或者后面的空格的需求，这个时候就可以使用下面的例子中展现的 strip 系列函数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;\tWang \n Xiao\tMing  &quot;</span></span><br><span class="line"><span class="built_in">print</span>(name.lstrip()) <span class="comment"># Left</span></span><br><span class="line"><span class="built_in">print</span>(name.rstrip()) <span class="comment"># Right</span></span><br><span class="line"><span class="built_in">print</span>(name.strip()) <span class="comment"># Left and Right</span></span><br></pre></td></tr></table></figure><ul><li>运行结果会是：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ python practise2.7.py</span><br><span class="line">Wang </span><br><span class="line"> Xiao   Ming</span><br><span class="line">        Wang</span><br><span class="line"> Xiao   Ming</span><br><span class="line">Wang</span><br><span class="line"> Xiao   Ming</span><br></pre></td></tr></table></figure><ul><li>可以看到，三个结果，分别去除了左空格，右空格，和两边的空格。</li></ul><h2 id="字符串去除前后缀"><a href="#字符串去除前后缀" class="headerlink" title="字符串去除前后缀"></a>字符串去除前后缀</h2><ul><li>去除前缀用 removeprefix()，比如</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">filename = &#x27;python_notes.txt&#x27;</span><br><span class="line">print(filename.removeprefix(&quot;python_&quot;))</span><br></pre></td></tr></table></figure><ul><li>去除后缀则是 removeprefix()，比如</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">filename = <span class="string">&#x27;python_notes.txt&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(filename.removesuffix(<span class="string">&quot;.txt&quot;</span>))</span><br></pre></td></tr></table></figure><h2 id="字符串大小写"><a href="#字符串大小写" class="headerlink" title="字符串大小写"></a>字符串大小写</h2><ul><li>直接上例子说明罢</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;Eric mask&quot;</span></span><br><span class="line"><span class="built_in">print</span>(name.lower()) <span class="comment"># 小写</span></span><br><span class="line"><span class="built_in">print</span>(name.upper()) <span class="comment"># 大写</span></span><br><span class="line"><span class="built_in">print</span>(name.title()) <span class="comment"># 首字母大写d</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">eric mask</span></span><br><span class="line"><span class="string">ERIC MASK</span></span><br><span class="line"><span class="string">Eric Mask</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="列表的顺序"><a href="#列表的顺序" class="headerlink" title="列表的顺序"></a>列表的顺序</h2><ul><li>sort 负责对列表排序后，保存列表顺序 <code>sorted_list = num_list.sort()</code></li><li>sorted 对列表进行排序，但不会保存 <code>sorted_list = sorted(num_list)</code></li><li>reverse 会反转列表顺序并保存 <code>reversed_list = num_list.reverse()</code></li></ul><h2 id="列表的删除"><a href="#列表的删除" class="headerlink" title="列表的删除"></a>列表的删除</h2><ul><li>del 根据索引删除列表元素 <code>del num_list[1]</code></li><li>remove 根据值删除元素 <code>num_list.remove(2)</code>，但是只会删除一个值，如果有多个这个值，需要循环删除。</li><li>pop 默认弹出列表最后元素，参数可以设定弹出元素索引 <code>deleted_num = num_list.pop()</code></li></ul><h2 id="单句-for-循环"><a href="#单句-for-循环" class="headerlink" title="单句 for 循环"></a>单句 for 循环</h2><ul><li><p>直接分析例子：<code>nums = [value**3 for value in range(1, 11)]</code></p></li><li><p>这个例子的意思是，创建一个列表，其中的元素是从 1 到 10 的立方组成。</p></li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul><li><p>用 pytest，pip install 后，在命令行输入 pytest，就会对当前工作目录中文件以 test_ 开头的进行扫描，并执行其中以 test_ 开头的函数做测试。</p></li><li><p>有一个叫夹子的功能，可以为大规模测试中的一部分测试提供相同的元素用于测试。比如下面：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@pytest.fixture</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">employee</span>():</span><br><span class="line">    e = Employee(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> e</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_give_default_raise</span>(<span class="params">employee</span>):</span><br><span class="line">    employee.give_raise()</span><br><span class="line">    <span class="keyword">assert</span> employee.year_salary == <span class="number">6000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_give_custom_raise</span>(<span class="params">employee</span>):</span><br><span class="line">    employee.give_raise(<span class="number">12138</span>)</span><br><span class="line">    <span class="keyword">assert</span> employee.year_salary == <span class="number">13138</span></span><br></pre></td></tr></table></figure><ul><li><code>@pytest.fixture</code>装饰的就是夹子，函数名可以作为其它测试函数的变量传入，变量内容就是夹子的返回值，与返回值变量名字无关。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> LearnTogether </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】2364统计坏数对的数目</title>
      <link href="/posts/3251256b.html"/>
      <url>/posts/3251256b.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/count-number-of-bad-pairs/description/">题目链接</a>。</p></li><li><p>简单地说，就是给了一个坏数对的定义，要求找出坏数对的总数。所谓的坏数对，就是这个整型数组中的两个数，他们的数值之差与下标之差不等就算。（默认差值计算只会是大减小，只会是正数）</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>陆爻齐思考了下，发现坏数对的共性，是数值减去下标后，差值不为零的情况，根据昨天所学的列未知量，可以这么看。</p></li><li><p>设两个数值分别为 a 和 b，下标分别为 i 和 j，那么坏数对的定义就是 a-b !&#x3D; i-j，简单变换得 a-i !&#x3D; b-j，也就是各自数值减去下标不相等就算坏数对。</p></li><li><p>这样就变换成了比较熟悉的枚举问题，遍历所有数值与自身下标之差，并记录到哈希表中，同时也统计已遍历个数。每次枚举新的数字，都会查找哈希表中对应的个数，这个个数就是好数对，但是总数对减去这个数字，就是坏数对的个数。这就是陆爻齐的解法（放到参考题解的注释里了）。</p></li><li><p>灵神的解法更直接一些，可以直接计算所有数对的个数（两两组合），然后减去好数对，剩下的就是坏数对的个数了。具体的做法与上面陆爻齐的解法一致。</p><blockquote><p><a href="https://leetcode.cn/problems/count-number-of-bad-pairs/solutions/1728063/by-endlesscheng-uam3/">https://leetcode.cn/problems/count-number-of-bad-pairs/solutions/1728063/by-endlesscheng-uam3/</a></p></blockquote></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countBadPairs</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        res = comb(<span class="built_in">len</span>(nums), <span class="number">2</span>) <span class="comment"># 计算总数目</span></span><br><span class="line">        rec = Counter()</span><br><span class="line">        <span class="keyword">for</span> index, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            tmp = num - index</span><br><span class="line">            res -= rec[tmp] <span class="comment"># 减去好数对</span></span><br><span class="line">            rec[tmp] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># class Solution:</span></span><br><span class="line"><span class="comment">#     def countBadPairs(self, nums: List[int]) -&gt; int:</span></span><br><span class="line"><span class="comment">#         res = 0 # 记录坏数对数目</span></span><br><span class="line"><span class="comment">#         total = 0 # 计算已遍历的总数目</span></span><br><span class="line"><span class="comment">#         rec = Counter()</span></span><br><span class="line"><span class="comment">#         index = 0 # 记录当前数组下标</span></span><br><span class="line"><span class="comment">#         for num in nums:</span></span><br><span class="line"><span class="comment">#             tmp = num - index</span></span><br><span class="line"><span class="comment">#             res += total - rec[tmp]</span></span><br><span class="line"><span class="comment">#             total += 1</span></span><br><span class="line"><span class="comment">#             index += 1</span></span><br><span class="line"><span class="comment">#             rec[tmp] += 1</span></span><br><span class="line"><span class="comment">#         return res</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】624数组列表中的最大距离</title>
      <link href="/posts/a9536981.html"/>
      <url>/posts/a9536981.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/maximum-distance-in-arrays/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个有整型数组组成的数组，现在求一个数字的最大值，该数字由其中两个不同的数组中各取一个数的差值。另外，每个小数组都已经化为了升序数组。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>枚举右，维护左。只要不断遍历小数组，记录已得最小值和最大值，并与当前正在遍历的数组的最小值和最大值分别求差，再记录最大差值即可。</p><blockquote><p><a href="https://leetcode.cn/problems/maximum-distance-in-arrays/solutions/3067679/mei-ju-you-wei-hu-zuo-pythonjavaccgojsru-wtgb/">https://leetcode.cn/problems/maximum-distance-in-arrays/solutions/3067679/mei-ju-you-wei-hu-zuo-pythonjavaccgojsru-wtgb/</a></p></blockquote></li><li><p>如果想不明白为什么先更新结果，再更新最小值和最大值，可以尝试这么理解：题目要求两个值应该出于两个数组，如果我先更新了最小值和最大值，那么就会存在可能：当前这个小数组拥有着最小的最小值和最大的最大值，导致结果会变成计算这个小数组内的差值，违反题意。</p></li><li><p>O(n) 枚举的基本思想可以看 <a href="/posts/d26591e4.html" title="【Leetcode Daily】1两数之和">【Leetcode Daily】1两数之和</a>。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDistance</span>(<span class="params">self, arrays: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        min_num = inf</span><br><span class="line">        max_num = -inf</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> arrays:</span><br><span class="line">            res = <span class="built_in">max</span>(res, l[-<span class="number">1</span>] - min_num, max_num - l[<span class="number">0</span>])</span><br><span class="line">            min_num = <span class="built_in">min</span>(l[<span class="number">0</span>], min_num)</span><br><span class="line">            max_num = <span class="built_in">max</span>(l[-<span class="number">1</span>], max_num)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Introduction to Mathematical Thinking】Lecture-2-Basic-Combinators</title>
      <link href="/posts/e4d33db3.html"/>
      <url>/posts/e4d33db3.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>该课程可以在 <a href="https://www.coursera.org/learn/mathematical-thinking">coursera</a> 网站上免费学习，<a href="https://www.coursera.org/learn/mathematical-thinking">具体课程的链接就点这里跳转</a>。</p></li><li><p>陆爻齐不太指望学完这门课就能让自己走向人生巅峰（笑，只是对于像这种方法论类型的比较感兴趣，而且也是一个很好的锻炼英语的机会 ：）</p></li></ul><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><ul><li>总得来说，要学会 mathematical thinking，首先得让语言变得严谨无歧义，一种方法是采用数理符号来实现。毕竟日常对话的歧义是通过大量上下文和背景知识来消除歧义，而当我们探索未知的边界（也就是学习研究）时，可没有这样方便的环境。</li></ul><h2 id="关于作业"><a href="#关于作业" class="headerlink" title="关于作业"></a>关于作业</h2><ul><li>作业是用来引领我们尝试不同方式思考的引子，所以不用专注于得到作业的答案，而是尽可能地通过各种思考来解决问题。</li></ul><h2 id="And"><a href="#And" class="headerlink" title="And"></a>And</h2><ul><li><p>与，在逻辑中表示两块部分观点一致，或者说相关。</p></li><li><p>但是日常生活中有一点歧义，也就是无意义的补充，比如“I took a bag, and I ate some bread.” 带了一个包与吃了些面包不一致，甚至不相关，但就是会这么说，这样的表述在逻辑中不会出现。</p></li><li><p>在说明一个逻辑时，我们可以列出他的组合表来认识他，下面的 &amp; 符号用来代表与。</p></li></ul><table><thead><tr><th>A</th><th>B</th><th>A&amp;B</th></tr></thead><tbody><tr><td>T</td><td>T</td><td>T</td></tr><tr><td>T</td><td>F</td><td>F</td></tr><tr><td>F</td><td>T</td><td>F</td></tr><tr><td>F</td><td>F</td><td>F</td></tr></tbody></table><ul><li>可以看到，需要两个部分都为真，他们的组合也为真，才算 与。</li></ul><h2 id="Or"><a href="#Or" class="headerlink" title="Or"></a>Or</h2><ul><li><p>或，在逻辑中表示只需要两个部分的其中一个为真，那么整体就是真的意思。</p></li><li><p>日常生活中，也有带歧义的句子，比如“Study hard, or you will fail.”，这里的 or，并非上面的逻辑含义，而是带有否则的含义，使得两个部分的观点，不可能都为真，这样的 or 叫做 exclusive-or，而之前的 or 叫 inclusive-or。之后的逻辑中的 or 均为 inclusive 的 or。</p></li><li><p>让我们看看组合表认识一下这个逻辑，下面用 | 这个符号来表示或。</p></li></ul><table><thead><tr><th>A</th><th>B</th><th>A|B</th></tr></thead><tbody><tr><td>T</td><td>T</td><td>T</td></tr><tr><td>T</td><td>F</td><td>T</td></tr><tr><td>F</td><td>T</td><td>T</td></tr><tr><td>F</td><td>F</td><td>F</td></tr></tbody></table><h2 id="Not"><a href="#Not" class="headerlink" title="Not"></a>Not</h2><ul><li><p>否，就是否定观点，取相反的结论。</p></li><li><p>我们直接看看组合表，然后通过例子更深刻地来认识这个逻辑。下面表格用 ！ 来代表否定符号</p></li></ul><table><thead><tr><th>A</th><th>!A</th></tr></thead><tbody><tr><td>T</td><td>F</td></tr><tr><td>F</td><td>T</td></tr></tbody></table><ul><li><p>或许你已经觉得你掌握了 否，但请你再看看下面例子来加深你的理解。</p><ul><li>请问 “All the male will die.” 的否定结论是什么？</li><li>A. “All the male will not die.”</li><li>B. “All the female will die.”</li><li>C. “All the female will not die.”</li></ul></li><li><p>答案是，上述的选项都是错的，A 的否定并不完全，因为当所有的男性都会死亡不成立时，也不意味着所有男性都不会死亡，如果有一个男性不会死亡，结论依旧不成立；B 和 C 都有一个问题，在于更改了结论，原观点只是在讨论男性，B 和 C 说的都是女性，两者毫无关联，根本谈不上是结论。</p></li><li><p>一个对应的示例答案可以是 “At least one male will not die.”</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Introduction to Mathematical Thinking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】3371识别数组中的最大异常值</title>
      <link href="/posts/88712ee8.html"/>
      <url>/posts/88712ee8.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/identify-the-largest-outlier-in-an-array/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个整型数组，数组中分三种值，特殊数字，特殊数字的和，异常值，要求找到数组中可能要在的异常值的最大的值，并且异常值和特殊数字的和必须不同，但可以共享相同的值。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>面对这种有几个类型的值的情况，可以用未知数列出关系，从而窥见规律得以解题。</p><blockquote><p><a href="https://leetcode.cn/problems/identify-the-largest-outlier-in-an-array/solutions/3006328/mei-ju-yi-chang-zhi-pythonjavacgo-by-end-wb3g/">https://leetcode.cn/problems/identify-the-largest-outlier-in-an-array/solutions/3006328/mei-ju-yi-chang-zhi-pythonjavacgo-by-end-wb3g/</a></p></blockquote></li><li><p>首先设我们要求的异常值为 x，剩下的特殊值之和为 y，那么整个数组的和 total&#x3D;x+2*y（剩下的特殊值的数值和也是 y 嘛）。那么现在我们就可以发现，这就是 <a href="/posts/d26591e4.html" title="【Leetcode Daily】1两数之和">【Leetcode Daily】1两数之和</a>。</p></li><li><p>O(n)枚举的基本思路，可以看 <a href="/posts/d26591e4.html" title="【Leetcode Daily】1两数之和">【Leetcode Daily】1两数之和</a>。</p></li><li><p>有两种枚举方式</p><ul><li>一种是枚举异常值 x，那么就得要先计算 total - x求 y*2，进一步求 y。然后要确保 y 在数组中存在，以及 y 和 x 不是一个值的情况下，记录异常值的最大值；</li><li>另一种枚举特殊值 y，那么先计算 x&#x3D;total-2*y，然后检查 x 在数组中，且 x 可以不与 y 重合的情况下，就记录异常值的最大值。</li></ul></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getLargestOutlier</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># x + 2*y = total x是异常值，y是特殊数字和</span></span><br><span class="line">        <span class="comment"># 如果尝试枚举 y，就得下面这样子</span></span><br><span class="line">        <span class="comment"># rec = Counter(nums)</span></span><br><span class="line">        <span class="comment"># total = sum(nums)</span></span><br><span class="line">        <span class="comment"># max_num = -inf</span></span><br><span class="line">        <span class="comment"># for num in nums:</span></span><br><span class="line">        <span class="comment">#     x = total-2*num</span></span><br><span class="line">        <span class="comment">#     if rec[x] and (x!=num or rec[x]&gt;1):</span></span><br><span class="line">        <span class="comment">#         max_num = max(max_num, x)</span></span><br><span class="line">        <span class="comment"># return max_num</span></span><br><span class="line">        <span class="comment"># 如果想枚举 x</span></span><br><span class="line">        rec = Counter(nums)</span><br><span class="line">        total = <span class="built_in">sum</span>(nums)</span><br><span class="line">        max_num = -inf</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            num, left = <span class="built_in">divmod</span>(total-x, <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> left == <span class="number">0</span> <span class="keyword">and</span> rec[num] <span class="keyword">and</span> (x!=num <span class="keyword">or</span> rec[num]&gt;<span class="number">1</span>):</span><br><span class="line">                max_num  = <span class="built_in">max</span>(max_num, x)</span><br><span class="line">        <span class="keyword">return</span> max_num</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】16-24数对和</title>
      <link href="/posts/2234bbea.html"/>
      <url>/posts/2234bbea.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/pairs-with-sum-lcci/description/">题目链接</a>。</p></li><li><p>简单地说，就是找出一个整型数组中所有的数对（元素为2的整型数组），这些数对的数值之和为 target</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>在昨天题目（<a href="/posts/b8d7f2cb.html" title="【Leetcode Daily】1679K和数对的最大数目">【Leetcode Daily】1679K和数对的最大数目</a>）的基础上，不要求数对个数，而是求每个数对的内容，所以只要把记录个数的语句换成记录数对内容的语句即可，不多赘述。</p></li><li><p>O(n) 枚举的基本思想可以看 <a href="/posts/d26591e4.html" title="【Leetcode Daily】1两数之和">【Leetcode Daily】1两数之和</a>。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pairSums</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        rec = Counter()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> rec[target-num]:</span><br><span class="line">                rec[target-num] -= <span class="number">1</span></span><br><span class="line">                res.append([num, target-num])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                rec[num] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】1679K和数对的最大数目</title>
      <link href="/posts/b8d7f2cb.html"/>
      <url>/posts/b8d7f2cb.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/max-number-of-k-sum-pairs/">题目链接</a>。</p></li><li><p>简单地说，就是找出一个整型数组中有多少对数字和为 K。（不重复）</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>和 <a href="/posts/d26591e4.html" title="【Leetcode Daily】1两数之和">【Leetcode Daily】1两数之和</a> 几乎一致，只是本题要统计数量，之前的题只要找一对下标就行，故不多赘述。</p></li><li><p>O(n) 枚举的基本思想可以看 <a href="/posts/d26591e4.html" title="【Leetcode Daily】1两数之和">【Leetcode Daily】1两数之和</a>。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxOperations</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        rec = Counter()</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            couple = k - num</span><br><span class="line">            <span class="comment">#print(couple)</span></span><br><span class="line">            <span class="keyword">if</span> rec[couple]:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">                rec[couple] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                rec[num] += <span class="number">1</span></span><br><span class="line">            <span class="comment">#print(rec)</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】2342数位和相等数对的最大和</title>
      <link href="/posts/5d1c0b81.html"/>
      <url>/posts/5d1c0b81.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/max-sum-of-a-pair-with-equal-sum-of-digits/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个整型数组，找其中数位和相同的两两一组的数字，从中找每组数组和最大值。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>与 <a href="/posts/fb24ea29.html" title="【Leetcode Daily】2815数组中的最大数对和">【Leetcode Daily】2815数组中的最大数对和</a> 几乎相同，只是把每组数字的要求变化为数位和相同，故不多赘述。</p></li><li><p>O(n) 枚举的基本思想可以看 <a href="/posts/d26591e4.html" title="【Leetcode Daily】1两数之和">【Leetcode Daily】1两数之和</a>。</p></li><li><p>灵神看出本题的数位和不超过 10 位数字，故用长度 82 的数组当哈希表使用，确实能够提升效率。</p><blockquote><p><a href="https://leetcode.cn/problems/max-sum-of-a-pair-with-equal-sum-of-digits/solutions/2531487/mei-ju-you-wei-hu-zuo-pythonjavacgojsrus-eoys/">https://leetcode.cn/problems/max-sum-of-a-pair-with-equal-sum-of-digits/solutions/2531487/mei-ju-you-wei-hu-zuo-pythonjavacgojsrus-eoys/</a></p></blockquote></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> max_sum = <span class="number">-1</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; rec; <span class="comment">// 数位和 对 最大数值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp;i : nums) &#123;</span><br><span class="line">            <span class="type">int</span> place_sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> val = i; val &gt; <span class="number">0</span>; val /= <span class="number">10</span>) &#123;</span><br><span class="line">                place_sum += val % <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rec.<span class="built_in">find</span>(place_sum) != rec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                max_sum = <span class="built_in">max</span>(max_sum, rec[place_sum]+i);</span><br><span class="line">            &#125;</span><br><span class="line">            rec[place_sum] = <span class="built_in">max</span>(rec[place_sum], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】2815数组中的最大数对和</title>
      <link href="/posts/fb24ea29.html"/>
      <url>/posts/fb24ea29.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/max-pair-sum-in-an-array/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个数组，找出其中一对数的和的最大值，这对数要求最大数位数字相等，不存在的情况下返回 -1.</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>要求最大数位的值相同，那么就有十种情况，0-9，可以相当于维护长度为 10 的表，每个记录和比较大的情况，然后遍历数字，在表内有值的情况下计算和并记录，取最大值。</p><blockquote><p><a href="https://leetcode.cn/problems/max-pair-sum-in-an-array/solutions/2385996/yi-ci-bian-li-by-endlesscheng-6zt9/">https://leetcode.cn/problems/max-pair-sum-in-an-array/solutions/2385996/yi-ci-bian-li-by-endlesscheng-6zt9/</a></p></blockquote></li><li><p>O(n) 枚举的基本思想可以看 <a href="/posts/d26591e4.html" title="【Leetcode Daily】1两数之和">【Leetcode Daily】1两数之和</a>。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rec_val[<span class="number">10</span>]&#123;&#125;;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp;i : nums) &#123;</span><br><span class="line">            <span class="type">int</span> max_num = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> val = i;</span><br><span class="line">            <span class="keyword">while</span> (val &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                max_num = <span class="built_in">max</span>(max_num, val%<span class="number">10</span>);</span><br><span class="line">                val /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rec_val[max_num]!=<span class="number">0</span>) &#123;</span><br><span class="line">                res = <span class="built_in">max</span>(rec_val[max_num] + i, res);</span><br><span class="line">            &#125;</span><br><span class="line">            rec_val[max_num] = <span class="built_in">max</span>(rec_val[max_num], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Introduction to Mathematical Thinking】Lecture-0-and-Lecture-1-Background</title>
      <link href="/posts/46219e20.html"/>
      <url>/posts/46219e20.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>该课程可以在 <a href="https://www.coursera.org/learn/mathematical-thinking">coursera</a> 网站上免费学习，<a href="https://www.coursera.org/learn/mathematical-thinking">具体课程的链接就点这里跳转</a>。</p></li><li><p>陆爻齐不太指望学完这门课就能让自己走向人生巅峰（笑，只是对于像这种方法论类型的比较感兴趣，而且也是一个很好的锻炼英语的机会 ：）</p></li></ul><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><ul><li><p>本次笔记记录了学习 Lecture 0 、Lecture 1和阅读材料 Background Reading 的内容。</p></li><li><p>第一节课都会讲讲这门课到底讲啥，这门课的重要性，开设的理由什么的。</p></li></ul><h2 id="本课的目标，重要性，也就是开设的理由"><a href="#本课的目标，重要性，也就是开设的理由" class="headerlink" title="本课的目标，重要性，也就是开设的理由"></a>本课的目标，重要性，也就是开设的理由</h2><ul><li><p>让学生学会使用 mathematical thinking，直译过来应该叫“数学思维”。</p></li><li><p>在大学之前，我们所学的中学及之前的数学，都可以叫 “think inside the box”，意思就是，我们会学习各种各样的方法，对已有的问题提供的数字相关信息进行加工，最后得出一个结果。</p></li><li><p>这样的过程与烹饪料理书何曾相似，只要按照步骤一步步地加工，就能获得一个对应的结果。</p></li><li><p>但是，大学的要学的高等数学，或者更广义一些，对于未来在科研或是企业中所要遇到的各种问题，我们往往需要去应对这些未知的问题。而去将未知的问题化为已知的问题并解决，正是 mathematical thinking 所对应的，即 make unvisble to visble. 这样的思考，可以叫 “think outside the box”.</p></li><li><p>这种思考能够引领我们解决问题，而本系列的课程不会给我们提供各种解决问题的方法，而是引领我们尝试去思考出这些方法。</p></li></ul><h2 id="数学的有趣小背景"><a href="#数学的有趣小背景" class="headerlink" title="数学的有趣小背景"></a>数学的有趣小背景</h2><ul><li><p>数学的起始就是十分工具性的用处，与金钱相关（数钱嘛），在漫长的岁月力，往往是在现有数理难以解决问题进展迅速。而大部分我们今日所熟知的数学，其实就是这最近几百年的成果。</p></li><li><p>数学符号是数学的表示，而非数学本身。就像是乐谱上的乐符表示的音乐（的演奏），但这不是音乐，通过乐器（或是合成）出来的与人共鸣的声音才是音乐。同理，数学的本质，其实应该是透过数学符号的，你对这个世界的认知。</p></li></ul><h2 id="小附录"><a href="#小附录" class="headerlink" title="小附录"></a>小附录</h2><ul><li>雅思的学习还是很有用处的，记得之前想上这门课，感觉十分吃力，主要是难以接受大量的生词输入，而雅思正是锻炼了这种能力，词汇量确实需要增长，但对于不会的生词也能大致了解大意的能力更是宝贵。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Introduction to Mathematical Thinking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】2016增量元素之间的最大差值</title>
      <link href="/posts/cf91cc6f.html"/>
      <url>/posts/cf91cc6f.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/maximum-difference-between-increasing-elements/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个整型数组，求其中两个数的最大差值，要求是后一个数减去前一个数的差值，且两个数的下标不能相同。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>就是普通枚举，而且只要保存一个数的下标左侧数值的最小值，然后与当前枚举数字做差值，取最大即可。</p></li><li><p>整体思路与 <a href="/posts/47b722c.html" title="【Leetcode Daily】121买卖股票的最佳时机-枚举">【Leetcode Daily】121买卖股票的最佳时机-枚举</a> 的思路一致。</p></li><li><p>O(n) 枚举的基本思想可以看 <a href="/posts/d26591e4.html" title="【Leetcode Daily】1两数之和">【Leetcode Daily】1两数之和</a>。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumDifference</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> min_num = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> i : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; min_num) &#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res, i-min_num);</span><br><span class="line">            &#125;</span><br><span class="line">            min_num = <span class="built_in">min</span>(min_num, i);</span><br><span class="line">            <span class="comment">//cout &lt;&lt; min_num &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】2260必须拿起的最小连续卡牌数</title>
      <link href="/posts/7637bc73.html"/>
      <url>/posts/7637bc73.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/minimum-consecutive-cards-to-pick-up/">题目链接</a>。</p></li><li><p>简单地说，就是给一个整型数组，找出其中子数组的最短长度，该子数组需满足至少内部有一个数字是出现两次及以上的。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>求子数组的最短长度属于不定长滑动窗口可以解决的范畴，因此可以参考 <a href="/posts/a7b9ac4.html" title="【Leetcode Daily】2904最短且字典序最小的美丽子字符串">【Leetcode Daily】2904最短且字典序最小的美丽子字符串</a> 的思路与解决方式。</p></li><li><p>接下来介绍一下枚举的思路，枚举就要比不定长滑动窗口实现上简单不少。就是昨天的 <a href="/posts/a448255f.html" title="【Leetcode Daily】219存在重复元素II">【Leetcode Daily】219存在重复元素II</a> 的换了个语境，故不在此详细说明。</p></li><li><p>枚举的基本思路可以看 <a href="/posts/d26591e4.html" title="【Leetcode Daily】1两数之和">【Leetcode Daily】1两数之和</a>。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumCardPickup</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cards)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用不定长滑动窗口求最小窗口长度比较好解</span></span><br><span class="line">        <span class="comment">// int res = INT_MAX;</span></span><br><span class="line">        <span class="comment">// unordered_map&lt;int, int&gt; rec;</span></span><br><span class="line">        <span class="comment">// int left = 0;</span></span><br><span class="line">        <span class="comment">// for (const int i : cards) &#123;</span></span><br><span class="line">        <span class="comment">//     rec[i]++;</span></span><br><span class="line">        <span class="comment">//     // cout &lt;&lt; &quot;left:&quot; &lt;&lt; left &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//     while(rec[i] &gt;= 2) &#123;</span></span><br><span class="line">        <span class="comment">//         // cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; cards[left] &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//         // cout &lt;&lt; rec[i] &lt;&lt; &quot; &quot; &lt;&lt; rec[cards[left]] &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//         rec[cards[left]]--;</span></span><br><span class="line">        <span class="comment">//         if (rec[cards[left]] == 0) &#123;</span></span><br><span class="line">        <span class="comment">//             rec.erase(cards[left]);</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//         left++;</span></span><br><span class="line">        <span class="comment">//         int n = rec.size();</span></span><br><span class="line">        <span class="comment">//         res = min(res, n+1);</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return res==INT_MAX ? -1 : res;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 或者哈希表记录上一次的下标来枚举</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; rec;</span><br><span class="line">        <span class="type">int</span> res = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cards.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> index = cards[i];</span><br><span class="line">            <span class="keyword">if</span> (rec.<span class="built_in">find</span>(index)!=rec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                res = <span class="built_in">min</span>(res, i-rec[index]<span class="number">+1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            rec[index]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res==INT_MAX?<span class="number">-1</span>:res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】219存在重复元素II</title>
      <link href="/posts/a448255f.html"/>
      <url>/posts/a448255f.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/contains-duplicate-ii/">题目链接</a>。</p></li><li><p>简单地说，就是给一个整型数组和一个整数 K，要求出该整型数组中是否存在这么一对数字，数值相同，下标不同。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>易得，如果存在这么一组值，那么只需要让每个数字与此前与自己相同数值的比较即可，所以构建一哈希表，保存每个数值的最新下标用于对照即可。</p></li><li><p>基础的枚举思路可以参考 <a href="/posts/d26591e4.html" title="【Leetcode Daily】1两数之和">【Leetcode Daily】1两数之和</a>。</p></li><li><p>以及，本题是可以采用滑动窗口解决的，毕竟下标之差不大于 K，相当于可以构建长度为 K 的窗口滑动，哈希表只用维护窗口内的数值是否存在即可。</p><blockquote><p><a href="https://leetcode.cn/problems/contains-duplicate-ii/solutions/3041742/liang-chong-fang-fa-mei-ju-you-wei-hu-zu-kwjf/">https://leetcode.cn/problems/contains-duplicate-ii/solutions/3041742/liang-chong-fang-fa-mei-ju-you-wei-hu-zu-kwjf/</a></p></blockquote></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; latest_index;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (latest_index.<span class="built_in">find</span>(nums[i])!=latest_index.<span class="built_in">end</span>() &amp;&amp; i-latest_index[nums[i]] &lt;= k) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            latest_index[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 枚举 </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】121买卖股票的最佳时机-枚举</title>
      <link href="/posts/47b722c.html"/>
      <url>/posts/47b722c.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个整型数组，说这里的每个数字都是股票加个，你可以在任意时期购买股票并在后面卖出一次，请给出最大利润，若无利润则返回 0.</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>本题可以用动态规划或枚举的方法解决，这里介绍枚举的方法。</p></li><li><p>可以遍历数字，从左到右，视为找最大值，同时引入一变量记录目前左侧的最小值，不断计算当前最小值与最右值的差的最大值，就能得到答案。</p><blockquote><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/solutions/2464650/mei-ju-mai-chu-jie-ge-wei-hu-mai-ru-de-z-02ud/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/solutions/2464650/mei-ju-mai-chu-jie-ge-wei-hu-mai-ru-de-z-02ud/</a></p></blockquote></li><li><p>无需哈希表，毕竟用记录最小值即可。基础的枚举思路可看 <a href="/posts/d26591e4.html" title="【Leetcode Daily】1两数之和">【Leetcode Daily】1两数之和</a>。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> min_price = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp;i : prices) &#123;</span><br><span class="line">            min_price = <span class="built_in">min</span>(min_price, i);</span><br><span class="line">            res = <span class="built_in">max</span>(res, i-min_price);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】1128等价多米诺骨牌对的数量</title>
      <link href="/posts/6cb0c69b.html"/>
      <url>/posts/6cb0c69b.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/number-of-equivalent-domino-pairs/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个元素为长度2的vector的vector，找出其中所有元素 vector 相同的对数，其中相同指的是两个 vector，各个元素相同，或者第一个元素与另一个的第二个相同，剩余两个相同。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>用二维数组当哈希表记录即可，可以选择对一个数对维护两个哈希表位，但哈希表的维护消耗资源其实不小，所以直接调整数对统一数对中的大小相对顺序，就只要用一个位置对应一个数对。比如把（2，1）转化为（1，2）来看。</p></li><li><p>C++中，可以通过 minmax 构建一个第一个元素小于第二个元素的 pair。</p><blockquote><p><a href="https://leetcode.cn/problems/number-of-equivalent-domino-pairs/solutions/3661647/mei-ju-you-wei-hu-zuo-pythonjavaccgojsru-me3c/">https://leetcode.cn/problems/number-of-equivalent-domino-pairs/solutions/3661647/mei-ju-you-wei-hu-zuo-pythonjavaccgojsru-me3c/</a></p></blockquote></li><li><p>O(n) 枚举的基本思想可以看 <a href="/posts/d26591e4.html" title="【Leetcode Daily】1两数之和">【Leetcode Daily】1两数之和</a>。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numEquivDominoPairs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; dominoes)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> rec[<span class="number">10</span>][<span class="number">10</span>] = &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;v : dominoes) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [a, b] = <span class="built_in">minmax</span>(v[<span class="number">0</span>], v[<span class="number">1</span>]);</span><br><span class="line">            res += rec[a][b]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】2001可互换矩形的组数</title>
      <link href="/posts/298736a3.html"/>
      <url>/posts/298736a3.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/number-of-pairs-of-interchangeable-rectangles/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个二维数组，其中的每一个一维数组只有两位，表示每个矩形的宽和长，找出所有两两长宽比相同矩形的组数。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>最重要的一点，是发现所谓的矩形不过是障眼法，题目看的就是长宽比，所以逐个枚举长宽比并记录即可。</p></li><li><p>后续步骤与上一题完全一致：<a href="/posts/3e235446.html" title="【Leetcode Daily】1512好数对的数目">【Leetcode Daily】1512好数对的数目</a>。</p></li><li><p>O(n) 枚举的基本思想可以看 <a href="/posts/d26591e4.html" title="【Leetcode Daily】1两数之和">【Leetcode Daily】1两数之和</a>。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">interchangeableRectangles</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; rectangles)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">double</span>, <span class="type">int</span>&gt; rec;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;r : rectangles) &#123;</span><br><span class="line">            res += rec[(<span class="type">double</span>)r[<span class="number">0</span>]/r[<span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】1512好数对的数目</title>
      <link href="/posts/3e235446.html"/>
      <url>/posts/3e235446.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/number-of-good-pairs/description/">题目链接</a>。</p></li><li><p>简单地说，就是找出数组中所有数值相同的数对（好数对）数目，但是数对内的两个值下标不能相同，且交换位置仍视作一个数对。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>本题就是很基础的枚举题，如果暴力方法就是一个循环遍历数对左侧，另一循环遍历右侧，复杂度为 O(n^2)。</p></li><li><p>而相对高效的枚举方法为，只用一次循环，遍历到的数字记录到哈希表上各个数值出现的频次，每次遇到一个值，就可以查其左边有多少相同值，也就出现了多少的好数对。</p></li><li><p>换句话，就是遍历数对的右侧值，并以 O(1) 的复杂度记录其左侧的情况。</p></li><li><p>枚举的思路以及先记录答案再更新记录的原因可看 <a href="/posts/d26591e4.html" title="【Leetcode Daily】1两数之和">【Leetcode Daily】1两数之和</a> </p></li><li><p>灵神把中间的记录的方式极度地简化，可以借鉴这种思路。</p><blockquote><p><a href="https://leetcode.cn/problems/number-of-good-pairs/solutions/2974653/mei-ju-you-wei-hu-zuo-pythonjavaccgojsru-7u5v/">https://leetcode.cn/problems/number-of-good-pairs/solutions/2974653/mei-ju-you-wei-hu-zuo-pythonjavaccgojsru-7u5v/</a></p></blockquote></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numIdenticalPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; rec;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp;i : nums) &#123;</span><br><span class="line">            res += rec[i]++;</span><br><span class="line">            <span class="comment">// const auto &amp;it = rec.find(i);</span></span><br><span class="line">            <span class="comment">// if (it!=rec.end()) &#123;</span></span><br><span class="line">            <span class="comment">//     res += it-&gt;second;</span></span><br><span class="line">            <span class="comment">//     it-&gt;second++;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">// else &#123;</span></span><br><span class="line">            <span class="comment">//     rec[i]++;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】2441与对应负数同时存在的最大正整数</title>
      <link href="/posts/361de13.html"/>
      <url>/posts/361de13.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/largest-positive-integer-that-exists-with-its-negative/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个数组，找一种一组值相加为 0，且在多组这样的值中，选出正数最大的数值返回。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><a href="/posts/d26591e4.html" title="【Leetcode Daily】1两数之和">【Leetcode Daily】1两数之和</a> ，在这个枚举上，要求相加为零，不过不用记录下标，因此可以采用 set 来记录遍历的值。<blockquote><p><a href="https://leetcode.cn/problems/largest-positive-integer-that-exists-with-its-negative/solutions/1895719/by-endlesscheng-jjtb/">https://leetcode.cn/problems/largest-positive-integer-that-exists-with-its-negative/solutions/1895719/by-endlesscheng-jjtb/</a></p></blockquote></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> max_int = <span class="number">-1</span>;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; rec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp;i : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rec.<span class="built_in">count</span>(-i)) &#123;</span><br><span class="line">                max_int = <span class="built_in">max</span>(max_int, <span class="built_in">abs</span>(i));</span><br><span class="line">            &#125;</span><br><span class="line">            rec.<span class="built_in">insert</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_int;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class Solution &#123;</span></span><br><span class="line"><span class="comment">// public:</span></span><br><span class="line"><span class="comment">//     int findMaxK(vector&lt;int&gt;&amp; nums) &#123;</span></span><br><span class="line"><span class="comment">//         int max_int = -1;</span></span><br><span class="line"><span class="comment">//         int index = 0;</span></span><br><span class="line"><span class="comment">//         unordered_map&lt;int, int&gt; rec;</span></span><br><span class="line"><span class="comment">//         for (const int &amp;i : nums) &#123;</span></span><br><span class="line"><span class="comment">//             if (rec.find(-i)!=rec.end() &amp;&amp; abs(i) &gt; max_int) &#123;</span></span><br><span class="line"><span class="comment">//                 max_int = abs(i);</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//             rec[i] = index++;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         return max_int;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】1两数之和</title>
      <link href="/posts/d26591e4.html"/>
      <url>/posts/d26591e4.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/two-sum/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个整型数组和目标值，从数组中找出两个值之和正好为目标值的下标，题目保证数组不重复，且必有唯一答案。要求两个下标不能相同。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>暴力法就是直接上两层循环，本题的目标是把时间复杂度降到O(n)。</p></li><li><p>下面就是灵神题解中介绍枚举方法，一个循环遍历一个值，每次遍历就在哈希表查找剩余另一个的值，没找到就把当前值和对应下标存哈希表。</p><blockquote><p><a href="https://leetcode.cn/problems/two-sum/solutions/2326193/dong-hua-cong-liang-shu-zhi-he-zhong-wo-0yvmj/">https://leetcode.cn/problems/two-sum/solutions/2326193/dong-hua-cong-liang-shu-zhi-he-zhong-wo-0yvmj/</a></p></blockquote></li><li><p>注意，顺序很重要，不能先放哈希表再查找，不然就会找到相同下标的情况。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; rec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> &amp;it = rec.<span class="built_in">find</span>(target-nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (it!=rec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;it-&gt;second, i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            rec[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】3488距离最小相等元素查询</title>
      <link href="/posts/24991b84.html"/>
      <url>/posts/24991b84.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/closest-equal-element-queries/">题目链接</a>。</p></li><li><p>简单地说，就是给两个整数数组，把一个数组中的各个数字作为目标下标，求每个目标下标在另一个数组（循环数组）对应数字左右侧与自己最相近的同值元素距离（没有则取-1）。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>陆爻齐原本想的是把数组加倍，然后对每个目标下标做一个记录的向量，再用二分找位置。但灵神的处理更好，就是给下标数组加上上一数组（循环数组的上一个循环）的最后一个下标和下一数组的第一个下标。</p><blockquote><p><a href="https://leetcode.cn/problems/closest-equal-element-queries/solutions/3613906/er-fen-cha-zhao-jian-ji-xie-fa-pythonjav-516v/">https://leetcode.cn/problems/closest-equal-element-queries/solutions/3613906/er-fen-cha-zhao-jian-ji-xie-fa-pythonjav-516v/</a></p></blockquote></li><li><p>基本的二分思路，请看<a href="/posts/ee27b191.html" title="【Leetcode Daily】34在排序数组中查找元素的第一个和最后一个位置">【Leetcode Daily】34在排序数组中查找元素的第一个和最后一个位置</a>。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">solveQueries</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; rec;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            rec[nums[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[_, v] : rec) &#123;</span><br><span class="line">            v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">back</span>()-n); <span class="comment">// 上一个循环最后一个</span></span><br><span class="line">            v.<span class="built_in">push_back</span>(v[<span class="number">1</span>] + n); <span class="comment">// 下一个循环第一个</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for (auto &amp;p : rec) &#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; p.first &lt;&lt; &quot;:&quot; &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//     for (int &amp;i: p.second) &#123;</span></span><br><span class="line">        <span class="comment">//         cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> &amp;i : queries) &#123;</span><br><span class="line">            <span class="keyword">auto</span> &amp;v = rec[nums[i]];</span><br><span class="line">            <span class="keyword">if</span> (v.<span class="built_in">size</span>()==<span class="number">3</span>) i = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> index = ranges::<span class="built_in">lower_bound</span>(v, i)-v.<span class="built_in">begin</span>();</span><br><span class="line">                <span class="comment">//cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; index &lt;&lt; endl;</span></span><br><span class="line">                i = <span class="built_in">min</span>(i - v[index - <span class="number">1</span>], v[index + <span class="number">1</span>] - i);</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queries;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】LeetcodeDailySummary-滑动窗口小结</title>
      <link href="/posts/e5148ede.html"/>
      <url>/posts/e5148ede.html</url>
      
        <content type="html"><![CDATA[<h1 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h1><ul><li><p>该算法主要分为定长滑动窗口和不定长滑动窗口，前者由于窗口大小固定，往往是来求窗口内某种极值，极大、极小或者其它事物，后者则专注于求子数组&#x2F;子字符串的数量。</p></li><li><p>不定长滑动窗口有的会尽可能追求窗口长度的极值，又会因为题目，细分几个种类，比如越长越满足、越短月满足，或者刚好满足的情况。</p></li></ul><h1 id="定长滑动窗口"><a href="#定长滑动窗口" class="headerlink" title="定长滑动窗口"></a>定长滑动窗口</h1><ul><li><p>基本的思路是，先是初始化一个定长的窗口，初始化到窗口长度减一，然后在循环过程中，先加入新元素，达到窗口满足大小的情况，然后自行检查窗口是否满足题目条件，并更新记录数值。随后退出最旧的元素。</p></li><li><p>示例题目与更为详细的思路讲解在博客 <a href="/posts/92a38711.html" title="【Leetcode Daily】1456定长子串中元音的最大数目">【Leetcode Daily】1456定长子串中元音的最大数目</a></p></li></ul><h1 id="不定长滑动窗口"><a href="#不定长滑动窗口" class="headerlink" title="不定长滑动窗口"></a>不定长滑动窗口</h1><ul><li><p>与定长滑动窗口的不同之处在于，不需要开始先把窗口调整至某个状态，只需要不断地加入元素，检查条件，然后在不满足条件时，持续退出旧元素，直到再次满足条件。</p></li><li><p>至于几种分类，对于求满足条件窗口长度，只要每次循环持续更新记录数值的最大或最小就好，像是博客 <a href="/posts/a7b9ac4.html" title="【Leetcode Daily】2904最短且字典序最小的美丽子字符串">【Leetcode Daily】2904最短且字典序最小的美丽子字符串</a>。</p></li><li><p>而子数组长度，对于越长越合法类型，相当于遍历右节点，统计左节点的可能，每次满足条件，就直接加上左节点的下标值到结果上，因为该左节点与其更左的节点下标都一定会满足，“越长越合法”嘛，比如博客 <a href="/posts/83629f2c.html" title="【Leetcode Daily】1358包含所有三种字符的子字符串数目">【Leetcode Daily】1358包含所有三种字符的子字符串数目</a>；</p></li><li><p>于此相对，“越短越合法”则是满足条件后，给结果累计 right-left+1 的下标，比如博客 <a href="/posts/946aa542.html" title="【Leetcode Daily】713乘积小于K的子数组">【Leetcode Daily】713乘积小于K的子数组</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】2080区域内查询数字的频率</title>
      <link href="/posts/59db4b70.html"/>
      <url>/posts/59db4b70.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/range-frequency-queries/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个数组，要求建立一个数据结构，使得输入一个区间和一个目标值，可以返回目标值在区间内的出现频率。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>用二分可以加速有序数组的查找效率，所以陆爻齐开始的思路是，截取区间数组，排序，然后二分查找上界与下界之差。然后在最后的几个样例超时了。</p></li><li><p>这时就显现灵神题解的强大了，如何快速查找一个区间内有几个这个数字呢？只要先把各个数字的下标用 map 记录即可，每个数字对应一串下标，由于初始化时就是从前往后，所以不用排序。</p></li><li><p>记录下标后，不是查询时会给区间嘛，用区间的上下界，在对应目标值的下标数组中，二分查找自己的位置，然后做差就可以得到这个区间内数字的频率了，毕竟此时这两位置之间就是之前数字的下标。</p><blockquote><p><a href="https://leetcode.cn/problems/range-frequency-queries/solutions/1113439/tong-ji-wei-zhi-er-fen-wei-zhi-by-endles-8l9u/">https://leetcode.cn/problems/range-frequency-queries/solutions/1113439/tong-ji-wei-zhi-er-fen-wei-zhi-by-endles-8l9u/</a></p></blockquote></li><li><p>这里补充一下，ranges 库的 upper 和 lower_bound 分别可以看作，找第一个大于 val 的下标和找第一个大于等于 val 的下标。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RangeFreqQuery</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RangeFreqQuery</span>(vector&lt;<span class="type">int</span>&gt;&amp; arr) &#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            rec[arr[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = rec.<span class="built_in">find</span>(value);</span><br><span class="line">        <span class="keyword">if</span> (it == rec.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; &amp;arr = it-&gt;second;</span><br><span class="line">        <span class="keyword">return</span> ranges::<span class="built_in">upper_bound</span>(arr, right)-ranges::<span class="built_in">lower_bound</span>(arr, left);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; rec;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RangeFreqQuery object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * RangeFreqQuery* obj = new RangeFreqQuery(arr);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;query(left,right,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】1170比较字符串最小字母出现频次</title>
      <link href="/posts/5cf033f6.html"/>
      <url>/posts/5cf033f6.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/compare-strings-by-frequency-of-the-smallest-character/description/">题目链接</a>。</p></li><li><p>简单地说，就是给两个字符串数组，看一个数组中各个字符串的最小字母频次，在另一个数组所有字符串的最小字母频次中，排第几。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>分别对两个数组做转换成最小字母频次的整型数组，然后让一个数组的各值在另一个数组做二分查找找到自己的位置即可。</p></li><li><p>二分的基本思想在 <a href="/posts/ee27b191.html" title="【Leetcode Daily】34在排序数组中查找元素的第一个和最后一个位置">【Leetcode Daily】34在排序数组中查找元素的第一个和最后一个位置</a>。</p></li><li><p>重点注意一个小问题，字典序的顺序与数字不同，字典序中 2 比 10 大，因为 2 大于 10 的第一位 1，所以 2 更大。正因如此，不能在 string 的数组上直接排序。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">numSmallerByFrequency</span><span class="params">(vector&lt;string&gt;&amp; queries, vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (string &amp;s : queries) &#123;</span><br><span class="line">            <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">            <span class="type">char</span> tar = s[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> index = ranges::<span class="built_in">upper_bound</span>(s, tar) - s.<span class="built_in">begin</span>();</span><br><span class="line">            q.<span class="built_in">push_back</span>(index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; w;</span><br><span class="line">        <span class="keyword">for</span> (string &amp;s : words) &#123;</span><br><span class="line">            <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">            <span class="type">char</span> tar = s[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> index = ranges::<span class="built_in">upper_bound</span>(s, tar) - s.<span class="built_in">begin</span>();</span><br><span class="line">            w.<span class="built_in">push_back</span>(index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(w.<span class="built_in">begin</span>(), w.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(q.size())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            res[i] = w.<span class="built_in">end</span>()-ranges::<span class="built_in">upper_bound</span>(w, q[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】2389和有限的最长子序列</title>
      <link href="/posts/f81bf6b7.html"/>
      <url>/posts/f81bf6b7.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/longest-subsequence-with-limited-sum/description/">题目链接</a>。</p></li><li><p>简单地说，就是求一个数组的每个值，与另一个数组子序列和的关系，在子序列和不超过这个值的前提下，求最长子序列的长度。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>前缀和+二分 </p><blockquote><p><a href="https://leetcode.cn/problems/longest-subsequence-with-limited-sum/solutions/1781111/fei-bao-li-zuo-fa-qian-zhui-he-er-fen-by-ny4m/">https://leetcode.cn/problems/longest-subsequence-with-limited-sum/solutions/1781111/fei-bao-li-zuo-fa-qian-zhui-he-er-fen-by-ny4m/</a></p></blockquote></li><li><p>为了使得子序列长度越长，要尽可能选取数值较小的元素。所以先排序，然后用前缀和得到各个子序列的和。</p></li><li><p>具体实现中，前缀和用 numeric 库的 partial_sum 实现，而二分就直接用 ranges 库的 upper_bound 函数，之所以不用 lower_bound 是因为本题要求“不超过”，而非小于。当然，用加一值的lower_cound也行。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">answerQueries</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        ranges::<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 排序</span></span><br><span class="line">        <span class="built_in">partial_sum</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), nums.<span class="built_in">begin</span>()); <span class="comment">// 前缀和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> &amp;q : queries) &#123;</span><br><span class="line">            <span class="comment">//q = ranges::upper_bound(nums, q) - nums.begin();</span></span><br><span class="line">            q = ranges::<span class="built_in">lower_bound</span>(nums, q<span class="number">+1</span>) - nums.<span class="built_in">begin</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queries;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 二分 </tag>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>备忘录 | ToDoList</title>
      <link href="/posts/83a53e85.html"/>
      <url>/posts/83a53e85.html</url>
      
        <content type="html"><![CDATA[<ul><li><p><input disabled="" type="checkbox"> Leetcode刷题，不急，慢慢学 2025.04.08-?</p></li><li><p><input disabled="" type="checkbox"> ESLpod 2025.06.23-?</p></li><li><p><input disabled="" type="checkbox"> 按照每天两个 Lecture 的量推进 Mathatical Thinking 课程 2025.06.26-2025.07.09</p></li><li><p><input checked="" disabled="" type="checkbox"> qt作业三 2025.06.13</p></li><li><p><input checked="" disabled="" type="checkbox"> 恢复 LALC 的 pr 维护事项 2025.06.13-17</p></li><li><p><input checked="" disabled="" type="checkbox"> 完成可视化的报告 2025.06.13-14</p></li><li><p><input checked="" disabled="" type="checkbox"> 紧急备战**考试 2025.06.12</p></li><li><p><input checked="" disabled="" type="checkbox"> 完成数据库安全的报告 2025.06.06-2025.06.07</p></li><li><p><input checked="" disabled="" type="checkbox"> 完成编译原理期末考试<del>（垂死挣扎）</del> 2025.06.05</p></li><li><p><input checked="" disabled="" type="checkbox"> 调整博客首页，隐藏像 Leetcode Daily 隐藏这样偏向记录形式的文章 2025.06.03</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】1385两个数组间的距离值</title>
      <link href="/posts/1f2eed63.html"/>
      <url>/posts/1f2eed63.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/find-the-distance-value-between-two-arrays/">题目链接</a>。</p></li><li><p>简单地说，就是给两个数组，求一个数组在另一数组不满足与其中一个值的一定区间内的元素数量。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>如何实现二分可看<a href="/posts/ee27b191.html" title="【Leetcode Daily】34在排序数组中查找元素的第一个和最后一个位置">【Leetcode Daily】34在排序数组中查找元素的第一个和最后一个位置</a>。</p></li><li><p>重点在于深刻理解二分的含义，比如上面样例的二分返回的下标的含义，其实是第一个大于目标值的下标，在这个基础上，如何该值同时已经超过目标值的区间，就说明满足题意。</p><blockquote><p><a href="https://leetcode.cn/problems/find-the-distance-value-between-two-arrays/solutions/3010185/liang-chong-fang-fa-er-fen-cha-zhao-san-15u9b/">https://leetcode.cn/problems/find-the-distance-value-between-two-arrays/solutions/3010185/liang-chong-fang-fa-er-fen-cha-zhao-san-15u9b/</a></p></blockquote></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lowerBound</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> tar)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; tar) &#123;</span><br><span class="line">                left = mid<span class="number">+1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTheDistanceValue</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr1, vector&lt;<span class="type">int</span>&gt;&amp; arr2, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(arr<span class="number">2.</span><span class="built_in">begin</span>(), arr<span class="number">2.</span><span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp; i : arr1) &#123;</span><br><span class="line">            <span class="type">int</span> index = <span class="built_in">lowerBound</span>(arr2, i-d);</span><br><span class="line">            <span class="keyword">if</span> (index == arr<span class="number">2.</span><span class="built_in">size</span>() || arr2[index] &gt; i + d) &#123;</span><br><span class="line">                ans+=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】2300咒语和药水的成功对数</title>
      <link href="/posts/22da0b5d.html"/>
      <url>/posts/22da0b5d.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/description/">题目链接</a>。</p></li><li><p>简单地说，就是给两个数组和一个目标值，求一个数组中的每个值，与另一数组每个值之积大于目标值的个数。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>先要对数组做排序，这要才能二分查找，然后对一个数组的每个值做一次二分查找，就确认了个数，毕竟是有序的，右侧之积都不满足的情况下，左侧之积必然不满足。</p></li><li><p>二分的基本思路可以看 <a href="/posts/ee27b191.html" title="【Leetcode Daily】34在排序数组中查找元素的第一个和最后一个位置">【Leetcode Daily】34在排序数组中查找元素的第一个和最后一个位置</a>。</p></li><li><p>不过，灵神的题解通过引入上取整和下取整的转换简化了不等式的比较，但暂且不甚理解，先放这里，说不定之后突然明白了呢。</p><blockquote><p><a href="https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/solutions/1595712/by-endlesscheng-1kbp/">https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/solutions/1595712/by-endlesscheng-1kbp/</a></p></blockquote></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">successfulPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; spells, vector&lt;<span class="type">int</span>&gt;&amp; potions, <span class="type">long</span> <span class="type">long</span> success)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(spells.size())</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(potions.<span class="built_in">begin</span>(), potions.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; spells.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> s = spells[i];</span><br><span class="line">            <span class="type">int</span> left = <span class="number">0</span>, right = potions.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">                <span class="type">int</span> mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (s*potions[mid] &lt; success) &#123;</span><br><span class="line">                    left = mid<span class="number">+1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    right = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = potions.<span class="built_in">size</span>()-left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】2529正整数和负整数的最大计数</title>
      <link href="/posts/8439e296.html"/>
      <url>/posts/8439e296.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个整数数组，求其中负整数和正整数数目中的最大值，0 不属于两者。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>本题暴力枚举也能 ac，下面就说说二分的写法。</p></li><li><p>就是解决两个问题，一是如何二分查找，二是如何利用二分找一个目标值的左部和右部。都在<a href="/posts/ee27b191.html" title="【Leetcode Daily】34在排序数组中查找元素的第一个和最后一个位置">【Leetcode Daily】34在排序数组中查找元素的第一个和最后一个位置</a>有所回答。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lowerBound</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid<span class="number">+1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> neg = <span class="built_in">lowerBound</span>(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> pos = nums.<span class="built_in">size</span>()-<span class="built_in">lowerBound</span>(nums, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//cout &lt;&lt; neg &lt;&lt; &quot; &quot; &lt;&lt; pos &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(neg, pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】744寻找比目标字母大的最小字母</title>
      <link href="/posts/c1a4c7b7.html"/>
      <url>/posts/c1a4c7b7.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/find-smallest-letter-greater-than-target/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个非递减顺序的字符数组，和一个字符 target，求数组中字典序大于 target 字符中最小的字符。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>解决三个问题就能做出本题，1. 二分怎么写；2. 怎么找二分目标值的后一个（前一个同理）；3. 如何正确检查目标字符是否存在；</p></li><li><p>前两个问题在 <a href="/posts/ee27b191.html" title="【Leetcode Daily】34在排序数组中查找元素的第一个和最后一个位置">【Leetcode Daily】34在排序数组中查找元素的第一个和最后一个位置</a> 中已说明，第三个问题在 <a href="/posts/c8c75710.html" title="【Leetcode Daily】704二分查找">【Leetcode Daily】704二分查找</a>也有所说明。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">nextGreatestLetter</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; letters, <span class="type">char</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = letters.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (letters[mid] &lt; target<span class="number">+1</span>) &#123;</span><br><span class="line">                left = mid<span class="number">+1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; left &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">return</span> (left &lt; letters.<span class="built_in">size</span>() &amp;&amp; letters[left] &gt; target) ? letters[left] : letters[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】704二分查找</title>
      <link href="/posts/c8c75710.html"/>
      <url>/posts/c8c75710.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/binary-search/">题目链接</a>。</p></li><li><p>简单地说，就是给一个升序不重复的整型数组和一个目标值 target，找出 target 在数组中的下标，若 target 不存在，则返回 -1.</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>看似与<a href="/posts/3cd7fbc1.html" title="【Leetcode Daily】35搜索插入位置">【Leetcode Daily】35搜索插入位置</a>相似，但有一个需要特别注意的地方，那就是本题在搜索完成后，需要取左指针 left 对应的值来查看 target 是否存在。</p></li><li><p>这个就会要求 left 指针应当不超过数组边界，因为此前的基本思路中（<a href="/posts/ee27b191.html" title="【Leetcode Daily】34在排序数组中查找元素的第一个和最后一个位置">【Leetcode Daily】34在排序数组中查找元素的第一个和最后一个位置</a>只能保证 left 指针的左侧所有下标元素均小于目标值，而不能保证 left 指针本身合法。</p></li><li><p>换句话，如果数组中所有元素小于目标值，那么 left 指针就会滑到 <code>nums.size()</code> 这个下标处，而下标的最大值是 <code>nums.size()-1</code>，就可能会不合法，需要在检测 target 是否存在前，先检测 left 是否合法。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> middle = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle<span class="number">+1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (left &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[left]==target) ? left : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】35搜索插入位置</title>
      <link href="/posts/3cd7fbc1.html"/>
      <url>/posts/3cd7fbc1.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/search-insert-position/">题目链接</a>。</p></li><li><p>简单地说，给一个升序的无重复元素数组和目标值，找到该值的下标，如果数组中无目标值，则返回应该插入的地方</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>基本思路可看<a href="/posts/ee27b191.html" title="【Leetcode Daily】34在排序数组中查找元素的第一个和最后一个位置">【Leetcode Daily】34在排序数组中查找元素的第一个和最后一个位置</a>。</p></li><li><p>回到本题，要求这个“位置”，其实就是左指针，因为左指针确保 left-1 小于 target，循环到最后，left 本身一定是 target 应该所属的位置。</p></li><li><p>此外，c++ 的 ranges 库自带二分的低边界，可以写<code>ranges::lower_bound(nums, target)</code>来得到指向目标值左侧边界的迭代器，减去起始迭代器 begin() 就得到下标了。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>(), middle = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            middle = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle]&lt;target) &#123;</span><br><span class="line">                left = middle<span class="number">+1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">        <span class="comment">// return ranges::lower_bound(nums, target)-nums.begin();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】34在排序数组中查找元素的第一个和最后一个位置</title>
      <link href="/posts/ee27b191.html"/>
      <url>/posts/ee27b191.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个不降序数组和一个目标值 target，求数组中这个 target 值的下标区间，若无则返回{-1，-1}。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><blockquote><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/1980196/er-fen-cha-zhao-zong-shi-xie-bu-dui-yi-g-t9l9/">https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/1980196/er-fen-cha-zhao-zong-shi-xie-bu-dui-yi-g-t9l9/</a></p></blockquote><ul><li><p>二分查找的开始，虽然算法早就学过，但灵神的讲解十分透彻，十分值得学习。</p></li><li><p>下面的二分，都以如果中间量小于目标量左指针动，否则右指针动的情况，这样会求得二分值的最左处。</p></li><li><p>二分的灵魂在于循环不变量，即在循环中不变的东西，比如，左右指针的区间含义是闭区间，左闭右开，亦或开区间就很重要；还有循环结束后左右指针的位置也是，拿左闭右开举例，结束后，左右指针都处于target值最左处下标，因为左指针保持了 left-1 处必定小于 target，而右指针则保持了 right 处必定大于等于 target。</p></li><li><p>此外要记得溢出的处理问题，除 python 外，求二分的中间下标如果用<code>(left+right)/2</code>的写法可能会溢出，所以要改写为<code>left+(right-left)/2</code>这样就减少了大于阈值的可能。</p></li><li><p>那么目标值的右侧下标怎么求呢？回顾上面左指针的定义，可以保持 left-1 处必定小于 target，那么如果求得 target+1 的左指针位置，那么该位置减一就是 target 的右边界嘛。即使 target+1 这个值不存在，也不妨碍找到这个位置。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lowerBound</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> middle = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            middle = left +(right-left)/<span class="number">2</span>; <span class="comment">// 除python外，防溢出的写法</span></span><br><span class="line">            <span class="keyword">if</span> (nums[middle]&lt;target) &#123;</span><br><span class="line">                left = middle<span class="number">+1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; left &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> start = <span class="built_in">lowerBound</span>(nums, target);</span><br><span class="line">        <span class="keyword">if</span> (start == nums.<span class="built_in">size</span>() || nums[start] != target) <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> end = <span class="built_in">lowerBound</span>(nums, target<span class="number">+1</span>)<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;start, end&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】1248统计优美子数组</title>
      <link href="/posts/914e0b28.html"/>
      <url>/posts/914e0b28.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/count-number-of-nice-subarrays/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个整数数组和一个整数 k，要求其中所有子数组的数量，不过子数组需要满足一个条件，即其中的奇数的个数恰好为 k。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>和<a href="/posts/e20623c8.html" title="【Leetcode Daily】930和相同的二元子数组">【Leetcode Daily】930和相同的二元子数组</a>类似的恰好型不定长滑动窗口，不过本题让陆爻齐更深入的思考，越长越合法的左指针的意义。</p></li><li><p>“众”所周知，我们灵神派的越长越合法类型的解法，是通过累计窗口左指针数值之和计算得出，其意义，除了充当窗口的左侧边界，实质意义可以理解为，窗口左侧满足条件的情况数目，而窗口本身是在遍历右指针情况，这样一来就算是统计了所有情况。</p></li><li><p>拿第一次满足条件的窗口举例，此时，窗口的左侧还在起点，下标为 0，示意着此前没有满足条件的情况，进入中间的循环，循环的作用是找出不满足条件的边界；如果第一个元素（下标为 0 的那个）恰好是窗口需要的元素，那么左指针右移一步后，因窗口不符合条件而终止循环，此时左指针下标为 1，同时也寓意着以后的窗口都有这一个合法情况。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberOfSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left1 = <span class="number">0</span>, left2 = <span class="number">0</span>, goal1 = k, goal2 = k<span class="number">+1</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, count1 = <span class="number">0</span>, count2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; nums.<span class="built_in">size</span>(); right++) &#123;</span><br><span class="line">            count1 += nums[right]&amp;<span class="number">1</span>;</span><br><span class="line">            count2 += nums[right]&amp;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(count1 &gt;= goal1) &#123;</span><br><span class="line">                count1 -= nums[left1++]&amp;<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(count2 &gt;= goal2) &#123;</span><br><span class="line">                count2 -= nums[left2++]&amp;<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += left1-left2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 不定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】930和相同的二元子数组</title>
      <link href="/posts/e20623c8.html"/>
      <url>/posts/e20623c8.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/binary-subarrays-with-sum/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个整数数组和目标整数 goal，求子数组和恰好为 goal 的子数组数量。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>这是“恰好型滑动窗口”，本质上就是两个越长越合法的窗口结果之差。</p></li><li><p>实现有两个方式，一个是单独把滑动窗口划分一个函数，调用两次，求结果之差；另一个是只设置一次滑动窗口，不过要同时维护两个左指针，计算结果是直接累计数值之差。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubarraysWithSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> goal)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left1 = <span class="number">0</span>, left2 = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum1 = <span class="number">0</span>, sum2 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> goal1 = goal, goal2 = goal<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; nums.<span class="built_in">size</span>(); right++) &#123;</span><br><span class="line">            sum1 += nums[right];</span><br><span class="line">            sum2 += nums[right];</span><br><span class="line">            <span class="keyword">while</span>(sum1 &gt;= goal1&amp;&amp;left1 &lt;= right) &#123;</span><br><span class="line">                sum1-=nums[left1++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(sum2 &gt;= goal2 &amp;&amp; left2 &lt;= right) &#123;</span><br><span class="line">                sum2-=nums[left2++];</span><br><span class="line">            &#125;</span><br><span class="line">            ans += left1-left2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 不定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】LCP68美观的花束</title>
      <link href="/posts/e5b0d046.html"/>
      <url>/posts/e5b0d046.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/1GxJYY/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个数组，和一个整数 K，要求返回所有满足条件的子数组数目。条件是子数组内每个数字的数目不超过 K。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li>很无聊的越短越合法不定长滑动窗口（<a href="/posts/946aa542.html" title="【Leetcode Daily】713乘积小于K的子数组">【Leetcode Daily】713乘积小于K的子数组</a>），甚至不需要按照题目所说来取模就可以 ac。</li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">beautifulBouquet</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; flowers, <span class="type">int</span> cnt)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; rec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; flowers.<span class="built_in">size</span>(); right++) &#123;</span><br><span class="line">            <span class="type">int</span> index = flowers[right];</span><br><span class="line">            rec[index]++;</span><br><span class="line">            <span class="keyword">while</span>(rec[index] &gt; cnt) &#123;</span><br><span class="line">                rec[flowers[left++]]--;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += (right-left<span class="number">+1</span>)%<span class="number">1000000007</span>;</span><br><span class="line">            ans %= <span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】2762不间断数组</title>
      <link href="/posts/23cfa8ee.html"/>
      <url>/posts/23cfa8ee.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/continuous-subarrays/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个整数数组，并找出其中所有子数组的数目，子数组的要求为其中任意两元素之差不大于 2.</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>越短越合法的不定长滑动窗口的简单变式（<a href="/posts/946aa542.html" title="【Leetcode Daily】713乘积小于K的子数组">【Leetcode Daily】713乘积小于K的子数组</a></p></li><li><p>暴力一点的思路，是每次窗口变动，都遍历一边窗口内的元素找其中最大值与最小值之差，但是这样的话，复杂度就是 O(n^2)，所以解决这个问题就是本题关键。</p></li><li><p>以 C++ 的角度，无论是 map 还是 multiset 都能实现本题，陆爻齐采用 map 的方式，可以 O(1) 地取到窗口内的最大值和最小值，只要对首尾迭代器取 first 就行，毕竟这里看的是值差，并非数目差。</p><blockquote><p><a href="https://leetcode.cn/problems/continuous-subarrays/solutions/2327219/shuang-zhi-zhen-ping-heng-shu-ha-xi-biao-4frl/">https://leetcode.cn/problems/continuous-subarrays/solutions/2327219/shuang-zhi-zhen-ping-heng-shu-ha-xi-biao-4frl/</a></p></blockquote></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">continuousSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; rec;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; nums.<span class="built_in">size</span>(); right++) &#123;</span><br><span class="line">            rec[nums[right]]++;</span><br><span class="line">            <span class="keyword">while</span>(!rec.<span class="built_in">empty</span>() &amp;&amp; rec.<span class="built_in">rbegin</span>()-&gt;first-rec.<span class="built_in">begin</span>()-&gt;first &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="type">int</span> index = nums[left++];</span><br><span class="line">                rec[index]--;</span><br><span class="line">                <span class="keyword">if</span> (rec[index] == <span class="number">0</span>) &#123;</span><br><span class="line">                    rec.<span class="built_in">erase</span>(index);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += right-left<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 不定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】2302统计得分小于K的子数组数目</title>
      <link href="/posts/f27e810e.html"/>
      <url>/posts/f27e810e.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/count-subarrays-with-score-less-than-k/description/">题目链接</a>。</p></li><li><p>简单地说，就是定义了一种计算子数组分数的方式，即数组元素之和与数组长度之积，要求给出一个数组内，所有分数小于 K 的子数组数目。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li>越短越合法的不定长滑动窗口（<a href="/posts/946aa542.html" title="【Leetcode Daily】713乘积小于K的子数组">【Leetcode Daily】713乘积小于K的子数组</a>），没有任何要补充的地方，甚至陆爻齐写的答案和灵神几乎一样了，毕竟就是模板题。</li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">long</span> <span class="type">long</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; nums.<span class="built_in">size</span>(); right++) &#123;</span><br><span class="line">            sum += nums[right];</span><br><span class="line">            <span class="keyword">while</span>(sum *(right-left<span class="number">+1</span>) &gt;= k) &#123;</span><br><span class="line">                sum -= nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line">            ans += right-left<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 不定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】3258统计满足K约束的子字符串数量I</title>
      <link href="/posts/1f89498b.html"/>
      <url>/posts/1f89498b.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/count-substrings-that-satisfy-k-constraint-i/description/">题目链接</a>。</p></li><li><p>简单地说，给一个由 0 和 1 组成的字符串，求其中所有的子字符串数量，但子字符串必须满足 0 <strong>或</strong> 1 最多为 K 的限制。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>简单的越短越合法类型的不定长滑动窗口，直接使用例题思路即可，<a href="/posts/946aa542.html" title="【Leetcode Daily】713乘积小于K的子数组">【Leetcode Daily】713乘积小于K的子数组</a>。</p></li><li><p>参考灵神的题解，可以用<strong>与 1</strong>的方式来实现对字母’0’，’1’的区分，毕竟本质上两个字母一个是奇数，一个是偶数，与 1 后直接映射到 0 和 1 上，具体映射哪个也不重要，反正题目也并不区分 0 和 1 的限制方式。</p><blockquote><p><a href="https://leetcode.cn/problems/count-substrings-that-satisfy-k-constraint-i/solutions/2884495/on-hua-dong-chuang-kou-pythonjavacgo-by-keubv/">https://leetcode.cn/problems/count-substrings-that-satisfy-k-constraint-i/solutions/2884495/on-hua-dong-chuang-kou-pythonjavacgo-by-keubv/</a></p></blockquote></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考解法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countKConstraintSubstrings</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rec[<span class="number">2</span>]&#123;&#125;;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> right = <span class="number">0</span>; right &lt; s.<span class="built_in">size</span>(); right++) &#123;</span><br><span class="line">            rec[s[right]-<span class="string">&#x27;0&#x27;</span>]++;</span><br><span class="line">            <span class="keyword">while</span>(rec[<span class="number">0</span>] &gt; k &amp;&amp; rec[<span class="number">1</span>] &gt; k) &#123;</span><br><span class="line">                rec[s[left++]-<span class="string">&#x27;0&#x27;</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; left &lt;&lt; &quot; &quot; &lt;&lt; right &lt;&lt; &quot; &quot; &lt;&lt; s.substr(left, right-left+1) &lt;&lt; endl;</span></span><br><span class="line">            ans += right-left<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 不定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】713乘积小于K的子数组</title>
      <link href="/posts/946aa542.html"/>
      <url>/posts/946aa542.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/subarray-product-less-than-k/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个整数数组，求其中连续子数组之和小于 K 的个数。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>与之前越长越合法的题目稍有些不同，这时越短越合法，所以在之前的基础上（<a href="/posts/d3ee12e8.html" title="【Leetcode Daily】2962统计最大元素出现至少K次的子数组">【Leetcode Daily】2962统计最大元素出现至少K次的子数组</a>）略作修改。</p></li><li><p>无论是哪种类型，本质上都是遍历窗口的右端。以前是满足条件时不断向右滑窗口，直到滑不动时，记录当前窗口左侧加到结果上；而现在是满足条件时，要记录窗口内个数（right-left+1），因为窗口的左端在窗口内的任意一处必定满足条件。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cur = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; nums.<span class="built_in">size</span>(); right++) &#123;</span><br><span class="line">            cur *= nums[right];</span><br><span class="line">            <span class="keyword">while</span> (cur &gt;= k) &#123;</span><br><span class="line">                cur /= nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line">            ans += right-left<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 不定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】3298统计重新排列后包含另一个字符串的子字符串数目II</title>
      <link href="/posts/76973594.html"/>
      <url>/posts/76973594.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/count-substrings-that-can-be-rearranged-to-contain-a-string-ii/description/">题目链接</a>。</p></li><li><p>简单地说，就是给两个字符串，记作 s1 和 s2，求包含 s2 的 s1 字符串数目。所谓的包含是指 s2 各个字母数量不多于子串。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>虽说是 hard 题，但只要知道是越长越合法的不定长滑动窗口类型，就能轻松解决。总体上思路同<a href="/posts/f5ab7a8a.html" title="【Leetcode Daily】2799统计完全子数组的数目">【Leetcode Daily】2799统计完全子数组的数目</a>。</p></li><li><p>简单说下参照灵神题解后的改进，原来是直接对比26个字母是否都大于，虽然复杂度也是 O(n)，但时间耗费肯定大些，好在数组效率高还是 ac 了。要更快些，可以设立单独的变量记录包含字母的个数，条件就直接判断该变量是否满足条件即可。</p><blockquote><p><a href="https://leetcode.cn/problems/count-substrings-that-can-be-rearranged-to-contain-a-string-ii/solutions/2925828/on-hua-dong-chuang-kou-qiu-ge-shu-python-0x7a/">https://leetcode.cn/problems/count-substrings-that-can-be-rearranged-to-contain-a-string-ii/solutions/2925828/on-hua-dong-chuang-kou-qiu-ge-shu-python-0x7a/</a></p></blockquote></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">validSubstringCount</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rec1[<span class="number">26</span>]&#123;&#125;, rec2[<span class="number">26</span>]&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span> &amp;c : word1) &#123;</span><br><span class="line">            rec1[c-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span> &amp;c : word2) &#123;</span><br><span class="line">            rec2[c-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rec2[i] &gt; rec1[i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> left = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> less = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp;i : rec2) &#123;</span><br><span class="line">            less += (i&gt;<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> rec[<span class="number">26</span>] &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; word<span class="number">1.</span><span class="built_in">size</span>(); right++) &#123;</span><br><span class="line">            <span class="type">int</span> index = word1[right]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            rec[index]++;</span><br><span class="line">            <span class="keyword">if</span> (rec[index] == rec2[index]) less--;</span><br><span class="line">            <span class="keyword">while</span>(less == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rec[word1[left]-<span class="string">&#x27;a&#x27;</span>]==rec2[word1[left]-<span class="string">&#x27;a&#x27;</span>]) less++;</span><br><span class="line">                rec[word1[left++]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    bool contain(const int *rec1, const int *rec2) &#123;</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; 26; i++) &#123;</span></span><br><span class="line"><span class="comment">            if (rec2[i] &gt; rec1[i]) return false;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return true;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    long long validSubstringCount(string word1, string word2) &#123;</span></span><br><span class="line"><span class="comment">        int rec1[26]&#123;&#125;, rec2[26]&#123;&#125;;</span></span><br><span class="line"><span class="comment">        for (const char &amp;c : word1) &#123;</span></span><br><span class="line"><span class="comment">            rec1[c-&#x27;a&#x27;]++;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        for (const char &amp;c : word2) &#123;</span></span><br><span class="line"><span class="comment">            rec2[c-&#x27;a&#x27;]++;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; 26; i++) &#123;</span></span><br><span class="line"><span class="comment">            if (rec2[i] &gt; rec1[i]) return 0;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        long long left = 0, ans = 0;</span></span><br><span class="line"><span class="comment">        int rec[26] &#123;&#125;;</span></span><br><span class="line"><span class="comment">        for (int right = 0; right &lt; word1.size(); right++) &#123;</span></span><br><span class="line"><span class="comment">            rec[word1[right]-&#x27;a&#x27;]++;</span></span><br><span class="line"><span class="comment">            while(contain(rec, rec2)) &#123;</span></span><br><span class="line"><span class="comment">                rec[word1[left++]-&#x27;a&#x27;]--;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            ans += left;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        return ans;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 不定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】2799统计完全子数组的数目</title>
      <link href="/posts/f5ab7a8a.html"/>
      <url>/posts/f5ab7a8a.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/count-complete-subarrays-in-an-array/description/">题目链接</a>。</p></li><li><p>简单地说，就是找出数组中不同数目种类与完全数组一致的子数组数目。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>先简单说下思路，通过哈希表记录完全数组不同数目的种类，然后就用滑动窗口记录满足条件的子数目，也属于越长越合法的类型。</p></li><li><p>就是简单不定长滑动窗口的变式，不过看了灵神的题解，发现在简单撰写上，其实还有些方法可以借鉴，比如想要快速统计数组的不同数字，可以直接用数组来初始化set，像是<code>unordered_set&lt;int&gt; st(nums.begin(), nums.end());</code>这样就可以直接用 set 的 size 获得不同数目了。</p><blockquote><p><a href="https://leetcode.cn/problems/count-complete-subarrays-in-an-array/solutions/2364671/on-hua-dong-chuang-kou-by-endlesscheng-9ztb/">https://leetcode.cn/problems/count-complete-subarrays-in-an-array/solutions/2364671/on-hua-dong-chuang-kou-by-endlesscheng-9ztb/</a></p></blockquote></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countCompleteSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> rec_type[<span class="number">2001</span>]&#123;&#125;;</span><br><span class="line">        <span class="type">int</span> type_count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp;i : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!rec_type[i]) &#123;</span><br><span class="line">                rec_type[i] = <span class="literal">true</span>;</span><br><span class="line">                type_count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> rec[<span class="number">2001</span>]&#123;&#125;;</span><br><span class="line">        <span class="type">int</span> rec_count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; nums.<span class="built_in">size</span>(); right++) &#123;</span><br><span class="line">            rec[nums[right]]++;</span><br><span class="line">            <span class="keyword">if</span> (rec[nums[right]]==<span class="number">1</span>) &#123;</span><br><span class="line">                rec_count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(rec_count == type_count) &#123;</span><br><span class="line">                rec[nums[left]]--;</span><br><span class="line">                <span class="keyword">if</span> (rec[nums[left++]]==<span class="number">0</span>) &#123;</span><br><span class="line">                    rec_count--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 不定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【一起来学 CMake】CMakeCookBook-开始编译，然后执行【Learn CMake Together】</title>
      <link href="/posts/5cb682ce.html"/>
      <url>/posts/5cb682ce.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>这是一个陆爻齐主要借助资源 <a href="https://chenxiaowei.gitbook.io/cmake-cookbook"><code>CMake Cookbook</code></a> 学习 CMake 的系列记录。</p><blockquote><p><a href="https://chenxiaowei.gitbook.io/cmake-cookbook">https://chenxiaowei.gitbook.io/cmake-cookbook</a></p></blockquote></li><li><p>不定时更新，也不一定全按上面的章节顺序走，用到哪学到哪罢了：）</p></li><li><p>运行环境：VSCode + CMake + MinGW</p></li></ul><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><ul><li>首先在项目新建一个名为<code>hello.cpp</code>的文件，内容是</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>上面是十分甚至有九分标准的代码，要将这个代码编译执行， 在IDE 上就是点一下或者两下按钮的事，但在 VSCode，这事没那么轻松。</p></li><li><p>下载完 C++ 之类的拓展后，虽然右上角出现了运行和调试的按钮，但对多文件不管用，这是因为 VSCode 还需要你编辑 <code>.vscode</code> 文件夹内的 json 配置文件，麻烦，而且与其它编辑器不通用。虽然现在也不用其它编辑器，但学习一种更通用的方法总是好的，这就是本系列的由来。</p></li></ul><h2 id="对-Hello-World！单文件编译与执行"><a href="#对-Hello-World！单文件编译与执行" class="headerlink" title="对 Hello World！单文件编译与执行"></a>对 Hello World！单文件编译与执行</h2><blockquote><p><a href="https://chenxiaowei.gitbook.io/cmake-cookbook/1.0-chinese/1.1-chinese">https://chenxiaowei.gitbook.io/cmake-cookbook/1.0-chinese/1.1-chinese</a></p></blockquote><ul><li>那么进入正题，如何用 CMake 来对单文件编译然后执行呢？</li></ul><h3 id="编译步骤"><a href="#编译步骤" class="headerlink" title="编译步骤"></a>编译步骤</h3><ul><li>首先要初始化 CMake 的环境，先在项目的根目录下新建一个 CMakeLists.txt 文件，内容只需要三行。</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一句的意思是要求当前 CMake 的版本不低于 3.5，否则就会报错</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span> FATAL_ERROR)</span><br><span class="line"><span class="comment"># 这句话的意思，是为当前项目起名为 hello，同时限定语言为 cpp</span></span><br><span class="line"><span class="keyword">project</span>(hello LANGUAGES CXX)</span><br><span class="line"><span class="comment"># 这句话的意思是，把 hello.cpp 文件编译为名字是 hello-world 的可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(hello-world hello.cpp)</span><br></pre></td></tr></table></figure><ul><li>然后创建 build 目录来配置项目，用命令有以下三行：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br></pre></td></tr></table></figure><ul><li><p>注意，要是这时没有<code>CMakeLists.txt</code>文件的话，是不会配置成功的。</p></li><li><p>配置文件后，下面这句代码才会正式开始编译工作，注意，输入命令的位置在 build 文件夹内：<code>cmake --build .</code></p></li></ul><h3 id="可执行文件位置"><a href="#可执行文件位置" class="headerlink" title="可执行文件位置"></a>可执行文件位置</h3><ul><li><p>这时就有人说了：“陆爻齐！我看到编译成功了，但没有执行程序，你是不是教错了？”，嘛，编译成功并不是执行成功，在 build 文件夹内找找可执行文件运行就可以啦。</p></li><li><p>再次注意，根据生成器的不同，可执行文件的位置也会有所不同。</p></li><li><p>比如要是默认生成器是<code>Visual Studio</code>系列的话，build 文件夹内很可能会有个 Debug 文件夹，里面就是可执行文件；如果是<code>MinGW</code>的话，可执行文件会直接出现在 build 文件夹内。</p></li><li><p>刚刚说生成器的不同会对编译有所影响，而生成器当然也是可以切换的，这将在后文阐述。</p></li></ul><h3 id="更简单的编译步骤"><a href="#更简单的编译步骤" class="headerlink" title="更简单的编译步骤"></a>更简单的编译步骤</h3><ul><li><p>上述的编译步骤其实是“传统派”，CMake 支持更为“简单”的方法。</p></li><li><p>就是在 CMakeLists 文件写好后，在根目录运行 <code>cmake -H. -Bbuild</code>，<code>-H.</code>表示当前目录中搜索根CMakeLists.txt文件。<code>-Bbuild</code>告诉CMake在一个名为build的目录中生成所有的文件。</p></li><li><p>嘛，陆爻齐本人姑且还是传统派的：）所以后续提起编译步骤就默认是传统方法吧。</p></li></ul><h3 id="build文件夹的意义"><a href="#build文件夹的意义" class="headerlink" title="build文件夹的意义"></a>build文件夹的意义</h3><ul><li><p>回到编译步骤中写完 CMakeLists 的时候，如果此时直接运行命令<code>cmake .</code>也可以完成编译工作并正常运行。</p></li><li><p><strong>但是</strong>，那些繁杂的配置文件就会出现在项目根目录，十分不整齐，这就需要 build 文件夹装好这些配置文件。</p></li></ul><h2 id="切换生成器"><a href="#切换生成器" class="headerlink" title="切换生成器"></a>切换生成器</h2><blockquote><p><a href="https://chenxiaowei.gitbook.io/cmake-cookbook/1.0-chinese/1.2-chinese">https://chenxiaowei.gitbook.io/cmake-cookbook/1.0-chinese/1.2-chinese</a></p></blockquote><ul><li><p>回到编译步骤中写完 CMakeLists 的时候，先用<code>cmake --help</code>来查看自己能选什么生成器。</p></li><li><p>比如，我想换 MinGW Makefiles，在 build 文件夹中这么来初始化：<code>cmake -G &quot;MinGW Makefiles&quot; ..</code></p></li><li><p>注意，如果已经初始化了，是不能直接用上面的句子重新初始化，需要清除冲突部分。可以干脆删掉 build 文件夹，或者专门清理特定的缓存文件夹。</p></li></ul><h2 id="多文件编译与执行"><a href="#多文件编译与执行" class="headerlink" title="多文件编译与执行"></a>多文件编译与执行</h2><blockquote><p><a href="https://chenxiaowei.gitbook.io/cmake-cookbook/1.0-chinese/1.3-chinese">https://chenxiaowei.gitbook.io/cmake-cookbook/1.0-chinese/1.3-chinese</a></p></blockquote><ul><li><p>题目都说是多文件了，项目的内容也要有所变化，不过这部分陆爻齐没什么需要特别补充的，建议直接看<a href="https://chenxiaowei.gitbook.io/cmake-cookbook/1.0-chinese/1.3-chinese">链接</a>完成初始配置。</p></li><li><p>然后就在前面单文件的基础上改改 CMakeLists 就行，直接看代码吧，说明都在注释里</p></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(hello LANGUAGES CXX)</span><br><span class="line"><span class="comment"># 把新增的两个 Message 编成静态库 message</span></span><br><span class="line"><span class="keyword">add_library</span>(<span class="keyword">message</span> STATIC <span class="keyword">Message</span>.hpp <span class="keyword">Message</span>.cpp)</span><br><span class="line"><span class="keyword">add_executable</span>(hello-world hello.cpp)</span><br><span class="line"><span class="comment"># 把 message 库连接到可执行文件上</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(hello-world <span class="keyword">message</span>)</span><br></pre></td></tr></table></figure><ul><li>目前暂且只对<code>STATIC</code>感兴趣，那就说明下：STATIC 是静态库，SHARED 是动态库，或者说是动态共享对象（DSO）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 一起来学 CMake | Learn CMake Together </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMake </tag>
            
            <tag> LearnTogether </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】3325字符至少出现K次的子字符串</title>
      <link href="/posts/98a39247.html"/>
      <url>/posts/98a39247.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/count-substrings-with-k-frequency-characters-i/">题目链接</a>。</p></li><li><p>简单地说，就是给一个小写字母字符串以及一个数字 K，要求给出其中所有子字符串，每个字符串至少有一个字母的个数不小于 K。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>越长越合法类型的不定长滑动窗口（<a href="/posts/83629f2c.html" title="【Leetcode Daily】1358包含所有三种字符的子字符串数目">【Leetcode Daily】1358包含所有三种字符的子字符串数目</a>）</p></li><li><p>这里就稍微再解释下所谓的“越长越合法”罢，毕竟也是今天看了题解，突然有所感悟。这句话就是所得答案长度越长的情况下，往往是合法的。拿本题第一个输入举例。</p></li><li><p>输入：“s &#x3D; “abacb”, k &#x3D; 2”；输出：“4”</p></li><li><p>如果窗口内现在是 aba，那么肯定是符合条件的，所以窗口左部滑动后，窗口内容变成 ba，在下一循环变成 bac 时，答案也加上一，原因就是“越长越合法”，即把之前合法的情况和现在的窗口拼一起算上了。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberOfSubstrings</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> rec[<span class="number">26</span>]&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; s.<span class="built_in">size</span>(); right++) &#123;</span><br><span class="line">            rec[s[right]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            <span class="keyword">while</span> (rec[s[right]-<span class="string">&#x27;a&#x27;</span>]==k) &#123;</span><br><span class="line">                rec[s[left++]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; left &lt;&lt; &quot; &quot; &lt;&lt; right &lt;&lt; endl;</span></span><br><span class="line">            ans += left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 不定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】2962统计最大元素出现至少K次的子数组</title>
      <link href="/posts/d3ee12e8.html"/>
      <url>/posts/d3ee12e8.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/count-subarrays-where-max-element-appears-at-least-k-times/">题目链接</a>。</p></li><li><p>简单地说，就是给一个数组和一个整数 K，找出其中所有数组最大值出现次数不少于 K 的子数组的数目。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li>先用 ranges::max 得出最大值，然后根据统计出现次数的不定长滑动窗口方法解决。与上一道题相比（<a href="/posts/83629f2c.html" title="【Leetcode Daily】1358包含所有三种字符的子字符串数目">【Leetcode Daily】1358包含所有三种字符的子字符串数目</a>）没太多变化。</li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*int max_count = 0;</span></span><br><span class="line"><span class="comment">        int max_num = 0;</span></span><br><span class="line"><span class="comment">        for (const int &amp;i : nums) &#123;</span></span><br><span class="line"><span class="comment">            if (i &gt; max_num) &#123;</span></span><br><span class="line"><span class="comment">                max_num = i;</span></span><br><span class="line"><span class="comment">                max_count = 1;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            else if (i == max_num) &#123;</span></span><br><span class="line"><span class="comment">                max_count++;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        if (max_count &lt; k) return 0;*/</span></span><br><span class="line">        <span class="type">int</span> max_num = ranges::<span class="built_in">max</span>(nums);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> max_rec = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; nums.<span class="built_in">size</span>(); right++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[right]==max_num) &#123;</span><br><span class="line">                max_rec++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(max_rec == k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left++]==max_num) &#123;</span><br><span class="line">                    max_rec--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 不定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】1358包含所有三种字符的子字符串数目</title>
      <link href="/posts/83629f2c.html"/>
      <url>/posts/83629f2c.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/number-of-substrings-containing-all-three-characters/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个字符串，由 a b c 组成，找出其中所有至少包含a b c各一个的子字符串。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>不定长滑动窗口变式，变在“至少”，也就是说，一旦找到一个合适的窗口，就是一个合适的窗口右端点，窗口左侧一直往左都是答案，所以最终计算答案时，直接看包含 a b c 至少各一个的最短窗口的左端数值之和。</p></li><li><p>不过具体判断窗口是否满足条件，除了直接计算对三个字母的记录是否都非零外，也可以引入另一个变量统计当前字母为零的个数，看起来更快，但实际上差别不大，复杂度都是O(1)。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberOfSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rec[<span class="number">3</span>]&#123;&#125;;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> empty = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; n; right++) &#123;</span><br><span class="line">            <span class="type">int</span> index = s[right]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (rec[index]++ == <span class="number">0</span>) empty--;</span><br><span class="line">            <span class="keyword">while</span> (empty == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--rec[s[left++]-<span class="string">&#x27;a&#x27;</span>]==<span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//cout &lt;&lt; left-1 &lt;&lt; &quot; &quot; &lt;&lt; right &lt;&lt; endl;</span></span><br><span class="line">                    ans += left;</span><br><span class="line">                    empty++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;<span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberOfSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rec[<span class="number">3</span>]&#123;&#125;;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> empty = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; n; right++) &#123;</span><br><span class="line">            <span class="type">int</span> index = s[right]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (rec[index]++ == <span class="number">0</span>) empty--;</span><br><span class="line">            <span class="keyword">while</span> (empty == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--rec[s[left++]-<span class="string">&#x27;a&#x27;</span>]==<span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//cout &lt;&lt; left-1 &lt;&lt; &quot; &quot; &lt;&lt; right &lt;&lt; endl;</span></span><br><span class="line">                    empty++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*class Solution &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int numberOfSubstrings(string s) &#123;</span></span><br><span class="line"><span class="comment">        int rec[3]&#123;&#125;;</span></span><br><span class="line"><span class="comment">        int left = 0;</span></span><br><span class="line"><span class="comment">        int ans = 0;</span></span><br><span class="line"><span class="comment">        int n = s.size();</span></span><br><span class="line"><span class="comment">        for (int right = 0; right &lt; n; right++) &#123;</span></span><br><span class="line"><span class="comment">            rec[s[right]-&#x27;a&#x27;]++;</span></span><br><span class="line"><span class="comment">            while (rec[0]&amp;&amp;rec[1]&amp;&amp;rec[2]) &#123;</span></span><br><span class="line"><span class="comment">                //cout &lt;&lt; left &lt;&lt; &quot; &quot; &lt;&lt; right &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">                rec[s[left++]-&#x27;a&#x27;]--;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            ans += left;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return ans;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 不定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】76最小覆盖子串</title>
      <link href="/posts/c61f2c8f.html"/>
      <url>/posts/c61f2c8f.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/minimum-window-substring/description/">题目链接</a>。</p></li><li><p>简单地说，就是给两个字符串 s 和 t，求 s 中能够涵盖 t 的最小子字符串的长度。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>可惜，差点就不看题解ac了。不过大致思路与灵神类似也算进步罢。</p><blockquote><p><a href="https://leetcode.cn/problems/minimum-window-substring/solutions/2713911/liang-chong-fang-fa-cong-o52mn-dao-omnfu-3ezz/">https://leetcode.cn/problems/minimum-window-substring/solutions/2713911/liang-chong-fang-fa-cong-o52mn-dao-omnfu-3ezz/</a></p></blockquote></li><li><p>完整思路直接戳上面链接跳转查看比较好，下面写写遇到的坑。</p></li></ul><ol><li><p>对于 ASCII 表专用的哈希表形式，直接用长 128 的数组比较省心省力，用专门设定长度有可能恰好忘记考虑边缘值；</p></li><li><p>substr 方法的本质是拷贝一个字符串，所以执行效率低；</p></li></ol><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isCover</span><span class="params">(<span class="type">int</span> *recs, <span class="type">int</span> *rect)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="string">&#x27;a&#x27;</span>; i &lt;= <span class="string">&#x27;z&#x27;</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (recs[i] &lt; rect[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="string">&#x27;A&#x27;</span>; i &lt;= <span class="string">&#x27;Z&#x27;</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (recs[i] &lt; rect[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> rect[<span class="string">&#x27;z&#x27;</span><span class="number">+1</span>]&#123;&#125;;</span><br><span class="line">        <span class="type">int</span> recs[<span class="string">&#x27;z&#x27;</span><span class="number">+1</span>]&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span> &amp;c : t) &#123;</span><br><span class="line">            rect[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans_left = <span class="number">-1</span>, ans_right = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; s.<span class="built_in">size</span>(); right++) &#123;</span><br><span class="line">            recs[s[right]]++;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">isCover</span>(recs, rect)) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((ans_right-ans_left)&gt;(right-left)) &#123;</span><br><span class="line">                    ans_left = left;</span><br><span class="line">                    ans_right = right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">                recs[s[left]]--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans_left==<span class="number">-1</span>?<span class="string">&quot;&quot;</span>:s.<span class="built_in">substr</span>(ans_left, ans_right-ans_left<span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】2875无限数组的最短子数组</title>
      <link href="/posts/40a240db.html"/>
      <url>/posts/40a240db.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/minimum-size-subarray-in-infinite-array/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个数组，可以将该数组无限地复制自身，求无限的数组中，子数组和恰好为 target 的最短长度。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>本问题看似没那么难，实则藏了一个难点，由于数组可以无限叠加，那么所求的子数组很可能横跨了很多数组，只有解决了这个问题，才能回归普通的不定长滑动窗口（<a href="/posts/6dc72043.html" title="【Leetcode Daily】3090每个字符最多出现两次的最长字符串">【Leetcode Daily】3090每个字符最多出现两次的最长字符串</a>）。</p></li><li><p>问题可以这么解决，对目标和 target 取余记为 mod，然后加倍数组，在其中找到和为 mod 的窗口长度，最后加上中间省略的数组长度（target&#x2F;all_sum*nums.size()）。</p><blockquote><p><a href="https://leetcode.cn/problems/minimum-size-subarray-in-infinite-array/solutions/2464878/hua-dong-chuang-kou-on-shi-jian-o1-kong-cqawc/">https://leetcode.cn/problems/minimum-size-subarray-in-infinite-array/solutions/2464878/hua-dong-chuang-kou-on-shi-jian-o1-kong-cqawc/</a></p></blockquote></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考解法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSizeSubarray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> all_sum = <span class="built_in">reduce</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0LL</span>);</span><br><span class="line">        <span class="type">int</span> target_sum = target % all_sum;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> cur_sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; <span class="number">2</span>*n; right++) &#123;</span><br><span class="line">            cur_sum += nums[right%n];</span><br><span class="line">            <span class="keyword">while</span>(cur_sum &gt; target_sum) &#123;</span><br><span class="line">                </span><br><span class="line">                cur_sum -= nums[left++%n];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur_sum == target_sum) &#123;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; &quot;cur:&quot; &lt;&lt; cur_sum &lt;&lt; &quot;; nums[left]:&quot; &lt;&lt; nums[left] &lt;&lt; &quot;; left:&quot; &lt;&lt; left &lt;&lt; &quot;; right:&quot; &lt;&lt; right &lt;&lt; endl;</span></span><br><span class="line">                ans = <span class="built_in">min</span>(ans, right-left<span class="number">+1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == INT_MAX ? <span class="number">-1</span> : ans  + target / all_sum * n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 不定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】1234替换子串得到平衡字符串</title>
      <link href="/posts/3b8d17a9.html"/>
      <url>/posts/3b8d17a9.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/replace-the-substring-for-balanced-string/description/">题目链接</a>。</p></li><li><p>简单地说，给一个由 QWER 四个字母组成的字符串，可以变换其中的子字符串，使得四个字母数量相同，求变换的子字符串的最短长度。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>不定长滑动窗口的求“至少”应用，思路上基本同<a href="/posts/6dc72043.html" title="【Leetcode Daily】3090每个字符最多出现两次的最长字符串">【Leetcode Daily】3090每个字符最多出现两次的最长字符串</a>，下面主要讲讲灵茶山艾府在题解中可以借鉴的地方。</p><blockquote><p><a href="https://leetcode.cn/problems/replace-the-substring-for-balanced-string/solutions/2108358/tong-xiang-shuang-zhi-zhen-hua-dong-chua-z7tu/">https://leetcode.cn/problems/replace-the-substring-for-balanced-string/solutions/2108358/tong-xiang-shuang-zhi-zhen-hua-dong-chua-z7tu/</a></p></blockquote></li><li><p>一个是数组的初始化，由于 ASCII 码的对应，其实用字符初始化数组数量是可以的，所以就有了<code>int rec[&#39;Z&#39;]&#123;&#125;</code>这种写法。</p></li><li><p>另一个是结果在窗口合法时更新，避免窗口不合法后，去猜合法情况的代码。这样做很容易把自己绕进去。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考解法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">balancedString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> rec[<span class="string">&#x27;X&#x27;</span>]&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span> &amp;c:s) &#123;</span><br><span class="line">            rec[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> base = n/<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// rec的意思变为窗口内多余的字母</span></span><br><span class="line">        <span class="keyword">if</span> (rec[<span class="string">&#x27;Q&#x27;</span>]==base &amp;&amp; rec[<span class="string">&#x27;W&#x27;</span>]==base &amp;&amp; rec[<span class="string">&#x27;E&#x27;</span>]==base &amp;&amp; rec[<span class="string">&#x27;R&#x27;</span>]==base) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans = INT_MAX;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right=<span class="number">0</span>; right &lt; n; right++) &#123;</span><br><span class="line">            rec[s[right]]--;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(rec[<span class="string">&#x27;Q&#x27;</span>]&lt;=base &amp;&amp; rec[<span class="string">&#x27;W&#x27;</span>]&lt;=base &amp;&amp; rec[<span class="string">&#x27;E&#x27;</span>]&lt;=base &amp;&amp; rec[<span class="string">&#x27;R&#x27;</span>]&lt;=base) &#123;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, right-left<span class="number">+1</span>);</span><br><span class="line">                <span class="comment">// cout &lt;&lt; left &lt;&lt; &quot; &quot; &lt;&lt; right &lt;&lt; &quot; &quot; &lt;&lt; rec[&#x27;Q&#x27;] &lt;&lt; rec[&#x27;W&#x27;] &lt;&lt; rec[&#x27;E&#x27;]&lt;&lt;rec[&#x27;R&#x27;] &lt;&lt; endl;</span></span><br><span class="line">                rec[s[left++]]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; left &lt;&lt; &quot; &quot; &lt;&lt; right &lt;&lt; &quot; &quot; &lt;&lt; rec[&#x27;Q&#x27;] &lt;&lt; rec[&#x27;W&#x27;] &lt;&lt; rec[&#x27;E&#x27;]&lt;&lt;rec[&#x27;R&#x27;] &lt;&lt; endl;</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 不定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】2904最短且字典序最小的美丽子字符串</title>
      <link href="/posts/a7b9ac4.html"/>
      <url>/posts/a7b9ac4.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/shortest-and-lexicographically-smallest-beautiful-string/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个由 0 和 1 组成的字符串，找出其中子字符串的最短长度，该子字符串要满足条件：1. 其中恰好有 k 个 1；2. 字典序在相同长度的子字符串中最小；</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>简单不定长滑动窗口（<a href="/posts/6dc72043.html" title="【Leetcode Daily】3090每个字符最多出现两次的最长字符串">【Leetcode Daily】3090每个字符最多出现两次的最长字符串</a>）的应用，思路上不用多说，主要讲讲从灵茶山艾府的题解中吸取到的经验。</p><blockquote><p><a href="https://leetcode.cn/problems/shortest-and-lexicographically-smallest-beautiful-string/solutions/2483144/mei-ju-pythonjavacgo-by-endlesscheng-5th8/">https://leetcode.cn/problems/shortest-and-lexicographically-smallest-beautiful-string/solutions/2483144/mei-ju-pythonjavacgo-by-endlesscheng-5th8/</a></p></blockquote></li><li><p>一个是<code>ranges::</code>系列的学习，除了之前排序的 range::sort，这次还有 ranges::count，ranges::count(str, ‘1’)就会统计字符串 str 中字符 1 的个数。</p></li><li><p>还有就是 move 函数，比如 s &#x3D; move(str); 可以快速地把字符串 str 的内容放到 s 中，在追求效率的算法竞赛中挺有用的。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考解法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">shortestBeautifulSubstring</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ranges::<span class="built_in">count</span>(s, <span class="string">&#x27;1&#x27;</span>) &lt; k) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        string ans = s;</span><br><span class="line">        <span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> one_count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> left = <span class="number">0</span>; left &lt; n; left++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(one_count &lt; k &amp;&amp; right &lt; n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[right++]==<span class="string">&#x27;1&#x27;</span>) one_count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (one_count == k &amp;&amp; right &lt;= n) &#123;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; left &lt;&lt; &quot; &quot; &lt;&lt; right &lt;&lt; endl;</span></span><br><span class="line">                <span class="function">string <span class="title">tmp</span><span class="params">(s.begin()+left, s.begin()+right)</span></span>;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; tmp &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">if</span> (tmp.<span class="built_in">size</span>() &lt; ans.<span class="built_in">size</span>() || tmp.<span class="built_in">size</span>() == ans.<span class="built_in">size</span>() &amp;&amp; tmp &lt; ans) &#123;</span><br><span class="line">                    ans = <span class="built_in">move</span>(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[left]==<span class="string">&#x27;1&#x27;</span>) one_count--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 不定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】209长度最小的子数组</title>
      <link href="/posts/b13baa93.html"/>
      <url>/posts/b13baa93.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">题目链接</a>。</p></li><li><p>简单地说，就是给一个数组和一个整数，找出数组中总和大于该整数的子数组中的最小长度。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>不定长滑动窗口(% post_link 3090每个字符最多出现两次的最长字符串 %)的简单变式，不过以往的滑动窗口是为了求最长值，这里是求最短值。</p></li><li><p>所以陆爻齐有个想法，以前都是主循环窗口右侧，不满足条件就让窗口左侧右滑，那么就反过来，主循环窗口左侧滑动，不满足这个条件就让窗口右侧右滑，这就是下面的代码的意思。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>陆爻齐的参考题解</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> left = <span class="number">0</span>; left &lt; n; left++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (sum &lt; target &amp;&amp; right &lt; n) &#123;</span><br><span class="line">                sum += nums[right++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt;= target &amp;&amp; right &lt;= n) &#123;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; sum &lt;&lt; &quot; &quot; &lt;&lt; left &lt;&lt; &quot; &quot; &lt;&lt; right &lt;&lt; endl;</span></span><br><span class="line">                ans = <span class="built_in">min</span>(ans, right-left);</span><br><span class="line">            &#125;</span><br><span class="line">            sum -= nums[left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans==INT_MAX ? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 不定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】2271毯子覆盖的最多白色砖块数</title>
      <link href="/posts/ea441eea.html"/>
      <url>/posts/ea441eea.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/maximum-white-tiles-covered-by-a-carpet/description/">题目链接</a>。</p></li><li><p>简单地说，就是把一系列的数组当作一块块连续的白色瓷砖组，瓷砖组互不重叠，再给一个数字作为地毯长度，问地毯盖下去能覆盖的最长的瓷砖数是多少。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>又是评鉴大佬（灵茶山艾府）题解的一集。</p><blockquote><p><a href="https://leetcode.cn/problems/maximum-white-tiles-covered-by-a-carpet/solutions/1496434/by-endlesscheng-kdy9/">https://leetcode.cn/problems/maximum-white-tiles-covered-by-a-carpet/solutions/1496434/by-endlesscheng-kdy9/</a></p></blockquote></li><li><p>首先我们可以思考一下如何覆盖地毯能尽可能覆盖最多瓷砖。易得（想几种情况比较，地毯右端在瓷砖组右侧，右端在中间，右端在左边），地毯的右侧如果直接与瓷砖组右侧对齐能尽可能地多覆盖瓷砖（拿地毯左侧与瓷砖组左侧对齐也可行）。</p></li><li><p>那么可以想象地毯（窗口）如何滑动能够比较高效地计算出最长的情况。由上面的推导式，想要让窗口单向滑动，先要对瓷砖组做排序，按第一位，也就是瓷砖组的起点做升序排序。</p></li><li><p>那么计算窗口内瓷砖数量呢？其实只要每次窗口滑动，就把新瓷砖组的瓷砖数加入，就能直到窗口内的总瓷砖数。要知道窗口最左侧的瓷砖组是否需要排除，只要在这个最左侧的瓷砖组的右侧加上地毯长度，发现这个值还是比目前最右侧的值小，说明地毯无法保持与右侧对齐，这是就要去除最左侧的瓷砖组。</p></li><li><p>说完了加入和排除策略，那么如果地毯左侧处于某个瓷砖组中间呢？只要拿最左侧瓷砖组的左侧加上地毯长度与当前最右侧瓷砖组右侧之差与零取一个最大值，就能找出当前地毯没有覆盖最左侧瓷砖的长度，如果长度为负数也能取到零。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumWhiteTiles</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; tiles, <span class="type">int</span> carpetLen)</span> </span>&#123;</span><br><span class="line">        ranges::<span class="built_in">sort</span>(tiles, &#123;&#125;, [](<span class="keyword">auto</span> &amp;t)&#123;<span class="keyword">return</span> t[<span class="number">0</span>];&#125;);</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cover = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;ti : tiles) &#123;</span><br><span class="line">            cover += ti[<span class="number">1</span>]-ti[<span class="number">0</span>]<span class="number">+1</span>;</span><br><span class="line">            <span class="keyword">while</span>(tiles[left][<span class="number">1</span>]+carpetLen<span class="number">-1</span> &lt; ti[<span class="number">1</span>]) &#123;</span><br><span class="line">                cover -= tiles[left][<span class="number">1</span>]-tiles[left][<span class="number">0</span>]<span class="number">+1</span>;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> uncover = <span class="built_in">max</span>(<span class="number">0</span>, ti[<span class="number">1</span>]-carpetLen<span class="number">+1</span>-tiles[left][<span class="number">0</span>]);</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, cover-uncover);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 不定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】2831找出最长等值子数组</title>
      <link href="/posts/54f641d9.html"/>
      <url>/posts/54f641d9.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/find-the-longest-equal-subarray/description/">题目链接</a>。</p></li><li><p>简单地说，可以对数组做 k 次以内的删除操作，求删除完后数组内最长子数组的长度，该子数组连续。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>陆爻齐输力，得很很地研究灵茶山艾府的题解才行。</p><blockquote><p><a href="https://leetcode.cn/problems/find-the-longest-equal-subarray/solutions/2396401/fen-zu-shuang-zhi-zhen-pythonjavacgo-by-lqqau/">https://leetcode.cn/problems/find-the-longest-equal-subarray/solutions/2396401/fen-zu-shuang-zhi-zhen-pythonjavacgo-by-lqqau/</a></p></blockquote></li><li><p>这是挺高级的分组滑动窗口，数组内有多少个数字，就有多少个窗口需要滑动，每个窗口的责任是找到自己负责的数组最长连续的情况长度是多少。而这个怎么找的思路就很有意思。</p></li><li><p>对于每个数值，都有一个唯一对应的数组来保存各个数值在原数组的下标，该对应由哈希表实现。想计算两个相同数值之间有多少个数值（闭区间）只要用两个下标相减加一即可，暂且把这个数值记作 A。</p></li><li><p>那么如何满足题目中删除最多 k 个数字来保证子数组连续的要求呢？只要找到这两个数在哈希表自己数组中的下标之差，就对应了该区间内，想连续数值的数量，这个数量记作 B。现在，有了一个区间内数字的数量 A，和需要的相同数字的数量 B，只要 A-B 小于 k，那么这个子数组就是满足条件的。把所有的 B 中最大值求出，就是结果。</p></li><li><p>不过上面的这一条是思路，具体实现时，发现只要记录数值下标时，同时对这个值减去当前哈希表对应数组的长度，就能使得对这个数组的窗口左右相减时的值就是上面的 A-B。毕竟相当于每个数存的是 a1-b1, a2-b2……，任意两个相减就是 a2-a1-(b2-b1), A&#x3D;&#x3D;a2-a1, B&#x3D;&#x3D;b2-b1。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestEqualSubarray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">rec</span>(nums.<span class="built_in">size</span>()<span class="number">+1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            rec[nums[i]].<span class="built_in">push_back</span>(i-rec[nums[i]].<span class="built_in">size</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;p : rec) &#123;</span><br><span class="line">            <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; p.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                <span class="keyword">while</span>(p[i]-p[left]&gt;k) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, i-left<span class="number">+1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 不定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】2516每种字符至少取K个</title>
      <link href="/posts/ec968a0f.html"/>
      <url>/posts/ec968a0f.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/take-k-of-each-character-from-left-and-right/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个字符串，由a、b、c组成，每次可以从<strong>最左侧</strong>或<strong>最右侧</strong>删除一个，求在每个字符至少删除 k 个的情况下，删除最少的数目。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>从<a href="/posts/9d513cff.html" title="【Leetcode Daily】1658将x减到0的最小操作数">【Leetcode Daily】1658将x减到0的最小操作数</a>这样的题中学到了，滑动窗口对于这种对<strong>最左侧</strong>和<strong>最右侧</strong>操作的题，往往采用所谓的“逆向”思路，也就是最大化地“去除”，从而最后计算出结果。</p></li><li><p>拿本题来说，可以先记录整个字符串的各个字符的数目，窗口的内容并非是记录最左侧或最右侧的删除，而是记录最左侧和最右侧操作完后，中间的部分，目标是最大化这部分，从而间接最小化所求数目。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>陆爻齐的参考解法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">takeCharacters</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> *rec = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>]();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span> c : s) &#123;</span><br><span class="line">            rec[c-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rec[<span class="number">0</span>] &lt; k || rec[<span class="number">1</span>] &lt; k || rec[<span class="number">2</span>] &lt; k) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; rec[0] &lt;&lt; &quot; &quot; &lt;&lt; rec[1] &lt;&lt; &quot; &quot; &lt;&lt; rec[2] &lt;&lt; endl;</span></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> win = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            rec[s[i]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="keyword">while</span>(rec[<span class="number">0</span>] &lt; k || rec[<span class="number">1</span>] &lt; k || rec[<span class="number">2</span>] &lt; k) &#123;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; &quot;update:&quot; &lt;&lt; &quot;i:&quot; &lt;&lt; i &lt;&lt; &quot;;left:&quot; &lt;&lt; left &lt;&lt; endl;</span></span><br><span class="line">                rec[s[left++]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//cout &lt;&lt; rec[0] &lt;&lt; &quot; &quot; &lt;&lt; rec[1] &lt;&lt; &quot; &quot; &lt;&lt; rec[2] &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span> (rec[<span class="number">0</span>] &gt;= k &amp;&amp; rec[<span class="number">1</span>] &gt;= k &amp;&amp; rec[<span class="number">2</span>] &gt;= k) &#123;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; &quot;result:&quot; &lt;&lt; &quot;i:&quot; &lt;&lt; i &lt;&lt; &quot;;left:&quot; &lt;&lt; left &lt;&lt; endl;</span></span><br><span class="line">                win = <span class="built_in">max</span>(win, i-left<span class="number">+1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">size</span>()-win;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 不定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】1838最高频元素的频数</title>
      <link href="/posts/49f7fd3b.html"/>
      <url>/posts/49f7fd3b.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/frequency-of-the-most-frequent-element/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个数组，可以对其中任意数字做加一操作，最多 k 次，求操作后，数组内最高频的数字的数目是多少。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>总得来说就是不定长滑动窗口，但是具体实现比较多样，陆爻齐下面提供两种思路。一种是自己想出来的，另一种看别人题解，自己实现总结的。</p></li><li><p>第一种，陆爻齐审完题发现，本题要想通过滑动窗口解决，先需排序，就像<a href="/posts/a991ab19.html" title="【Leetcode Daily】2779数组的最大美丽值">【Leetcode Daily】2779数组的最大美丽值</a>一样。排序后，通过窗口右侧，窗口长度就能计算窗口与右侧同步后的总和，以及滑动窗口可以方便计算当前和，这样就能计算出差值。而窗口的不满足条件则设定为该差值大于 k，就让左窗口滑动，更新窗口目标和与当前和，直到符合。</p></li><li><p>另一种，算是上面思路的一些简化。对于排序后的窗口，其实用下面的方法就能方便地计算窗口目标和与当前和的差值。上面的思路聚焦于“和”，而本思路直接计算“差值”。每次窗口向右滑，则把<strong>新值与其左侧邻居之差</strong>乘以<strong>新窗口长度减一</strong>加到差值上。这么做可以在每次更新右侧的值时，快速地把其与剩余元素的差值计算出来，由于上一次也这么同步了，所以就计算<strong>新值与其左侧邻居之差</strong>；而新窗口右侧的值与自己差值为 0，所以只用乘以<strong>新窗口长度减一</strong>。这样一来，窗口不满足条件就好写了，就是该差值大于 k。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>陆爻齐想的参考解法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxFrequency</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> cur_sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            cur_sum += nums[i];</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> tar_sum = (<span class="type">long</span> <span class="type">long</span>)nums[i]*(i-left<span class="number">+1</span>);</span><br><span class="line">            <span class="keyword">while</span>(tar_sum-cur_sum&gt;k) &#123;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; &quot;i:&quot; &lt;&lt; i &lt;&lt; &quot;;left:&quot; &lt;&lt; left &lt;&lt; &quot;;tar_sum:&quot; &lt;&lt; tar_sum &lt;&lt; &quot;;cur_sum:&quot; &lt;&lt; cur_sum &lt;&lt; endl;</span></span><br><span class="line">                tar_sum -= nums[i];</span><br><span class="line">                cur_sum -= nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, i-left<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>陆爻齐参考其它题解的参考解法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxFrequency</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> cur_dif = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            cur_dif += (<span class="type">long</span> <span class="type">long</span>)(nums[i]-nums[i<span class="number">-1</span>])*(i-left); <span class="comment">// 不加一是因为最右边不用加数值</span></span><br><span class="line">            <span class="keyword">while</span>(cur_dif&gt;k) &#123;</span><br><span class="line">                cur_dif -= (nums[i]-nums[left++]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; &quot;i:&quot; &lt;&lt; i &lt;&lt; &quot;;left:&quot; &lt;&lt; left &lt;&lt; &quot;;cur_dif:&quot; &lt;&lt; cur_dif &lt;&lt; endl;</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, i-left<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 不定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】2779数组的最大美丽值</title>
      <link href="/posts/a991ab19.html"/>
      <url>/posts/a991ab19.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/maximum-beauty-of-an-array-after-applying-operation/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个整数数组和一个数字 k，让你对每一个位的数字可以做一个操作也就是上下浮动不超过 k 的数值，最后整个数组最多的数字的数量就是要求的结果。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>陆爻齐吃亏在了审题不当，题目中的子序列是可以删除数组的内容，也就是说，顺序不重要，只要找到最多的公共数值就行。</p></li><li><p>而要找到这个公共数值，可以这么做，先排序，然后开始不定长滑动窗口（<a href="/posts/6dc72043.html" title="【Leetcode Daily】3090每个字符最多出现两次的最长字符串">【Leetcode Daily】3090每个字符最多出现两次的最长字符串</a>），而不满足窗口的条件是，左窗口加上 k 的值小于右窗口减去 k 的值，这意味着窗口的左右两侧不再有公共的数值。</p></li><li><p>数组经过排序，所以只要左窗口不断向右滑动，总会再次处于左右窗口有公共数值的阶段。这样一来窗口就会高效率地遍历并找到有公共值的最长子序列。</p><blockquote><p><a href="https://leetcode.cn/problems/maximum-beauty-of-an-array-after-applying-operation/solutions/2345805/pai-xu-shuang-zhi-zhen-by-endlesscheng-hbqx/">https://leetcode.cn/problems/maximum-beauty-of-an-array-after-applying-operation/solutions/2345805/pai-xu-shuang-zhi-zhen-by-endlesscheng-hbqx/</a></p></blockquote></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考题解</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumBeauty</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i]-k &gt; nums[left]+k) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, i-left<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 不定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】2730找到最长的半重复子字符串</title>
      <link href="/posts/3e4fd694.html"/>
      <url>/posts/3e4fd694.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/find-the-longest-semi-repetitive-substring/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个由 0 和 1 组成的字符串，现在找到其中最长连续子字符串的长度，要求字符串中间没有超过一个的相邻重复数字的情况。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li>经典不定长滑动窗口一则(<a href="/posts/6dc72043.html" title="【Leetcode Daily】3090每个字符最多出现两次的最长字符串">【Leetcode Daily】3090每个字符最多出现两次的最长字符串</a>)，不过本题有一点需要注意的是，判断相邻重复数字后的 left 指针的位置要清楚。如果像陆爻齐一样，left 判断完都会 ++ 那么就与灵茶山艾府的解法没那么一样，不能直接用 i-left+1，毕竟 left 其实一直在左窗口+1的位置上。</li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestSemiRepetitiveSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> same_count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[i<span class="number">-1</span>]) &#123;</span><br><span class="line">                same_count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (same_count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[left] == s[left<span class="number">-1</span>]) &#123;</span><br><span class="line">                    same_count--;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, i-left<span class="number">+2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 不定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【一起来学 Git】LearnGitBranching-完结撒花与感言【Learn Git Together】</title>
      <link href="/posts/73d3bb24.html"/>
      <url>/posts/73d3bb24.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>这是一个陆爻齐跟着 <code>Learn Git Branching</code> 网站学习(<del>复习</del>) Git 的系列记录，会跟着其内容的步伐做学习记录，并结合自身<strong>浅薄</strong>的知识积累和<strong>几乎为零</strong>的实践经验做<strong>一点点</strong>的补充。</p><blockquote><p><a href="https://learngitbranching.js.org/">https://learngitbranching.js.org</a></p></blockquote></li><li><p>私以为，该网站比较适合有一点 Git 基础来学习，如果是完全零基础，还是看看 Git 官网教程，在 GitHub 这样的代码托管网站走一遍流程比较好。</p></li><li><p>注意，由于下面的笔记不可避免地涉及到过关的答案，所以<strong>强烈建议</strong>，自行体验过网站内容再看本文。</p></li></ul><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><ul><li><p>经过大概一周有余的更新，这个系列就算是完结了（8787878787），对陆爻齐自身而言算是受益匪浅啊。</p></li><li><p>其实吧，陆爻齐原本最熟悉的部分大多在<a href="/posts/c477e115.html" title="【一起来学 Git】LearnGitBranching-基础篇【Learn Git Together】">【一起来学 Git】LearnGitBranching-基础篇【Learn Git Together】</a>和<a href="/posts/2867501f.html" title="【一起来学 Git】LearnGitBranching-Push&amp;Pull-Git远程仓库【Learn Git Together】">【一起来学 Git】LearnGitBranching-Push&amp;Pull-Git远程仓库【Learn Git Together】</a>，前者很多命令本地用，后者主要使用 pull 和 push。 </p></li><li><p>但是吧，有时候遇到一些想编辑 commit 顺序的时候就很难受，问 ai 吧，操作完又不知所以然，有时候 ai 也不会。现在总算是对 git 有了更多的了解，至少这一点点的基础，看着网上的帖子和官方文档也不会太痛苦了。</p></li><li><p>现在学完之后，陆爻齐之后至少会有以下的变化</p></li></ul><ol><li>从前只会 merge，现在为了保持线性的提交历史，会多多地使用 rebase 命令；</li><li>对于提交的更改，学会使用交互式 rebase 与 –amend 相结合，以及 cherry-pick；</li><li>对于版本的发布，会在本地上自己用 tag 标注好，并结合自动化工作流，而不是只依赖 github 的图形化；</li></ol><ul><li>总之十分推荐没有玩过这个网站的人尝试一下，以及如果你没有在本地上用过 git，也十分推荐你用一下，作为一个版本管理工具，除了学习成本较高外，并没有什么缺点。</li></ul><h1 id="证明：）"><a href="#证明：）" class="headerlink" title="证明：）"></a>证明：）</h1><ul><li><p><img src="/%5Cimg%5CLearnGitBranching%5Clearn_git_branching_finish_1.png" alt="Learn_Git_Branching_Finish_1"></p></li><li><p><img src="/%5Cimg%5CLearnGitBranching%5Clearn_git_branching_finish_2.png" alt="Learn_Git_Branching_Finish_2"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 一起来学 Git | Learn Git Together </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> LearnTogether </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【一起来学 Git】LearnGitBranching-关于origin和它的周边-Git远程仓库高级操作【Learn Git Together】</title>
      <link href="/posts/7de72648.html"/>
      <url>/posts/7de72648.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>这是一个陆爻齐跟着 <code>Learn Git Branching</code> 网站学习(<del>复习</del>) Git 的系列记录，会跟着其内容的步伐做学习记录，并结合自身<strong>浅薄</strong>的知识积累和<strong>几乎为零</strong>的实践经验做<strong>一点点</strong>的补充。</p><blockquote><p><a href="https://learngitbranching.js.org/">https://learngitbranching.js.org</a></p></blockquote></li><li><p>私以为，该网站比较适合有一点 Git 基础来学习，如果是完全零基础，还是看看 Git 官网教程，在 GitHub 这样的代码托管网站走一遍流程比较好。</p></li><li><p>注意，由于下面的笔记不可避免地涉及到过关的答案，所以<strong>强烈建议</strong>，自行体验过网站内容再看本文。</p></li></ul><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><blockquote><p>做一名仁慈的独裁者一定会很有趣……</p></blockquote><ul><li>好奇怪的引语，不过本章说是高级操作，陆爻齐在此前 git 出现奇怪问题的时候，向 gpt 请教过，给出类似的代码，有时奏效有时又寄，所以还是十分建议学习的：）</li></ul><h2 id="推送主分支"><a href="#推送主分支" class="headerlink" title="推送主分支"></a>推送主分支</h2><ul><li>这章要展示的是，开发者从远程仓库获取主分支的更新，然后在本地其它分支开发完后，如何在主分支上完成更新并推送的步骤。</li></ul><ol><li><p>获取主分支的更新，为了保持<strong>线性</strong>的提交历史，就可以采用<code>git pull --rebase</code>，注意，先切换到主分支再用 pull；</p></li><li><p>然后更新本地主分支，此时主分支已经接收了远程仓库的更新。那么这里为了<strong>线性</strong>的提交历史，还是选择 rebase 方法，分别让其它几个分支变基（<a href="/posts/c477e115.html" title="【一起来学 Git】LearnGitBranching-基础篇【Learn Git Together】">【一起来学 Git】LearnGitBranching-基础篇【Learn Git Together】</a>）就行；</p></li><li><p>最后推送，这个简单，<code>git push</code>;</p></li></ol><h2 id="合并远程仓库"><a href="#合并远程仓库" class="headerlink" title="合并远程仓库"></a>合并远程仓库</h2><ul><li><p>这章和上一章要解决的是一个问题，只不过不要求<strong>线性</strong>的提交历史，用 merge 实现主分支的功能更新。</p></li><li><p>merge 不说怎么搞了，但是这一章关卡过完就能够深刻地感受到，<strong>线性</strong>的提交历史多清晰，多好看。</p></li></ul><h2 id="远程跟踪分支"><a href="#远程跟踪分支" class="headerlink" title="远程跟踪分支"></a>远程跟踪分支</h2><ul><li><p>本章解释了 main，origin&#x2F;main 如何关联的。其实除了之前所说的 pull 和 push 时两者的关系外，它们其实在 clone 其实会自动关联起来。</p></li><li><p>注意，远程分支的跟踪可以自定义，比如<code>git checkout -b foo origin/main</code>，那么就会新建一个分支 foo 跟踪远程分支 origin&#x2F;main，此时要是<code>git pull</code>就会把本地没有的提交拉取下来，更新到 origin&#x2F;main 和 foo 上。</p></li><li><p><strong>注意</strong>，自定义后，原来的 main 就没有跟踪 origin&#x2F;main 了，所以刚刚的拉取不会更新 main。</p></li><li><p>同理，推送 push 时，也可以推送到远程的指定分支，比如上面关联后，<code>git push</code>就会把 foo 上新的提交推送到远程仓库的 main 上。</p></li><li><p>但是，上面的绑定方法也会新建分支，有没有直接绑定现有分支和远程分支的方法呢？有的：）<code>git branch -u origin/main foo</code>就能让 foo 跟踪 远程仓库的 main ，而且如果当前分支就是 foo，还能省略成<code>git branch -u origin/main</code>。</p></li></ul><h2 id="Git-push-的参数"><a href="#Git-push-的参数" class="headerlink" title="Git push 的参数"></a>Git push 的参数</h2><ul><li><p>有时候想不切换过去，而是直接推送一个分支上去，那就用到本章知识。</p></li><li><p>比如，当前的<code>HEAD</code>指针在其它地方，却想把本地的 foo 分支推到远程的 foo 分支。而如果直接写<code>git push</code>，是不会有用的，因为完整的句子其实是<code>git push &lt;remote&gt; &lt;locale&gt;</code>。这里的<code>&lt;remote&gt;</code>指的是目的地——远程仓库，一般写 origin 就行，<code>&lt;locale&gt;</code>是本地分支的名字。</p></li></ul><h2 id="Git-push-的参数2"><a href="#Git-push-的参数2" class="headerlink" title="Git push 的参数2"></a>Git push 的参数2</h2><ul><li><p>上面的 push 参数能够让指定分支推送上去，但有时候在其他分支开发的东西，想推送到远程仓库的指定分支，这个时候就可以设定 push 的参数来实现。</p></li><li><p>比如<code>git push origin foo^:main</code>就会把 foo 的上一个提交之前的远程仓库没有的提交推送到远程仓库的 main 分支上，如果远程仓库没有 main 分支，就会新建一个 main 分支获取推送信息。</p></li></ul><h2 id="Git-fetch-的参数"><a href="#Git-fetch-的参数" class="headerlink" title="Git fetch 的参数"></a>Git fetch 的参数</h2><ul><li><p>与上面的 push 类似，拿例子比较好理解。</p></li><li><p>对于<code>git fetch origin foo</code> 则会把远程仓库中<code>foo</code>的本地没有的提交给 fetch 下来，更新到 origin&#x2F;foo 上。</p></li><li><p>对于<code>git fetch orgin main^:foo</code>则会把远程仓库的<code>main</code>分支上一个提交之前的本地没有的分支 fetch 到本地的 foo 分支上，注意，是 foo 和 origin&#x2F;main 上，不是 origin&#x2F;foo。（这个操作几乎用不到，但语法是支持的）</p></li><li><p>最后，绝大部分情况下，一个<code>git fetch</code>拉取那些更新就行，不用搞上面那些虚头八脑的。</p></li></ul><h2 id="没有-source-的-source"><a href="#没有-source-的-source" class="headerlink" title="没有 source 的 source"></a>没有 source 的 source</h2><ul><li><p>这里看网站内容才能理解标题的含义，下面主要简单说下知识点。</p></li><li><p>Git 支持下面删除远程分支的方式<code>git push origin :foo</code>就会把远程仓库中的 foo 分支给删除。</p></li><li><p>同时也支持下面创建新分支的方式<code>git fetch origin :bar</code>就会在本地新建一个叫 bar 的分支</p></li></ul><h2 id="Git-pull-的参数"><a href="#Git-pull-的参数" class="headerlink" title="Git pull 的参数"></a>Git pull 的参数</h2><ul><li><p>前面（<a href="/posts/2867501f.html" title="【一起来学 Git】LearnGitBranching-Push&amp;Pull-Git远程仓库【Learn Git Together】">【一起来学 Git】LearnGitBranching-Push&amp;Pull-Git远程仓库【Learn Git Together】</a>）说过，pull 就是 fetch +（merge || rebase），所以这里加的参与与 fetch 类似。</p></li><li><p>比如<code>git pull origin foo</code>就会等于<code>git fetch origin foo</code> + <code>git merge origin/foo</code>，<code>git pull origin main^:bar</code>就是<code>git fetch origin main^:bar</code>+<code>git merge bar</code>。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 一起来学 Git | Learn Git Together </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> LearnTogether </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】1658将x减到0的最小操作数</title>
      <link href="/posts/9d513cff.html"/>
      <url>/posts/9d513cff.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/description/">题目链接</a>。</p></li><li><p>简单地说，给你一个整数数组，可以从左或从右一次删除一个数，使得删除的总数之和恰好为x。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>两个思路，正向和逆向，皆基于不定长滑动窗口(<a href="/posts/6dc72043.html" title="【Leetcode Daily】3090每个字符最多出现两次的最长字符串">【Leetcode Daily】3090每个字符最多出现两次的最长字符串</a>)。</p></li><li><p>正向是计算窗口内之和恰好为 x，由于最左和最右的删除形式，可以把原数组拼接。但是还需要限定两点，一个是窗口长度不大于原数组长度；二个是窗口的左侧和右侧满足左侧或者右侧贴边，或者左侧和右侧在加倍窗口的两侧。总之，挺麻烦的。</p></li><li><p>逆向是，先计算数组之和，目标为最大化窗口内数值，至于删除的结果就拿数组和减去窗口值获得。这个简单，不需要加倍数组，也不需要限定窗口位置。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>正向</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minOperations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="type">int</span> m = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//cout &lt;&lt; &quot;m:&quot; &lt;&lt; m &lt;&lt; endl;</span></span><br><span class="line">        nums.<span class="built_in">insert</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>;        </span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cur += nums[i];</span><br><span class="line">            <span class="keyword">while</span> (cur &gt; x) &#123;</span><br><span class="line">                cur -= nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur == x &amp;&amp; i-left<span class="number">+1</span> &lt;= m &amp;&amp; (left == <span class="number">0</span> || (left &lt;= m &amp;&amp; i &gt;= m) || i == n<span class="number">-1</span>)) &#123;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; left &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; cur &lt;&lt; endl;</span></span><br><span class="line">                ans = <span class="built_in">min</span>(ans, i-left<span class="number">+1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == INT_MAX ? <span class="number">-1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>逆向</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minOperations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> win = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> target = <span class="built_in">reduce</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>())-x;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>;        </span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cur += nums[i];</span><br><span class="line">            <span class="keyword">while</span> (target &lt; cur) &#123;</span><br><span class="line">                cur -= nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (target == cur) &#123;</span><br><span class="line">                win = <span class="built_in">max</span>(win, i-left<span class="number">+1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> win&lt;<span class="number">0</span> ? <span class="number">-1</span> : n-win;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 不定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】1004最大连续1的个数III</title>
      <link href="/posts/d5241e62.html"/>
      <url>/posts/d5241e62.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/max-consecutive-ones-iii/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个由 0 和 1 组成的整数数组，现在最多可以把其中 k 个 0 反转成 1。求反转后最长连续 1 的个数。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li>纯粹的不定长滑动窗口（<a href="/posts/6dc72043.html" title="【Leetcode Daily】3090每个字符最多出现两次的最长字符串">【Leetcode Daily】3090每个字符最多出现两次的最长字符串</a>），无需多盐。</li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>陆爻齐的解法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestOnes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> zero_count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;i++) &#123;</span><br><span class="line">            zero_count += <span class="number">1</span>-nums[i];</span><br><span class="line">            <span class="keyword">while</span>(zero_count &gt; k) &#123;</span><br><span class="line">                zero_count -= <span class="number">1</span>-nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, i-left<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 不定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】2024考试的最大困扰度</title>
      <link href="/posts/9e0763eb.html"/>
      <url>/posts/9e0763eb.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/maximize-the-confusion-of-an-exam/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个由 T 和 F 组成的字符串和一个整数 K，可以对整个字符串做最多 K 次的反转（T&lt;-&gt;F），求反转后最长的连续 T 或 F 串长度。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>如果只有单个 T 或 F 就是极其单纯的不定长滑动窗口（<a href="/posts/6dc72043.html" title="【Leetcode Daily】3090每个字符最多出现两次的最长字符串">【Leetcode Daily】3090每个字符最多出现两次的最长字符串</a>），但他两个都要。</p></li><li><p>陆爻齐直接想到的是都求一次，也就是下面的原始解法。</p></li><li><p>但显然，肯定有更好的方法，根据灵茶山艾府的解法，其实不满足的条件直接算 T 和 F 的记录都大于 K 就行。</p><blockquote><p><a href="https://leetcode.cn/problems/maximize-the-confusion-of-an-exam/solutions/1028668/zhi-jie-zhao-ban-1004-de-dai-ma-by-endle-42x3/">https://leetcode.cn/problems/maximize-the-confusion-of-an-exam/solutions/1028668/zhi-jie-zhao-ban-1004-de-dai-ma-by-endle-42x3/</a></p></blockquote></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>陆爻齐的原始解法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxConsecutiveAnswers</span><span class="params">(string answerKey, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> max_true = <span class="number">0</span>, max_false = <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cur_true = <span class="number">0</span>, cur_false = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = answerKey.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (answerKey[i]==<span class="string">&#x27;T&#x27;</span>) &#123;</span><br><span class="line">                cur_true++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cur_false++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(cur_false &gt; k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (answerKey[left++]==<span class="string">&#x27;T&#x27;</span>) &#123;</span><br><span class="line">                    cur_true--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur_false--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            max_true = <span class="built_in">max</span>(i-left<span class="number">+1</span>, max_true);</span><br><span class="line">        &#125;</span><br><span class="line">        cur_true = <span class="number">0</span>, cur_false = <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (answerKey[i]==<span class="string">&#x27;T&#x27;</span>) &#123;</span><br><span class="line">                cur_true++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cur_false++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(cur_true &gt; k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (answerKey[left++]==<span class="string">&#x27;T&#x27;</span>) &#123;</span><br><span class="line">                    cur_true--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur_false--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            max_false = <span class="built_in">max</span>(i-left<span class="number">+1</span>, max_false);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(max_true, max_false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 不定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【一起来学 Git】LearnGitBranching-Push&amp;Pull-Git远程仓库【Learn Git Together】</title>
      <link href="/posts/2867501f.html"/>
      <url>/posts/2867501f.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>这是一个陆爻齐跟着 <code>Learn Git Branching</code> 网站学习(<del>复习</del>) Git 的系列记录，会跟着其内容的步伐做学习记录，并结合自身<strong>浅薄</strong>的知识积累和<strong>几乎为零</strong>的实践经验做<strong>一点点</strong>的补充。</p><blockquote><p><a href="https://learngitbranching.js.org/">https://learngitbranching.js.org</a></p></blockquote></li><li><p>私以为，该网站比较适合有一点 Git 基础来学习，如果是完全零基础，还是看看 Git 官网教程，在 GitHub 这样的代码托管网站走一遍流程比较好。</p></li><li><p>注意，由于下面的笔记不可避免地涉及到过关的答案，所以<strong>强烈建议</strong>，自行体验过网站内容再看本文。</p></li></ul><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><blockquote><p>是时候分享你的代码了，让编码变得社交化吧</p></blockquote><ul><li>事实上，远程仓库的部分才是大部分人使用 Git 的用途。对于自己的本地小项目，多数人倾向于采用比较“简单”的本地复制文件存档。只要这个项目还在开发迭代，过不了多久就会发生版本混乱。</li></ul><h2 id="Git-Clone"><a href="#Git-Clone" class="headerlink" title="Git Clone"></a>Git Clone</h2><ul><li><p>正如网站中所说，网站演示效果与实际不符，输入<code>git clone</code>命令后，并非从远程创建本地复制，而是在本地创建一个远程仓库的副本。</p></li><li><p>这个命令用得可太多了，陆爻齐需要本地复现别人的模型，或者试下别人的开源代码，都需要用 clone 复制仓库副本。（陆爻齐的LALC每天也有不少 clone 的请求啊）</p></li></ul><h2 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h2><ul><li><p>一言以蔽之，就是本地中上一次与远程仓库通信时的状态，该分支是可以用 HEAD 切换上去，不过会自动进入分离 HEAD 的状态，毕竟人工修改本地中远程仓库的状态没有且容易混乱。</p></li><li><p>举一个小栗子更能帮助理解该部分罢。比如，现在直接从一个仓库 clone 下来，你的分支上除了 main，其实还有 origin&#x2F;main，这个 origin 是 git 给远程仓库起的别名（网站用 o 代替）。</p></li><li><p>origin&#x2F;main 只会在远程仓库更新后，与远程仓库交互时才会跟着更新，比如<code>git pull</code>,<code>git push</code>等等。</p></li></ul><h2 id="Git-Fetch"><a href="#Git-Fetch" class="headerlink" title="Git Fetch"></a>Git Fetch</h2><ul><li><p>该命令的作用是，从远程仓库获取数据，让本地的远程分支同步更新一下。具体而言，会从远程仓库下载本地缺失的提交记录和更新远程分支指针。</p></li><li><p><strong>但是</strong>，更新远程分支不等于更新本地分支，所以使用该命令后，你会发现本地仓库的内容一点没变。</p></li><li><p>当然，这个时候通过以前学过的移动分支指针的知识（<a href="/posts/c477e115.html" title="【一起来学 Git】LearnGitBranching-基础篇【Learn Git Together】">【一起来学 Git】LearnGitBranching-基础篇【Learn Git Together】</a>中的 merge、rebase 和 <a href="/posts/b3c82686.html" title="【一起来学 Git】LearnGitBranching-移动提交记录【Learn Git Together】">【一起来学 Git】LearnGitBranching-移动提交记录【Learn Git Together】</a>中的 cherry-pick），就可以实现更新了。比如<code>git fetch; git rebase origin/main</code>, <code>git fetch; git merge origin/main</code>。</p></li><li><p>这个命令存在感很低，至少在陆爻齐十分有限的代码实践环节里没有用过。毕竟从上面几段可以看出，这个命令对应的需求十分常见，而实现需求的过程居然需要两步，这样的麻烦促使后面一个强大命令的诞生<code>git pull</code>。</p></li></ul><h2 id="Git-Pull"><a href="#Git-Pull" class="headerlink" title="Git Pull"></a>Git Pull</h2><ul><li><p>面对<code>git fetch</code>的窘迫，<code>git pull</code>应运而生。</p></li><li><p>普通的<code>git pull</code>对应<code>git fetch; git merge origin/main</code>，而<code>git pull --rebase</code>对应<code>git fetch; git rebase origin/main</code>.</p></li></ul><h1 id="模拟团队合作"><a href="#模拟团队合作" class="headerlink" title="模拟团队合作"></a>模拟团队合作</h1><ul><li><p>网站给了一个模拟其他人提交的命令，和 Git 关系不大，故不做详解。</p></li><li><p>本关只要模拟提交后，pull就行。</p></li></ul><h1 id="Git-Push"><a href="#Git-Push" class="headerlink" title="Git Push"></a>Git Push</h1><ul><li><p>该命令的本质，是把本地的变更上传到远程仓库，同时让本地的远程分支也同步到最新的提交。</p></li><li><p>这个也是核心命令。一般来说，add、commit、push，三件套不会有什么太大的问题（本地的小玩具项目上），不过要真正实现网络远程协作开发，还是远远不够，当然后面会有的：）</p></li></ul><h2 id="偏离的工作"><a href="#偏离的工作" class="headerlink" title="偏离的工作"></a>偏离的工作</h2><ul><li><p>这个标题有些迷惑，要理解这个部分的内容还得看例子。</p></li><li><p>比如说，远程仓库本来最新提交是 c1，现在 A 同学 clone 下来，做了变更作为新提交 c2，但没有立即 push 上去。此时，B 同学 clone 了仓库，开发并 push 了提交 c3，使得远程仓库的最新提交为 c3。接下来，问题来了，A 同学可以把自己的变更 c2 push 上去吗？</p></li><li><p>答案是不行，毕竟 c2 是基于 c1 开发的，而仓库最新的提交是 c3，push 不能直接把 c2 连接到 c3 后，也不会自动从 c1 分离出一条新的分支，无论 A 还是 B 都是用 main 分支。</p></li><li><p>而要解决这个事情有两个方法，merge或rebase，比如用<code>git pull</code>把远程分支拉下来就算是 merge，或者<code>git pull --rebase</code>也能拉下来，不过不会产生merge的交叉，而是rebase。</p></li></ul><h2 id="锁定的Main"><a href="#锁定的Main" class="headerlink" title="锁定的Main"></a>锁定的Main</h2><ul><li><p>拓展下标题，应该是：“解决因锁定的Main而无法直接Push的问题”</p></li><li><p>锁定Main在大公司的Git流程应该属于正常范畴，毕竟如果每个人都能push到 main 那可就混沌咯。</p></li><li><p>所以个人只能在自己的 branch 上开发，然后 push 上去，提 pr 来等待合并。</p></li><li><p>但是如果发生了自己不小心在本地的 main 上提交导致无法 push 上远程仓库的情况呢？那就是本关的内容，其实只要把 main 分支指针移到和远程仓库一样的状态就行。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 一起来学 Git | Learn Git Together </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> LearnTogether </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】2958最多K个重复元素的最长子数组</title>
      <link href="/posts/22746f84.html"/>
      <url>/posts/22746f84.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/length-of-longest-subarray-with-at-most-k-frequency/">题目链接</a>。</p></li><li><p>简单地说，就是求一个整数子数组的最长长度，但该子数组的每个元素重复次数不允许超过k个。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li>不定长滑动窗口（<a href="/posts/6dc72043.html" title="【Leetcode Daily】3090每个字符最多出现两次的最长字符串">【Leetcode Daily】3090每个字符最多出现两次的最长字符串</a>）的经典应用，而且只要把重复的阈值设定为k，那么该题解（<a href="/posts/b5561483.html" title="【Leetcode Daily】1695删除子数组的最大得分">【Leetcode Daily】1695删除子数组的最大得分</a>）也能用。总之很简单，直接看代码吧。</li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>陆爻齐的解法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubarrayLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; rec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> m = nums[i];</span><br><span class="line">            rec[m]++;</span><br><span class="line">            <span class="keyword">while</span>(rec[m]&gt;k) &#123;</span><br><span class="line">                rec[nums[left++]]--;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, i-left<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 不定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】1695删除子数组的最大得分</title>
      <link href="/posts/b5561483.html"/>
      <url>/posts/b5561483.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/maximum-erasure-value/description/">题目链接</a>。</p></li><li><p>简单地说，就是求数组中一段子数组的和的最大值，要求子数组内的元素不重复。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li>纯粹的不定长滑动窗口（<a href="/posts/6dc72043.html" title="【Leetcode Daily】3090每个字符最多出现两次的最长字符串">【Leetcode Daily】3090每个字符最多出现两次的最长字符串</a>），唯一需要注意的是，记得左侧滑动窗口时，减去最左元素的值。</li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>陆爻齐的解法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumUniqueSubarray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;rec;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> m = nums[i];</span><br><span class="line">            sum += m;</span><br><span class="line">            rec[m]++;</span><br><span class="line">            <span class="keyword">while</span>(rec[m]&gt;<span class="number">1</span>) &#123;</span><br><span class="line">                sum -= nums[left];</span><br><span class="line">                rec[nums[left++]]--;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(sum, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 不定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【一起来学 Git】LearnGitBranching-高级话题【Learn Git Together】</title>
      <link href="/posts/5aa3ef8b.html"/>
      <url>/posts/5aa3ef8b.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>这是一个陆爻齐跟着 <code>Learn Git Branching</code> 网站学习(<del>复习</del>) Git 的系列记录，会跟着其内容的步伐做学习记录，并结合自身<strong>浅薄</strong>的知识积累和<strong>几乎为零</strong>的实践经验做<strong>一点点</strong>的补充。</p><blockquote><p><a href="https://learngitbranching.js.org/">https://learngitbranching.js.org</a></p></blockquote></li><li><p>私以为，该网站比较适合有一点 Git 基础来学习，如果是完全零基础，还是看看 Git 官网教程，在 GitHub 这样的代码托管网站走一遍流程比较好。</p></li><li><p>注意，由于下面的笔记不可避免地涉及到过关的答案，所以<strong>强烈建议</strong>，自行体验过网站内容再看本文。</p></li></ul><h1 id="正文-高级话题"><a href="#正文-高级话题" class="headerlink" title="正文-高级话题"></a>正文-高级话题</h1><blockquote><p>只为真正的勇士</p></blockquote><ul><li>说是高级话题，实际上就是一些 Git 版小测，把之前的命令做了一点点的变化</li></ul><h2 id="多次-Rebase"><a href="#多次-Rebase" class="headerlink" title="多次 Rebase"></a>多次 Rebase</h2><ul><li><p>题目说的很明白，“把所有这些分支上所做的工作都通过 rebase 合并到 main 分支上”，无需多盐。</p></li><li><p>对于 rebase 为什么有这样的效果，可以看看此前基础篇相关解释（<a href="/posts/c477e115.html" title="【一起来学 Git】LearnGitBranching-基础篇【Learn Git Together】">【一起来学 Git】LearnGitBranching-基础篇【Learn Git Together】</a>）</p></li></ul><h2 id="两个-Parent-节点"><a href="#两个-Parent-节点" class="headerlink" title="两个 Parent 节点"></a>两个 Parent 节点</h2><ul><li><p>此前没怎么提到 parent 节点这个概念，实际上，一旦在当前的 HEAD 上 commit 一下，现在的节点就是新节点的 parent 节点。</p></li><li><p>而出现两个 parent 节点的情况，就是 merge 命令执行后的交点部分。</p></li><li><p>现在回想下之前学过的相对引用（<a href="/posts/6476fef2.html" title="【一起来学 Git】LearnGitBranching-高级篇【Learn Git Together】">【一起来学 Git】LearnGitBranching-高级篇【Learn Git Together】</a>，比如命令<code>git checkout HEAD^</code>这样的命令会在两个 parent 节点中如何选择呢？</p></li><li><p>答案是，他会自动选择比较早的节点，不过通过命令<code>git checkout HEAD^2</code>可以选择到第二早的节点，<code>^</code>后面的参数不是对几个节点操作的含义（要与<code>~</code>有所区分）而是选择第几个 parent 节点的意思。</p></li><li><p>此外，相对引用支持链式操作，比如本题答案就可以用下面这一条命令来结束<code>git branch -f bugWork HEAD~^2~</code></p></li></ul><h2 id="纠缠不清的分支"><a href="#纠缠不清的分支" class="headerlink" title="纠缠不清的分支"></a>纠缠不清的分支</h2><ul><li>这一题就是 cherry-pick 和分支移动的简单应用，只可惜 cherry-pick 这个命令只能对 HEAD 指着的地方做操作，不然还会更舒服：）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 一起来学 Git | Learn Git Together </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> LearnTogether </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】904水果成篮</title>
      <link href="/posts/da6d362d.html"/>
      <url>/posts/da6d362d.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/fruit-into-baskets/description/">题目链接</a>。</p></li><li><p>简单地说，就是一个整形数组，求最长连续子串，且其中数字种类不超过2.</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>不定长滑动窗口（<a href="/posts/6dc72043.html" title="【Leetcode Daily】3090每个字符最多出现两次的最长字符串">【Leetcode Daily】3090每个字符最多出现两次的最长字符串</a>）+ 哈希表</p></li><li><p>浅浅地说明一下哈希表好了，哈希表int：int，用种类对应数目，当数目为 0 时，erase 掉这个种类，所以哈希表的元素数量就可以代表水果的最大数目。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>陆爻齐的解法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalFruit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; fruits)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; count_fruit;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = fruits.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> index = fruits[i];</span><br><span class="line">            count_fruit[index]++;</span><br><span class="line">            <span class="keyword">while</span>(count_fruit.<span class="built_in">size</span>()&gt;<span class="number">2</span>) &#123;</span><br><span class="line">                count_fruit[fruits[left]]--;</span><br><span class="line">                <span class="keyword">if</span> (count_fruit[fruits[left]]==<span class="number">0</span>) &#123;</span><br><span class="line">                    count_fruit.<span class="built_in">erase</span>(fruits[left]);</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, i-left<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 不定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】1208尽可能使字符串相等</title>
      <link href="/posts/35b06540.html"/>
      <url>/posts/35b06540.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/get-equal-substrings-within-budget/">题目链接</a>。</p></li><li><p>简单地说，就是给两个字符串，和一个整数变量，求一个最长字符串的长度，使得一个字符串变换为另一个（ASCII码差值），变换的总值在那个整数之内。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li>典型的不定长滑动窗口（<a href="/posts/6dc72043.html" title="【Leetcode Daily】3090每个字符最多出现两次的最长字符串">【Leetcode Daily】3090每个字符最多出现两次的最长字符串</a>，无需多盐</li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>陆爻齐的解法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">equalSubstring</span><span class="params">(string s, string t, <span class="type">int</span> maxCost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> curCost = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            curCost += <span class="built_in">abs</span>(s[i]-t[i]);</span><br><span class="line">            <span class="keyword">if</span> (curCost &gt; maxCost) &#123;</span><br><span class="line">                curCost -= <span class="built_in">abs</span>(s[left]-t[left]);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, i-left<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 不定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【一起来学 Git】LearnGitBranching-杂项【Learn Git Together】</title>
      <link href="/posts/506b058c.html"/>
      <url>/posts/506b058c.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>这是一个陆爻齐跟着 <code>Learn Git Branching</code> 网站学习(<del>复习</del>) Git 的系列记录，会跟着其内容的步伐做学习记录，并结合自身<strong>浅薄</strong>的知识积累和<strong>几乎为零</strong>的实践经验做<strong>一点点</strong>的补充。</p><blockquote><p><a href="https://learngitbranching.js.org/">https://learngitbranching.js.org</a></p></blockquote></li><li><p>私以为，该网站比较适合有一点 Git 基础来学习，如果是完全零基础，还是看看 Git 官网教程，在 GitHub 这样的代码托管网站走一遍流程比较好。</p></li><li><p>注意，由于下面的笔记不可避免地涉及到过关的答案，所以<strong>强烈建议</strong>，自行体验过网站内容再看本文。</p></li></ul><h1 id="正文-杂项"><a href="#正文-杂项" class="headerlink" title="正文-杂项"></a>正文-杂项</h1><blockquote><p>Git 技术、技巧与贴士大集合</p></blockquote><ul><li>标题党喵，要是我来总结就是：1. 如何高效修改前几个commit；2. Tag；3. Describe</li></ul><h2 id="只取一个提交记录-提交的技巧-1-提交的技巧-2"><a href="#只取一个提交记录-提交的技巧-1-提交的技巧-2" class="headerlink" title="只取一个提交记录 &amp; 提交的技巧#1 &amp; 提交的技巧#2"></a>只取一个提交记录 &amp; 提交的技巧#1 &amp; 提交的技巧#2</h2><ul><li><p>由于前三个部分说的都是一件事，就合并力。</p></li><li><p>都是为了解决：如果想修改一个处于“中间”的 commit，该如何处理？</p></li><li><p>从 <a href="/posts/b3c82686.html" title="【一起来学 Git】LearnGitBranching-移动提交记录【Learn Git Together】">【一起来学 Git】LearnGitBranching-移动提交记录【Learn Git Together】</a>可以看出，就两个方式 cherry-pick 和交互式 rebase。</p></li><li><p>无论哪个方式，都会遵循下面的步骤来执行（至少是过关的步骤）</p></li></ul><ol><li>提取出中间那个要修改的 commit；</li><li>通过命令<code>git commit --amend</code>来修改 commit 内容；</li><li>按照原定顺序，编排修改后 commit 和涉及到的路程中其它 commit。</li></ol><ul><li>如果感觉上面的步骤说得比较抽象，那么把网站对应部分的关过一次就好力。</li></ul><h2 id="Git-Tag"><a href="#Git-Tag" class="headerlink" title="Git Tag"></a>Git Tag</h2><ul><li><p>就好比是给 commit 下一个“永久”的标签，作为重要版本或者错误修复的标记。</p></li><li><p><code>git tag v1 c1</code>就是给 c1（提交的哈希值）添加一个名为 v1 的标签，后续这个 v1 就当作分支指针一样用，可以<code>git checkout v1</code>。如果没有 c1 这个参数，就默认对 HEAD 正在指着的 commit 贴标签。</p></li><li><p>以及，虽然是使用后面的 describe 命令才发现的事情，但陆爻齐觉着放着比较好。陆爻齐在某个本地仓库实验 describe 命令时，出现了下面的语句提示</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git describe</span><br><span class="line">fatal: No annotated tags can describe &#x27;0f5137947385b1dd89d72a9b68a108b73e81d110&#x27;.</span><br></pre></td></tr></table></figure><ul><li><p>经查阅，该语句的意思是，没有带标注的 tag 可以 describe，之所以会出现这样的情况，是因为之前的 tag 的产生都是在 GitHub 发布 release 时产生的，没有标注。</p><blockquote><p><a href="https://stackoverflow.org.cn/questions/10268641">https://stackoverflow.org.cn/questions/10268641</a></p></blockquote></li><li><p>平常打标签时，尽量打带标注的标签，<code>git tag -a &quot;tag_name&quot; -m &quot;description of tag&quot;</code>。</p></li><li><p>实际上，如果采用命令<code>git describe --tags</code>也可以正常描述无标注的标签。</p></li></ul><h2 id="Git-Describe"><a href="#Git-Describe" class="headerlink" title="Git Describe"></a>Git Describe</h2><ul><li><p><code>git describe</code>用于描述当前 HEAD 与上一个标签的情况，比如<code>V3.1.1-8-g0f51379</code>的意思是：上一个标签是叫 V3.1.1，距离是八个 commit，该 tag 的 commit 的哈希值为 g0f51379。</p></li><li><p>当然如果给后面加点参数会更灵活，比如<code>git describe main</code>就会描述 main 前面 tag 的情况，以及上面的<code>git describe --tags</code>就可以描述无标注标签的情况。</p></li><li><p>以及，如果当前的 commit 就是最新带 tag 的，describe 命令就会直接输入 tag 的名字。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 一起来学 Git | Learn Git Together </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> LearnTogether </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】1493删掉一个元素以后全为1的最长子数组</title>
      <link href="/posts/c87da625.html"/>
      <url>/posts/c87da625.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/longest-subarray-of-1s-after-deleting-one-element/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个由 0 和 1 组成的数组，现在<strong>需要</strong>从中删除一个元素，求删除后只含 1 的最长子数组长度。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>除了不定长滑动窗口模板的内容（<a href="/posts/6dc72043.html" title="【Leetcode Daily】3090每个字符最多出现两次的最长字符串">【Leetcode Daily】3090每个字符最多出现两次的最长字符串</a>），本题只有一点需要特别注意，那就是必须要删除一个字符的需求。</p></li><li><p>由于这个需求的存在，会造成一种情况，如果子串内没有 0，也必须删除一个字符，而如果子串内有一个 0，那就删除 0 来获取长度。所以可以发现，无论是什么情况，最后求得的结果都要减一。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>陆爻齐的解法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestSubarray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> zero_count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]==<span class="number">0</span>) &#123;</span><br><span class="line">                zero_count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(zero_count&gt;<span class="number">1</span>) &#123;</span><br><span class="line">                zero_count -= <span class="number">1</span>-nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果正规一点，应该用变量m=max(1, zero_count)</span></span><br><span class="line">            <span class="comment">// 然后ans = max(ans,i-left+1-m)；这样的意思比较明确</span></span><br><span class="line">            <span class="comment">// 至少删除一个，有0删0，无0删1，不过正好发现怎么都是1，直接抵消</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, i-left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 不定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】3090每个字符最多出现两次的最长字符串</title>
      <link href="/posts/6dc72043.html"/>
      <url>/posts/6dc72043.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/maximum-length-substring-with-two-occurrences/">题目链接</a>。</p></li><li><p>简单地说，就是给一个字符串，求里面子串的最长长度，该子串需要每个字母不超过两个。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>不定长滑动窗口，在这里正式引入灵神的模板，也就是循环扩大窗口右侧，当条件不满足时，让窗口左侧右移，直到满足条件。</p><blockquote><p><a href="https://leetcode.cn/problems/maximum-length-substring-with-two-occurrences/solutions/2704776/on-hua-dong-chuang-kou-pythonjavacgo-by-hl44d/">https://leetcode.cn/problems/maximum-length-substring-with-two-occurrences/solutions/2704776/on-hua-dong-chuang-kou-pythonjavacgo-by-hl44d/</a></p></blockquote></li><li><p>简单地把2改成1就能用在上一题上力，就是 <a href="/posts/bef9257a.html" title="【Leetcode Daily】3无重复字符的最长子串">【Leetcode Daily】3无重复字符的最长子串</a>。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考灵神的模板答案</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumLengthSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rec</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> index = s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            rec[index]++;</span><br><span class="line">            <span class="keyword">while</span> (rec[index] &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                rec[s[left++]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, i-left<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 不定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】3无重复字符的最长子串</title>
      <link href="/posts/bef9257a.html"/>
      <url>/posts/bef9257a.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个字符串，该字符串由字母、数字、符号和空格组成，求其中无重复字符的最长子串。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>这是不定长滑动窗口的开题！不过灵神并没有给出模板题解，所以陆爻齐参照着官方题解试着总结一下模板。</p></li><li><p>哦对，像这种求无重复字符的，如果字符比较特殊，比如本题的字符范围显然就是 ASCII 表，就可以直接用一个长度为 128 的数组记录，相比 unordered_set 方便快捷一点。</p></li><li><p>先想想暴力，直接两层遍历子串的各种组合，第三层检查是否重复，这过于暴力了。</p></li><li><p>相比之下，不定长滑动窗口确实高效不少。滑动窗口本质上就可以视为窗口左边和右边的变化，习惯上可以先移动右边，直到再移动窗口内不符合条件，再记录结果（比如本题记录最长的窗口长度即可），接着移动窗口左边，直到窗口内符合条件（这里移动左边不需要单独循环，原因可以看参考代码），再移动窗口右边，重复至尽。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考着官方题解写的代码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLongestSubstring(string s) &#123;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        int right = 0; // 虽然是左闭右开，但0开始才能记录所有字母</span><br><span class="line">        int n = s.size();</span><br><span class="line">        vector&lt;int&gt; rec(129, 0);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (i!=0) &#123;</span><br><span class="line">                rec[s[i-1]]--;</span><br><span class="line">            &#125;</span><br><span class="line">            while(right &lt; n &amp;&amp; rec[s[right]]==0) &#123;</span><br><span class="line">                rec[s[right]]++;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans, right-i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 不定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【一起来学 Git】LearnGitBranching-移动提交记录【Learn Git Together】</title>
      <link href="/posts/b3c82686.html"/>
      <url>/posts/b3c82686.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>这是一个陆爻齐跟着 <code>Learn Git Branching</code> 网站学习(<del>复习</del>) Git 的系列记录，会跟着其内容的步伐做学习记录，并结合自身<strong>浅薄</strong>的知识积累和<strong>几乎为零</strong>的实践经验做<strong>一点点</strong>的补充。</p><blockquote><p><a href="https://learngitbranching.js.org/">https://learngitbranching.js.org</a></p></blockquote></li><li><p>私以为，该网站比较适合有一点 Git 基础来学习，如果是完全零基础，还是看看 Git 官网教程，在 GitHub 这样的代码托管网站走一遍流程比较好。</p></li><li><p>注意，由于下面的笔记不可避免地涉及到过关的答案，所以<strong>强烈建议</strong>，自行体验过网站内容再看本文。</p></li></ul><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><blockquote><p>自由修改提交树</p></blockquote><ul><li>作者在这表示之前的内容（<a href="/posts/c477e115.html" title="【一起来学 Git】LearnGitBranching-基础篇【Learn Git Together】">【一起来学 Git】LearnGitBranching-基础篇【Learn Git Together】</a>、<a href="/posts/6476fef2.html" title="【一起来学 Git】LearnGitBranching-高级篇【Learn Git Together】">【一起来学 Git】LearnGitBranching-高级篇【Learn Git Together】</a>）已经涵盖了 Git 90% 的功能，但是剩下 10% 的功能正是为一些复杂的工作而准备的。</li></ul><h2 id="Git-Cherry-pick"><a href="#Git-Cherry-pick" class="headerlink" title="Git Cherry-pick"></a>Git Cherry-pick</h2><ul><li><p>正如本篇的引语一般可以自由地修改提交树（的一点），可以把任意 commit 集中到当前分支上来，比如在其他分支有名为 c2、c5 的分支（这里的名指的是哈希值），那么可以用以下命令来实现集中 c2 和 c5 到当前分支来。<code>git cherry-pick c2 c5</code></p></li><li><p>非常地简单啊，还是赶紧到下一个环节罢。</p></li></ul><h2 id="交互式-rebase"><a href="#交互式-rebase" class="headerlink" title="交互式 rebase"></a>交互式 rebase</h2><ul><li><p>此前在 <a href="/posts/6476fef2.html" title="【一起来学 Git】LearnGitBranching-高级篇【Learn Git Together】">【一起来学 Git】LearnGitBranching-高级篇【Learn Git Together】</a>，我们学过 git rebase，这里用到了其中的参数，-i，也就是使其能够交互的原因。</p></li><li><p>比如我要对包括新 commit 在内，HEAD的前四个 commit 做修改，那么就用命令<code>git rebase -i HEAD~4</code>。在修改完后，会在前面第五个 commit 出现另一条分支，把修改后的四个 commit 复制到这个小分支上。</p></li><li><p>修改的具体过程在网站采用了另一种形式表达，并支持删除和重新排序。下面陆爻齐复制一下真实情况下，对某个项目采用这个交互式 rebase 出现的操作界面。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">pick f8a55e9 [3.1.4]update themepack config</span><br><span class="line">pick e78d15b [3.1.5]1. rewrite i18n to avoid having to update it frequently; 2. add style refresh when cost enough; 3. avoid the ego gift about ego resource</span><br><span class="line">pick ec004ff [3.1.6]1. improve the logic when acquiring the ego; 2. stop when finishing mirror without enough enkephalin modules; 3. only click enhanceable ego in the enhancing</span><br><span class="line">pick 0f51379 [3.1.7]update version</span><br><span class="line"></span><br><span class="line"># Rebase 1725f2a..0f51379 onto 1725f2a (4 commands)</span><br><span class="line">#</span><br><span class="line"># Commands:</span><br><span class="line"># p, pick &lt;commit&gt; = use commit</span><br><span class="line"># r, reword &lt;commit&gt; = use commit, but edit the commit message</span><br><span class="line"># e, edit &lt;commit&gt; = use commit, but stop for amending</span><br><span class="line"># s, squash &lt;commit&gt; = use commit, but meld into previous commit</span><br><span class="line"># f, fixup [-C | -c] &lt;commit&gt; = like &quot;squash&quot; but keep only the previous</span><br><span class="line">#                    commit&#x27;s log message, unless -C is used, in which case</span><br><span class="line">#                    keep only this commit&#x27;s message; -c is same as -C but</span><br><span class="line">#                    opens the editor</span><br><span class="line"># x, exec &lt;command&gt; = run command (the rest of the line) using shell</span><br><span class="line"># b, break = stop here (continue rebase later with &#x27;git rebase --continue&#x27;)</span><br><span class="line"># d, drop &lt;commit&gt; = remove commit</span><br><span class="line"># l, label &lt;label&gt; = label current HEAD with a name</span><br><span class="line"># t, reset &lt;label&gt; = reset HEAD to a label</span><br><span class="line"># m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]</span><br><span class="line">#         create a merge commit using the original merge commit&#x27;s</span><br><span class="line">#         message (or the oneline, if no original merge commit was</span><br><span class="line">#         specified); use -c &lt;commit&gt; to reword the commit message</span><br><span class="line"># u, update-ref &lt;ref&gt; = track a placeholder for the &lt;ref&gt; to be updated</span><br><span class="line">#                       to this position in the new commits. The &lt;ref&gt; is</span><br><span class="line">#                       updated at the end of the rebase</span><br><span class="line">#</span><br><span class="line"># These lines can be re-ordered; they are executed from top to bottom.</span><br><span class="line">#</span><br><span class="line"># If you remove a line here THAT COMMIT WILL BE LOST.</span><br><span class="line">#</span><br><span class="line"># However, if you remove everything, the rebase will be aborted.</span><br><span class="line">#</span><br></pre></td></tr></table></figure><ul><li>可以看到除了删除和重新排序的功能外，还支持合并 commit 等功能，反正十分强大。修改后只要保存这个命令就行。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 一起来学 Git | Learn Git Together </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> LearnTogether </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】30串联所有单词的子串</title>
      <link href="/posts/7268e6e9.html"/>
      <url>/posts/7268e6e9.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/substring-with-concatenation-of-all-words/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个字符串的数组与一个长字符串。现在定义由字符串数组中每个字符串按任意顺序组成的新字符串为一个子串，求长字符串中，所有子串出现的初始索引。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>定长滑动窗口的高级变式，首先假设读者已经具备定长滑动窗口的基本知识（<a href="/posts/92a38711.html" title="【Leetcode Daily】1456定长子串中元音的最大数目">【Leetcode Daily】1456定长子串中元音的最大数目</a>），下面模拟一遍陆爻齐从懵逼到 ac 的思路历程。</p></li><li><p>刚开始下意识地想直接套模板，也就是窗口每次滑入一个字符，然后判断窗口内的单词组成情况。但是这么做的话，其实基本与暴力无异，都是一次遍历获取子串，另一次遍历获取子串内容，违背了滑动窗口对窗口内只用 O（1）复杂度处理的初衷。</p></li><li><p>既然一个个字母滑入不行，那就试试一个个单词滑入吧，题目中也提示了“ words 中所有字符串 长度相同”，换句话就是子串长度固定，且子串中的单词长度也固定。那就把单词当作之前的字母，把子串长度视为窗口大小的限制，这样一写，确实把样例 demo 给过了。当陆爻齐高高兴兴地提交时，遭了当头一棒。</p></li><li><p>上面的这个方法其实符合了核心思想，但忽略了一点，一次滑动一个单词的距离，不就错过了其中单词长度的情况吗？比如一次划四个字母，那么整个子串可能出现的索引只能是四的倍数，而虽然子串及其中间的单词长度固定，但起始的索引可没固定。这里就要引入<strong>多起点滑动窗口</strong>了。</p></li><li><p>所谓的多起点滑动窗口，就是设置多个长度相同的窗口，从不同的起点开始滑动。拿本题来说，如果单词长度为四，那么就需要三个窗口，分别从0，1，2三个起点开始滑，这样才能覆盖到所有的索引情况。不过这个方法如何实现，陆爻齐发现自己的写法与看到的几个题解不太相同，下面都会简单说明一下。</p></li><li><p>先说说陆爻齐的解法，陆爻齐采用二重循环，因为内层是定长滑动窗口模板，外层则是设置滑动窗口起点。每次外层循环都会重置窗口对应的哈希表以及对于窗口内单词数目的记录。思路很简单，不多做说明。代码也在下面可供参考。</p></li><li><p>那么主要说说别人题解的实现思路，别人是通过多个哈希表，每个哈希表记录一个窗口对应的单词，所以就不需要对哈希表的清空。相当于用空间复杂度换一点时间，但是大部分情况下还是陆爻齐的解法更优：）（时间上）</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>陆爻齐的解法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findSubstring</span><span class="params">(string s, vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;string, <span class="type">int</span>&gt; rec_words;</span><br><span class="line">        unordered_map&lt;string, <span class="type">int</span>&gt; rec_win;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> string a : words) &#123;</span><br><span class="line">            rec_words[a]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> word_size = words[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> win_size = word_size*words.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; rec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; word_size; j++) &#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; j &lt;&lt; endl;</span></span><br><span class="line">            rec_win.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="type">int</span> word_count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = word_size+j; i &lt;= s.<span class="built_in">size</span>(); i+=word_size) &#123;</span><br><span class="line">                string tmp=s.<span class="built_in">substr</span>(i-word_size, word_size);</span><br><span class="line">                <span class="comment">//cout &lt;&lt; &quot;enter:&quot; &lt;&lt; tmp &lt;&lt; endl;</span></span><br><span class="line">                word_count++;</span><br><span class="line">                rec_win[tmp]++;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (word_count &lt; words.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rec_win == rec_words) &#123;</span><br><span class="line">                    rec.<span class="built_in">push_back</span>(i-win_size);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                string q_str = s.<span class="built_in">substr</span>(i-win_size, word_size);</span><br><span class="line">                <span class="comment">//cout &lt;&lt; &quot;quit:&quot; &lt;&lt; q_str &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">if</span> (--rec_win[q_str]==<span class="number">0</span>) &#123;</span><br><span class="line">                    rec_win.<span class="built_in">erase</span>(q_str);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】438找到字符串中所有字母异位词</title>
      <link href="/posts/f1f52633.html"/>
      <url>/posts/f1f52633.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">题目链接</a>。</p></li><li><p>简单地说，就是给了两个字符串，求一个字符串的异位词在另一个字符串的所有起始索引，所谓的异位词，就是把字符串中的字母重新排列所得的字符串。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>与上一题<a href="/posts/a0c56f97.html" title="【Leetcode Daily】567字符串的排列">【Leetcode Daily】567字符串的排列</a>十分相似，区别仅在于本题要把所有“异位词”的起始索引都记下，所有只用改几行代码就能 ac 了。</p></li><li><p>不过这题灵茶山艾府有题解，姑且加一段解析他的题解好力。灵茶山艾府的定长滑动窗口解法，是采用两个哈希表，分别记录两边的字符串的各字母个数，滑动窗口的内容也只要维护其中一个哈希表的进出，至于判断异位词的方法，就是简单粗暴地直接用等号判断（unordered_map重载过&#x3D;&#x3D;了罢）。私以为，实现更为符合直觉，不过论效率应该不如陆爻齐的解法，空间上少一个哈希表，时间上差不多罢。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>陆爻齐的解法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rec</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> count_char = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span> a : p) &#123;</span><br><span class="line">            rec[a-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            <span class="keyword">if</span> (rec[a-<span class="string">&#x27;a&#x27;</span>]==<span class="number">1</span>) count_char++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> win = p.<span class="built_in">length</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rec[s[i]-<span class="string">&#x27;a&#x27;</span>]--==<span class="number">1</span>) count_char--;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &lt; win<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (count_char==<span class="number">0</span>) res.<span class="built_in">push_back</span>(i-win<span class="number">+1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rec[s[i-win<span class="number">+1</span>]-<span class="string">&#x27;a&#x27;</span>]++==<span class="number">0</span>) count_char++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】567字符串的排列</title>
      <link href="/posts/a0c56f97.html"/>
      <url>/posts/a0c56f97.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/permutation-in-string/description/">题目链接</a>。</p></li><li><p>简单地说，就是给两个字符串，判断一个字符串，是否包含另一个字符串的排列（也就是对每个字母重新排序的字符串）。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>本质是求字符串子串的进阶版，但是其实只是滑动窗口+哈希表的基本运用。哈希表记录字母的次数，滑动窗口则按一定规则更新哈希表，直至哈希表的内部元素为空，则算是满足条件。老样子，放下滑动窗口的模板（<a href="/posts/92a38711.html" title="【Leetcode Daily】1456定长子串中元音的最大数目">【Leetcode Daily】1456定长子串中元音的最大数目</a>）。</p></li><li><p>上面的方法在 C++ 中一般用 unordered_map 来实现，遍历小字符串，记录每个字母对应的个数。然后滑动窗口，对遇到的每个字母做数字减一的操作，减到零就去除元素，字母退出窗口则加一加回去。</p></li><li><p>不过，陆爻齐还是喜欢把字母映射成 vector 中来处理，由于题目说明了，字母只会是小写字母，因此每个字母可以用减去字母’a’处理映射到[0,25]上。那么怎么记录字母是否剪干净了呢？可以引入一个外部整型变量，该变量在vector的某个变量从零到一时加一，从一减到零时减一，也就是统计了尚存字母的个数，该变量为零时，说明满足了条件。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>陆爻齐的解法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkInclusion</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rec_char</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> char_count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span> a : s1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rec_char[a-<span class="string">&#x27;a&#x27;</span>]==<span class="number">0</span>) char_count++;</span><br><span class="line">            rec_char[a-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> win = s<span class="number">1.</span><span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s<span class="number">2.</span><span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            rec_char[s2[i]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="keyword">if</span> (rec_char[s2[i]-<span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                char_count--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &lt; win<span class="number">-1</span>) <span class="keyword">continue</span>; <span class="comment">// i 为 win-1 时，窗口开始为 win</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (char_count == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            rec_char[s2[i-win<span class="number">+1</span>]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            <span class="keyword">if</span> (rec_char[s2[i-win<span class="number">+1</span>]-<span class="string">&#x27;a&#x27;</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                char_count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【一起来学 Git】LearnGitBranching-高级篇【Learn Git Together】</title>
      <link href="/posts/6476fef2.html"/>
      <url>/posts/6476fef2.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>这是一个陆爻齐跟着 <code>Learn Git Branching</code> 网站学习(<del>复习</del>) Git 的系列记录，会跟着其内容的步伐做学习记录，并结合自身<strong>浅薄</strong>的知识积累和<strong>几乎为零</strong>的实践经验做<strong>一点点</strong>的补充。</p><blockquote><p><a href="https://learngitbranching.js.org/">https://learngitbranching.js.org</a></p></blockquote></li><li><p>私以为，该网站比较适合有一点 Git 基础来学习，如果是完全零基础，还是看看 Git 官网教程，在 GitHub 这样的代码托管网站走一遍流程比较好。</p></li><li><p>注意，由于下面的笔记不可避免地涉及到过关的答案，所以<strong>强烈建议</strong>，自行体验过网站内容再看本文。</p></li></ul><h1 id="正文-高级篇"><a href="#正文-高级篇" class="headerlink" title="正文-高级篇"></a>正文-高级篇</h1><blockquote><p>要开始介绍 Git 的超棒特性了，快来吧！</p></blockquote><ul><li>该章节的内容是陆爻齐从未接触过的，不过这也正是学习的意义啊（感慨）</li></ul><h2 id="分离-HEAD"><a href="#分离-HEAD" class="headerlink" title="分离 HEAD"></a>分离 HEAD</h2><ul><li><p>这里的 <code>HEAD</code> 就是 git 操作时正处于的指针位置，一般情况下，<code>HEAD</code> 会跟着分支指针走，比如在<a href="/posts/c477e115.html" title="【一起来学 Git】LearnGitBranching-基础篇【Learn Git Together】">【一起来学 Git】LearnGitBranching-基础篇【Learn Git Together】</a>中，每次输入命令<code>git checkout main</code>，实际上就是让 <code>HEAD</code> 和 main 同步（HEAD-&gt;main-&gt;节点），后续每次 <code>commit</code>，main 会移动，相当于两个指针会一起更新到新的节点。</p></li><li><p>而所谓的分离 <code>HEAD</code>，就是让 <code>HEAD</code> 离开分支头。这里就要引入一个小知识，每个 <code>commit</code> 都会有一串哈希值来对应，不过一般情况下，只要前四个字母就能确认一个 <code>commit</code>。假定某个 <code>commit</code> 的节点哈希值为 c1，那么把 <code>HEAD</code> 移到该节点的命令就是 <code>git checkout c1</code></p></li></ul><h2 id="相对引用1"><a href="#相对引用1" class="headerlink" title="相对引用1"></a>相对引用1</h2><ul><li><p>上面移动 <code>HEAD</code> 的方式需要查看 <code>commit</code> 对应的哈希值（通常用<code>git log</code>命令查看），那么有没有什么简单又强势的方法来移动 <code>HEAD</code> 呢？有的，兄弟，有的：）那就是这里的相对引用。</p></li><li><p>比如，我想移到 main 的上一个节点，就可以用命令<code>git checkout main^</code>，如果想移到前两个节点，多加个<code>^</code>变成<code>git checkout main^^</code>即可。如果只是移到 <code>HEAD</code> 前一个，也可以，用命令<code>git checkout HEAD^</code>就好。</p></li></ul><h2 id="相对引用2"><a href="#相对引用2" class="headerlink" title="相对引用2"></a>相对引用2</h2><ul><li><p>在前一个章节，虽然学会了相对移动的 一种方式，但是如果想移动多次，比如前一百个节点（一般没这种情况罢），可以用新的符号<code>~</code>，也就是命令<code>git checkout HEAD~100</code>。</p></li><li><p>但是，相对引用实际上应用最多的地方是移动分支的指针，比如我想把 main 分支的指针移动到 <code>HEAD</code> 的前三个点，就用以下命令<code>git branch -f main HEAD~3</code>。注意，这里用的是 branch 而不是 checkout，私以为 checkout 是对 <code>HEAD</code> 的操作，而 branch 是对分支指针的操作。</p></li></ul><h2 id="撤销更改"><a href="#撤销更改" class="headerlink" title="撤销更改"></a>撤销更改</h2><ul><li><p>两个方式 <code>reset</code> 和 <code>revert</code>，一个个介绍。</p></li><li><p>如果现在在本地，你想撤销 main 刚刚提交的 <code>commit</code>，可以用<code>git reset HEAD^</code>来实现，这样相当于把 main 分支指针上移，这时最新的 <code>commit</code> 的变更其实还在，只是不在暂存区了。</p></li><li><p>上面的 <code>reset</code> 命令本质上是通过移动分支指针的方式，但是这种方式肯定不能用于远程的仓库上，所以就需要 <code>revert</code> 命令。同样的用处，命令则是<code>git revert HEAD</code>。该命令实际上会创建新的 <code>commit</code>，该 <code>commit</code> 的内容就是撤销上一次的 <code>commit</code>。如果事项撤销上上次的 <code>commit</code>，则要写<code>git revert HEAD^</code>。这样的命令可以在远程仓库也实现撤销的操作。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 一起来学 Git | Learn Git Together </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> LearnTogether </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】1888使二进制字符串字符交替的最少反转次数</title>
      <link href="/posts/6b1dc510.html"/>
      <url>/posts/6b1dc510.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个由 0 和 1 组成的字符串，想把该字符串改造为交替字符串，也就是 0 和 1 交替，但是只能做两个操作，1. 把第一个字符放到最后； 2. 使任意位置字符反转（0和1）。求实现的最少操作二次数。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>挺绕的，让吃完火锅的脑子转不过来。不过通过滑动窗口能够优雅地解决。</p><blockquote><p><a href="https://leetcode.cn/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/solutions/1/ding-chang-hua-dong-chuang-kou-bian-shi-dqfi2/">https://leetcode.cn/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/solutions/1/ding-chang-hua-dong-chuang-kou-bian-shi-dqfi2/</a></p></blockquote></li><li><p>简单说明思路，就是要解决两个问题：如何模拟操作一以及如何模拟操作二。</p></li><li><p>对于第一个问题，如果真的不断地把第一个字符放最后，也不难，但字符串操作效率不高，通过加倍字符串，然后让窗口直接向后滑动就能模拟每种操作一的情况了。老样子，还是把滑动窗口模板放一下（<a href="/posts/92a38711.html" title="【Leetcode Daily】1456定长子串中元音的最大数目">【Leetcode Daily】1456定长子串中元音的最大数目</a>）。</p></li><li><p>对于第二个问题，由于连续字符串只有两个情况，010101 和 101010，可以用两个变量，分别存储两种情况下，需要操作二的次数，比如对于 010101，那么下标模 2 为 0 的地方，数值也应为 0，当满足这个条件，对应的变量值就不变，但另外一种情况必定不满足，就加一。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考解决方案</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minFlips</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        s = s + s; <span class="comment">// 双倍，通过滑动窗口模拟操作一</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对于滑动窗口的每个值，要满足的字符串情况有两种 010101 和 101010</span></span><br><span class="line">        <span class="type">int</span> cur_num1 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cur_num2 = <span class="number">0</span>;<span class="comment">// 这两个数字分别表示两种情况下，操作二的最小次数</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = INT_MAX;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>*n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;s[i]==<span class="string">&#x27;0&#x27;</span>)||(i%<span class="number">2</span>==<span class="number">1</span>&amp;&amp;s[i]==<span class="string">&#x27;1&#x27;</span>)) &#123;</span><br><span class="line">                cur_num1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cur_num2++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &lt; n<span class="number">-1</span>) <span class="keyword">continue</span>; <span class="comment">// 窗口大小应恰好为 n</span></span><br><span class="line"></span><br><span class="line">            ans = <span class="built_in">min</span>(ans, <span class="built_in">min</span>(cur_num1, cur_num2));</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> drop_index = i-n<span class="number">+1</span>;</span><br><span class="line">            <span class="keyword">if</span> ((drop_index%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;s[drop_index]==<span class="string">&#x27;0&#x27;</span>)||(drop_index%<span class="number">2</span>==<span class="number">1</span>&amp;&amp;s[drop_index]==<span class="string">&#x27;1&#x27;</span>)) &#123;</span><br><span class="line">                cur_num1--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cur_num2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】2653滑动子数组的美丽值</title>
      <link href="/posts/fe2bb093.html"/>
      <url>/posts/fe2bb093.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/sliding-subarray-beauty/">题目链接</a>。</p></li><li><p>简单地说，就是给一个整数数组，元素取值为[-50, 50]，按要求返回各子数组中的“美丽值”，要求子数组的长度为 k，而“美丽值”是其中第 x 小的负数，如果没有负数，则为 0.</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>就是定长滑动窗口模板（<a href="/posts/92a38711.html" title="【Leetcode Daily】1456定长子串中元音的最大数目">【Leetcode Daily】1456定长子串中元音的最大数目</a>）加上了对子数组的穷举遍历。</p><blockquote><p><a href="https://leetcode.cn/problems/sliding-subarray-beauty/solutions/2241294/hua-dong-chuang-kou-bao-li-mei-ju-by-end-9mvl/">https://leetcode.cn/problems/sliding-subarray-beauty/solutions/2241294/hua-dong-chuang-kou-bao-li-mei-ju-by-end-9mvl/</a></p></blockquote></li><li><p>其中是通过把[-50, 50]的数值区间加上偏差值+50，从而转化为[0, 100]的数值遍历，穷尽遍历会在其中从小到大地找出子数组的负数。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>定长滑动窗口+穷举遍历</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getSubarrayBeauty</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> BIAS = <span class="number">50</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">num_rec</span><span class="params">(<span class="number">2</span>*BIAS<span class="number">+1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先初始化 k-1 长度的窗口</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k<span class="number">-1</span>; i++) &#123;</span><br><span class="line">            num_rec[nums[i]+BIAS]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始滑动窗口</span></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n-k<span class="number">+1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k<span class="number">-1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            num_rec[nums[i]+BIAS]++;</span><br><span class="line">            <span class="type">int</span> negative = x;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; BIAS; j++) &#123;</span><br><span class="line">                negative -= num_rec[j];</span><br><span class="line">                <span class="keyword">if</span> (negative &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//cout &lt;&lt; j-BIAS &lt;&lt; endl;</span></span><br><span class="line">                    res[i-k<span class="number">+1</span>] = j-BIAS;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            num_rec[nums[i-k<span class="number">+1</span>]+BIAS]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【一起来学 Git】LearnGitBranching-基础篇【Learn Git Together】</title>
      <link href="/posts/c477e115.html"/>
      <url>/posts/c477e115.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>这是一个陆爻齐跟着 <code>Learn Git Branching</code> 网站学习(<del>复习</del>) Git 的系列记录，会跟着其内容的步伐做学习记录，并结合自身<strong>浅薄</strong>的知识积累和<strong>几乎为零</strong>的实践经验做<strong>一点点</strong>的补充。</p><blockquote><p><a href="https://learngitbranching.js.org/">https://learngitbranching.js.org</a></p></blockquote></li><li><p>私以为，该网站比较适合有一点 Git 基础来学习，如果是完全零基础，还是看看 Git 官网教程，在 GitHub 这样的代码托管网站走一遍流程比较好。</p></li><li><p>注意，由于下面的笔记不可避免地涉及到过关的答案，所以<strong>强烈建议</strong>，自行体验过网站内容再看本文。</p></li></ul><h1 id="正文-基础篇"><a href="#正文-基础篇" class="headerlink" title="正文-基础篇"></a>正文-基础篇</h1><blockquote><p>循序渐进地介绍 Git 主要命令</p></blockquote><ul><li>太主要了，私以为省略了不少，这就是为什么说先看 Git 的官网教程比较好。嘛，下面也会把省略的部分简单带带的：）</li></ul><h2 id="Git-Commit"><a href="#Git-Commit" class="headerlink" title="Git Commit"></a>Git Commit</h2><ul><li><p>commit，翻译过来就是“提交”，相当于为当前的 Git 仓库下的文件做了一个存档，而且每次 commit 并非对所有文件的拷贝，而是会保存该版本与上个版本的差异作为提交记录。</p></li><li><p>命令直接就是<code>git commit</code>，实际上一般 commit 时会附上提交的注解信息，所以个人经常会写<code>git commit -m &quot;你想加的信息&quot;</code>。毕竟后期查起来，如果有一个 commit 的信息写着 “更新A功能”，而该功能正是排查对象，这不就方便多了嘛。</p></li><li><p>不过实际应用时，会先用 add 命令来将文件加入到等待 commit 的列表中，再 commit，这样一来就可以选择性的更改，灵活美丽的设计。</p></li><li><p>查看仓库文件的状态用 status 命令，所谓的状态，主要有没有追踪（也就是没 add 过），待提交（刚 add），更改（commit 过，有变更），删除（这个一般看不到，毕竟都删了）等。有时候仓库结构比较复杂，该命令能够辅助快速查询需要处理的文件有哪些。</p></li><li><p>在网站中，一次 commit 视为一个版本，算是简化了些，也挺好，更能专注于 git 的特性。</p></li></ul><h2 id="Git-Branch"><a href="#Git-Branch" class="headerlink" title="Git Branch"></a>Git Branch</h2><ul><li><p>核心！毕竟网站名都叫这个：）</p></li><li><p>branch，翻译过来是“分支”，该命令和名字一样，会从当前的分支分裂出一条新分支来，说是分裂，其实就多了个分支指针。</p></li><li><p>涉及到的命令多了一点，一点点来罢。</p></li><li><p>首先是<code>git branch dev</code>，这个命令会创建一个名为<code>dev</code>的分支，不过还没切换过去。</p></li><li><p>切换的命令为<code>git checkout dev</code>或者<code>git switch dev</code>，后者是新命令，准备用来代替<code>checkout</code>在分支切换上的功能。</p></li><li><p>不过，如果想新建分支后立即切换过去，可以用<code>git checkout -b dev</code>实现，看着方便，其实用得不算多，不过建议还是记一记。</p></li><li><p>网站中只要新建分支，然后在新分支 commit 一下就过了，没啥好讲的。</p></li><li><p>哦对，一般来说代码托管仓库（Github，Gitee等）默认分支叫 <code>master</code> 或者 <code>main</code>，这些分支会拿去当作主分支，开发的时候可以新建个 <code>dev</code> 分支，然后有什么开发任务就在 <code>dev</code> 先试验完成，差不多了就合并到主分支，这样子版本管理就方便点。</p></li></ul><h2 id="Git-Merge"><a href="#Git-Merge" class="headerlink" title="Git Merge"></a>Git Merge</h2><ul><li><p>也是核心，或者说，灵魂！（<del>塔玛希</del>）</p></li><li><p>该命令就是把另外一条分支合并到本分支来（具体怎么合并，合并冲突如何解决建议看官方文档）</p></li><li><p>如果你对于命令中的分支名字是被合并还是合并的，那么就记住：merge 操作中，当前所处在的分支（当前分支）就是目标分支，要合并到哪个分支，就先切换过去。换句话，就是“merge 过来”。</p></li><li><p>如果当前处于 <code>main</code> 分支，输入命令 <code>git merge dev</code>，那么就会把 <code>dev</code> 分支的最新 commit 的部分合并到当前 <code>main</code> 来，该合并会产生一个新的 commit，commit 的内容就是合并。</p></li><li><p>这个时候，再把分支切换到 <code>dev</code>，然后输入 <code>git merge main</code>，就会把 <code>main</code> 的内容合并到 <code>dev</code>。但是，因为现在的 <code>main</code> 已经合并了 <code>dev</code>，所以实际上的处理会把 <code>dev</code> 的指针直接指到现在 <code>main</code> 最新的 commit。</p></li><li><p>上面两段话如何看着绕，说明没看网站演示，建议实践看看。</p></li><li><p>以及，其实可以不切换分支就直接实现合并，比如现在处于<code>dev</code>，想把<code>dev</code>合并到<code>main</code>上，可以输入命令<code>git merge main dev</code>中来实现。这一点也是刚刚查资料才看到的，涨知识力，下次实践下看看。</p></li></ul><h2 id="Git-Rebase"><a href="#Git-Rebase" class="headerlink" title="Git Rebase"></a>Git Rebase</h2><ul><li><p>也是一种合并分支的方法，相对 merge 而言，没那么瞩目（甚至在这之前，陆爻齐也没用过）</p></li><li><p>翻译过来其实可以叫“变基”，结合这个名字，命令的作用也会更好理解一点。</p></li><li><p>网站上简单说明了 rebase 的结果和作用，通过 rebase，会把一个分支的新 commit 复制到另一个分支中，从而避免 merge 那样分支交叉的样子，呈现出来线性的提交历史。</p></li><li><p>不过其实采用双参数的形式可能会更清晰，比如<code>git rebase main bugFix</code>就会以 <code>main</code> 为基础，编辑两个分支分界点后的 <code>bugFix</code> 的新提交节点，编辑后直接放在 <code>main</code> 最新的提交后。</p></li><li><p>注意，操作目标分支在这里，是“rebase 过去”的形式。比如，当前分支为<code>dev</code>，现在已经在<code>dev</code>分支产生了几个 commit，而<code>main</code>主分支因为其他人的开发也产生了一个新的 commit。对于<code>dev</code>分支来说，除了使用<code>git merge main</code>来把<code>main</code>分支的新 commit 合并过来之外，可以先把当前分支切换到<code>main</code>上，再输入命令<code>git rebase dev</code>，用自然语言表示就是，把<code>dev</code>分支变基为<code>main</code>，这样一来，<code>main</code>的新 commit 就会复制到 <code>dev</code> 的最新 commit 上，避免了一次 merge 产生的分支交叉。</p></li><li><p>实际运用中，十分忌讳对公共分支变基。继续沿用上面的例子，如果不用 merge 来把<code>dev</code>合并到<code>main</code>上，而是 rebase，那将产生可怕的<strong>恶魔</strong>。设想一下，还有很多其它开发者基于<code>main</code>来在其他分支开发功能，而 rebase 突然往<code>main</code>上加了几十条 commit 记录，对于主分支的版本管理无异于从大师卡包里随机选取六十张卡片组成一个卡组那样混乱，而且其它开发者如果想排除主分支对自己分支开发影响，也会很麻烦。</p><blockquote><p><a href="https://developer.aliyun.com/article/1509758">https://developer.aliyun.com/article/1509758</a></p></blockquote></li><li><p>简单小结一下，rebase 可以避免分支交叉使得提交历史线性化一些，总得来说是用于避免一些不必要的 merge，但使用时需要避免对于公共节点的变基。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 一起来学 Git | Learn Git Together </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> LearnTogether </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】1297子串的最大出现次数</title>
      <link href="/posts/4e4c059c.html"/>
      <url>/posts/4e4c059c.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/maximum-number-of-occurrences-of-a-substring/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个字符串，求满足要求的子串中，出现最多的次数。该要求为 1. 内部的字母数量小于 maxLetters；2. 整个字符串的长度在 minSize 和 maxSize 之间（闭区间）。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>该题的难度在于干扰项 maxSize，由于求子串尽可能多的出现，所以该子串的长度必然越小越好，就是 minSize。</p></li><li><p>就是定长滑动窗口(<a href="/posts/92a38711.html" title="【Leetcode Daily】1456定长子串中元音的最大数目">【Leetcode Daily】1456定长子串中元音的最大数目</a>)，有了个字母数量不大于 maxLetters 的限制，再用哈希统计满足要求字符串出现的次数即可。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>陆爻齐的解法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxFreq</span><span class="params">(string s, <span class="type">int</span> maxLetters, <span class="type">int</span> minSize, <span class="type">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rec_letter</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>; <span class="comment">// 记录窗口内个字母的计数</span></span><br><span class="line">        <span class="type">int</span> count_letter = <span class="number">0</span>; <span class="comment">// 窗口内字幕数目的计数</span></span><br><span class="line">        </span><br><span class="line">        unordered_map&lt;string, <span class="type">int</span>&gt; rec_str;</span><br><span class="line">        <span class="type">int</span> max_count_str = <span class="number">0</span>; <span class="comment">// 记录子串出现的最大数目</span></span><br><span class="line"></span><br><span class="line">        string tmps;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            tmps += s[i];</span><br><span class="line">            rec_letter[s[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            <span class="keyword">if</span> (rec_letter[s[i]-<span class="string">&#x27;a&#x27;</span>]==<span class="number">1</span>) count_letter++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &lt; minSize<span class="number">-1</span>) <span class="keyword">continue</span>; <span class="comment">// 窗口大小</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (count_letter &lt;= maxLetters) &#123;</span><br><span class="line">                rec_str[tmps]++;</span><br><span class="line">                max_count_str = <span class="built_in">max</span>(rec_str[tmps], max_count_str);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            rec_letter[tmps[<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="keyword">if</span> (rec_letter[tmps[<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span>]==<span class="number">0</span>) count_letter--;</span><br><span class="line">            tmps.<span class="built_in">erase</span>(tmps.<span class="built_in">begin</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_count_str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】2134最少交换次数来组合所有的1II</title>
      <link href="/posts/4c83e11b.html"/>
      <url>/posts/4c83e11b.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/minimum-swaps-to-group-all-1s-together-ii/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个由 1 和 0 组成的数组，求把所有的 1 放在一起所需要的最少交换次数。注意数组视为环形数组，即第一个和最后一个相邻，且交换可以是数组中任意两个位置的交换。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>阅读题，先不看环形数组来试着解决一下，实际上，由于数组中 1 的个数固定，可以确定对一个数组，最后连续 1 的长度是确定的。这个 1 的长度，就可以是窗口的定长。由于交换是任意两个位置，只要计算出窗口内最少的 0 的个数，就是所谓的最小交换次数了。</p></li><li><p>那么环形数组的问题如何解决呢？其实也简单，只要把当前数组双倍拼接一下就行。然后使用的时候就不用考虑坐标的变换啥的，直接延长遍历的位置。在这一点上，陆爻齐相对灵茶山艾府做了点优化，灵茶山艾府直接遍历完加长后的数组，而经简单思考就能得知，其实需要多遍历的部分就是一个窗口长度，所以其实遍历原长度加上窗口长度即可，复杂度不变。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>陆爻齐的解法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSwaps</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> win_size = <span class="built_in">reduce</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        nums.<span class="built_in">insert</span>(nums.<span class="built_in">end</span>(), nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> min_swap = INT_MAX;</span><br><span class="line">        <span class="type">int</span> one_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n+win_size; i++) &#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">            one_count += nums[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &lt; win_size<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            min_swap = <span class="built_in">min</span>(min_swap, win_size-one_count);</span><br><span class="line"></span><br><span class="line">            one_count -= nums[i-win_size<span class="number">+1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min_swap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>灵茶山艾府的go解法</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minSwaps</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">tot1 := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">tot1 += num</span><br><span class="line">&#125;</span><br><span class="line">cnt1, maxCnt1 := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">nums = <span class="built_in">append</span>(nums, nums...) <span class="comment">// 断环成链</span></span><br><span class="line"><span class="keyword">for</span> i, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">cnt1 += num</span><br><span class="line"><span class="keyword">if</span> i &gt;= tot1 &#123; <span class="comment">// 滑窗</span></span><br><span class="line">cnt1 -= nums[i-tot1]</span><br><span class="line"><span class="keyword">if</span> cnt1 &gt; maxCnt1 &#123;</span><br><span class="line">maxCnt1 = cnt1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tot1 - maxCnt1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://leetcode.cn/problems/minimum-swaps-to-group-all-1s-together-ii/solutions/1200295/duan-huan-cheng-lian-hua-dong-chuang-kou-ws80/">https://leetcode.cn/problems/minimum-swaps-to-group-all-1s-together-ii/solutions/1200295/duan-huan-cheng-lian-hua-dong-chuang-kou-ws80/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】3439重新安排会议得到最多空余时间I</title>
      <link href="/posts/d77650e.html"/>
      <url>/posts/d77650e.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/reschedule-meetings-for-maximum-free-time-i/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一系列会议的起始时间和结束时间（不重合），可以对其中最多 k 个会议进行时间调整，但不能改变会议的相对顺序，求调整后最大会议间休息时间。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li>可以视作定长滑动窗口，窗口内的最大容量为 k + 1 个空闲时间。关键就在于如何像之前一样获取第 i 个空闲时间了。<blockquote><p><a href="https://leetcode.cn/problems/reschedule-meetings-for-maximum-free-time-i/solutions/3061619/zhuan-huan-cheng-ding-chang-hua-dong-chu-1kg1/">https://leetcode.cn/problems/reschedule-meetings-for-maximum-free-time-i/solutions/3061619/zhuan-huan-cheng-ding-chang-hua-dong-chu-1kg1/</a></p></blockquote></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考解法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxFreeTime</span><span class="params">(<span class="type">int</span> eventTime, <span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; startTime, vector&lt;<span class="type">int</span>&gt;&amp; endTime)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = startTime.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">auto</span> get = [&amp;](<span class="type">int</span> i) -&gt; <span class="type">int</span> &#123; <span class="comment">// lambda，[&amp;]的意思是父域的所有变量以引用形式导入</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> startTime[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">                <span class="keyword">return</span> eventTime - endTime[n - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> startTime[i] - endTime[i - <span class="number">1</span>];</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> s = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            s += <span class="built_in">get</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (i &lt; k) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, s);</span><br><span class="line">            s -= <span class="built_in">get</span>(i - k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】1652拆炸弹</title>
      <link href="/posts/5fef68a9.html"/>
      <url>/posts/5fef68a9.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/defuse-the-bomb/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个整型数组加一个数字 k，按照 k 的值重新生成一个数组，比如 k 为正数，那么数组的每个下标要<strong>同时</strong>替换为其后面 k 个数之和；k 为附属，则换为其前面 k 个数之和。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p><strong>同时</strong>这个关键词说明，各个替换互不影响，正是因此，可以用定长滑动窗口来解决。</p></li><li><p>嘛，还是简单提一下暴力解法，就是先遍历每一位，按照 k 的情况，对每一位设立循环找前或后的数字之和。由于二重循环，时间复杂度就达到了 O(n^2)</p></li><li><p>那么滑动窗口解法首先要找到 k 不同情况下，首个窗口的范围。经测试，第一个窗口右侧的坐标在 k 正数时，会设置为 k+1，而 k 为负数时设为 n。而左侧坐标一直是右侧坐标减去 k 即可。（这里的窗口都是左闭右开的）后续窗口都是右移，参照模板即可（<a href="/posts/92a38711.html" title="【Leetcode Daily】1456定长子串中元音的最大数目">【Leetcode Daily】1456定长子串中元音的最大数目</a></p><blockquote><p><a href="https://leetcode.cn/problems/defuse-the-bomb/solutions/2765762/on-ding-chang-hua-dong-chuang-kou-python-y2py/">https://leetcode.cn/problems/defuse-the-bomb/solutions/2765762/on-ding-chang-hua-dong-chuang-kou-python-y2py/</a></p></blockquote></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参照的解法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">decrypt</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; code, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = code.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> right = k &gt; <span class="number">0</span> ? k<span class="number">+1</span> : n; <span class="comment">// 第一个窗口右边的下标</span></span><br><span class="line"></span><br><span class="line">        k = <span class="built_in">abs</span>(k);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> s = <span class="built_in">reduce</span>(code.<span class="built_in">begin</span>() + right - k, code.<span class="built_in">begin</span>() + right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ans[i] = s;</span><br><span class="line">            s += code[right % n] - code[(right - k) % n]; </span><br><span class="line">            right++;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】1052爱生气的书店老板</title>
      <link href="/posts/43c1b2c7.html"/>
      <url>/posts/43c1b2c7.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/grumpy-bookstore-owner/description/">题目链接</a>。</p></li><li><p>简单地说，就是给两个整型数组，以及一个整数 minutes，按某个要求（具体看原题，难以简化），求一个数组在另一个数组和 minutes 约束下的求的最大值。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li>陆爻齐的思路是计算窗口内（也就是冷静的分钟）不满意生气离开的最大值，加上不生气的心情值，再减去所有生气离开的数值得出答案，但由于思想复杂了点，所以略微修改模板结构，也就是下面陆爻齐的答案。</li><li>参照灵茶山艾府，其实只要区分开两部分相加即可，然后直接参照模板。这两部分，一个是不生气的值，一个是生气下的值，取生气下最大值即可。这样就不用像上面一样多一次运算。<blockquote><p><a href="https://leetcode.cn/problems/grumpy-bookstore-owner/solutions/2751888/ding-chang-hua-dong-chuang-kou-fu-ti-dan-rch7/">https://leetcode.cn/problems/grumpy-bookstore-owner/solutions/2751888/ding-chang-hua-dong-chuang-kou-fu-ti-dan-rch7/</a></p></blockquote></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>陆爻齐的解法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSatisfied</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; customers, vector&lt;<span class="type">int</span>&gt;&amp; grumpy, <span class="type">int</span> minutes)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> mental_sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> max_mental_sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> all_angry = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> all_mental = <span class="built_in">reduce</span>(customers.<span class="built_in">begin</span>(), customers.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; customers.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            cout &lt;&lt; mental_sum &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">if</span> (grumpy[i]) &#123;</span><br><span class="line">                mental_sum += customers[i];</span><br><span class="line">                all_angry += customers[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mental_sum &gt; max_mental_sum) &#123;</span><br><span class="line">                max_mental_sum = mental_sum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; minutes - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (grumpy[i-minutes<span class="number">+1</span>]) mental_sum -= customers[i-minutes<span class="number">+1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> all_mental - all_angry + max_mental_sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 不定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】1423可获得的最大点数</title>
      <link href="/posts/ba08c0dc.html"/>
      <url>/posts/ba08c0dc.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个整型数组和一个数字 k，求按照某种方式下获取卡牌所得的最大点数。该方式为每次只能够取得最左或者最右的卡牌。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>逆向思路，由于每次拿卡牌只拿两侧，所以中间部分是连续的，可以视为一个定长滑动窗口，只不过是求窗口内的最小和，通过这个数值得到答案。滑动窗口模板沿用<a href="/posts/92a38711.html" title="【Leetcode Daily】1456定长子串中元音的最大数目">【Leetcode Daily】1456定长子串中元音的最大数目</a></p></li><li><p>正向思路，穷举所有组合可能。</p><blockquote><p><a href="https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/solutions/2551432/liang-chong-fang-fa-ni-xiang-si-wei-zhen-e3gb/">https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/solutions/2551432/liang-chong-fang-fa-ni-xiang-si-wei-zhen-e3gb/</a></p></blockquote></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>逆向</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxScore</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cardPoints, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">reduce</span>(cardPoints.<span class="built_in">begin</span>(), cardPoints.<span class="built_in">begin</span>()) &lt;&lt; endl;</span><br><span class="line">        <span class="type">int</span> win_size = cardPoints.<span class="built_in">size</span>() - k;</span><br><span class="line">        <span class="keyword">if</span> (win_size == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">reduce</span>(cardPoints.<span class="built_in">begin</span>(), cardPoints.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> min_sum = INT_MAX;</span><br><span class="line">        <span class="type">int</span> cur_sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> all_sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cardPoints.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            all_sum += cardPoints[i];</span><br><span class="line">            cur_sum += cardPoints[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &lt; win_size<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cur_sum &lt; min_sum) min_sum = cur_sum;</span><br><span class="line"></span><br><span class="line">            cur_sum -= cardPoints[i-win_size<span class="number">+1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> all_sum - min_sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>正向</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxScore</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cardPoints, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cards_size = cardPoints.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = cards_size - k;</span><br><span class="line">        <span class="type">int</span> cur_sum = <span class="built_in">reduce</span>(cardPoints.<span class="built_in">begin</span>(), cardPoints.<span class="built_in">begin</span>()+k);</span><br><span class="line">        <span class="type">int</span> tmp_sum = cur_sum;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            tmp_sum += -cardPoints[k<span class="number">-1</span>-i]+cardPoints[cards_size<span class="number">-1</span>-i];</span><br><span class="line">            cur_sum = <span class="built_in">max</span>(cur_sum, tmp_sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur_sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】2461长度为K子数组中的最大和</title>
      <link href="/posts/f55d2bc8.html"/>
      <url>/posts/f55d2bc8.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/maximum-sum-of-distinct-subarrays-with-length-k/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个整型数组和一个数字 K，要求一个长度为 K 且内部数字各不相同的子数组之和的最大值。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li>就是上一题（<a href="/posts/51bf6728.html" title="【Leetcode Daily】2841几乎唯一子数组的最大和">【Leetcode Daily】2841几乎唯一子数组的最大和</a>）把不相同数字固定为 k 的改版，直接用模板（<a href="/posts/92a38711.html" title="【Leetcode Daily】1456定长子串中元音的最大数目">【Leetcode Daily】1456定长子串中元音的最大数目</a>）写过，也就是下面的陆爻齐解法。</li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>陆爻齐解法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maximumSubarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; rec_num;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> cur_sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> type_count = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            cur_sum += nums[i];</span><br><span class="line">            rec_num[nums[i]]++;</span><br><span class="line">            <span class="keyword">if</span> (rec_num[nums[i]]==<span class="number">1</span>) &#123;</span><br><span class="line">                type_count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &lt; k<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (type_count == k &amp;&amp; cur_sum &gt; res) &#123;</span><br><span class="line">                res = cur_sum;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cur_sum -= nums[i-k<span class="number">+1</span>];</span><br><span class="line">            rec_num[nums[i-k<span class="number">+1</span>]]--;</span><br><span class="line">            <span class="keyword">if</span> (rec_num[nums[i-k<span class="number">+1</span>]] == <span class="number">0</span>) &#123;</span><br><span class="line">                type_count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 不定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】2841几乎唯一子数组的最大和</title>
      <link href="/posts/51bf6728.html"/>
      <url>/posts/51bf6728.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/maximum-sum-of-almost-unique-subarray/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个整数数组，以及两个正整数 m 和 k。要求满足某个条件的子数组的和的最大值。该条件为，该子数组内至少有 m 个不同的数字。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>几乎直接套定长滑动窗口模板解决（<a href="/posts/92a38711.html" title="【Leetcode Daily】1456定长子串中元音的最大数目">【Leetcode Daily】1456定长子串中元音的最大数目</a>），也就是下面陆爻齐的解法。而且个人认为比<a href="https://leetcode.cn/problems/maximum-sum-of-almost-unique-subarray/solutions/2424847/hua-dong-chuang-kou-fu-ti-dan-pythonjava-2vd6/">灵茶山艾府的解法</a> 更易于实现与理解。具体细节放第二点。</p></li><li><p>灵茶山艾府的解法可能更贴近模拟的思路，用 map 记录对应数值数量，当数量为零就删除 map 上对应的数值，统计不同种类数只要调用 map 的 size 函数即可。</p></li><li><p>陆爻齐认为，要统计子数组内不同数字的种类，可以引入一个整形变量来管理，当 map 数字对应的值为零，说明这是新的种类，那么该变量加一；而当对 map 对应数字值减一后，如果 map 的值为零，那么说明子数组中没有该值了，该变量也减一。这样的解法避免了对 map 的 erase 操作。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>陆爻齐的解法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maxSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> m, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; rec_num; <span class="comment">// 记录窗口内的数值重复情况</span></span><br><span class="line">        <span class="type">int</span> type_num = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> cur_sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            cur_sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (rec_num[nums[i]] == <span class="number">0</span>) type_num++;</span><br><span class="line">            rec_num[nums[i]]++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &lt; k<span class="number">-1</span>) <span class="keyword">continue</span>; <span class="comment">// 初始化窗口</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (type_num &gt;= m) result = <span class="built_in">max</span>(cur_sum, result); <span class="comment">// 满足几乎唯一的条件</span></span><br><span class="line"></span><br><span class="line">            cur_sum -= nums[i-k<span class="number">+1</span>];</span><br><span class="line">            rec_num[nums[i-k<span class="number">+1</span>]]--;</span><br><span class="line">            <span class="keyword">if</span> (rec_num[nums[i-k<span class="number">+1</span>]]==<span class="number">0</span>) type_num--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】2379得到K个黑块的最少涂色次数</title>
      <link href="/posts/a4720173.html"/>
      <url>/posts/a4720173.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个由’W’和’B”组成的字符串，w是白色色块，b是黑色色块。再给一个整数 K，要求如果要一个连续 K 个黑色块的子数组，至少要填几次白色快为黑色。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>本质还是定长滑动窗口的模板题（<a href="/posts/9087881b.html" title="【Leetcode Daily】1534统计好三元组">【Leetcode Daily】1534统计好三元组</a>），具体思路直接略，下面陆爻齐的解法也就是该模板解法</p></li><li><p>但是，由于’W’的’B’的 ASCII 码最低位的值分别为 1 和 0.所以可以通过二进制避免分支预测。</p><blockquote><p><a href="https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks/">https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks/</a></p></blockquote></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>陆爻齐的解法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumRecolors</span><span class="params">(string blocks, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> min_oper = INT_MAX;</span><br><span class="line">        <span class="type">int</span> white_count = <span class="number">0</span>;  <span class="comment">// 既是表示窗口内白色块数组，又是表示涂色的次数</span></span><br><span class="line">        <span class="type">int</span> block_size = blocks.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; block_size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (blocks[i] == <span class="string">&#x27;W&#x27;</span>) white_count++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &lt; k<span class="number">-1</span>) <span class="keyword">continue</span>; <span class="comment">// 达到窗口大小</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (white_count &lt; min_oper) min_oper = white_count;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (blocks[i-k<span class="number">+1</span>]==<span class="string">&#x27;W&#x27;</span>) white_count--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min_oper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>避免分支预测解法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minimumRecolors(string blocks, int k) &#123;</span><br><span class="line">        int cnt_w = 0;</span><br><span class="line">        for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">            cnt_w += blocks[i] &amp; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = cnt_w;</span><br><span class="line">        for (int i = k; i &lt; blocks.length(); i++) &#123;</span><br><span class="line">            cnt_w += (blocks[i] &amp; 1) - (blocks[i - k] &amp; 1);</span><br><span class="line">            ans = min(ans, cnt_w);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】2090半径为K的子数组平均值</title>
      <link href="/posts/de10af9a.html"/>
      <url>/posts/de10af9a.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/k-radius-subarray-averages/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个整型数组和一个数字 k，要求返回一个数组，每一位对应以该位为中心，半径为 k 的子数组平均值（如果位数不够，则置-1）（如果半径为 3，那么子数组长度为 7）</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li>是滑动窗口的简单变式，本质上，窗口的大小从简单的直接取 k，变成了 1+2*k。其余步骤与 <a href="/posts/92a38711.html" title="【Leetcode Daily】1456定长子串中元音的最大数目">【Leetcode Daily】1456定长子串中元音的最大数目</a> 相同。</li><li>下面的参考实现与灵茶山艾府类似，各别变量的计算与使用有一点差异。<blockquote><p><a href="https://leetcode.cn/problems/k-radius-subarray-averages/solutions/1126276/on-hua-dong-chuang-kou-by-endlesscheng-jtr5/">https://leetcode.cn/problems/k-radius-subarray-averages/solutions/1126276/on-hua-dong-chuang-kou-by-endlesscheng-jtr5/</a></p></blockquote></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>陆爻齐解法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getAverages</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> window_size = <span class="number">1</span> + <span class="number">2</span>*k;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> nums_size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">avg</span><span class="params">(nums_size, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums_size; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &lt; window_size - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            avg[i-k] = sum / window_size;</span><br><span class="line"></span><br><span class="line">            sum -= nums[i-window_size<span class="number">+1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> avg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】1343大小为K且平均值大于等于与之的子数组数目</title>
      <link href="/posts/c509b2d2.html"/>
      <url>/posts/c509b2d2.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个整数数组，两个整数 threshold 和 k。k是限定子数组的长度，threshold 是阈值。求这个数组中长度为 k 且平均值大于阈值 threshold 的数目。</p></li><li><p>注意，在算法题中，子数组默认连续，而子序列默认不连续。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>定长滑动窗口模板秒了,具体参照 <a href="/posts/92a38711.html" title="【Leetcode Daily】1456定长子串中元音的最大数目">【Leetcode Daily】1456定长子串中元音的最大数目</a></p></li><li><p>不过这里的和用 int 也没问题，我估计是因为是大于等于阈值这个条件的关系，大于的情况即使因为整数的小数丢失，也能算做等于情况计入。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>滑动窗口</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numOfSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k, <span class="type">int</span> threshold)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            sum += arr[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &lt; k<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((sum / k) &gt;= threshold) &#123;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sum -= arr[i-k<span class="number">+1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】643子数组最大平均数I</title>
      <link href="/posts/b41dda00.html"/>
      <url>/posts/b41dda00.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/maximum-average-subarray-i/">题目链接</a>。</p></li><li><p>简单地说，就是给一个整数数组和数字 k，要求给出其中 k 个长度的连续子数组平均数的最大值。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li>自从学了定长滑动窗口三步法，思路就很清晰。本题窗口固定长度，可以用。1. 入；2. 更新；3. 出；具体分析请看 <a href="/posts/92a38711.html" title="【Leetcode Daily】1456定长子串中元音的最大数目">【Leetcode Daily】1456定长子串中元音的最大数目</a>。</li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>滑动窗口</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMaxAverage</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> max_average = -(numeric_limits&lt;<span class="type">double</span>&gt;::<span class="built_in">max</span>());</span><br><span class="line">        <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &lt; k - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((sum / k) &gt; max_average) &#123;</span><br><span class="line">                max_average = sum / k;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sum -= nums[i-k<span class="number">+1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_average;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】1456定长子串中元音的最大数目</title>
      <link href="/posts/92a38711.html"/>
      <url>/posts/92a38711.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个字符串以及一个数字 k，要求找出长度为 k 的子串中元音最高的数字。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>暴力解法就是遍历左右长度 k 的子串，同时遍历字串内，求得每个子串的元音个数，从而得出最大值。由于两层遍历，复杂度为 O(n^2)。</p></li><li><p>本题可以采用定长滑动窗口，从而把复杂度降到 O(n)。</p></li><li><p>所谓的滑动窗口由三个部分组成，加入、更新、退出。具体过程如下</p></li></ul><ol><li>加入，让下标为 i 元素进入窗口，如果 i 小于 k - 1 则重复这一步（重复的目的是初始化一个长为 k-1 的窗口）</li><li>更新，更新统计值（最大&#x2F;最小）</li><li>退出，让下标 i-k+1 的元素离开窗口（也就是最左边那个），同时更新统计值<blockquote><p><a href="https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/2809359/tao-lu-jiao-ni-jie-jue-ding-chang-hua-ch-fzfo/">https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/2809359/tao-lu-jiao-ni-jie-jue-ding-chang-hua-ch-fzfo/</a></p></blockquote></li></ol><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>滑动窗口</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxVowels</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> yuan_count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;a&#x27;</span> || s[i] == <span class="string">&#x27;e&#x27;</span> || s[i] == <span class="string">&#x27;i&#x27;</span> || s[i] == <span class="string">&#x27;o&#x27;</span> || s[i] == <span class="string">&#x27;u&#x27;</span>) &#123;</span><br><span class="line">                yuan_count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &lt; k - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            result = <span class="built_in">max</span>(result, yuan_count);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result == k) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">char</span> c = s[i-k<span class="number">+1</span>];</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;a&#x27;</span> || c == <span class="string">&#x27;e&#x27;</span> || c == <span class="string">&#x27;i&#x27;</span> || c == <span class="string">&#x27;o&#x27;</span> || c == <span class="string">&#x27;u&#x27;</span>) &#123;</span><br><span class="line">                yuan_count--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 定长滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】1534统计好三元组</title>
      <link href="/posts/9087881b.html"/>
      <url>/posts/9087881b.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/count-good-triplets/description/?envType=daily-question&envId=2025-04-14">题目链接</a>。</p></li><li><p>简单地说，就是给一个数组，要求统计其中所有满足要求三元组的数量。该要求是，两两之差，满足题目的三个数字。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>首先就是暴力解法，O(n^3)，不过陆爻齐在普通的暴力上做了一点点剪枝，但终究还是暴力。</p></li><li><p>想要比较好的完成本题，就需要学习前缀和，总体的思路是固定三元组中的两个，通过要求来求得剩下一个值的范围，将该范围在前缀和中搜寻，符合则找到合适的三元组。</p><blockquote><p><a href="https://leetcode.cn/problems/count-good-triplets/?envType=daily-question&envId=2025-04-14">https://leetcode.cn/problems/count-good-triplets/?envType=daily-question&amp;envId=2025-04-14</a></p></blockquote></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>陆爻齐小改良的暴力解法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countGoodTriplets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; size; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">abs</span>(arr[i] - arr[j]) &gt; a) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = j + <span class="number">1</span>; k &lt; size; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">abs</span>(arr[j] - arr[k]) &lt;= b &amp;&amp; <span class="built_in">abs</span>(arr[i]-arr[k]) &lt;= c) &#123;</span><br><span class="line">                        <span class="comment">//cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot; &lt;&lt; arr[j] &lt;&lt; &quot; &quot; &lt;&lt; arr[k] &lt;&lt; endl;</span></span><br><span class="line">                        result++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>前缀和解法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countGoodTriplets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>(), mx = ranges::<span class="built_in">max</span>(arr), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(mx<span class="number">+2</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; arr.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="type">int</span> y = arr[j];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = j + <span class="number">1</span>; k &lt; arr.<span class="built_in">size</span>(); k++) &#123;</span><br><span class="line">                <span class="type">int</span> z = arr[k];</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">abs</span>(y-z) &gt; b) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> l = <span class="built_in">max</span>(&#123;y-a, z-c, <span class="number">0</span>&#125;);</span><br><span class="line">                <span class="type">int</span> r = <span class="built_in">min</span>(&#123;y+a, z+c, mx&#125;);</span><br><span class="line">                ans += <span class="built_in">max</span>(s[r<span class="number">+1</span>]-s[l], <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v = y<span class="number">+1</span>; v &lt; mx<span class="number">+2</span>; v++) &#123;</span><br><span class="line">                s[v]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】1922统计好数字的数目</title>
      <link href="/posts/45109f47.html"/>
      <url>/posts/45109f47.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li>想查看原题可以点击<a href="https://leetcode.cn/problems/count-good-numbers/description/?envType=daily-question&envId=2025-04-13">题目链接</a>。</li><li>简单地说，就是给一个数字 n，要求给出满足特定要求的位数为 n 的数字个数，该要求是（从零开始）偶数下标为偶数且奇数下标为质数。</li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li>刚开始本想用数位 dp，但细算觉着计算量还是太大，本地对于每一位实际上没有太多限制，但是总数量非常大，只好看看题解思路。</li><li>本题本质上可以用组合数学算出，一个 n 位的数字，必定有 (n&#x2F;2) 取下位偶数下标，剩下奇数下标，偶数下标有 5 个可能，奇数下标有 4个可能，所以只要计算出 5^((n+1)&#x2F;2) + 4^(n&#x2F;2) 即可（这里的 &#x2F; 为整除）。</li><li>注意，由于数字很大，有两个要点，一个是快速幂，二是如何正确取模。</li></ul><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><ul><li>快速幂的本质是通过把普通的累乘，转化为平方乘积，复杂度由O(n)降到了O(log(n))。</li><li>比如，计算 2 的 13 次方，13 的二进制表示为 1101，2 的 13 次方可以视为 2^4 * 2^3 * 2^1。</li><li>转化为程序的自然语言，就是不断判断次方数的最后一位是否为 1，是的话，将结果乘上当前底数，每次次方数右移时，底数则平方。</li><li>如果指数为负数，则将指数取反得正数，同时把底数求倒数。<blockquote><p><a href="https://leetcode.cn/problems/powx-n/">https://leetcode.cn/problems/powx-n/</a></p></blockquote></li></ul><h2 id="取模方法"><a href="#取模方法" class="headerlink" title="取模方法"></a>取模方法</h2><ul><li>这里涉及到不少离散数学的知识，简单地说，除了 python 以外的语言如果先求解结果再取模一般都会因为溢出出错。因此需要通过下面方法来解决。</li><li>对于加法 a + b，可以这么取模：a + b % MOD</li><li>对于减法 a - b，可以取模：(a - b + MOD ) % MOD</li><li>对于乘法 a*b*c, 可以取模：(a * b % MOD) * c % MOD</li><li>除法尚未理解，姑且放着，用到自然会学：）<blockquote><p><a href="https://leetcode.cn/discuss/post/3584387/fen-xiang-gun-mo-yun-suan-de-shi-jie-dan-7xgu/">https://leetcode.cn/discuss/post/3584387/fen-xiang-gun-mo-yun-suan-de-shi-jie-dan-7xgu/</a></p></blockquote></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>参考的解法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">qpow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x, <span class="type">long</span> <span class="type">long</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n&amp;<span class="number">1</span>) &#123;</span><br><span class="line">                ans = ans * x % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">            x = x * x % MOD;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countGoodNumbers</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">qpow</span>(<span class="number">5</span>, (n<span class="number">+1</span>)/<span class="number">2</span>) * <span class="built_in">qpow</span>(<span class="number">4</span>, n/<span class="number">2</span>) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】2843统计对称整数的数目</title>
      <link href="/posts/d52f4fd7.html"/>
      <url>/posts/d52f4fd7.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/count-symmetric-integers/description/">题目链接</a>。</p></li><li><p>简单地说，就是给一个范围，统计这其中所有的对称整数的数目，对称整数要求有 2*n 位，n是整数，而且前n位数字之和与后n位数字之和相等。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li><p>首先是普通的枚举法，毕竟本题是 easy，数字范围不大，暴力即可 ac。不过如何优雅简洁地暴力也是一门学问，如果是陆爻齐原来的想法，很可能会通过逐位模十来获取位数，但实际上处理数位用字符串更合适，结合上 reduce 函数可以间接地求得数位和，就有了下面的枚举写法。</p></li><li><p>接下来使用数位 dp 就可以解决当数字范围大时候的问题，但安排紧张，就先这样罢，要是能有时间把灵山的慢慢过就好力。</p></li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>枚举法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSymmetricIntegers</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = low; i &lt; high<span class="number">+1</span>; i++) &#123;</span><br><span class="line">            string tmp_s = <span class="built_in">to_string</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (tmp_s.<span class="built_in">size</span>() % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; (<span class="built_in">reduce</span>(tmp_s.<span class="built_in">begin</span>(), tmp_s.<span class="built_in">begin</span>() + tmp_s.<span class="built_in">size</span>()/<span class="number">2</span>) == <span class="built_in">reduce</span>(tmp_s.<span class="built_in">begin</span>() + tmp_s.<span class="built_in">size</span>()/<span class="number">2</span>, tmp_s.<span class="built_in">end</span>()))) &#123;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 枚举 </tag>
            
            <tag> 数位dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】2999统计强大整数的数目</title>
      <link href="/posts/dc9756f0.html"/>
      <url>/posts/dc9756f0.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/count-the-number-of-powerful-integers/description/?envType=daily-question&envId=2025-04-10">题目链接</a>。</p></li><li><p>简单地说，要求你在某个区间内找到所有的“强大整数”，所谓的强大整数，是满足特定后缀（题目给定）的每一位有限制大小的（也是题目给定）的数字。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li>作为一道 Hard 题确实不算容易，陆爻齐一开始尝试了暴力回溯，但由于没有合适地剪枝，还是失败了。</li><li>于是向灵神学习了数位dp来解决此题，所谓的数位就是从数字的位数来看问题。不过既然涉及到了动态规划，就有存储信息从而节省时间的步骤，嘛，具体的下面再说。</li><li>首先，由于数字很大，需要用字符串来表示。然后从左向右逐位遍历数字，这是要做剪枝。要限制每一位的最高位和最低位，当一位数字前面都是最高数字相同，那么自己这一位最大只能到最大数字的相同位置。如果前面有非最高数字，那么该位可以取任意值0-9；最低值同理。</li><li>上面是思路清晰的遍历，但对于本题还不够，会超时，这时需要引入记忆数组（dp）。由于如果某一位开始不用受到数值限制，那么这一位到最后产生的结果是固定的，可以记录下来，后续遇到相同的位数且无数值限制，就可以直接调用数组的数字。</li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>憋出来的数位 dp</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">c2i</span><span class="params">(<span class="type">const</span> <span class="type">char</span> &amp;c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;n, <span class="type">const</span> string &amp;start_str, <span class="type">const</span> string &amp;finish_str, <span class="type">int</span> i, <span class="type">bool</span> limit_high, <span class="type">bool</span> limit_low, <span class="type">int</span> &amp;post_fix_index, <span class="type">const</span> <span class="type">int</span> &amp;limit_num, <span class="type">const</span> string &amp;s, vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; &amp;memo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!limit_high &amp;&amp; !limit_low &amp;&amp; memo[i][<span class="number">0</span>] != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 限制一个数位的最高和最低的值</span></span><br><span class="line">        <span class="type">int</span> high_num = limit_high ? <span class="built_in">c2i</span>(finish_str[i]) : <span class="number">9</span>;</span><br><span class="line">        <span class="type">int</span> low_num = limit_low ? <span class="built_in">c2i</span>(start_str[i]) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; post_fix_index) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> new_num = low_num; new_num &lt;= <span class="built_in">min</span>(high_num,limit_num); new_num++) &#123;</span><br><span class="line">                result += <span class="built_in">dfs</span>(n, start_str, finish_str, i<span class="number">+1</span>, limit_high &amp;&amp; new_num==high_num, limit_low &amp;&amp; new_num == low_num, post_fix_index, limit_num, s, memo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> x = <span class="built_in">c2i</span>(s[i - post_fix_index]);</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= low_num &amp;&amp; x &lt;= <span class="built_in">min</span>(high_num,limit_num)) &#123;</span><br><span class="line">                result = <span class="built_in">dfs</span>(n, start_str, finish_str, i<span class="number">+1</span>, limit_high &amp;&amp; x==high_num, limit_low &amp;&amp; x == low_num, post_fix_index, limit_num, s, memo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!limit_high &amp;&amp; !limit_low) &#123;</span><br><span class="line">            memo[i][<span class="number">0</span>] = result;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">numberOfPowerfulInt</span><span class="params">(<span class="type">long</span> <span class="type">long</span> start, <span class="type">long</span> <span class="type">long</span> finish, <span class="type">int</span> limit, string s)</span> </span>&#123;</span><br><span class="line">        string finish_str = <span class="built_in">to_string</span>(finish);</span><br><span class="line">        string start_str = <span class="built_in">to_string</span>(start);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n = finish_str.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">        start_str = <span class="built_in">string</span>(n - start_str.<span class="built_in">length</span>(), <span class="string">&#x27;0&#x27;</span>) + start_str;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> post_index = n - s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;post:&quot; &lt;&lt; post_index &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">memo</span>(n, <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(<span class="number">1</span>, <span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="built_in">dfs</span>(n, start_str, finish_str, <span class="number">0</span>, <span class="literal">true</span>, <span class="literal">true</span>, post_index, limit, s, memo);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 数位dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】3375使数组的值全部为K的最少操作次数</title>
      <link href="/posts/9cd156e7.html"/>
      <url>/posts/9cd156e7.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/minimum-operations-to-make-array-values-equal-to-k/description/?envType=daily-question&envId=2025-04-09">题目链接</a>。</p></li><li><p>简单地说，就是只能用一种操作来使数组变化，即每次只能把最大值化为第二大值，最终可以将整个数组化为一个值K。其中，所有大于某个值I的数值都相同时，I 叫做合法值。求这个操作次数最小的值是多少。如果不能化为 K，则返回 -1.</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><ul><li>普通的方法就是每次操作都暴力遍历所有值，但是复杂度应该是 O(n^2)。</li><li>陆爻齐把求解的方法更抽象了些，实际上，要求整个数组是否能化为 K，必须要求 K 小于等于数组中的最小值。假设，K 大于数组的最小值，那么 K 就无法作为合法值来合并那些比 K 小的值。而求操作的最小值，实际上就是求有多少个值大于 K，因为每次合法值做合并都是把大于他的值合并成合法值，和大于合法值的数值只有一个数值。</li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ul><li>陆爻齐的解法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minOperations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">is_rec</span><span class="params">(<span class="number">101</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> min_num = INT_MAX;</span><br><span class="line">        <span class="type">int</span> over_k_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> &amp;i : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!is_rec[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; min_num) &#123;</span><br><span class="line">                    min_num = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; k) &#123;</span><br><span class="line">                    over_k_count++;</span><br><span class="line">                &#125;</span><br><span class="line">                is_rec[i] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k &gt; min_num) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> over_k_count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Leetcode Daily】3396使数组元素互不相同所需的最少操作次数</title>
      <link href="/posts/8ae3eeff.html"/>
      <url>/posts/8ae3eeff.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目浅析"><a href="#题目浅析" class="headerlink" title="题目浅析"></a>题目浅析</h1><ul><li><p>想查看原题可以点击<a href="https://leetcode.cn/problems/minimum-number-of-operations-to-make-elements-in-array-distinct/">题目链接</a>。</p></li><li><p>简单地说，就是给一个数组，你要进行操作使得数组中元素各不相同或变成空数组，该操作为去除数组前三个元素。</p></li></ul><h1 id="思路分享"><a href="#思路分享" class="headerlink" title="思路分享"></a>思路分享</h1><h2 id="1-顺着题目走"><a href="#1-顺着题目走" class="headerlink" title="1. 顺着题目走"></a>1. 顺着题目走</h2><ul><li><p>直接用代码来模拟这个过程，听着容易，做着不算难，不过通过一些小细节能够优化这个过程。</p></li><li><p>比如，陆爻齐第一次就用 unordered_map 作为哈希存储重复值，但是后来发现，数值大小为 1-100，于是就可以用长度 100 的整形 vector 来存储，速度和消耗内存也有所提升。</p></li><li><p>嘛，说回题目的模拟思路，首先遍历 nums 来初始化 hash，每个数字对应的数字表示其个数，并且用另一个整数来记录重复数字个数。</p></li><li><p>模拟过程中，陆爻齐采用双指针，左指针从 nums[0] 开始向右每次模拟三步，若有遇到数字是重复的，则更新哈希值，哈希值减少到一定程度就更新记录重复数字的个数变量，直到右指针的末尾或者没有重复数字。</p></li></ul><h2 id="2-逆推法"><a href="#2-逆推法" class="headerlink" title="2. 逆推法"></a>2. 逆推法</h2><ul><li>从模拟的方法来看，其实倒着看更快，毕竟至少后面的部分不重复就行。所以思路就是倒着数不重复的数量，然后计算剩余包含重复数字的部分长度，将该长度整除三就是答案。</li><li>该方法麻烦在要准确地计算数字的关系，说实话，挺麻烦的，思维上，还是模拟法比较节约脑子。</li></ul><h1 id="代码解答（强烈建议自行解答后再看）"><a href="#代码解答（强烈建议自行解答后再看）" class="headerlink" title="代码解答（强烈建议自行解答后再看）"></a>代码解答（强烈建议自行解答后再看）</h1><ol><li>模拟解法</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// unordered_map&lt;int, int&gt; rec;</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumOperations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rec</span><span class="params">(<span class="number">101</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> over_single_count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> &amp; n : nums) &#123;</span><br><span class="line">            rec[n]++;</span><br><span class="line">            <span class="keyword">if</span> (rec[n] == <span class="number">2</span>) &#123;</span><br><span class="line">                over_single_count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> least_oper_count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(over_single_count &gt; <span class="number">0</span> &amp;&amp; left &lt; right) &#123;</span><br><span class="line">            least_oper_count += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt; left + <span class="number">3</span> &amp;&amp; i &lt; right; i++) &#123;</span><br><span class="line">                rec[nums[i]] -= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (rec[nums[i]] == <span class="number">1</span>) &#123;</span><br><span class="line">                    over_single_count -= <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            left += <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> least_oper_count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>逆推解法</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumOperations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">rec</span><span class="params">(<span class="number">101</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> not_over_count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = nums.<span class="built_in">rbegin</span>(); it &lt; nums.<span class="built_in">rend</span>(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!rec[*it]) rec[*it]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            not_over_count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (size-not_over_count)%<span class="number">3</span>==<span class="number">0</span> ? (size-not_over_count)/<span class="number">3</span> : (size-not_over_count)/<span class="number">3</span><span class="number">+1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣日常 | LeetcodeDaily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Weekly Algorithm】算法周记之《代码随想录》图论（四）</title>
      <link href="/posts/503f932b.html"/>
      <url>/posts/503f932b.html</url>
      
        <content type="html"><![CDATA[<h1 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h1><p>本周跟随代码随想录继续图论相关学习，主要聚焦于从一个点到另一个点的最小距离问题，学习了 dijkstra，bellman_ford，floyd，A* 算法。</p><p>相比于此前的算法设计课，更深刻地了解了各个算法的优势和缺点，比如 dijkstra 不能应对 负权 的边，bellman_ford可能会陷入负权回路的陷阱中，A* 不擅长多源距离等。</p><p>至此，代码随想录的一刷算是完成力，嘛，明天起就得开始狠狠二刷咯。</p><h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><ul><li><h2 id="dijkstra-朴素版"><a href="#dijkstra-朴素版" class="headerlink" title="dijkstra(朴素版)"></a>dijkstra(朴素版)</h2></li><li><p><a href="https://www.programmercarl.com/kamacoder/0047.%E5%8F%82%E4%BC%9Adijkstra%E6%9C%B4%E7%B4%A0.html">代码随想录</a></p></li><li><p><a href="https://kamacoder.com/problempage.php?pid=1047">47. 参加科学大会（第六期模拟笔试）</a></p></li><li><p>题意：给一些节点和节点之间部分路径（有向），求起点到终点的最短路径是多少。</p></li><li><p>方法：其实bfs&#x2F;dfs应该也行吧，dijkstra 是求一个点到其余点的最短路径距离。<br>本质和prim差不多，但prim只要关注点之间的距离就行，而dijkstra要考虑的可就多了，每次更新最短距离不仅要看新纳入点与当前体系的距离，还要看起点到体系边缘的距离。  </p><p>但是该方法不能对有负数权值的图使用，比如下面这个<br><img src="/../assets/image_1740494367450_0.png" alt="image.png"><br>从节点一出发，如果按照算法，走的路线是 1-3-4，最后看到1-2；但上帝视角可以看到，应该走 1-2-3-4。路线错误的原因是，该算法处理不了多段路程权值小于一段路程的情况。  </p></li><li><p>参考代码随想录思路的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;climits&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; grid(n+1, vector&lt;int&gt;(n+1, INT_MAX));</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        int s, e, v;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; e &gt;&gt; v;</span><br><span class="line">        grid[s][e] = v;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;bool&gt;visited(n+1, false);</span><br><span class="line">    vector&lt;int&gt;min_dist(n+1, INT_MAX);// 到各点最短距离</span><br><span class="line">    min_dist[1] = 0;// 起点到自己的距离为零</span><br><span class="line">    for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">        // 寻找与当前节点最近的的节点</span><br><span class="line">        int cur = 1; // 默认第一个，解决初始化的问题</span><br><span class="line">        int closest_way = INT_MAX;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            if (!visited[i] &amp;&amp; min_dist[i] &lt; closest_way) &#123;</span><br><span class="line">                cur = i;</span><br><span class="line">                closest_way = min_dist[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 加入访问列表中</span><br><span class="line">        visited[cur] = true;</span><br><span class="line">        </span><br><span class="line">        // 更新最短距离</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            if (!visited[i] &amp;&amp; grid[cur][i] != INT_MAX &amp;&amp; min_dist[cur] + grid[cur][i] &lt; min_dist[i]) &#123;</span><br><span class="line">                min_dist[i] = min_dist[cur] + grid[cur][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (min_dist[n] == INT_MAX) &#123;</span><br><span class="line">        cout &lt;&lt; -1 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        cout &lt;&lt; min_dist[n] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h2 id="dijkstra-堆优化版"><a href="#dijkstra-堆优化版" class="headerlink" title="dijkstra(堆优化版)"></a>dijkstra(堆优化版)</h2></li><li><p><a href="https://www.programmercarl.com/kamacoder/0047.%E5%8F%82%E4%BC%9Adijkstra%E5%A0%86.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p></li><li><p><a href="https://kamacoder.com/problempage.php?pid=1047">47. 参加科学大会（第六期模拟笔试）</a></p></li><li><p>题意：与 [[dijkstra(朴素版)]]相同，都是求起点到终点最短距离</p></li><li><p>方法：此处重点阐述该方法与普通迪杰斯特拉的不同，在[[dijkstra(朴素版)]]中，每次都要遍历所有的边来选取与当前体系距离最短的点，堆优化则是引入了小顶堆来解决这个问题，小顶堆保持堆顶是所有边中最小的那个，每次只需要取堆顶即可。C++中通过优先级队列来实现小顶堆。</p></li><li><p>参考代码随想录思路的解法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;climits&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class my_comparison &#123;</span><br><span class="line">    public:</span><br><span class="line">    bool operator()(const pair&lt;int, int&gt; &amp;lhs, const pair&lt;int, int&gt; &amp;rhs) &#123;</span><br><span class="line">        return lhs.second &gt; rhs.second; // 队尾到队首降序，取出来就是升序</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int,int&gt;&gt;, my_comparison&gt; pq;</span><br><span class="line"></span><br><span class="line">struct Edge &#123;</span><br><span class="line">    int to;// 连接点号</span><br><span class="line">    int val; // 权值</span><br><span class="line">    </span><br><span class="line">    Edge(int a, int b): to(a), val(b) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    vector&lt;list&lt;Edge&gt;&gt; grid(n+1);</span><br><span class="line">    // 初始化</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        int from, to, val;</span><br><span class="line">        cin &gt;&gt; from &gt;&gt; to &gt;&gt; val;</span><br><span class="line">        grid[from].push_back(Edge(to, val));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;bool&gt; visited(n+1, false);</span><br><span class="line">    vector&lt;int&gt; min_dist(n+1, INT_MAX);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    // 初始化优先级队列</span><br><span class="line">    int start = 1;</span><br><span class="line">    int end = n;</span><br><span class="line">    pq.push(make_pair(start, 0));</span><br><span class="line">    min_dist[start] = 0;</span><br><span class="line">    </span><br><span class="line">    // 开始算法</span><br><span class="line">    while(!pq.empty()) &#123;</span><br><span class="line">        // 第一步，取到最近点，取优先级队列队首即可</span><br><span class="line">        pair&lt;int, int&gt; p = pq.top(); </span><br><span class="line">        pq.pop();</span><br><span class="line">        </span><br><span class="line">        // 去除已访问的点</span><br><span class="line">        if (visited[p.first]) continue;</span><br><span class="line">        </span><br><span class="line">        // 标记取点成功</span><br><span class="line">        visited[p.first] = true;</span><br><span class="line">        </span><br><span class="line">        // 开始遍历当前点所连接的其它点</span><br><span class="line">        for (Edge &amp;e : grid[p.first]) &#123;</span><br><span class="line">            if (!visited[e.to] &amp;&amp; e.val + min_dist[p.first] &lt; min_dist[e.to]) &#123;</span><br><span class="line">                min_dist[e.to] = e.val + min_dist[p.first];</span><br><span class="line">                pq.push(make_pair(e.to, min_dist[e.to]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (min_dist[n] != INT_MAX) cout &lt;&lt; min_dist[n] &lt;&lt; endl;</span><br><span class="line">    else cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h2 id="Bellman-ford算法应用"><a href="#Bellman-ford算法应用" class="headerlink" title="Bellman_ford算法应用"></a>Bellman_ford算法应用</h2></li><li><p><a href="https://www.programmercarl.com/kamacoder/0094.%E5%9F%8E%E5%B8%82%E9%97%B4%E8%B4%A7%E7%89%A9%E8%BF%90%E8%BE%93I.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p></li><li><p><a href="https://kamacoder.com/problempage.php?pid=1152">94. 城市间货物运输 I</a></p></li><li><p>题意：本质是有向图中求起点到终点的最短路程，但是可能出现负权值的边</p></li><li><p>方法：由于有负权值的边，不能用迪杰斯特拉，这里就要用 Bellman_ford 算法，该算法本质是对每条边做 n-1 次的松弛，n是点的数量，松弛指的是根据其它点到该点的距离和权值取小值。与此前的最大不同在于，该算法专注于边，所以grid只要记录每条边的起点、终点和权值即可。详情可查看注释与代码。</p><p>但是，该算法不能解决负权回路的问题。  </p></li><li><p>参考代码随想录思路的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;climits&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m; </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    // 初始化, 用于存储所有的边</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; grid;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        int s, t, v;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; t &gt;&gt; v;</span><br><span class="line">        grid.push_back(&#123;s, t, v&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 建立最小距离</span><br><span class="line">    // 对m条边各做n-1次松弛</span><br><span class="line">    vector&lt;int&gt; min_dist(n+1, INT_MAX);</span><br><span class="line">    min_dist[1] = 0;</span><br><span class="line">    </span><br><span class="line">    // 之所以要n-1次，是因为1次松弛能获取起点到该点通过一条边的最小值</span><br><span class="line">    // 每多松弛一次就能多通过一个边</span><br><span class="line">    // n-1 是处理一长条的极端情况</span><br><span class="line">    for (int i = 1; i &lt; n; i++) &#123; // n-1次松弛</span><br><span class="line">        for (auto &amp;e : grid) &#123;</span><br><span class="line">            int from = e[0];</span><br><span class="line">            int to = e[1];</span><br><span class="line">            int val = e[2];</span><br><span class="line">            if (min_dist[from] == INT_MAX) continue; // 该情况说明起点尚未连通</span><br><span class="line">            if (min_dist[to] &gt; min_dist[from] + val) &#123; // 松弛就是更新小值</span><br><span class="line">                min_dist[to] = min_dist[from] + val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (min_dist[n] == INT_MAX) cout &lt;&lt; &quot;unconnected&quot; &lt;&lt; endl;</span><br><span class="line">    else cout &lt;&lt; min_dist[n] &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h2 id="Bellman-ford队列优化算法（SPFA）应用"><a href="#Bellman-ford队列优化算法（SPFA）应用" class="headerlink" title="Bellman_ford队列优化算法（SPFA）应用"></a>Bellman_ford队列优化算法（SPFA）应用</h2></li><li><p><a href="https://www.programmercarl.com/kamacoder/0094.%E5%9F%8E%E5%B8%82%E9%97%B4%E8%B4%A7%E7%89%A9%E8%BF%90%E8%BE%93I-SPFA.html#%E8%83%8C%E6%99%AF">代码随想录</a></p></li><li><p><a href="https://kamacoder.com/problempage.php?pid=1152">94. 城市间货物运输 I</a></p></li><li><p>题意，与 [[Bellman_ford算法应用]]一样，都是在无负权回路的情况下，求起点到终点的最短路径长度。</p></li><li><p>方法，顾名思义，SPFA通过队列一定程度上减少了松弛的次数，在原先的 Bellman_ford算法中，每条边必须要经过 n-1 次松弛，n 为点的数量。显然，很多松弛是不必要的，比如一开始有的点与起点尚未连接就要进行松弛。</p><p>所以可以引入队列来保存起点开始的目标点，每次成功松弛，就将目标点放到队列，遍历完一个点所连边，就排除该点（后续可能再次松弛该点）。  </p></li><li><p>参考代码随想录思路的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;climits&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Edge &#123;</span><br><span class="line">    int to; // 目标</span><br><span class="line">    int val; // 权值</span><br><span class="line">    </span><br><span class="line">    Edge(int a, int b): to(a), val(b) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 初始化</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;list&lt;Edge&gt;&gt; grid(n+1);</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        int s, t, v;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; t &gt;&gt; v;</span><br><span class="line">        grid[s].push_back(Edge(t,v));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;bool&gt; is_in_queue(n+1, false);</span><br><span class="line">    queue&lt;int&gt; q;// 待松弛边</span><br><span class="line">    vector&lt;int&gt; min_dist(n+1, INT_MAX);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    q.push(1);</span><br><span class="line">    is_in_queue[1] = true;</span><br><span class="line">    min_dist[1] = 0;</span><br><span class="line">    while(!q.empty()) &#123;</span><br><span class="line">        int node = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        </span><br><span class="line">        for (const Edge &amp;e : grid[node]) &#123;</span><br><span class="line">            min_dist[e.to] = min(min_dist[e.to], min_dist[node]+e.val);</span><br><span class="line">            if (!is_in_queue[e.to]) &#123; // 成功松弛就准备遍历目标点</span><br><span class="line">                q.push(e.to);</span><br><span class="line">                is_in_queue[e.to] = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        is_in_queue[node] = false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (min_dist[n] == INT_MAX) cout &lt;&lt; &quot;unconnected&quot; &lt;&lt; endl;</span><br><span class="line">    else cout &lt;&lt; min_dist[n] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h2 id="Bellman-ford判断负权回路"><a href="#Bellman-ford判断负权回路" class="headerlink" title="Bellman_ford判断负权回路"></a>Bellman_ford判断负权回路</h2></li><li><p><a href="https://www.programmercarl.com/kamacoder/0095.%E5%9F%8E%E5%B8%82%E9%97%B4%E8%B4%A7%E7%89%A9%E8%BF%90%E8%BE%93II.html#%E6%8B%93%E5%B1%95">代码随想录</a></p></li><li><p><a href="https://kamacoder.com/problempage.php?pid=1153">95. 城市间货物运输 II</a></p></li><li><p>题意，与 [[Bellman_ford算法应用]]类似，但是现在会出现负权回路。</p></li><li><p>方法，要解决负权回路，就要知道一点，在传统的Bellman_ford算法中，每条边最多 n-1 次松弛即可获取结果，此后再多的松弛也不会改变结果。所以，如果一条边松弛次数达到 n 次，说明存在负权回路。</p><p>而对于队列优化版的 Bellman_ford 算法，每个点最多进入队列 n-1 次，毕竟每次进队列，都是因为某条连着这个点的边被成功松弛，如果次数到达 n，也说明存在负权回路。  </p></li><li><p>普通Bellman_ford判断负权回路</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;climits&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m; </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    // 初始化, 用于存储所有的边</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; grid;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        int s, t, v;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; t &gt;&gt; v;</span><br><span class="line">        grid.push_back(&#123;s, t, v&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 建立最小距离</span><br><span class="line">    // 对m条边各做n-1次松弛</span><br><span class="line">    vector&lt;int&gt; min_dist(n+1, INT_MAX);</span><br><span class="line">    min_dist[1] = 0;</span><br><span class="line">    bool circle_flag = false;</span><br><span class="line">    </span><br><span class="line">    // 之所以要n-1次，是因为1次松弛能获取起点到该点通过一条边的最小值</span><br><span class="line">    // 每多松弛一次就能多通过一个边</span><br><span class="line">    // n-1 是处理一长条的极端情况</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123; // n-1次松弛，最后一次用来判断负权回路</span><br><span class="line">        for (auto &amp;e : grid) &#123;</span><br><span class="line">            int from = e[0];</span><br><span class="line">            int to = e[1];</span><br><span class="line">            int val = e[2];</span><br><span class="line">            if (min_dist[from] == INT_MAX) continue; // 该情况说明起点尚未连通</span><br><span class="line">            </span><br><span class="line">            if (min_dist[to] &gt; min_dist[from] + val) &#123; // 松弛就是更新小值</span><br><span class="line">                if (i &lt; n) &#123;</span><br><span class="line">                    min_dist[to] = min_dist[from] + val;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    circle_flag = true;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (circle_flag) break;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (circle_flag) cout &lt;&lt; &quot;circle&quot; &lt;&lt; endl;</span><br><span class="line">    else if (min_dist[n] == INT_MAX) cout &lt;&lt; &quot;unconnected&quot; &lt;&lt; endl;</span><br><span class="line">    else cout &lt;&lt; min_dist[n] &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SPFA判断负权回路  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;climits&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Edge &#123;</span><br><span class="line">    int to; // 目标</span><br><span class="line">    int val; // 权值</span><br><span class="line">    </span><br><span class="line">    Edge(int a, int b): to(a), val(b) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 初始化</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;list&lt;Edge&gt;&gt; grid(n+1);</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        int s, t, v;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; t &gt;&gt; v;</span><br><span class="line">        grid[s].push_back(Edge(t,v));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;bool&gt; is_in_queue(n+1, false);</span><br><span class="line">    queue&lt;int&gt; q;// 待松弛边</span><br><span class="line">    vector&lt;int&gt; min_dist(n+1, INT_MAX);</span><br><span class="line">    bool circle_flag = false;</span><br><span class="line">    vector&lt;int&gt; count_release(n+1, 0);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    q.push(1);</span><br><span class="line">    is_in_queue[1] = true;</span><br><span class="line">    min_dist[1] = 0;</span><br><span class="line">    while(!q.empty()) &#123;</span><br><span class="line">        int node = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        </span><br><span class="line">        for (const Edge &amp;e : grid[node]) &#123;</span><br><span class="line">            min_dist[e.to] = min(min_dist[e.to], min_dist[node]+e.val);</span><br><span class="line">            if (!is_in_queue[e.to]) &#123;</span><br><span class="line">                q.push(e.to);</span><br><span class="line">                is_in_queue[e.to] = true;</span><br><span class="line">                count_release[e.to]++;</span><br><span class="line">                if(count_release[e.to] == n) &#123;</span><br><span class="line">                    circle_flag = true;</span><br><span class="line">                    while(!q.empty()) q.pop();</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        is_in_queue[node] = false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (circle_flag) cout &lt;&lt; &quot;circle&quot; &lt;&lt; endl;</span><br><span class="line">    else if (min_dist[n] == INT_MAX) cout &lt;&lt; &quot;unconnected&quot; &lt;&lt; endl;</span><br><span class="line">    else cout &lt;&lt; min_dist[n] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h2 id="Bellman-ford之单源有限最短路"><a href="#Bellman-ford之单源有限最短路" class="headerlink" title="Bellman_ford之单源有限最短路"></a>Bellman_ford之单源有限最短路</h2></li><li><p><a href="https://www.programmercarl.com/kamacoder/0096.%E5%9F%8E%E5%B8%82%E9%97%B4%E8%B4%A7%E7%89%A9%E8%BF%90%E8%BE%93III.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p></li><li><p><a href="https://kamacoder.com/problempage.php?pid=1154">96. 城市间货物运输 III</a></p></li><li><p>题意：在 [[Bellman_ford判断负权回路]]的基础上，加上了最多经过 k 个节点的限制。</p></li><li><p>方法：两个重点</p><ol><li>经过 k 个节点的本质是，对每条边最多k+1次松弛。因为每次松弛就能让起点向外多延申一边；</li><li>其实以往的 Bellman_ford 的实现中，对所有边遍历 n-1 次后，实际上很可能有边超过了 n-1 次松弛。比如 1 与 3 本没有直接连接，但由于对 1 与 2 的连接，使得 min_dist[3] 可以推出。换句话，就是用了本次遍历的结果推出本应下次遍历的结果。之所以之前的题目都没问题，是因为之前的题目中边松弛过多对结果没有影响。解决方法就是每次遍历时记录上一次的遍历结果，基于这个结果来松弛。</li></ol></li><li><p>参考代码随想录思路的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// 版本一</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;climits&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int src, dst,k ,p1, p2, val ,m , n;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; grid;</span><br><span class="line"></span><br><span class="line">    for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;</span><br><span class="line">        // p1 指向 p2，权值为 val</span><br><span class="line">        grid.push_back(&#123;p1, p2, val&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; src &gt;&gt; dst &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; minDist(n + 1 , INT_MAX);</span><br><span class="line">    vector&lt;int&gt; minDist_copy(n+1);// 记录上一次遍历结果</span><br><span class="line">    minDist[src] = 0;</span><br><span class="line">    for (int i = 1; i &lt;= k + 1; i++) &#123; // 对所有边松弛 k + 1次</span><br><span class="line">        minDist_copy = minDist;</span><br><span class="line">        for (vector&lt;int&gt; &amp;side : grid) &#123;</span><br><span class="line">            int from = side[0];</span><br><span class="line">            int to = side[1];</span><br><span class="line">            int price = side[2];</span><br><span class="line">            if (minDist_copy[from] != INT_MAX &amp;&amp; minDist[to] &gt; minDist_copy[from] + price) minDist[to] = minDist_copy[from] + price;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // for (int i = 0; i &lt;=n; i++) &#123;</span><br><span class="line">    //     cout &lt;&lt; minDist[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    // &#125;</span><br><span class="line">    // cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    if (minDist[dst] == INT_MAX) cout &lt;&lt; &quot;unreachable&quot; &lt;&lt; endl; // 不能到达终点</span><br><span class="line">    else cout &lt;&lt; minDist[dst] &lt;&lt; endl; // 到达终点最短路径</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><h2 id="Floyd算法应用"><a href="#Floyd算法应用" class="headerlink" title="Floyd算法应用"></a>Floyd算法应用</h2></li><li><p><a href="https://www.programmercarl.com/kamacoder/0097.%E5%B0%8F%E6%98%8E%E9%80%9B%E5%85%AC%E5%9B%AD.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p></li><li><p><a href="https://kamacoder.com/problempage.php?pid=1155">97. 小明逛公园</a></p></li><li><p>题目：给一个无向图，要求给出任意起点终点，能够输出存在的最短的路线的长度。</p></li><li><p>方法：这是多源最短路径求解，之前的 [[dijkstra(朴素版)]]和 [[Bellman_ford算法应用]]都是单源最短路径。Floyd算法不要求边的正负值，其中心思想是动态规划。建立三维数组，dp[i][j][k] val 的含义是，节点 i 到 j 经过 [1,k]的中间节点的最短值为 val。只要从0遍历到 k 层，就能获取所有点到其它点的最短路径。</p><p>但是要注意遍历方向，如果去数组按 dp[i][j][k]，那么k的循环必须在最外面一层，而 i 和 j 的顺序无关系。因为初始化时在 dp[i][j][0] 初始化的，必须由 0 层向上遍历才有意义。  </p></li><li><p>参考代码随想录思路的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(n + 1, vector&lt;vector&lt;int&gt;&gt;(n+1, vector&lt;int&gt;(n+1, 10002))); </span><br><span class="line">    // dp[i][j][k] val 的含义是，节点 i 到 j 经过 [1,k]的中间节点的最短值为 val</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        int u, v, w;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        dp[u][v][0] = w;</span><br><span class="line">        dp[v][u][0] = w; // 无向图</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int k = 1; k &lt;= n; k++) &#123;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= n; j++) &#123;</span><br><span class="line">                dp[i][j][k] = min(dp[i][j][k-1], dp[i][k][k-1] + dp[k][j][k-1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int q;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    for (int i = 0; i &lt; q; i++) &#123;</span><br><span class="line">        int s, e;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; e;</span><br><span class="line">        if (dp[s][e][n] == 10002) cout &lt;&lt; -1 &lt;&lt; endl;</span><br><span class="line">        else cout &lt;&lt; dp[s][e][n] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h2 id="A-算法应用"><a href="#A-算法应用" class="headerlink" title="A*算法应用"></a>A*算法应用</h2></li><li><p><a href="https://www.programmercarl.com/kamacoder/0126.%E9%AA%91%E5%A3%AB%E7%9A%84%E6%94%BB%E5%87%BBastar.html#astar">代码随想录</a></p></li><li><p><a href="https://kamacoder.com/problempage.php?pid=1203">127. 骑士的攻击</a></p></li><li><p>题意：给一个起点和终点，从起点只能按一定规则移动，本题走 日（象棋中马的走法），求最短步数。</p></li><li><p>方法：bfs能解决，但时间消耗比较大，这里就要引入 A* 算法。实际上，A*算法没有定式，本质是 bfs，迪杰斯特拉 等算法的优化，其灵魂在于启发函数，通过这个函数指导高效遍历。</p><p>拿本体来说，在 bfs 的基础上，引入优先级队列和启发函数，启发函数用欧拉距离（也可用其它距离表示）衡量目前的点与目标点距离，优先选择离目标更近的点遍历。具体动画可看：<a href="https://kamacoder.com/tools/knight.html">A* &amp;&amp; BFS</a>  </p><p>不过，A* 也有缺点，那就是不能像迪杰斯特拉一样对多个点都有遍历距离。如此看来，A*更适合于有明确信息指向目的地且只要单源的情况。  </p><p>此外，陆爻齐突发奇想，如果点到起点也用启发函数衡量距离会怎样，结果当然有误。其原因在于，对节点统一衡量为 5，相当于对节点有层数的划分。如果也换启发函数，那么算法会趋近于走两点之间连线的点，这不一定是最佳路线，因为有走法规则限制。比如（5，2）和（5，4），在这个错误方法下要可能会走4步才能到。  </p></li><li><p>参考代码随想录思路的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int a1, a2, b1, b2;</span><br><span class="line">int dr[8][2] = &#123;1, 2, 2, 1, 2, -1, 1, -2, -1, -2, -2, -1, -2, 1, -1, 2&#125;;</span><br><span class="line"></span><br><span class="line">int moves[1001][1001];</span><br><span class="line"></span><br><span class="line">struct Knight &#123;</span><br><span class="line">  int x, y;</span><br><span class="line">  int g, h, f; // f = g + h</span><br><span class="line"></span><br><span class="line">  Knight(int a, int b) : x(a), y(b) &#123;&#125;</span><br><span class="line">  Knight() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  bool operator &lt; (const Knight &amp;o) const&#123; return o.f &lt; this-&gt;f; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;Knight&gt; que;</span><br><span class="line"></span><br><span class="line">int dis2begin(Knight &amp;k) &#123;</span><br><span class="line">  return (k.x - a1) * (k.x - a1) + (k.y - a2) * (k.y - a2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int dis2end(Knight &amp;k) &#123;</span><br><span class="line">  return (k.x - b1) * (k.x - b1) + (k.y - b2) * (k.y - b2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bfsastar(Knight &amp;k) &#123;</span><br><span class="line">    Knight cur, next;</span><br><span class="line">    que.push(k);</span><br><span class="line">    while(!que.empty()) &#123;</span><br><span class="line">        cur = que.top(); que.pop();</span><br><span class="line">        if (cur.x == b1 &amp;&amp; cur.y == b2) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; 8; i++) &#123;</span><br><span class="line">            next.x = cur.x + dr[i][0];</span><br><span class="line">            next.y = cur.y + dr[i][1];</span><br><span class="line"></span><br><span class="line">            if (next.x &lt; 1 || next.x &gt; 1000 || next.y &lt; 1 || next.y &gt; 1000) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!moves[next.x][next.y]) &#123;</span><br><span class="line">                moves[next.x][next.y] = moves[cur.x][cur.y] + 1;</span><br><span class="line"></span><br><span class="line">                // 计算f</span><br><span class="line">                //next.g = dis2begin(next);</span><br><span class="line">                next.g = cur.g + 5;</span><br><span class="line">                next.h = dis2end(next);</span><br><span class="line">                next.f = next.g + next.h;</span><br><span class="line"></span><br><span class="line">                que.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  int n;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">  while (n--) &#123;</span><br><span class="line">    memset(moves, 0, sizeof(moves));</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; a1 &gt;&gt; a2 &gt;&gt; b1 &gt;&gt; b2;</span><br><span class="line"></span><br><span class="line">    Knight k(a1, a2);</span><br><span class="line">    k.g = 0;</span><br><span class="line">    k.h = dis2end(k);</span><br><span class="line">    k.f = k.h;</span><br><span class="line">    bfsastar(k);</span><br><span class="line">    while(!que.empty()) que.pop();</span><br><span class="line">    cout &lt;&lt; moves[b1][b2] &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法周记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Weekly Algorithm】算法周记之《代码随想录》图论（三）</title>
      <link href="/posts/8659ba4e.html"/>
      <url>/posts/8659ba4e.html</url>
      
        <content type="html"><![CDATA[<h1 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h1><p>本周跟随《代码随想录》继续学习关于图论的知识，主要是关于并查集以及最小生成树的两个经典算法（prim和kruskal）。</p><p>并查集的作用在于快速区分不同的类别并补充内容。prim 则是从点的角度从图中划分出最小生成树，kruskal 是划分边来种最小生成树。</p><h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><ul><li><h2 id="有向图的完全可达性"><a href="#有向图的完全可达性" class="headerlink" title="有向图的完全可达性"></a>有向图的完全可达性</h2></li><li><p><a href="https://www.programmercarl.com/kamacoder/0105.%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%AE%8C%E5%85%A8%E5%8F%AF%E8%BE%BE%E6%80%A7.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p></li><li><p><a href="https://kamacoder.com/problempage.php?pid=1177">105. 有向图的完全可达性</a></p></li><li><p>问题：给一个有向图，但求中的1节点是否能到达其他节点。</p></li><li><p>方法：从 1 开始 dfs&#x2F;bfs 就可以，重点在于用邻接表存储</p></li><li><p>参考代码随想录思路的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void dfs(const vector&lt;list&lt;int&gt;&gt; grid, vector&lt;bool&gt; &amp;visited, int &amp;count, int node) &#123;</span><br><span class="line">    count++;</span><br><span class="line">    visited[node] = true;</span><br><span class="line">    // 遍历每个节点所链接的部分</span><br><span class="line">    for (const auto &amp;i : grid[node]) &#123;</span><br><span class="line">        if (visited[i]) continue;</span><br><span class="line">        dfs(grid, visited, count, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    </span><br><span class="line">    vector&lt;list&lt;int&gt;&gt; grid(n+1);</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">        int a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        grid[a].push_back(b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;bool&gt; visited(n+1, false);</span><br><span class="line">    int count = 0;</span><br><span class="line">    </span><br><span class="line">    dfs(grid, visited, count, 1);</span><br><span class="line">    </span><br><span class="line">    int result;</span><br><span class="line">    if (count == n) &#123;</span><br><span class="line">        result = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        result = -1;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    // 测试输出图</span><br><span class="line">    // for (int i = 0; i &lt; n+1; i++) &#123;</span><br><span class="line">    //     cout &lt;&lt; i &lt;&lt; &quot;: &quot;;</span><br><span class="line">    //     for (auto &amp;j : grid[i]) &#123;</span><br><span class="line">    //         cout &lt;&lt; j &lt;&lt; &quot; &quot;;</span><br><span class="line">    //     &#125;</span><br><span class="line">    //     cout &lt;&lt; endl;</span><br><span class="line">    // &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h2 id="岛屿的周长"><a href="#岛屿的周长" class="headerlink" title="岛屿的周长"></a>岛屿的周长</h2></li><li><p><a href="https://www.programmercarl.com/kamacoder/0106.%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p></li><li><p><a href="https://kamacoder.com/problempage.php?pid=1178">106. 岛屿的周长</a></p></li><li><p>题意：二维数组中的岛屿没有内部水，求该一个岛屿的边缘周长。</p></li><li><p>方法：两个思路，一个是遍历岛屿，求每块的边界；第二个思路是求岛屿块数，4*块数 - 相邻区块的重叠边，该思路只要注意求相邻区块的方向不要重合，比如每个区块都只检查左上两个方向。</p></li><li><p>参考代码随想录思路的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 一格的四个方向</span><br><span class="line">int dr[4][2] = &#123;1, 0, -1, 0, 0, 1, 0, -1&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    </span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; grid(n, vector&lt;int&gt;(m, 0));</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 遍历统计边</span><br><span class="line">    int edge_num = 0;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            if (grid[i][j] == 0) continue;</span><br><span class="line">            </span><br><span class="line">            for (int k = 0; k &lt; 4; k++) &#123;</span><br><span class="line">                int nx = i + dr[k][0];</span><br><span class="line">                int ny = j + dr[k][1];</span><br><span class="line">                </span><br><span class="line">                if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m || grid[nx][ny] == 0) &#123;</span><br><span class="line">                    edge_num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; edge_num &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h2 id="寻找存在的路径"><a href="#寻找存在的路径" class="headerlink" title="寻找存在的路径"></a>寻找存在的路径</h2></li><li><p><a href="https://www.programmercarl.com/kamacoder/0107.%E5%AF%BB%E6%89%BE%E5%AD%98%E5%9C%A8%E7%9A%84%E8%B7%AF%E5%BE%84.html">代码随想录</a></p></li><li><p><a href="https://kamacoder.com/problempage.php?pid=1179">107. 寻找存在的路径</a></p></li><li><p>题意：给一个无向图和两个点，由于无向图不是连通，要判断两点是否连通</p></li><li><p>方法：用并查集，每次输入边就联系两点的并查集。</p></li><li><p>参考代码随想录思路的解法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int find(vector&lt;int&gt; &amp;father, int a) &#123;</span><br><span class="line">    return father[a] == a ? a : father[a] = find(father, father[a]);// 路径压缩</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    // n个点 m条边</span><br><span class="line">    vector&lt;int&gt; father(n+1, -1);</span><br><span class="line">    </span><br><span class="line">    // 初始化并查集</span><br><span class="line">    for (int i = 0; i &lt; n+1; i++) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        int a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        a = find(father, a);</span><br><span class="line">        b = find(father, b);</span><br><span class="line">        //cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">        if (a != b) father[a] = b;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // for (int i = 0; i &lt; n+1; i++) &#123;</span><br><span class="line">    //     cout &lt;&lt; father[i] &lt;&lt; endl;</span><br><span class="line">    // &#125;</span><br><span class="line">    </span><br><span class="line">    int source, destination;</span><br><span class="line">    cin &gt;&gt; source &gt;&gt; destination;</span><br><span class="line">    </span><br><span class="line">    // 本质上就是两个点是否属于统一个并查集（同一个无向连通图）</span><br><span class="line">    cout &lt;&lt; int(find(father, father[source])==find(father, father[destination])) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h2 id="冗余连接"><a href="#冗余连接" class="headerlink" title="冗余连接"></a>冗余连接</h2></li><li><p><a href="https://www.programmercarl.com/kamacoder/0108.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p></li><li><p><a href="https://kamacoder.com/problempage.php?pid=1181">108. 冗余连接</a></p></li><li><p>题意：给一个无向图的构建，但要求返回最后一个连成环的边</p></li><li><p>方法：用并查集，一旦检测出一个边的两个点在同一个并查集，就返回这条边</p></li><li><p>参考代码随想录思路的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int find(vector&lt;int&gt; &amp;father, int a)&#123; // 查找并查集所属类</span><br><span class="line">    return father[a] == a ? a : father[a] = find(father, father[a]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool join(vector&lt;int&gt; &amp;father, int a, int b) &#123; // 尝试合并两个点</span><br><span class="line">    a = find(father, a);</span><br><span class="line">    b = find(father, b);</span><br><span class="line">    if (a == b) return false;</span><br><span class="line">    father[a] = b;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;int&gt; father(n, 0); // 并查集</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123; // 初始化</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        int a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        if (!join(father, a, b)) &#123;</span><br><span class="line">            cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h2 id="冗余连接II"><a href="#冗余连接II" class="headerlink" title="冗余连接II"></a>冗余连接II</h2></li><li><p><a href="https://www.programmercarl.com/kamacoder/0109.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5II.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p></li><li><p><a href="https://kamacoder.com/problempage.php?pid=1182">109. 冗余连接II</a></p></li><li><p>题意：[[冗余连接]]的有向图版。</p></li><li><p>方法，由于无向图变成有向图，就不能无脑找那个并查集重复的那条边，这只能避免成环的情况，无法避免一个点有两个父节点的情况。</p></li><li><p>参考代码随想录思路的解法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">vector&lt;int&gt; father(1001, 0);</span><br><span class="line"></span><br><span class="line">// 并查集初始化</span><br><span class="line">void init() &#123;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) father[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 寻根</span><br><span class="line">int find(int u) &#123;</span><br><span class="line">    return father[u]==u ? u : father[u] = find(father[u]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 查看是否相同</span><br><span class="line">bool isSame(int p, int q) &#123;</span><br><span class="line">    return find(p) == find(q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 加入并查集</span><br><span class="line">void join(int p, int q) &#123;</span><br><span class="line">    p = find(p);</span><br><span class="line">    q = find(q);</span><br><span class="line">    if (p == q) return;</span><br><span class="line">    father[p] = q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在图里找到要删除的边</span><br><span class="line">// 原理是从前向后找到第一组同一个并查集的的一组点就行</span><br><span class="line">void deleteCircleEdge(const vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123;</span><br><span class="line">    init();</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        if (isSame(edges[i][0], edges[i][1])) &#123;</span><br><span class="line">            cout &lt;&lt; edges[i][0] &lt;&lt; &quot; &quot; &lt;&lt; edges[i][1] &lt;&lt; endl;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            join(edges[i][0], edges[i][1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 判断去除边后剩下能否成树</span><br><span class="line">bool isDelOk(const vector&lt;vector&lt;int&gt;&gt; edges, int del) &#123;</span><br><span class="line">    init();</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        if (i == del) continue;</span><br><span class="line">        if (isSame(edges[i][0], edges[i][1]))&#123; // 出现环说明删除到错的边了，换另一条即可</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        join(edges[i][0], edges[i][1]);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; edges; // 边的记录</span><br><span class="line">    vector&lt;int&gt; inDegree(n+1, 0); // 入度</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        int a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        edges.push_back(&#123;a,b&#125;);</span><br><span class="line">        inDegree[b]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 倒序添加入度为2的点对应的边</span><br><span class="line">    vector&lt;int&gt; vec;</span><br><span class="line">    for (int i = n-1; i &gt;= 0; i--) &#123;</span><br><span class="line">        if (inDegree[edges[i][1]] == 2) &#123;</span><br><span class="line">            vec.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 处理非成环的情况</span><br><span class="line">    if (vec.size() &gt; 0) &#123;</span><br><span class="line">        // 只有两种情况，倒数第一条或者倒数第二条</span><br><span class="line">        // 因为有可能倒数第一条取出后，会产生孤立点，所以去除另一条边</span><br><span class="line">        if (isDelOk(edges, vec[0])) &#123;</span><br><span class="line">            cout &lt;&lt; edges[vec[0]][0] &lt;&lt; &quot; &quot; &lt;&lt; edges[vec[0]][1] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            cout &lt;&lt; edges[vec[1]][0] &lt;&lt; &quot; &quot; &lt;&lt; edges[vec[1]][1] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 处理有向环</span><br><span class="line">    deleteCircleEdge(edges);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h2 id="最小生成树之prim"><a href="#最小生成树之prim" class="headerlink" title="最小生成树之prim"></a>最小生成树之prim</h2></li><li><p><a href="https://www.programmercarl.com/kamacoder/0053.%E5%AF%BB%E5%AE%9D-prim.html#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF">代码随想录</a></p></li><li><p><a href="https://kamacoder.com/problempage.php?pid=1053">53. 寻宝（第七期模拟笔试）</a></p></li><li><p>题意：本质就是求最小生成树的值大小</p></li><li><p>方法：prim算法<br>分三步：  </p><ol><li>找到与最小生成树距离最近的节点（初始化就随便一个都行）</li><li>把节点加入最小生成树</li><li>根据加入节点，更新其他节点与最小生成树的距离</li></ol></li><li><p>但是具体实现还有很多细节，写在了注释中。</p></li><li><p>参考代码随想录思路的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;climits&gt;// INT_MAX</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int v, e;</span><br><span class="line">    cin &gt;&gt; v &gt;&gt; e;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; grid(v+1, vector&lt;int&gt;(v+1, 0));</span><br><span class="line">    for (int i = 0; i &lt; e; i++) &#123;</span><br><span class="line">        int x, y, k;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line">        grid[x][y] = k;</span><br><span class="line">        grid[y][x] = k;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; min_dist(v+1, 10001);// 题目最大值10000</span><br><span class="line">    vector&lt;bool&gt; visited(v+1, false);</span><br><span class="line">    // 找到构成最小生成树的v-1条边</span><br><span class="line">    for (int i = 1; i &lt; v; i++) &#123;</span><br><span class="line">        int min_val = INT_MAX;</span><br><span class="line">        int cur = -1;// 要加入最小生成树的点</span><br><span class="line">        </span><br><span class="line">        for (int j = 1; j &lt;= v; j++) &#123; // 遍历所有点</span><br><span class="line">            // 找一个不在树里面，且与最小生成树距离最小的点</span><br><span class="line">            if (!visited[j] &amp;&amp; min_dist[j] &lt; min_val) &#123;</span><br><span class="line">                min_val = min_dist[j];</span><br><span class="line">                cur = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 加入最小生成树的点</span><br><span class="line">        visited[cur] = true;</span><br><span class="line">        </span><br><span class="line">        // 遍历与加入点相连的其它点，更新与最小生成树的距离</span><br><span class="line">        for (int i = 1; i &lt;= v; i++) &#123;</span><br><span class="line">            if (visited[i]) continue; // 已在树内</span><br><span class="line">            if (grid[cur][i] == 0) continue; // 无连接</span><br><span class="line">            if (grid[cur][i] &lt; min_dist[i]) &#123;</span><br><span class="line">                min_dist[i] = grid[cur][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int result = 0;</span><br><span class="line">    for (int i = 2; i &lt;= v; i++) &#123; // 之所以i从2开始，是因为min_dist[1]不会赋值</span><br><span class="line">    // 从理解的角度，1一开始就在树内，所以没有计算距离（或是距离为0）</span><br><span class="line">        result += min_dist[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h2 id="最小生成树之kruskal"><a href="#最小生成树之kruskal" class="headerlink" title="最小生成树之kruskal"></a>最小生成树之kruskal</h2></li><li><p><a href="https://www.programmercarl.com/kamacoder/0053.%E5%AF%BB%E5%AE%9D-Kruskal.html#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF">代码随想录</a></p></li><li><p><a href="https://kamacoder.com/problempage.php?pid=1053">53. 寻宝（第七期模拟笔试）</a></p></li><li><p>题目：与[[最小生成树之prim]]一样，但方法不同。</p></li><li><p>方法：kruskal看边，而prim看点。简单地说，kruskal会升序遍历边，不断加入不同并查集的边，最后得到最小生成树。</p></li><li><p>参考代码随想录思路的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;climits&gt;// INT_MAX</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef struct _Edge &#123;</span><br><span class="line">    int l;</span><br><span class="line">    int r;</span><br><span class="line">    int val;</span><br><span class="line">&#125;Edge;</span><br><span class="line"></span><br><span class="line">int n = 10001;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; father(n, 0);</span><br><span class="line"></span><br><span class="line">int find(int u) &#123;</span><br><span class="line">    return father[u]==u ? u : father[u] = find(father[u]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void join(int u, int v) &#123;</span><br><span class="line">    u = find(u);</span><br><span class="line">    v = find(v);</span><br><span class="line">    if (u == v) return;</span><br><span class="line">    father[u] = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isSame(int u, int v) &#123;</span><br><span class="line">    return find(u) == find(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    for (int i = 0; i &lt; 10001; i++) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;                                                     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int v, e;</span><br><span class="line">    cin &gt;&gt; v &gt;&gt; e;</span><br><span class="line">    </span><br><span class="line">    vector&lt;Edge&gt; edge;</span><br><span class="line">    </span><br><span class="line">    while(e--) &#123;</span><br><span class="line">        int l, r, val;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r &gt;&gt; val;</span><br><span class="line">        edge.push_back(&#123;l, r, val&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sort(edge.begin(), edge.end(), [](Edge &amp;e1, Edge &amp;e2) &#123;return e1.val &lt; e2.val;&#125;);</span><br><span class="line">    </span><br><span class="line">    init();</span><br><span class="line">    int result = 0;</span><br><span class="line">    </span><br><span class="line">    for (const auto &amp; line : edge) &#123;</span><br><span class="line">        int l = find(line.l);</span><br><span class="line">        int r = find(line.r);</span><br><span class="line">        if (l != r) &#123;</span><br><span class="line">            join(l, r);</span><br><span class="line">            result += line.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法周记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Weekly Algorithm】算法周记之《代码随想录》图论（二）</title>
      <link href="/posts/cb47191c.html"/>
      <url>/posts/cb47191c.html</url>
      
        <content type="html"><![CDATA[<h1 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h1><p>本周跟随《代码随想录》继续学习关于图论的知识，主要是学习岛屿，也就是 bfs&#x2F;dfs 的经典应用。同时还有[[字符串接龙]]这种新颖的图论题目，才知道各种字符串也能抽象为一个图。</p><h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><ul><li><h2 id="岛屿数量广搜版"><a href="#岛屿数量广搜版" class="headerlink" title="岛屿数量广搜版"></a>岛屿数量广搜版</h2></li><li><p><a href="https://www.programmercarl.com/kamacoder/0099.%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%95%B0%E9%87%8F%E5%B9%BF%E6%90%9C.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p></li><li><p><a href="https://kamacoder.com/problempage.php?pid=1171">99. 岛屿数量</a></p></li><li><p>直接说明区别和放代码好力，代码就是在[[岛屿数量深搜版]]的基础上做了一点更改，原本的搜索函数不断递归向深了探索，现在是用队列（栈也可，区别在于遍历顺序）来记录要遍历的区块，再按顺序处理</p></li><li><p>修改后的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int dir[4][2] = &#123;0, 1, 1, 0, -1, 0, 0, -1&#125;;</span><br><span class="line">void bfs(const vector&lt;vector&lt;int&gt;&gt; &amp;grid, vector&lt;vector&lt;bool&gt;&gt; &amp;visited, int x, int y) &#123;</span><br><span class="line">    queue&lt;pair&lt;int, int&gt;&gt; q;</span><br><span class="line">    q.push(make_pair(x, y));</span><br><span class="line">    while (!q.empty()) &#123;</span><br><span class="line">        int tmpx = q.front().first;</span><br><span class="line">        int tmpy = q.front().second;</span><br><span class="line">        q.pop();</span><br><span class="line">        for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">            int nextx = tmpx + dir[i][0];</span><br><span class="line">            int nexty = tmpy + dir[i][1];</span><br><span class="line">            if (nextx &lt; 0 || nextx &gt;= grid.size() || nexty &lt; 0 || nexty &gt;= grid[0].size()) continue;</span><br><span class="line">            if (!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == 1) &#123;</span><br><span class="line">                visited[nextx][nexty] = true;</span><br><span class="line">                q.push(make_pair(nextx, nexty));</span><br><span class="line">                // dfs(grid, visited, nextx, nexty);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; grid(n, vector&lt;int&gt;(m, 0));</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;bool&gt;&gt; visited(n, vector&lt;bool&gt;(m, false));</span><br><span class="line">    </span><br><span class="line">    int result = 0;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            if (!visited[i][j] &amp;&amp; grid[i][j] == 1) &#123;</span><br><span class="line">                visited[i][j] = true;</span><br><span class="line">                result++;</span><br><span class="line">                bfs(grid, visited, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h2 id="岛屿的最大面积"><a href="#岛屿的最大面积" class="headerlink" title="岛屿的最大面积"></a>岛屿的最大面积</h2></li><li><p><a href="https://www.programmercarl.com/kamacoder/0100.%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p></li><li><p><a href="https://kamacoder.com/problempage.php?pid=1172">100. 岛屿的最大面积</a></p></li><li><p>题意：给一个二维数组，求其中纵横相连最大区块面积</p></li><li><p>方法：dfs&#x2F;bfs</p></li><li><p>从零手搓代码，重点在于visited的更新要及时，这也是易忘点<br>第一次把visited放再递归前，少了第一块的计算，故最后会多1<br>下面是最后修正的正确代码  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int result = 0;</span><br><span class="line"></span><br><span class="line">int dr[4][2] = &#123;1, 0, 0, 1, -1, 0, 0, -1&#125;;</span><br><span class="line"></span><br><span class="line">void dfs(const vector&lt;vector&lt;int&gt;&gt; &amp;grid, vector&lt;vector&lt;int&gt;&gt; &amp;visited, int &amp;cur_area, int x, int y) &#123;</span><br><span class="line">    cur_area++;</span><br><span class="line">    visited[x][y] = 1;</span><br><span class="line">    //cout &lt;&lt; &quot;visiting:&quot; &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">        int tmpx = x + dr[i][0];</span><br><span class="line">        int tmpy = y + dr[i][1];</span><br><span class="line">        if (tmpx &lt; 0 || tmpx &gt;= grid.size() || tmpy &lt; 0 || tmpy &gt;= grid[0].size()) continue;</span><br><span class="line">        if (grid[tmpx][tmpy] == 1 &amp;&amp; visited[tmpx][tmpy] == 0) &#123;</span><br><span class="line">            dfs(grid, visited, cur_area, tmpx, tmpy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; grid(n, vector&lt;int&gt;(m, 0));</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; visited(grid);</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            int cur_area = 0;</span><br><span class="line">            if (!(grid[i][j] == 1 &amp;&amp; visited[i][j] == 0)) continue;</span><br><span class="line">            dfs(grid, visited, cur_area, i, j);</span><br><span class="line">            if (cur_area &gt; result) result = cur_area;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h2 id="孤岛的总面积"><a href="#孤岛的总面积" class="headerlink" title="孤岛的总面积"></a>孤岛的总面积</h2></li><li><p><a href="https://www.programmercarl.com/kamacoder/0101.%E5%AD%A4%E5%B2%9B%E7%9A%84%E6%80%BB%E9%9D%A2%E7%A7%AF.html">代码随想录</a></p></li><li><p><a href="https://kamacoder.com/problempage.php?pid=1173">101. 孤岛的总面积</a></p></li><li><p>题意：求没有与边缘相连的纵横相连区块的总面积</p></li><li><p>方法：先对边缘的岛屿用dfs&#x2F;bfs，排除这些区块，然后再遍历中间的面积。</p></li><li><p>代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int dr[4][2] = &#123;0, 1, 0, -1, 1, 0, -1, 0&#125;;</span><br><span class="line"></span><br><span class="line">void dfs(vector&lt;vector&lt;int&gt;&gt; &amp;grid, vector&lt;vector&lt;bool&gt;&gt; &amp;visited, int x, int y) &#123;</span><br><span class="line">    visited[x][y] = true;</span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">        int nextx = x + dr[i][0];</span><br><span class="line">        int nexty = y + dr[i][1];</span><br><span class="line">        if (nextx &lt; 0 || nextx &gt;= grid.size() || nexty &lt; 0 || nexty &gt;= grid[0].size()) continue;</span><br><span class="line">        if (!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == 1) &#123;</span><br><span class="line">            dfs(grid, visited, nextx, nexty);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; grid(n, vector&lt;int&gt;(m, 0));</span><br><span class="line">    vector&lt;vector&lt;bool&gt;&gt; visited(n, vector&lt;bool&gt;(m, false));</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        if (grid[i][0] == 1 &amp;&amp; !visited[i][0]) &#123;</span><br><span class="line">            dfs(grid, visited, i, 0);</span><br><span class="line">        &#125;</span><br><span class="line">        if (grid[i][m-1] &amp;&amp; !visited[i][m-1]) &#123;</span><br><span class="line">            dfs(grid, visited, i, m-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        if (grid[0][i] == 1 &amp;&amp; !visited[0][i]) &#123;</span><br><span class="line">            dfs(grid, visited, 0, i);</span><br><span class="line">        &#125;</span><br><span class="line">        if (grid[n-1][i] &amp;&amp; !visited[n-1][i]) &#123;</span><br><span class="line">            dfs(grid, visited, n-1, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int result = 0;</span><br><span class="line">    for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 1; j &lt; m; j++) &#123;</span><br><span class="line">            if (!visited[i][j] &amp;&amp; grid[i][j] == 1) &#123;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h2 id="沉没孤岛"><a href="#沉没孤岛" class="headerlink" title="沉没孤岛"></a>沉没孤岛</h2></li><li><p><a href="https://www.programmercarl.com/kamacoder/0102.%E6%B2%89%E6%B2%A1%E5%AD%A4%E5%B2%9B.html">代码随想录</a></p></li><li><p><a href="https://kamacoder.com/problempage.php?pid=1174">102. 沉没孤岛</a></p></li><li><p>题意：就是求孤岛之外的面积之和</p></li><li><p>方法：[[孤岛的总面积]]的小变式，只要在计算边缘区块时计算面积就行</p></li><li><p>代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int dr[4][2] = &#123;0, 1, 0, -1, 1, 0, -1, 0&#125;;</span><br><span class="line"></span><br><span class="line">void dfs(vector&lt;vector&lt;int&gt;&gt; &amp;grid, vector&lt;vector&lt;bool&gt;&gt; &amp;visited, int x, int y) &#123;</span><br><span class="line">    visited[x][y] = true;</span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">        int nextx = x + dr[i][0];</span><br><span class="line">        int nexty = y + dr[i][1];</span><br><span class="line">        if (nextx &lt; 0 || nextx &gt;= grid.size() || nexty &lt; 0 || nexty &gt;= grid[0].size()) continue;</span><br><span class="line">        if (!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == 1) &#123;</span><br><span class="line">            dfs(grid, visited, nextx, nexty);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; grid(n, vector&lt;int&gt;(m, 0));</span><br><span class="line">    vector&lt;vector&lt;bool&gt;&gt; visited(n, vector&lt;bool&gt;(m, false));</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        if (grid[i][0] == 1 &amp;&amp; !visited[i][0]) &#123;</span><br><span class="line">            dfs(grid, visited, i, 0);</span><br><span class="line">        &#125;</span><br><span class="line">        if (grid[i][m-1] &amp;&amp; !visited[i][m-1]) &#123;</span><br><span class="line">            dfs(grid, visited, i, m-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        if (grid[0][i] == 1 &amp;&amp; !visited[0][i]) &#123;</span><br><span class="line">            dfs(grid, visited, 0, i);</span><br><span class="line">        &#125;</span><br><span class="line">        if (grid[n-1][i] &amp;&amp; !visited[n-1][i]) &#123;</span><br><span class="line">            dfs(grid, visited, n-1, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            if (visited[i][j] == true) &#123;</span><br><span class="line">                cout &lt;&lt; &quot;1 &quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                cout &lt;&lt; &quot;0 &quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h2 id="水流问题"><a href="#水流问题" class="headerlink" title="水流问题"></a>水流问题</h2></li><li><p><a href="https://www.programmercarl.com/kamacoder/0103.%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98.html#%E4%BC%98%E5%8C%96">代码随想录</a></p></li><li><p><a href="https://kamacoder.com/problempage.php?pid=1175">103. 水流问题</a></p></li><li><p>题意：给一个数组，找其中所有能够到达（左||上）&amp;&amp;（右||下）从高到低（同值也行）的格子</p></li><li><p>方法：普通思路是对每一个格子都做遍历，看是否能到两种边界。但是复杂度过高。反过来，从两种边界逆流遍历，再求两次遍历的交集即可获得格子</p></li><li><p>参考代码随想录思路的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n, m;</span><br><span class="line">int dir[4][2] = &#123;-1, 0, 0, -1, 1, 0, 0, 1&#125;;</span><br><span class="line">void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int x, int y) &#123;</span><br><span class="line">    if (visited[x][y]) return;</span><br><span class="line"></span><br><span class="line">    visited[x][y] = true;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">        int nextx = x + dir[i][0];</span><br><span class="line">        int nexty = y + dir[i][1];</span><br><span class="line">        if (nextx &lt; 0 || nextx &gt;= n || nexty &lt; 0 || nexty &gt;= m) continue;</span><br><span class="line">        if (grid[x][y] &gt; grid[nextx][nexty]) continue; // 注意：这里是从低向高遍历</span><br><span class="line"></span><br><span class="line">        dfs (grid, visited, nextx, nexty);</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; grid(n, vector&lt;int&gt;(m, 0));</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 逆流遍历,这些本质上就是visited</span><br><span class="line">    vector&lt;vector&lt;bool&gt;&gt; firstBoard(n, vector&lt;bool&gt;(m, false));</span><br><span class="line">    vector&lt;vector&lt;bool&gt;&gt; secondBoard(firstBoard);</span><br><span class="line">    </span><br><span class="line">    // 从第一组边界和第二组边界分别逆推</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        dfs(grid, firstBoard, i, 0);</span><br><span class="line">        dfs(grid, secondBoard, i, m-1);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        dfs(grid, firstBoard, 0, i);</span><br><span class="line">        dfs(grid, secondBoard, n-1, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 遍历并输出最终结果</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            if (firstBoard[i][j] &amp;&amp; secondBoard[i][j]) &#123;</span><br><span class="line">                cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><h2 id="建造最大工岛"><a href="#建造最大工岛" class="headerlink" title="建造最大工岛"></a>建造最大工岛</h2></li><li><p><a href="https://www.programmercarl.com/kamacoder/0104.%E5%BB%BA%E9%80%A0%E6%9C%80%E5%A4%A7%E5%B2%9B%E5%B1%BF.html#%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF">代码随想录</a></p></li><li><p><a href="https://kamacoder.com/problempage.php?pid=1176">104. 建造最大岛屿</a></p></li><li><p>题意：给一个二维数组，沿用上面的岛屿设定，不过本题可以最多填充一块陆地，求填充完最大的陆地面积</p></li><li><p>方法：普通的暴力思路是对每块海洋求四边的陆地和；优化后，先把所有陆地给遍历，求各陆地面积，避免暴力思路中的重复遍历。</p><p>实现的重点在于，考虑全陆地的情况，并且要考虑到四边的陆地可能是同一块陆地，所以要去重。  </p></li><li><p>参考代码随想录思路的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &lt;unordered_set&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n, m;</span><br><span class="line"></span><br><span class="line">int dr[4][2] = &#123;0, 1, 0, -1, 1, 0, -1, 0&#125;;</span><br><span class="line"></span><br><span class="line">void dfs(vector&lt;vector&lt;int&gt;&gt; &amp;grid, vector&lt;vector&lt;bool&gt;&gt; &amp;visited, int x, int y, int &amp;count, int mark) &#123;</span><br><span class="line">    // 加速返回</span><br><span class="line">    if (visited[x][y] || grid[x][y] == 0) return;</span><br><span class="line">    count++;</span><br><span class="line">    visited[x][y] = true;</span><br><span class="line">    grid[x][y] = mark;</span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">        int nextx = x + dr[i][0];</span><br><span class="line">        int nexty = y + dr[i][1];</span><br><span class="line">        if (nextx &lt; 0 || nextx &gt;= n || nexty &lt; 0 || nexty &gt;= m) continue;</span><br><span class="line">        if (grid[nextx][nexty] == 1 &amp;&amp; !visited[nextx][nexty]) &#123;</span><br><span class="line">            dfs(grid, visited, nextx, nexty, count, mark);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; grid(n, vector&lt;int&gt;(m, 0));</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;bool&gt;&gt; visited(n, vector&lt;bool&gt;(m, false));</span><br><span class="line">    unordered_map&lt;int, int&gt; gridNum;</span><br><span class="line">    </span><br><span class="line">    int flagNum = 2;</span><br><span class="line">    bool isAllGrid = true;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            if (grid[i][j] == 0) isAllGrid = false;</span><br><span class="line">            int count = 0;</span><br><span class="line">            if (!visited[i][j] &amp;&amp; grid[i][j] == 1) &#123;</span><br><span class="line">                dfs(grid, visited, i, j, count, flagNum);</span><br><span class="line">                gridNum[flagNum] = count;</span><br><span class="line">                //cout &lt;&lt; &quot;flagNum:&quot; &lt;&lt; flagNum &lt;&lt; &quot;; count:&quot; &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">                flagNum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (isAllGrid) &#123;</span><br><span class="line">        cout &lt;&lt; n*m &lt;&lt; endl;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    unordered_set&lt;int&gt; visitGrid;</span><br><span class="line">    int result = 0;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            if (grid[i][j] != 0) continue;</span><br><span class="line">            visitGrid.clear();</span><br><span class="line">            int area = 1;</span><br><span class="line">            //cout &lt;&lt; &quot;出发：&quot; &lt;&lt; i &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">            for (int k = 0; k &lt; 4; k++) &#123;</span><br><span class="line">                int nx = i + dr[k][0];</span><br><span class="line">                int ny = j + dr[k][1];</span><br><span class="line">                //cout &lt;&lt; &quot;查看：&quot; &lt;&lt; nx &lt;&lt; ny &lt;&lt; endl;</span><br><span class="line">                if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m || grid[nx][ny] == 0) continue;</span><br><span class="line">                if (visitGrid.count(grid[nx][ny])) continue;</span><br><span class="line">                area += gridNum[grid[nx][ny]];</span><br><span class="line">                //cout &lt;&lt; &quot;发现：&quot; &lt;&lt; grid[nx][ny] &lt;&lt; &quot;;gridNum:&quot; &lt;&lt; gridNum[grid[nx][ny]] &lt;&lt; &quot;;area:&quot; &lt;&lt; area &lt;&lt; endl;</span><br><span class="line">                visitGrid.insert(grid[nx][ny]);</span><br><span class="line">            &#125;</span><br><span class="line">            result = max(result, area);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h2 id="字符串接龙"><a href="#字符串接龙" class="headerlink" title="字符串接龙"></a>字符串接龙</h2></li><li><p><a href="https://www.programmercarl.com/kamacoder/0110.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%A5%E9%BE%99.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p></li><li><p><a href="https://kamacoder.com/problempage.php?pid=1183">110. 字符串接龙</a></p></li><li><p>题意：给一个起始字符串和终止字符串，以及一系列字符串，求起始字符串每次更改一个字符，从这些字符串最少更改几步到终止字符串。</p></li><li><p>方法：看作从起始字符串开始的无向图，向周围bfs（bfs比dfs更方便找最短路径），也就是逐个尝试26字母。</p></li><li><p>参考代码随想录思路的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt; </span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;unordered_set&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string beginStr, endStr, str;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    unordered_set&lt;string&gt; strSet;</span><br><span class="line">    cin &gt;&gt; beginStr &gt;&gt; endStr;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; str;</span><br><span class="line">        strSet.insert(str);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 记录字符串是否访问，以及访问到字符串的路径长度</span><br><span class="line">    unordered_map&lt;string, int&gt; visitMap; </span><br><span class="line">    </span><br><span class="line">    // 为了bfs的队列</span><br><span class="line">    queue&lt;string&gt; que;</span><br><span class="line">    que.push(beginStr);</span><br><span class="line">    </span><br><span class="line">    // 起始的长度为1</span><br><span class="line">    visitMap.insert(make_pair(beginStr, 1));</span><br><span class="line">    </span><br><span class="line">    while(!que.empty()) &#123;</span><br><span class="line">        string word = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        int path = visitMap[word];</span><br><span class="line">        </span><br><span class="line">        // 对于word逐个字符尝试替换，然后匹配strSet</span><br><span class="line">        for (int i = 0; i &lt; word.size(); i++) &#123;</span><br><span class="line">            string newWord = word;</span><br><span class="line">            </span><br><span class="line">            // 遍历所有字母</span><br><span class="line">            for (int j = 0; j &lt; 26; j++) &#123;</span><br><span class="line">                newWord[i] = j + &#x27;a&#x27;;</span><br><span class="line">                // 到达重点，直接结束</span><br><span class="line">                if (newWord == endStr) &#123;</span><br><span class="line">                    cout &lt;&lt; path+1 &lt;&lt; endl;</span><br><span class="line">                    return 0;</span><br><span class="line">                &#125;</span><br><span class="line">                // 与字典匹配且没有匹配过</span><br><span class="line">                if (strSet.find(newWord) != strSet.end() &amp;&amp;</span><br><span class="line">                visitMap.find(newWord) == visitMap.end()) &#123;</span><br><span class="line">                    // 记录访问结果，并添加队列</span><br><span class="line">                    visitMap.insert(make_pair(newWord, path+1));</span><br><span class="line">                    que.push(newWord);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 无结果</span><br><span class="line">    cout &lt;&lt; 0 &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法周记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Weekly Algorithm】算法周记之《代码随想录》单调栈和图论（一）</title>
      <link href="/posts/30a37951.html"/>
      <url>/posts/30a37951.html</url>
      
        <content type="html"><![CDATA[<h1 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h1><p>本周跟随《代码随想录》学习关于单调栈的知识，同时开启图论。</p><p>单调栈通过保持一个栈从栈顶到栈底的递增或是递减序列，来解决找一个元素左&#x2F;右的“第一个”更大&#x2F;更小元素。</p><p>图论则是初窥dfs的门路，虽然道理一年前早在算法课学过考过，但现在也得复习才能捡回来。</p><h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><ul><li><h2 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a>每日温度</h2></li><li><p><a href="https://www.programmercarl.com/0739.%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p></li><li><p><a href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度 - 力扣（LeetCode）</a></p></li><li><p>题意：给一个整数数组，求每个数字右侧比该数字更大的间距</p></li><li><p>方法：暴力解法就是O(n^2)的遍历。更高效率的方法是使用单调栈，所谓的单调栈就是从栈顶到栈底递增或递减的，如此排列，就能方便找任意元素的左右第一个更大更小的元素。</p><p>比如本题是找右边更大的，那么遍历数组时，遇到更小或相等的元素就直接入栈，而遇到更大的元素就弹栈，直到触底或碰到大元素再入栈，其中弹栈的元素就能记录本元素的下标与当时元素下标之差。  </p></li><li><p>参考代码随想录思路的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) &#123;</span><br><span class="line">        vector&lt;int&gt; result(temperatures.size(), 0);</span><br><span class="line"></span><br><span class="line">        stack&lt;int&gt; st;</span><br><span class="line"></span><br><span class="line">        st.push(0);</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; temperatures.size(); i++) &#123;</span><br><span class="line">            if (temperatures[i] &lt;= temperatures[st.top()]) &#123;</span><br><span class="line">                st.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                while(!st.empty() &amp;&amp; temperatures[i] &gt; temperatures[st.top()]) &#123;</span><br><span class="line">                    result[st.top()] = i - st.top();</span><br><span class="line">                    st.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                st.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h2 id="下一个更大的元素I"><a href="#下一个更大的元素I" class="headerlink" title="下一个更大的元素I"></a>下一个更大的元素I</h2></li><li><p><a href="https://www.programmercarl.com/0496.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0I.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p></li><li><p><a href="https://leetcode.cn/problems/next-greater-element-i/">496. 下一个更大元素 I - 力扣（LeetCode）</a></p></li><li><p>题意：给两个整数数组，找一个数组在另一个数组对应元素的下一个更大元素的集合。</p></li><li><p>方法：用哈希建立两个数组元素和下标的对应，单调栈则实现元素的下一个更大的元素。</p></li><li><p>参考代码随想录思路的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">        // 按照代码随想录思路，用哈希表构建两数组之间的映射，然后得出nums2单调栈，由此就得到了结果</span><br><span class="line">        unordered_map&lt;int, int&gt; umap; // 从nums2数字到nums1对应数字下标的映射</span><br><span class="line">        for (int i = 0; i &lt; nums1.size(); i++) &#123;</span><br><span class="line">            umap[nums1[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 求nums2单调栈</span><br><span class="line">        // vector&lt;int&gt; next(nums2.size(), -1);</span><br><span class="line">        stack&lt;int&gt; st;</span><br><span class="line">        vector&lt;int&gt; result(nums1.size(), -1);</span><br><span class="line">        if (result.size() == 1) return result;</span><br><span class="line">        st.push(0);</span><br><span class="line"></span><br><span class="line">        for(int i = 1; i &lt; nums2.size(); i++) &#123;</span><br><span class="line">            if (nums2[i] &lt;= nums2[st.top()]) &#123;</span><br><span class="line">                st.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                while(!st.empty() &amp;&amp; nums2[i] &gt; nums2[st.top()]) &#123;</span><br><span class="line">                    // next[st.top()] = i - st.top();</span><br><span class="line">                    if (umap.count(nums2[st.top()]) &gt; 0) &#123;</span><br><span class="line">                        result[umap[nums2[st.top()]]] = nums2[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                    st.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                st.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h2 id="下一个更大的元素II"><a href="#下一个更大的元素II" class="headerlink" title="下一个更大的元素II"></a>下一个更大的元素II</h2></li><li><p><a href="https://www.programmercarl.com/0503.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0II.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p></li><li><p><a href="https://leetcode.cn/problems/next-greater-element-ii/description/">503. 下一个更大元素 II - 力扣（LeetCode）</a></p></li><li><p>题意：和[[下一个更大的元素I]]相似，但是下一个更大元素要看循环数组。</p></li><li><p>方法：解决循环以往就有把数组循环乘二的情况，但是这种处理方式对于空间稍显浪费，所以还有一种方式，就是循环时当作两倍的情况。</p></li><li><p>参考代码随想录思路的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; result(nums.size(), -1);</span><br><span class="line"></span><br><span class="line">        stack&lt;int&gt; st;</span><br><span class="line">        st.push(0);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; nums.size()*2; i++) &#123;</span><br><span class="line">            if (nums[i % nums.size()] &lt;= nums[st.top()]) &#123;</span><br><span class="line">                st.push(i % nums.size());</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                while(!st.empty() &amp;&amp; nums[i % nums.size()] &gt; nums[st.top()]) &#123;</span><br><span class="line">                    result[st.top()] = nums[i % nums.size()];</span><br><span class="line">                    st.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                st.push(i % nums.size());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h2 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h2></li><li><p><a href="https://www.programmercarl.com/0042.%E6%8E%A5%E9%9B%A8%E6%B0%B4.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p></li><li><p><a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水 - 力扣（LeetCode）</a></p></li><li><p>题意，给一个高度数组，每个数字代表柱子高度，求下完雨后，柱子之间积水量</p></li><li><p>方法，暴力解法，按行或列求，以按列为例，对每一列求其左右最高柱子高度，取最小值，与该列高度差为该列水量。优化方法是用双指针，分别从两侧向另一侧遍历，求每个柱子一侧方向的最高柱子，这样就避免了暴力方法中重复求两侧柱子高度的浪费；</p><p>重点在于单调栈方法，按行求，单调栈保持递增（栈顶到栈底），具体处理方法写在注释中  </p></li><li><p>参考代码随想录思路的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int trap(vector&lt;int&gt;&amp; height) &#123;</span><br><span class="line">        stack&lt;int&gt; st;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        st.push(0);</span><br><span class="line">        for (int i = 1; i &lt; height.size(); i++) &#123;</span><br><span class="line">            // 三种情况</span><br><span class="line">            // 第一种，后续柱子高度低于栈顶，则直接入栈</span><br><span class="line">            if (height[i] &lt; height[st.top()]) &#123;</span><br><span class="line">                st.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">            // 第二种，后续柱子高度与栈顶一致，则更新栈顶，坐标保留靠右的</span><br><span class="line">            // 因为如果右侧有凹陷，计算积水的左侧左边起始是从靠右的柱子开始计算</span><br><span class="line">            else if (height[i] == height[st.top()]) &#123;</span><br><span class="line">                st.pop();</span><br><span class="line">                st.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">            // 第三种，后续柱子比栈顶高，开始计算积水</span><br><span class="line">            // 总得来说，就是计算i，栈顶和栈顶前一个柱子三个柱子之间的积水</span><br><span class="line">            // 高度上，取左右两柱子的最小值，宽度上，就计算左右柱子的间隔就好</span><br><span class="line">            // 上述步骤循环，直至新柱子小于栈顶位置再入栈（或者栈空）</span><br><span class="line">            // 计算完成后，左侧柱子在栈顶位置，还有计算价值，毕竟说不定后续用作底部柱子使用</span><br><span class="line">            else &#123;</span><br><span class="line">                while(!st.empty() &amp;&amp; height[i] &gt; height[st.top()]) &#123;</span><br><span class="line">                    int bottom = height[st.top()];</span><br><span class="line">                    st.pop();</span><br><span class="line">                    if (!st.empty()) &#123; // 防止遇到没有左侧柱子的情况</span><br><span class="line">                        int h = min(height[i], height[st.top()]) - bottom;</span><br><span class="line">                        int w = i - st.top() - 1;</span><br><span class="line">                        sum += h*w;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                st.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h2 id="柱状图中最大的矩形"><a href="#柱状图中最大的矩形" class="headerlink" title="柱状图中最大的矩形"></a>柱状图中最大的矩形</h2></li><li><p><a href="https://programmercarl.com/0084.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p></li><li><p><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/submissions/597563485/">84. 柱状图中最大的矩形 - 力扣（LeetCode）</a></p></li><li><p>题意：给一个柱状图（数组表示）求其中最大矩形面积</p></li><li><p>方法：实际上与[[接雨水]]相似，但是单调栈方向相反，[[接雨水]]栈顶到栈底递增，如此就能对于每个柱子找到旁边更大的柱子；这里则是递减，找到更小的柱子，以两侧小柱子为下标区间，乘以基准柱子高度，就是一块矩形面积</p></li><li><p>参考代码随想录思路的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;</span><br><span class="line">        heights.insert(heights.begin(), 0);</span><br><span class="line">        heights.push_back(0);</span><br><span class="line">        stack&lt;int&gt; st;// 存储下标</span><br><span class="line">        int result = 0;</span><br><span class="line">        </span><br><span class="line">        st.push(0);</span><br><span class="line">        for (int i = 1; i &lt; heights.size(); i++) &#123;</span><br><span class="line">            if (heights[st.top()] &lt; heights[i]) &#123;</span><br><span class="line">                st.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (heights[st.top()] == heights[i]) &#123;</span><br><span class="line">                st.pop();</span><br><span class="line">                st.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                while(!st.empty() &amp;&amp; heights[st.top()] &gt; heights[i]) &#123;</span><br><span class="line">                    int mid = st.top();</span><br><span class="line">                    st.pop();</span><br><span class="line">                    if (!st.empty()) &#123;</span><br><span class="line">                        int left = st.top();</span><br><span class="line">                        int right = i;</span><br><span class="line">                        int w = right - left - 1;</span><br><span class="line">                        int h = heights[mid];</span><br><span class="line">                        result = max(result, h * w);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                st.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><ul><li><h2 id="所有可达路径"><a href="#所有可达路径" class="headerlink" title="所有可达路径"></a>所有可达路径</h2></li><li><a href="https://www.programmercarl.com/kamacoder/0098.%E6%89%80%E6%9C%89%E5%8F%AF%E8%BE%BE%E8%B7%AF%E5%BE%84.html#%E6%9C%AC%E9%A2%98%E4%BB%A3%E7%A0%81">代码随想录</a></li><li><a href="https://kamacoder.com/problempage.php?pid=1170">98. 所有可达路径</a></li><li>题意：给一个无环有向图，要求一个初次节点到末尾节点的所有路径</li><li>方法：dfs，重点在于具体的实现方法，注意邻接矩阵的vector长度，是n+1，因为题目的编号是1-n。还有题目的输出示例格式要求。</li><li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">vector&lt;int&gt; path;</span><br><span class="line"></span><br><span class="line">void dfs(vector&lt;vector&lt;int&gt;&gt; &amp;g, int vis, int end) &#123;</span><br><span class="line">    if (vis == end) &#123;</span><br><span class="line">        result.push_back(path);</span><br><span class="line">        // cout &lt;&lt; &quot;path:&quot; &lt;&lt; endl;;</span><br><span class="line">        // for (int i = 0; i &lt; path.size(); i++) &#123;</span><br><span class="line">        //     cout &lt;&lt; path[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">        // &#125;</span><br><span class="line">        // cout &lt;&lt; endl;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= end; i++) &#123;</span><br><span class="line">        if (g[vis][i] == 1) &#123;</span><br><span class="line">            path.push_back(i);</span><br><span class="line">            dfs(g, i, end);</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    </span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    // 用邻接矩阵来存储看看</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; g(n+1, vector&lt;int&gt;(n+1, 0));</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        int s, t;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">        g[s][t] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    path.push_back(1);</span><br><span class="line">    dfs(g, 1, n);</span><br><span class="line">    </span><br><span class="line">    if (result.size() == 0) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; result.size(); i++) &#123;</span><br><span class="line">        vector&lt;int&gt; &amp;t = result[i];</span><br><span class="line">        for (int j = 0; j &lt; t.size()-1; j++) &#123;</span><br><span class="line">            cout &lt;&lt; t[j] &lt;&lt; &quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; t[t.size()-1] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h2 id="岛屿数量深搜版"><a href="#岛屿数量深搜版" class="headerlink" title="岛屿数量深搜版"></a>岛屿数量深搜版</h2></li><li><a href="https://www.programmercarl.com/kamacoder/0099.%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%95%B0%E9%87%8F%E6%B7%B1%E6%90%9C.html#%E6%80%9D%E8%B7%AF">代码随想录</a></li><li><a href="https://kamacoder.com/problempage.php?pid=1171">99. 岛屿数量</a></li><li>题意：给一个二维数组，数组中横纵相连视为一个岛，求岛屿数量</li><li>方法：dfs，模板题，重点在于注意数组的存储</li><li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int dir[4][2] = &#123;0, 1, 1, 0, -1, 0, 0, -1&#125;;</span><br><span class="line">void dfs(const vector&lt;vector&lt;int&gt;&gt; &amp;grid, vector&lt;vector&lt;bool&gt;&gt; &amp;visited, int x, int y) &#123;</span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">        int nextx = x + dir[i][0];</span><br><span class="line">        int nexty = y + dir[i][1];</span><br><span class="line">        if (nextx &lt; 0 || nextx &gt;= grid.size() || nexty &lt; 0 || nexty &gt;= grid[0].size()) continue;</span><br><span class="line">        if (!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == 1) &#123;</span><br><span class="line">            visited[nextx][nexty] = true;</span><br><span class="line">            dfs(grid, visited, nextx, nexty);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; grid(n, vector&lt;int&gt;(m, 0));</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;bool&gt;&gt; visited(n, vector&lt;bool&gt;(m, false));</span><br><span class="line">    </span><br><span class="line">    int result = 0;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            if (!visited[i][j] &amp;&amp; grid[i][j] == 1) &#123;</span><br><span class="line">                visited[i][j] = true;</span><br><span class="line">                result++;</span><br><span class="line">                dfs(grid, visited, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法周记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Weekly Algorithm】算法周记之《代码随想录》动态规划（七）</title>
      <link href="/posts/95ef6250.html"/>
      <url>/posts/95ef6250.html</url>
      
        <content type="html"><![CDATA[<h1 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h1><p>本周跟随《代码随想录》继续推进动态规划的相关学习，本周主要学习子序列相关内容，其中的编辑距离在网络搜索引擎的期末考试见过。但通过本次学习，逐渐感受到在算法，或者说计算机的世界中，很多事情往往会通过抽象来变得简洁从而易于处理。</p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><ul><li><h2 id="最长重复子数组"><a href="#最长重复子数组" class="headerlink" title="最长重复子数组"></a>最长重复子数组</h2></li><li><p><a href="https://www.programmercarl.com/0718.%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p></li><li><p><a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/">718. 最长重复子数组 - 力扣（LeetCode）</a></p></li><li><p>题意：给两个数组，问两个数组中最长重复的子数组长度是什么</p></li><li><p>方法：用二维dp，dp[i][j] 代表第一个数组 i-1 为尾部和第二个数组 j-1 处为尾部，最长重复子数组长度。<br>递推公式，当 num1[i-1]&#x3D;&#x3D;num2[j-1]，即可 dp[i][j] &#x3D; dp[i-1][j-1]+1;<br>初始化，都为0<br>遍历顺序，无所谓，不过从前向后就可<br>举例……  </p></li><li><p>参考代码随想录思路的解法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findLength(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(nums1.size()+1, vector&lt;int&gt;(nums2.size()+1, 0));</span><br><span class="line">        </span><br><span class="line">        int max_len = 0;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; nums1.size()+1; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; nums2.size()+1; j++) &#123;</span><br><span class="line">                if(nums1[i-1] == nums2[j-1]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-1][j-1] + 1;</span><br><span class="line">                    if (dp[i][j] &gt; max_len) max_len = dp[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return max_len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>优化一下，用滚动数组，注意每次从后向前遍历，以及刷0  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findLength(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">        // vector&lt;vector&lt;int&gt;&gt; dp(nums1.size()+1, vector&lt;int&gt;(nums2.size()+1, 0));</span><br><span class="line">        vector&lt;int&gt; dp(nums2.size()+1, 0);</span><br><span class="line">        </span><br><span class="line">        int max_len = 0;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; nums1.size()+1; i++) &#123;</span><br><span class="line">            for (int j = nums2.size(); j &gt; 0; j--) &#123;</span><br><span class="line">                if(nums1[i-1] == nums2[j-1]) &#123;</span><br><span class="line">                    dp[j] = dp[j-1] + 1;</span><br><span class="line">                    if (dp[j] &gt; max_len) max_len = dp[j];</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    dp[j] = 0; // 需要刷零避免前两层的记录影响</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return max_len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2></li><li><p><a href="https://www.programmercarl.com/1143.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p></li><li><p><a href="https://leetcode.cn/problems/longest-common-subsequence/description/">1143. 最长公共子序列 - 力扣（LeetCode）</a></p></li><li><p>题意，给两个字符串，给出两串的最长公共子序列的长度</p></li><li><p>方法：与[[最长重复子数组]]相近，不过本题不要求连续，所以递推公式除了上一个相同+1之外，还保存两个子序列可能的最长情况。</p></li><li><p>参考代码随想录的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int longestCommonSubsequence(string text1, string text2) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(text1.size()+1, vector&lt;int&gt;(text2.size()+1, 0));</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; text1.size()+1; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; text2.size()+1; j++) &#123;</span><br><span class="line">                if (text1[i-1] == text2[j-1]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-1][j-1]+1;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // for (int i = 0; i &lt; text1.size()+1; i++) &#123;</span><br><span class="line">        //     for (int j = 0; j &lt; text2.size()+1; j++) &#123;</span><br><span class="line">        //         cout &lt;&lt; dp[i][j] &lt;&lt; &quot; &quot;;</span><br><span class="line">        //     &#125;</span><br><span class="line">        //     cout &lt;&lt; endl;</span><br><span class="line">        // &#125;</span><br><span class="line"></span><br><span class="line">        return dp[text1.size()][text2.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><h2 id="不相交的线"><a href="#不相交的线" class="headerlink" title="不相交的线"></a>不相交的线</h2></li><li><p><a href="https://www.programmercarl.com/1035.%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p></li><li><p><a href="https://leetcode.cn/problems/uncrossed-lines/">1035. 不相交的线 - 力扣（LeetCode）</a></p></li><li><p>题意：两个整型数组，相同数字可以两两相连，但是线不能交错。求最大连线数。</p></li><li><p>方法：换了个题意的[[最长公共子序列]]，除了题目，其余都一样，其余省略。</p></li><li><h2 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h2></li><li><p><a href="https://www.programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p></li><li><p><a href="https://leetcode.cn/problems/maximum-subarray/description/">53. 最大子数组和 - 力扣（LeetCode）</a></p></li><li><p>题意：给一个数组，找个其中子序列之和最大的和。</p></li><li><p>方法：<br>dp[i] 是到下标为 i 为尾部的子序列最大和数值<br>递推公式比较有意思，两种情况，一个是延续之前的最大和 dp[i] &#x3D; dp[i-1]+num[i];或者不延续，从 i 处新开 dp[i] &#x3D; num[i]，两种情况取较大数值即可。<br>初始化，dp[0] 取 num[0],其它的初始化不重要，毕竟都会被覆盖。<br>遍历顺序：从前向后。<br>举例：……  </p></li><li><p>参考代码随想录思路的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(nums.size(), 0);</span><br><span class="line">        dp[0] = nums[0];</span><br><span class="line">        int result = dp[0];</span><br><span class="line">        for (int i = 1; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            dp[i] = max(dp[i-1]+nums[i], nums[i]);</span><br><span class="line">            if (dp[i] &gt; result) &#123;</span><br><span class="line">                result = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        //     cout &lt;&lt; dp[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">        // &#125;</span><br><span class="line">        // cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><h2 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a>判断子序列</h2></li><li><p><a href="https://www.programmercarl.com/0392.%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p></li><li><p><a href="https://leetcode.cn/problems/is-subsequence/submissions/595432953/">392. 判断子序列 - 力扣（LeetCode）</a></p></li><li><p>题意：给两个字符串序列，判断一个字符串是否为另一个字符串的子序。</p></li><li><p>方法：其实[[最长公共子序列]]类似，只是说判断公共字符串的长度是否为子串长度相等，而且递推公式中，如果两个字符不相等，稍微更改，只会继承本字符的匹配情况，因为明确表示了该字符串是否为另一字符串的子串，不能反过来。</p></li><li><p>参考代码随想录思路的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSubsequence(string s, string t) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(s.size()+1, vector&lt;int&gt;( t.size()+1, 0));</span><br><span class="line">        // dp[i][j] 字符串s[i-1] 和 t[j-1] 为止最长子序列长度</span><br><span class="line">        // 初始化 第一行和第一列都为 0 即可</span><br><span class="line">        // 递推公式，当两个字符相等时，dp[i][j]=dp[i-1][j-1]+1;不同时，dp[i][j]则取dp[i][j-1];相当于匹配t失败，延续之前匹配结果（要么是匹配上的情况，要么是0，也就是断匹配了</span><br><span class="line">        for(int i = 1; i &lt;= s.size(); i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= t.size(); j++) &#123;</span><br><span class="line">                if (s[i-1] == t[j-1]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-1][j-1] + 1;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j-1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return (dp[s.size()][t.size()] == s.size()) ? true : false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><h2 id="不同子序列"><a href="#不同子序列" class="headerlink" title="不同子序列"></a>不同子序列</h2></li><li><p><a href="https://www.programmercarl.com/0115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p></li><li><p><a href="https://leetcode.cn/problems/distinct-subsequences/">115. 不同的子序列 - 力扣（LeetCode）</a></p></li><li><p>题意，判断一个字符串和另一个字符串的几种不同子序列相同（这里的子序列由字符串删除字符获得），求不同子序列的数量。</p></li><li><p>方法，是编辑距离的简单版，只考虑删除字符的情况，如果对应字符相等，就取上个字符的匹配情况<br><img src="/../assets/image_1737950806585_0.png" alt="image.png"><br>dp[i][j]是s[i]到t[j]匹配时，已有匹配到的数量，这个数量指的是可能出现的前缀数量，如果字符匹配成功，就继承上一个；如果之前有重复字符，则会叠加  </p></li><li><p>参考代码随想录思路的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numDistinct(string s, string t) &#123;</span><br><span class="line">        vector&lt;vector&lt;uint64_t&gt;&gt; dp(s.size()+1, vector&lt;uint64_t&gt;(t.size()+1, 0));</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; s.size(); i++) &#123;</span><br><span class="line">            dp[i][0] = 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt;= s.size(); i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= t.size(); j++) &#123;</span><br><span class="line">                if (s[i-1] == t[j-1]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    dp[i][j] = dp[i-1][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[s.size()][t.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h2 id="两个字符串的删除操作"><a href="#两个字符串的删除操作" class="headerlink" title="两个字符串的删除操作"></a>两个字符串的删除操作</h2></li><li><p><a href="https://www.programmercarl.com/0583.%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p></li><li><p><a href="https://leetcode.cn/problems/delete-operation-for-two-strings/">583. 两个字符串的删除操作 - 力扣（LeetCode）</a></p></li><li><p>题意：给两个字符串，请给出多少次删除（一次删除任意字符串的一个字符）能使两个字符串相等。</p></li><li><p>方法：</p><ol><li>dp[i][j] 对于一个字符串的前 i-1 个字符和另一个字符串的前 j-1 个字符相同需要删除次数</li><li>递推公式，当字符相同时，dp[i][j] &#x3D; dp[i-1][j-1]；也就是说对于这两个位置的字符不需要删除。当字符不相同时，dp[i][j] &#x3D; min(dp[i-1][j]+1, dp[i][j-1]+1);也就是删除其中个字符串中的字符，那可能说，要是两个字符都要删除呢？这个状态包含于上一次内，也就是说两个删除一个字符情况也就是删除两个字符。</li><li>初始化，第一行第一列，分别是一个字符串与空字符串相等需要的删除次数，也就是删完，取字符串长度。</li><li>遍历顺序，从前向后，前上到下，普通顺序</li><li>举例……</li></ol></li><li><p>参考代码随想录思路的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minDistance(string word1, string word2) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(word1.size()+1,vector&lt;int&gt;(word2.size()+1, 0));</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; word1.size()+1; i++) &#123;</span><br><span class="line">            dp[i][0] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int j = 0; j &lt; word2.size()+1; j++) &#123;</span><br><span class="line">            dp[0][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; word1.size()+1; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; word2.size()+1; j++) &#123;</span><br><span class="line">                if (word1[i-1] == word2[j-1]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-1][j-1];</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    dp[i][j] = min(dp[i-1][j]+1, dp[i][j-1]+1);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[word1.size()][word2.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h2></li><li><p><a href="https://www.programmercarl.com/0072.%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p></li><li><p><a href="https://leetcode.cn/problems/edit-distance/description/">72. 编辑距离 - 力扣（LeetCode）</a></p></li><li><p>题意，给两个字符串，要求编辑距离（也就是对任意字符串增删换使其相同的次数），增一个字符，删一个字符，换一个字符的操作个数。</p></li><li><p>方法，[[两个字符串的删除操作]]的进阶，现在不只是删除，还有增加字符和替换的操作，但是，增加字符，其实可以等效为另一个字符串删除那个要增加的字符。而替换操作，可以理解为两边字符串同时删除，但只算一次操作(dp[i][j]&#x3D;dp[i-1][j-1]+1)，除了这个递推公式加上一条，其余相同。</p></li><li><p>参考代码随想录思路的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minDistance(string word1, string word2) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(word1.size()+1, vector&lt;int&gt;(word2.size()+1, 0));</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; word1.size()+1; i++) &#123;</span><br><span class="line">            dp[i][0] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int j = 0; j &lt; word2.size()+1; j++) &#123;</span><br><span class="line">            dp[0][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; word1.size()+1; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; word2.size()+1; j++) &#123;</span><br><span class="line">                if (word1[i-1] == word2[j-1]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-1][j-1];</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    dp[i][j] = min(&#123;dp[i-1][j-1], dp[i-1][j], dp[i][j-1]&#125;)+1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[word1.size()][word2.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h2 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a>回文子串</h2></li><li><p><a href="https://www.programmercarl.com/0647.%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p></li><li><p><a href="https://leetcode.cn/problems/palindromic-substrings/description/">647. 回文子串 - 力扣（LeetCode）</a></p></li><li><p>题意，给一个字符串，统计其中回文字符串的个数</p></li><li><p>方法，如果按照之前思路dp[i]代表到下标 i 回文字符串个数的话，各个状态间无联系无规律。故用下面的 dp 定义。<br>除了 dp 定义有改变，还有遍历顺序与以往不太一样，由于递推公式的关系。<br>具体内容在注释中  </p></li><li><p>参考代码随想录思路的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int countSubstrings(string s) &#123;</span><br><span class="line">        vector&lt;vector&lt;bool&gt;&gt; dp(s.size(), vector&lt;bool&gt;(s.size(), false));</span><br><span class="line">        // 这里的 dp[i][j] 是字符串 i 到 j（闭区间）是否为回文字符串、</span><br><span class="line">        // 初始化默认全部为 false</span><br><span class="line"></span><br><span class="line">        // 先看递推公式，当 s[i] != s[j] dp[i][j] = false;</span><br><span class="line">        // 复杂的是 s[i] == s[j]时，如果 i==j，那么 dp[i][j] = true，因为”a“算回文字符串</span><br><span class="line">        // 如果j==i+1，那么也是true，“aa”这种情况中也算回文字符串</span><br><span class="line">        // 如果 上述都不是，那么 dp[i][j] = dp[i+1][j-1] ，i到j是否为回文字符串取决于 i+1到j-1是否为回文字符串</span><br><span class="line"></span><br><span class="line">        // 由于递推公式有 dp[i][j] = dp[i+1][j-1],那么要先遍历 i 较大的情况以及 j 较小的情况</span><br><span class="line"></span><br><span class="line">        for(int i = s.size()-1; i &gt;= 0; i--) &#123;</span><br><span class="line">            for (int j = i; j &lt; s.size(); j++) &#123;</span><br><span class="line">                if (s[i] != s[j]) &#123;</span><br><span class="line">                    dp[i][j] = false;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (i == j) &#123;</span><br><span class="line">                    dp[i][j] = true;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (j == i + 1) &#123;</span><br><span class="line">                    dp[i][j] = true;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    dp[i][j] = dp[i+1][j-1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int count = 0;</span><br><span class="line">        for (int i = 0; i &lt; s.size(); i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; s.size(); j++) &#123;</span><br><span class="line">                if (dp[i][j] == true) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                //cout &lt;&lt; dp[i][j] &lt;&lt; &quot; &quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            //cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h2 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h2></li><li><p><a href="https://www.programmercarl.com/0516.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p></li><li><p><a href="https://leetcode.cn/problems/longest-palindromic-subsequence/description/">516. 最长回文子序列 - 力扣（LeetCode）</a></p></li><li><p>题意：找出字符串上，最长回文子序列长度（可删字符）</p></li><li><p>方法：详情写在注释中，值得注意的是，dp是闭区间</p></li><li><p>参考代码随想录思路的解法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int longestPalindromeSubseq(string s) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(s.size(), vector&lt;int&gt;(s.size(), 0));</span><br><span class="line">        // dp[i][j]代表了 s[i]到s[j] 最长回文子序列的长度</span><br><span class="line"></span><br><span class="line">        // 在 s[i] == s[j] 时，dp[i][j] = dp[i+1][j-1]+2</span><br><span class="line">        // 不相等时， 则从两个方向取大值，dp[i][j] = max(dp[i][j-1], dp[i+1][j]);</span><br><span class="line"></span><br><span class="line">        // 初始化时，所有相等得先赋值1</span><br><span class="line">        for (int i = 0; i &lt; s.size(); i++) dp[i][i] = 1;</span><br><span class="line"></span><br><span class="line">        for (int i = s.size()-1; i &gt;= 0; i--) &#123;</span><br><span class="line">            for (int j = i+1; j &lt; s.size(); j++) &#123;</span><br><span class="line">                if (s[i] == s[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i+1][j-1] + 2;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    dp[i][j] = max(dp[i][j-1], dp[i+1][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[0][s.size()-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法周记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Weekly Algorithm】算法周记之《代码随想录》动态规划（六）</title>
      <link href="/posts/47ef15cf.html"/>
      <url>/posts/47ef15cf.html</url>
      
        <content type="html"><![CDATA[<h1 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h1><p>本周跟随《代码随想录》继续推进动态规划的相关学习，本周主要学习完买卖股票相关内容，并初步探索子序列的部分。</p><p>买卖股票的题有明显的状态转换，但子序列就没那么明显。</p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><ul><li><h2 id="买卖股票的最佳时机II"><a href="#买卖股票的最佳时机II" class="headerlink" title="买卖股票的最佳时机II"></a>买卖股票的最佳时机II</h2></li><li><p><a href="https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p></li><li><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">122. 买卖股票的最佳时机 II - 力扣（LeetCode）</a></p></li><li><p>题意，在[[买卖股票的最佳时机]]的基础上，要求可以多次购买股票，但同一时段只能持有一支股票，也就是再卖出上一支股票前，不允许购入下一支股票。</p></li><li><p>方法，与[[买卖股票的最佳时机]]的差别，在于考虑购入当前股票时，是在上一支股票考虑购入和卖出的两个情况中取最大，并非直接取历史最便宜股票和当前股票对比。</p></li><li><p>参考代码随想录思路解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        // dp[i][0] 考虑第i支股票时，考虑买入的情况；dp[i][1] 考虑第i支股票时，卖出的情况</span><br><span class="line">        int len = prices.size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(len, vector&lt;int&gt;(2, 0));</span><br><span class="line">        dp[0][0] -= prices[0];</span><br><span class="line">        dp[0][1] = 0;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][0] = max(dp[i-1][0], dp[i-1][1]-prices[i]);</span><br><span class="line">            dp[i][1] = max(dp[i-1][1], dp[i-1][0]+prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[len-1][1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><h2 id="买卖股票的最佳时机III"><a href="#买卖股票的最佳时机III" class="headerlink" title="买卖股票的最佳时机III"></a>买卖股票的最佳时机III</h2></li><li><p><a href="https://programmercarl.com/0123.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p></li><li><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III - 力扣（LeetCode）</a></p></li><li><p>题意，在[[买卖股票的最佳时机II]]基础上，要求最多只能进行两次股票的购入和卖出。</p></li><li><p>方法，可以想想此前两题的 dp，dp[i] 代表第 i 天，后面是状态，有两状态就是持有和卖出。换到此题就是状态更多了，故本题可设 5 个状态，0 代表不操作（可省略），1 代表第一次持有（不代表一定购入，可能是之前的购入），2代表第一次卖出，3 是第二次持有，4 是第二次卖出。后面的状态均依赖于自己与前一个状态。</p><ol><li>dp[i][0-4]，意思如上</li><li>递推公式，对于持有的状态，dp[i][1] &#x3D; max(dp[i-1][0]-price[i],dp[i-1][1])，就是在不购买的基础上购买当日股票和采用之前购买股票的抉择；对于卖出状态，dp[i][2] &#x3D; max(dp[i-1][1]+price[i], dp[i-1][2]); 就是在前一日购买股票的基础上，售出当日股票与延续此前卖出的抉择；</li><li>初始化，dp[0][0] &#x3D; 0, 不作为当然为 0，dp[0][1] &#x3D; -1 * price[0]; 购入股票成本, dp[0][2] &#x3D; 0，马上卖出即无收益；dp[0][3] &#x3D; -1 * price[0]，当日连续第二次买入; dp[0][4] &#x3D; 0; 当日连续第二次卖出。</li><li>遍历方向，从前向后</li><li>举例……</li></ol></li><li><p>参考代码随想录思路的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        // 分五个状态，0 是无操作，1 是第一次持有，2 是第一次卖出，3是第二次持有，4是第二次卖出</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(prices.size(), vector&lt;int&gt;(5, 0));</span><br><span class="line">        dp[0][1] -= prices[0];</span><br><span class="line">        dp[0][3] -= prices[0];</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            dp[i][1] = max(dp[i-1][0]-prices[i], dp[i-1][1]);</span><br><span class="line">            dp[i][2] = max(dp[i-1][1]+prices[i], dp[i-1][2]);</span><br><span class="line">            dp[i][3] = max(dp[i-1][2]-prices[i], dp[i-1][3]);</span><br><span class="line">            dp[i][4] = max(dp[i-1][3]+prices[i], dp[i-1][4]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[prices.size()-1][4];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><h2 id="买卖股票的最佳时机IV"><a href="#买卖股票的最佳时机IV" class="headerlink" title="买卖股票的最佳时机IV"></a>买卖股票的最佳时机IV</h2></li><li><p><a href="https://programmercarl.com/0188.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p></li><li><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV - 力扣（LeetCode）</a></p></li><li><p>题意，在[[买卖股票的最佳时机III]]基础上，将购买股票的次数由 2 次，拓展为变量 k 次</p></li><li><p>方法，将dp数组拓展为 price.size() 个 2<em>k+1 的 vector，总共有 2</em>k+1 个状态，其余的思想与方法，同[[买卖股票的最佳时机III]]。</p></li><li><p>参考代码随想录思路的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        // dp[i][0] 为不操作，dp[i][2*k-1] 为第k笔交易持有, dp[i][2*k] 为第k笔交易卖出，k&gt;=1</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(prices.size(), vector&lt;int&gt;(2*k+1, 0));</span><br><span class="line"></span><br><span class="line">        // 初始化，对于奇数只是单纯买第一天的负价格，而偶数则是一买就卖的 0</span><br><span class="line">        for (int i = 1; i &lt; 2 * k; i+=2) &#123;</span><br><span class="line">            dp[0][i] -= prices[0];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 对往后每一行奇偶，分别是前一笔交易与上一天同笔交易的比较</span><br><span class="line">        for (int i = 1; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; 2*k+1; j+=2) &#123;</span><br><span class="line">                dp[i][j] = max(dp[i-1][j], dp[i-1][j-1]-prices[i]);</span><br><span class="line">                dp[i][j+1] = max(dp[i-1][j+1], dp[i-1][j]+prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[prices.size()-1][2*k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><h2 id="买卖股票的最佳时机含冷冻期"><a href="#买卖股票的最佳时机含冷冻期" class="headerlink" title="买卖股票的最佳时机含冷冻期"></a>买卖股票的最佳时机含冷冻期</h2></li><li><p><a href="https://www.programmercarl.com/0309.%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p></li><li><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/">309. 买卖股票的最佳时机含冷冻期 - 力扣（LeetCode）</a></p></li><li><p>题意，在 [[买卖股票的最佳时机II]] 可多次买卖股票的基础上，加入冷冻期，即在卖出股票的一天后，才能再买入股票。</p></li><li><p>方法，引入四种状态，买入，今日卖出，保持卖出，冷冻期。<br>买入状态可能有前一日的买入状态、保持卖出、冷冻期推出；<br>今日卖出只会由前一日买入状态卖出今日价格得出；<br>冷冻期保存前一日的今日卖出状态；<br>保持卖出则由前一日的保持卖出、冷冻期推出；  </p><p>dp[i][j] 则是 i 天的第 j 个状态<br>递推公式由上述的文字推出<br>初始化则是第一日的买入状态为价格负数，其余为零<br>遍历方向从前到后<br>举例……  </p></li><li><p>参考代码随想录思想的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        int n = prices.size();</span><br><span class="line">        if (n==0) return 0;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt;dp(n, vector&lt;int&gt;(4, 0));</span><br><span class="line">        // dp 有四种状态 1 买入；2 今日卖出；3 保持卖出； 4 冷静期</span><br><span class="line">        // 3 可能为 2 或 4 的延续</span><br><span class="line">        dp[0][0] -= prices[0];</span><br><span class="line">        for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][0] = max(dp[i-1][0], max(dp[i-1][2] - prices[i], dp[i-1][3] - prices[i]));</span><br><span class="line">            dp[i][1] = dp[i-1][0] + prices[i];</span><br><span class="line">            dp[i][2] = max(dp[i-1][2], dp[i-1][3]);</span><br><span class="line">            dp[i][3] = dp[i-1][1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return max(dp[n-1][1], max(dp[n-1][2], dp[n-1][3]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><h2 id="买卖股票的最佳时机含手续费"><a href="#买卖股票的最佳时机含手续费" class="headerlink" title="买卖股票的最佳时机含手续费"></a>买卖股票的最佳时机含手续费</h2></li><li><p><a href="https://www.programmercarl.com/0714.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html">代码随想录</a></p></li><li><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/">714. 买卖股票的最佳时机含手续费 - 力扣（LeetCode）</a></p></li><li><p>题意，在[[买卖股票的最佳时机II]]可多次交易的基础上，添加手续费，即每次交易后需扣除一定手续费。</p></li><li><p>方法，与[[买卖股票的最佳时机II]]的唯一差别在于递推公式，将卖出的部分添加手续费即可。</p><p>不过，陆爻齐由于太久没碰相关部分，想自己从零推出来，于是整合了三个状态，写下下面的代码  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123;</span><br><span class="line">        // 我觉着有三种状态</span><br><span class="line">        // 第一是直接买入，第二是今日卖出</span><br><span class="line">        // 与之前只会多次交易的题相比，多了个手续费，减一下就行了</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(prices.size(), vector&lt;int&gt;(3, 0));</span><br><span class="line"></span><br><span class="line">        // 递推公式的话，买入就直接取当日价格负数减下去，卖出则取前一日买入加上这一日卖出</span><br><span class="line">        // 初始化，除买入，取0</span><br><span class="line">        dp[0][0] -= prices[0];</span><br><span class="line">        for (int i = 1; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            dp[i][0] = max(dp[i-1][0], dp[i-1][2]-prices[i]);</span><br><span class="line">            dp[i][1] = dp[i-1][0] + prices[i] - fee;</span><br><span class="line">            dp[i][2] = max(dp[i-1][2], dp[i][1]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // for (int i = 0; i &lt; prices.size(); i++) &#123;</span><br><span class="line">        //     cout &lt;&lt; dp[i][0] &lt;&lt; &quot; &quot; &lt;&lt; dp[i][1] &lt;&lt; &quot; &quot; &lt;&lt; dp[i][2] &lt;&lt; endl;</span><br><span class="line">        // &#125;</span><br><span class="line"></span><br><span class="line">        return max(dp[prices.size()-1][1], dp[prices.size()-1][2]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看完发现，第三个状态确实可以与第二个状态合并，要追求简洁的情况下，每个状态应是由过去的部分推导出来的，如果有状态与现有状态有关，则可考虑适当合并  </p><p>于是可以优化成下面的代码，与代码随想录思路相近了  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123;</span><br><span class="line">        // 我觉着有三种状态</span><br><span class="line">        // 第一是直接买入，第二是今日卖出</span><br><span class="line">        // 与之前只会多次交易的题相比，多了个手续费，减一下就行了</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(prices.size(), vector&lt;int&gt;(2, 0));</span><br><span class="line"></span><br><span class="line">        // 递推公式的话，买入就直接取当日价格负数减下去，卖出则取前一日买入加上这一日卖出</span><br><span class="line">        // 初始化，除买入，取0</span><br><span class="line">        dp[0][0] -= prices[0];</span><br><span class="line">        for (int i = 1; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            dp[i][0] = max(dp[i-1][0], dp[i-1][1]-prices[i]);</span><br><span class="line">            dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i] - fee);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // for (int i = 0; i &lt; prices.size(); i++) &#123;</span><br><span class="line">        //     cout &lt;&lt; dp[i][0] &lt;&lt; &quot; &quot; &lt;&lt; dp[i][1] &lt;&lt; &quot; &quot; &lt;&lt; dp[i][2] &lt;&lt; endl;</span><br><span class="line">        // &#125;</span><br><span class="line"></span><br><span class="line">        return dp[prices.size()-1][1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2></li><li><p><a href="https://www.programmercarl.com/0300.%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97.html">代码随想录</a></p></li><li><p><a href="https://leetcode.cn/problems/longest-increasing-subsequence/description/">300. 最长递增子序列 - 力扣（LeetCode）</a></p></li><li><p>题意：给一个数组，求其中最长递增子序列的长度，该子序列可由删除数组中元素得出。</p></li><li><p>方法：用 dp[i] 表示下标 i 之前的最长递增子序列长度，通过循环得出。<br>递推公式：dp[i] &#x3D; max(dp[i], dp[j]+1); j遍历 0 到 i 的元素，该元素数值小于 i 的元素<br>初始化，均初始化为 1，长度至少为 1；<br>遍历顺序：从前往后，毕竟是递增<br>举例：……  </p></li><li><p>参考代码随想录思路的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(nums.size(), 1);</span><br><span class="line">        // dp[i]为地址为 i 的最长子序列长度</span><br><span class="line">        int max_len = 1;</span><br><span class="line">        // 外循环遍历数组</span><br><span class="line">        for (int i = 1; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            // 内循环取到已有的最长子序列长度</span><br><span class="line">            for (int j = 0; j &lt;= i; j++) &#123;</span><br><span class="line">                if (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    dp[i] = max(dp[i], dp[j]+1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (dp[i] &gt; max_len) max_len = dp[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return max_len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><h2 id="最长连续递增序列"><a href="#最长连续递增序列" class="headerlink" title="最长连续递增序列"></a>最长连续递增序列</h2></li><li><p><a href="https://www.programmercarl.com/0674.%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97.html">代码随想录</a></p></li><li><p><a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">674. 最长连续递增序列 - 力扣（LeetCode）</a></p></li><li><p>题意：与[[非递减子序列]]相比，要求子序列得是连续的，中间数据不能删。</p></li><li><p>方法，不需要代码随想录的思路参考，自己都能分析出来。<br>dp[i] 是下标 i 为末尾的最长连续递增序列长度<br>递推公式为 dp[i] &#x3D; dp[i-1]+1; 前提是 dp[i] &gt; dp[i-1]<br>初始化 全初始化为1<br>遍历方向从前向后<br>举例……  </p></li><li><p>解法（与代码随想录思路相近）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(nums.size(), 1); // dp[i] 展示前面某一点到下标 i，最长连续递增子序列长度</span><br><span class="line">        int max_len = 1;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            if (nums[i]&gt;nums[i-1]) &#123;</span><br><span class="line">                dp[i] = dp[i-1]+1;</span><br><span class="line">                if (dp[i] &gt; max_len) max_len = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return max_len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法周记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Weekly Algorithm】算法周记之《代码随想录》动态规划（五）</title>
      <link href="/posts/22e15e16.html"/>
      <url>/posts/22e15e16.html</url>
      
        <content type="html"><![CDATA[<h1 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h1><p>本周跟随《代码随想录》继续推进动态规划的相关学习，本周主要学会了完全背包的应用，多重背包的理论，<del>打劫</del>打家劫舍问题，和股票买卖问题的入门版。认识到了所存储的状态并不只有 整数 这一种形式，还能有多个整数并成的 vector 作为状态使用。</p><p>不得不说，动态规划十分的灵活，一百道题入门还不是说说而已啊。</p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><ul><li><h2 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a>完全平方数</h2></li><li><p><a href="https://programmercarl.com/0279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p></li><li><p><a href="https://leetcode.cn/problems/perfect-squares/description/">279. 完全平方数 - 力扣（LeetCode）</a></p></li><li><p>题意，给一个整数 n，求其被完全平方数组成的最小个数。</p></li><li><p>方法，就是[[零钱兑换II]]的变体，给的零钱变成了自己找小于 n 的完全平方数，背包容量为 n</p><ol><li>dp[j] 含义为 在背包容量为 j 的情况下，完全平方数的最小组合</li><li>递推公式，dp[i]&#x3D;min(dp[i],dp[i-j*j]+1)，也就是要么保持不变，要么就在已有的组合上加一</li><li>初始化，dp[0]&#x3D;0,这是为了递推公式才这么初始化，也能理解，完全平方数不算 0，不会有组合的</li><li>遍历方向，完全背包，从前向后</li><li>举例……</li></ol></li><li><p>参考代码随想录思路的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numSquares(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(n+1, INT_MAX);</span><br><span class="line">        dp[0] = 0;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; n+1; i++) &#123;</span><br><span class="line">            for (int j = 0; j*j &lt; n+1; j++) &#123;</span><br><span class="line">                if (i-j*j &gt;= 0 &amp;&amp; dp[i-j*j]!=INT_MAX) dp[i] = min(dp[i], dp[i-j*j]+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        /*</span><br><span class="line">        for (auto i : dp) &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        */</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h2 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a>单词拆分</h2></li><li><p><a href="https://programmercarl.com/0139.%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p></li><li><p><a href="https://leetcode.cn/problems/word-break/description/">139. 单词拆分 - 力扣（LeetCode）</a></p></li><li><p>题意，给字符串列表，看字符串能否由字符串列表中的字符串拼接而成（可重复利用，不要求全都用上）</p></li><li><p>方法，将字符串看成背包，列表中的字符串就是行李，对于每一处空间，可看其减去列表中字符串大小的前面空间，是否能由字符串列表组成，满足则该空间也能满足，如此便能递推至尾部。但注意本题要求的是排列数而非组合数，因为字符串如何拼接是没有顺序规定的。</p><ol><li>dp[j] 的意思是对于字符串 s 的前 j 个字符，能否用字符串列表组成</li><li>递推公式，if (str_list.find(str) !&#x3D; str_list.end() &amp;&amp; dp[j]) dp[i] &#x3D; true;即当前所截取的字符串在字符串列表中出现，且去掉该字符串的部分能由字符串列表组成，则该下标处的字符串也能由字符串列表组成</li><li>初始化，虽然空字符串无法组成，但递推公式决定 dp[0] &#x3D; true</li><li>遍历方向，先背包空间后物品，从前向后，求排列数</li><li>举例……</li></ol></li><li><p>参考代码随想录思路的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;</span><br><span class="line">        vector&lt;bool&gt; dp(s.size()+1, false); // dp[j] 代表在下标为 j 处能否由字典组成</span><br><span class="line">        dp[0] = true;</span><br><span class="line">        unordered_set&lt;string&gt; rec(wordDict.begin(), wordDict.end());</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; s.size()+1; i++) &#123;</span><br><span class="line">            // cout&lt;&lt; &quot;i:&quot; &lt;&lt; i &lt;&lt;endl;</span><br><span class="line">            for (int j = 0; j &lt; i; j++) &#123;</span><br><span class="line">                // cout&lt;&lt; &quot;j:&quot; &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">                string word = s.substr(j, i-j);</span><br><span class="line">                // cout&lt;&lt; &quot;word:&quot; &lt;&lt; word &lt;&lt; endl;</span><br><span class="line">                if (rec.find(word) != rec.end() &amp;&amp; dp[j]) &#123;</span><br><span class="line">                    dp[i] = true;</span><br><span class="line">                    // cout&lt;&lt; &quot;True i:&quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[s.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><h2 id="多重背包理论"><a href="#多重背包理论" class="headerlink" title="多重背包理论"></a>多重背包理论</h2></li><li><p><a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85.html#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85">代码随想录</a></p></li><li><p><a href="https://kamacoder.com/problempage.php?pid=1066">56. 携带矿石资源（第八期模拟笔试）</a></p></li><li><p>题意，有 c 个背包空间，给 n 类矿石，每类矿石的重量、价值和最大携带数量</p></li><li><p>方法，其实是 01 背包的变体，因为把最大携带数量摊平，就是 01 背包，不过其中有一部分物品重量和价值相同，但是直接摊平到 vector 让他动态增长会超时，所以有另一个方法，也就是先遍历物品，再遍历空间，然后遍历空间，向前试探。</p><ol><li>dp[j] 是在空间 j 上，能容纳的最大价值</li><li>递推公式，dp[j] &#x3D; max(dp[j], dp[j - k*weigh[i]]+ k * price[i])，也就是要么就当前的价值，要么就因这个最大携带数量，从小到大，向前试探；</li><li>初始化，全 0， 毕竟是找最大价值嘛</li><li>遍历顺序，从前向后</li><li>举例……</li></ol></li><li><p>参考代码随想录思路的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int bag_size, n;</span><br><span class="line">    cin &gt;&gt; bag_size &gt;&gt; n;</span><br><span class="line">    vector&lt;int&gt; weigh;</span><br><span class="line">    vector&lt;int&gt; price;</span><br><span class="line">    vector&lt;int&gt; num;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        int tmp;</span><br><span class="line">        cin &gt;&gt; tmp;</span><br><span class="line">        weigh.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        int tmp;</span><br><span class="line">        cin &gt;&gt; tmp;</span><br><span class="line">        price.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        int tmp;</span><br><span class="line">        cin &gt;&gt; tmp;</span><br><span class="line">        num.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; dp(bag_size+1, 0);</span><br><span class="line">    for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">        for (int i = bag_size; i &gt;= weigh[j]; i--) &#123;</span><br><span class="line">            for (int k = 1; k &lt;= num[j] &amp;&amp; i - k * weigh[j] &gt;= 0; k++) &#123;</span><br><span class="line">                dp[i] = max(dp[i], dp[i - k * weigh[j]] + k*price[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[bag_size] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h2 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h2></li><li><p><a href="https://programmercarl.com/0198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p></li><li><p><a href="https://leetcode.cn/problems/house-robber/submissions/586612097/">198. 打家劫舍 - 力扣（LeetCode）</a></p></li><li><p>题意，给一个数组（一组家），求取其中数值相加的最大值，但取值时不能取连续两值（不能连续偷两家）。</p></li><li><p>方法，由于每次取值与上一次有关，故递推公式为 dp[i] &#x3D; max(dp[i-1], dp[i-2]+nums[i]);，即要么间隔上一个数并加上当前值，要么考虑上一个数。</p><ol><li>dp[i] 的意思是在偷到 i 家时，能得到的最大金额；</li><li>递推公式， dp[i] &#x3D; max(dp[i-1], dp[i-2]+nums[i])</li><li>初始化，全 0，dp[0] &#x3D; nums[0]; dp[1] &#x3D; max(nums[0], nums[1]);</li><li>遍历方向，从前向后，其实后向前只要初始化变一变也行（dp[0] &#x3D; nums[nums.size()-1], dp[1] &#x3D; max(dp[0], nums[nums.size()-2]);</li><li>举例,……</li></ol></li><li><p>参考代码随想录思路的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rob(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if (nums.size() == 0) return 0;</span><br><span class="line">        vector&lt;int&gt; dp(nums.size(), 0); // dp[i] 在偷到 i 家时，窃取金额最高的数字</span><br><span class="line">        if (nums.size() == 1) return nums[0];</span><br><span class="line">        dp[0] = nums[0];</span><br><span class="line">        </span><br><span class="line">        dp[1] = max(nums[0], nums[1]);</span><br><span class="line">        for (int i = 2; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            dp[i] = max(dp[i-1], dp[i-2]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[nums.size()-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><h2 id="打家劫舍II"><a href="#打家劫舍II" class="headerlink" title="打家劫舍II"></a>打家劫舍II</h2></li><li><p><a href="https://programmercarl.com/0213.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p></li><li><p><a href="https://leetcode.cn/problems/house-robber-ii/description/">213. 打家劫舍 II - 力扣（LeetCode）</a></p></li><li><p>题意，在[[打家劫舍]]基础上，由于房屋成环，也就是首尾算相邻屋子，故不能同时取首尾。</p></li><li><p>方法，考虑有三种情况，1. 只考虑中间的房屋（无首尾）；2. 不考虑尾部屋子；3. 不考虑首部屋子。<br>发现情况 1 在 2 和 3 中，故只要考虑 2 和 3 即可。故可对 2 和 3 分别打家劫舍一次，取价值最高的情况。  </p></li><li><p>参考代码随想录思路的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rob(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">       if (nums.size() == 0) return 0;</span><br><span class="line">       if (nums.size() == 1) return nums[0];</span><br><span class="line">       if (nums.size() == 2) return max(nums[0], nums[1]);</span><br><span class="line"></span><br><span class="line">       int result1 = rogRange(nums, 0, nums.size()-2); // 只考虑首元素</span><br><span class="line">       int result2 = rogRange(nums, 1, nums.size()-1); // 只考虑尾元素</span><br><span class="line"></span><br><span class="line">       return max(result1, result2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int rogRange(vector&lt;int&gt; &amp;nums, int start, int end) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(end - start + 1, 0); // dp[j]为偷到 j 家可得最大价值</span><br><span class="line">        //cout &lt;&lt; &quot;start:&quot; &lt;&lt; start &lt;&lt; &quot; &quot; &lt;&lt; &quot;end:&quot; &lt;&lt; end &lt;&lt; endl;</span><br><span class="line">        dp[0] = nums[start];</span><br><span class="line">        dp[1] = max(nums[start], nums[start+1]);</span><br><span class="line">  </span><br><span class="line">        for (int i = start+2; i &lt; end+1; i++) &#123;</span><br><span class="line">            dp[i-start] = max(dp[i-start-1], dp[i-start-2]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return dp[end-start];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><h2 id="打家劫舍III"><a href="#打家劫舍III" class="headerlink" title="打家劫舍III"></a>打家劫舍III</h2></li><li><p><a href="https://programmercarl.com/0337.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p></li><li><p><a href="https://leetcode.cn/problems/house-robber-iii/description/">337. 打家劫舍 III - 力扣（LeetCode）</a></p></li><li><p>题意，本题可打劫的家变成二叉树形式排列，且同时不能偷一个节点和与之直接相连的节点，即其父节点与两个子节点；</p></li><li><p>方法，从递归的角度，采用后序遍历，从下向上，一个个计算并比较自己+孙子与儿子的组合哪个更好，采用 unordered map 来存储一个节点对应的值（该值为计算后可得最大价值）。<br>从动态规划的角度，可以让一个节点返回一对数，即不偷该点所得最大价值与偷该点所得最大价值，前者用子节点的最大价值和即可，后者则为该点当前价值加上子节点不偷的价值和。  </p></li><li><p>参考代码随想录思路的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; treeRob(TreeNode *root) &#123;</span><br><span class="line">        if (root == nullptr) return &#123;0, 0&#125;; // 不偷当前节点，得 0，偷当前节点，也是0</span><br><span class="line">        //if (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr) return &#123;0, root-&gt;val&#125;;</span><br><span class="line">        vector&lt;int&gt; left = treeRob(root-&gt;left);</span><br><span class="line">        vector&lt;int&gt; right = treeRob(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        int val1 = max(left[0],left[1]) + max(right[0],right[1]);</span><br><span class="line">        int val2 = root-&gt;val + left[0] + right[0];</span><br><span class="line"></span><br><span class="line">        return &#123;val1, val2&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int rob(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; tmp = treeRob(root);</span><br><span class="line">        return max(tmp[0], tmp[1]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><h2 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h2></li><li><p><a href="https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p></li><li><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机 - 力扣（LeetCode）</a></p></li><li><p>题意，给一个整型数组，分别是多天的股票价格，可买一天。</p></li><li><p>方法，用动态规划，记录一天买与不买持有资金，每天迭代选最大</p></li><li><p>参考代码随想录思路的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        // dp[i][0] 第i天持有金额（买入股票的利润，负数）</span><br><span class="line">        // dp[i][1] 第i天卖出股票的金额</span><br><span class="line">        /*</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(prices.size(), vector&lt;int&gt;(2, INT_MIN)); </span><br><span class="line">        dp[0][0] = -1 * prices[0];</span><br><span class="line">        dp[0][1] = 0;</span><br><span class="line">        for (int i = 1; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            dp[i][0] = max(dp[i-1][0], -1 * prices[i]);</span><br><span class="line">            dp[i][1] = max(dp[i-1][1], prices[i] + dp[i][0]);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[prices.size()-1][1];</span><br><span class="line">        */</span><br><span class="line">        // dp[i]只依赖于dp[i-1]的状态，优化为滚动数组</span><br><span class="line">        vector&lt;int&gt; dp(2, INT_MIN); </span><br><span class="line">        dp[0] = -1 * prices[0];</span><br><span class="line">        dp[1] = 0;</span><br><span class="line">        for (int i = 1; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            dp[0] = max(dp[0], -1 * prices[i]);</span><br><span class="line">            dp[1] = max(dp[1], prices[i] + dp[0]);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法周记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Weekly Algorithm】算法周记之《代码随想录》动态规划（四）</title>
      <link href="/posts/4d7f9b51.html"/>
      <url>/posts/4d7f9b51.html</url>
      
        <content type="html"><![CDATA[<h1 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h1><p>本周跟随《代码随想录》继续推进动态规划的相关学习，不过周五和周日两门考试太重了，浅做两题，接下来非考试周就继续至少一天一道罢。</p><p>本周两道题是完全背包求排列数的应用题和完全背包求 组合&#x2F;排列 的最小组合数，要记得组合与排列的区别在于背包空间和物品的遍历先后顺序，先遍历物品就不会出现物品乱序填背包的情况，所以是求组合数；而先遍历背包空间，使得同一个空间能有相同物品按不同顺序摆放，则是求排列数。</p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><ul><li><h2 id="爬楼梯（进阶版）"><a href="#爬楼梯（进阶版）" class="headerlink" title="爬楼梯（进阶版）"></a>爬楼梯（进阶版）</h2></li><li><p><a href="https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%89%88%E6%9C%AC.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p></li><li><p><a href="https://kamacoder.com/problempage.php?pid=1067">57. 爬楼梯（第八期模拟笔试）</a></p></li><li><p>题意，给 n 个台阶，和一起最多能迈 m 个台阶，问有多少不同方法可爬顶端</p></li><li><p>方法，由于同一步子可迈多次，故为完全背包问题，而且求的是排列数，与[[组合总和IV]]类似</p></li><li><p>陆爻齐的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    while(cin &gt;&gt; n &gt;&gt; m)&#123;</span><br><span class="line">        vector&lt;int&gt; dp(n+1, 0); // dp[j]到 j 有 dp[j] 个方法</span><br><span class="line">        </span><br><span class="line">        dp[0] = 1; // 初始化，如此上一阶台阶才能有一个</span><br><span class="line">        </span><br><span class="line">        for (int i = 1; i &lt; n+1; i++) &#123; // 先遍历背包容量，后遍历物品，才能求排列数，否则是组合数</span><br><span class="line">            for (int j = 1; j &lt; m+1; j++) &#123;</span><br><span class="line">                if (i - j &gt;= 0) &#123;</span><br><span class="line">                    dp[i] += dp[i-j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; dp[n] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h2 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h2></li><li><p><a href="https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p></li><li><p><a href="https://leetcode.cn/problems/coin-change/description/">322. 零钱兑换 - 力扣（LeetCode）</a></p></li><li><p>题意，和[[零钱兑换II]]一样，给硬币面额和目标金额，但求的是凑齐该金额的最小硬币数。</p></li><li><p>方法，由于最小硬币数用组合和排列都行，故先遍历物品还是背包就无所谓了，重点是由于求的是最小，初始化dp数组时不能都是 0，否则递推公式会被覆盖，其它就照常了</p><ol><li>dp[j] ，凑齐金额 j 的最小硬币数</li><li>递推公式，dp[j] &#x3D; min(dp[j], dp[j-coin[i]]+1),不过如果 dp[j-coin[i]] 为初始值，说明这种情况不存在，那就跳过</li><li>初始化，dp[0]&#x3D;0, dp[other]&#x3D;INT_MAX</li><li>遍历顺序，从前到后，这是滚动数组，实现完全背包</li><li>举例……</li></ol></li><li><p>参考代码随想录思路的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;</span><br><span class="line">        if (amount == 0) return 0;</span><br><span class="line">        vector&lt;int&gt; dp(amount+1, INT_MAX); // dp[j] 为凑齐总金额 j 的最小硬币数</span><br><span class="line">        dp[0] = 0;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; coins.size(); i++) &#123;</span><br><span class="line">            for (int j = coins[i]; j &lt; amount+1; j++) &#123;</span><br><span class="line">                if (dp[j-coins[i]] == INT_MAX) continue;</span><br><span class="line">                dp[j] = min(dp[j], dp[j-coins[i]] + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        /*for (auto i : dp) &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;*/</span><br><span class="line"></span><br><span class="line">        return (dp[amount]==INT_MAX) ? -1 : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法周记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Weekly Algorithm】算法周记之《代码随想录》动态规划（三）</title>
      <link href="/posts/fa528234.html"/>
      <url>/posts/fa528234.html</url>
      
        <content type="html"><![CDATA[<h1 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h1><p>本周跟随《代码随想录》继续推进动态规划的相关学习，主要是完全背包的入门，体会其与 01 背包的不同与关联。</p><p>下周两门考试，教务脑子真是进了水，搞这么紧干嘛。</p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><ul><li><h2 id="完全背包理论"><a href="#完全背包理论" class="headerlink" title="完全背包理论"></a>完全背包理论</h2></li><li><p><a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC">代码随想录</a></p></li><li><p><a href="https://kamacoder.com/problempage.php?pid=1052">52. 携带研究材料（第七期模拟笔试）</a></p></li><li><p>题目，与 [[01背包理论]]的差别在于一个物品可携带多次，求最大价值</p></li><li><p>方法，</p><ol><li>dp[j]，在遍历物品时，截止到空间为 j，可装入的最大价值</li><li>递推公式，dp[j]&#x3D;max(dp[j],dp[j-weigh[i]]+val[i])</li><li>初始化，全 0</li><li>遍历方向，重点，这是与 01 背包区别最大的地方，01 的滚动数组强调倒序遍历就是为了避免重复，在完全背包中，恰恰需要正序从而利用重复装入物品</li><li>举例，……</li></ol></li><li><p>参考代码随想录思路的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, v;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; v;</span><br><span class="line">    vector&lt;int&gt; weigh;</span><br><span class="line">    vector&lt;int&gt; val;</span><br><span class="line">    // 初始化输入</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        int tmp_w, tmp_v;</span><br><span class="line">        cin &gt;&gt; tmp_w &gt;&gt; tmp_v;</span><br><span class="line">        weigh.push_back(tmp_w);</span><br><span class="line">        val.push_back(tmp_v);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; dp(v+1, 0);</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = weigh[i]; j &lt;= v; j++) &#123;</span><br><span class="line">            dp[j] = max(dp[j], dp[j-weigh[i]]+val[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[v] &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h2 id="零钱兑换II"><a href="#零钱兑换II" class="headerlink" title="零钱兑换II"></a>零钱兑换II</h2></li><li><p><a href="https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p></li><li><p><a href="https://leetcode.cn/problems/coin-change-ii/description/">518. 零钱兑换 II - 力扣（LeetCode）</a></p></li><li><p>题意，给硬币面额和目标面额，求凑出目标面额的硬币组合数（ 122 和 221 算重复组合）</p></li><li><p>方法，</p><ol><li>dp[j] 是在目标面额为 j 时，组合数</li><li>递推公式，dp[j] +&#x3D; dp[j-coin[i]]；</li><li>初始化，由于递推公式，决定了 dp[0]&#x3D;1</li><li>遍历方向，这是重点，不可颠倒，求组合数就要先遍历硬币面额，后遍历目标面额；求排列数就要先遍历目标面额，后遍历硬币面额；可以这么理解，先遍历硬币面额，就可以让后面 dp[j] 的硬币大小顺序固定，不会出现 221 这种情况。</li><li>举例……</li></ol></li><li><p>参考代码随想录思路的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int change(int amount, vector&lt;int&gt;&amp; coins) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(amount+1, 0); // dp[j] 代表考虑前i种硬币，可以凑出多少种组合</span><br><span class="line">        dp[0] = 1;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; coins.size(); i++) &#123;</span><br><span class="line">            for (int j = coins[i]; j &lt; amount+1; j++) &#123;</span><br><span class="line">                if (dp[j] &lt; INT_MAX - dp[j-coins[i]]) </span><br><span class="line">                    dp[j] += dp[j-coins[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><h2 id="组合总和IV"><a href="#组合总和IV" class="headerlink" title="组合总和IV"></a>组合总和IV</h2></li><li><p><a href="https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p></li><li><p><a href="https://leetcode.cn/problems/combination-sum-iv/description/">377. 组合总和 Ⅳ - 力扣（LeetCode）</a></p></li><li><p>题意，有一个整数数组与一个目标整数，求整数数组中和为目标数的排列数，其值必为 int 范围内</p></li><li><p>方法，与[[零钱兑换II]]相似，不同的是，求排列数需要先遍历背包容量，再遍历物品，才能达到取到乱序的效果</p></li><li><p>陆爻齐试探出的解法，与代码随想录思路相近</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int combinationSum4(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        // dp[j] 即在目标为 j 时，元素组合个数</span><br><span class="line">        vector&lt;int&gt; dp(target+1, 0);</span><br><span class="line">        dp[0] = 1;</span><br><span class="line"></span><br><span class="line">        for (int j = 0; j &lt; target+1; j++) &#123;</span><br><span class="line">            for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">                if (j &gt;= nums[i] &amp;&amp; dp[j] &lt; INT_MAX - dp[j-nums[i]]) dp[j] += dp[j-nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法周记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Weekly Algorithm】算法周记之《代码随想录》动态规划（二）</title>
      <link href="/posts/b74c2166.html"/>
      <url>/posts/b74c2166.html</url>
      
        <content type="html"><![CDATA[<h1 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h1><p>本周跟随《代码随想录》继续推进动态规划的相关学习，由于期末月的到来，以及题目难度的增加，暂且将动态规划的学习进度放慢一点。下面继续巩固五步法。</p><ol><li>分析 dp 数组及其下标含义</li><li>确定递推公式</li><li>确定 dp 数组初始化</li><li>确定遍历顺序</li><li>举例分析 dp 数组是否如所想迭代</li></ol><p>只能感叹，这动态规划真是一百道题才入门啊。</p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><ul><li><h2 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h2></li><li><p><a href="https://programmercarl.com/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p></li><li><p><a href="https://leetcode.cn/problems/partition-equal-subset-sum/">416. 分割等和子集 - 力扣（LeetCode）</a></p></li><li><p>题意，给一个数组，返回判断该数组是否能平分为和相等的两部分</p></li><li><p>方法，直觉上，可以用回溯遍历树，找到那个子节点，但复杂度太高。<br>本题其实就是 01 背包的应用，nums[i] 本身，是物品，重量，以及价值。数组能否平分和的本质，就是平分和的大小的背包能否被刚好装满，也就是下标与值相等。  </p></li><li><p>参考代码随想录思路的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool canPartition(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int sum = accumulate(nums.begin(), nums.end(), 0); // 求整个数组之和</span><br><span class="line">        if (sum % 2 == 1) return false; // 不可能平分</span><br><span class="line">        int target = sum / 2;</span><br><span class="line">        vector&lt;int&gt; dp(10001, 0); // 由于总和不超 20000，最多 10001 元素足矣，dp[j]是在 j 内最接近 j 的和</span><br><span class="line">        for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            for (int j = target; j &gt;= nums[i]; j--) &#123;</span><br><span class="line">                dp[j] = max(dp[j], dp[j-nums[i]]+nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[target]==target; // 也就是在 target 处刚好有和能与之相等</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><h2 id="最后一块石头的重量II"><a href="#最后一块石头的重量II" class="headerlink" title="最后一块石头的重量II"></a>最后一块石头的重量II</h2></li><li><p><a href="https://programmercarl.com/1049.%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p></li><li><p><a href="https://leetcode.cn/problems/last-stone-weight-ii/">1049. 最后一块石头的重量 II - 力扣（LeetCode）</a></p></li><li><p>题意，从整型数组中，不断选取两数，使得大数减去小数同时小数消失，直到最后只剩一数，求剩下数字的最小值</p></li><li><p>方法，本质上，其实就是[[分割等和子集]]，还挺难看出来的。下面是五步法。</p><ol><li>确定 dp 数组及其下标含义，dp[j] 的意思是不大于 j 的重量内，最接近 j 的数值；</li><li>确认递推式，由于石头的重量和价值一体，故 dp[j]&#x3D;max(dp[j], dp[j-stone[i]]+stone[i]);</li><li>初始化，要避免初始值覆盖结果，而且重量不为负数，故初始化为 0，即可；</li><li>遍历顺序，从前往后即可，没有一定的要求</li><li>举例……</li></ol></li><li><p>参考代码随想录思路的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lastStoneWeightII(vector&lt;int&gt;&amp; stones) &#123;</span><br><span class="line">        int sum = accumulate(stones.begin(), stones.end(), 0);</span><br><span class="line">        int target = sum / 2;</span><br><span class="line">        vector&lt;int&gt; dp(target+1, 0); // 由于重量不为负数，初始化0比较合适</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; stones.size(); i++) &#123;</span><br><span class="line">            for (int j = target; j &gt;= stones[i]; j--) &#123;</span><br><span class="line">                dp[j] = max(dp[j], dp[j-stones[i]]+stones[i]);// 石头的重量和价值同义</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return (sum - dp[target]) - dp[target];// 前者为剩下石头，后者为分出来不大于一半的石头</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h2 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a>目标和</h2></li><li><p><a href="https://programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p></li><li><p><a href="https://leetcode.cn/problems/target-sum/description/">494. 目标和 - 力扣（LeetCode）</a></p></li><li><p>题意，给一个数组和目标整数，可以数组每个数前用加号或减号，看最后有几个组合可得到目标数</p></li><li><p>方法，回溯有类似题目，但普通回溯会超时。这里首先要将其转化为 01 背包问题，数组很显然就是行李，需要做一些变换，从两个方程式可知为达成目标值，左边为正号的数字之和，故以此为背包容量，本质就是求有多少个数之和为此和。</p><ol><li>确定 dp 数组及其下标含义，dp[i][j] 是考虑 0-i 的数字时，目标和为 j 的方案数；</li><li>确定递推公式，一个方案多考虑一个物品时相当于，原方案数+必须带上该物品且剩下空间的方案数，dp[i][j] &#x3D; dp[i-1][j]+dp[i-1][j-nums[i]]</li><li>初始化，第一行就只有物品大小的那个下标赋值为1，第一列则得看中间 0 的个数，每遇到一个 0，后面放空间 0 的起始方案数就会 * 2</li><li>递推顺序，从前向后（滚动数组的空间从后向前）</li><li>举例……</li></ol></li><li><p>参考代码随想录思路的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int sum = accumulate(nums.begin(), nums.end(), 0); // 总和</span><br><span class="line">        if (target &gt; sum) return 0;</span><br><span class="line">        if ((sum+target) % 2 == 1 || (sum+target) &lt; 0) return 0;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">        left + right = sum</span><br><span class="line">        left - right = target</span><br><span class="line">        两式相加除 2 得 left</span><br><span class="line">        */</span><br><span class="line">        int left = (sum + target) / 2;// 也就是为达成目标和，左边为正号的和</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(nums.size(), vector&lt;int&gt;(left+1, 0));</span><br><span class="line">        // dp[i][j] 是从0-i下标的数字中，凑出和为 j 的方法</span><br><span class="line">        // 初始化第一列，容量为0，只有不放一种方法，但是如果是 0，那么该位正负皆可</span><br><span class="line">        int numZero = 0;</span><br><span class="line">        for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            if (nums[i] == 0) numZero++;</span><br><span class="line">            dp[i][0] = (int) pow(2.0, numZero);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 初始化第一行，只有数值恰好相等为1</span><br><span class="line">        for (int i = 1; i &lt; left+1; i++) &#123;</span><br><span class="line">            if (nums[0] &gt; i) continue;</span><br><span class="line">            else if (nums[0] == i) dp[0][i] = 1;</span><br><span class="line">            else break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; left+1; j++) &#123;</span><br><span class="line">                if (j &lt; nums[i]) dp[i][j] = dp[i-1][j];</span><br><span class="line">                else dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i]]; // 相当于不用该物品的旧方法和用该物品的新方法之和</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; left+1;j++) &#123;</span><br><span class="line">                cout &lt;&lt; dp[i][j] &lt;&lt; &quot; &quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        return dp[nums.size()-1][left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><h2 id="一和零"><a href="#一和零" class="headerlink" title="一和零"></a>一和零</h2></li><li><p><a href="https://programmercarl.com/0474.%E4%B8%80%E5%92%8C%E9%9B%B6.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p></li><li><p><a href="https://leetcode.cn/problems/ones-and-zeroes/submissions/582275874/">474. 一和零 - 力扣（LeetCode）</a></p></li><li><p>题意，给一个各字符串只由 0 和 1 构成的字符串数组，再给两个整数，要求给出在 0 和 1 分别不超过这两数的情况下，最大子集的字符串个数（真子集）</p></li><li><p>方法，该题也是 01 背包，这两个分别代表最大 0 和 1 的数相当于两个背包容量的维度，实质上就是要求在这两个维度的束缚下，能装的最大的字符串个数</p><ol><li>dp[i][j]，最多有 i 个 0 和 j 个 1 的情况下，能装入的最多字符串个数</li><li>递推公式，dp[i][j]&#x3D;max(dp[i][j], dp[i-zero_num][j-one_num];意思是在原来的情况，与必须装入该字符串的情况相比，选取可装字符串最多的情况</li><li>初始化，由于是求个数，全数组初始化为 0 即可</li><li>遍历顺序，由于是二维滚动数组，从后向前</li><li>举例……</li></ol></li><li><p>参考代码随想录思路的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) &#123;</span><br><span class="line">        int zero_num, one_num; // 记录每个字符串的 0 和 1 数</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); // dp[i][j] 指在 i 和 j 的限制数内，包含最大字符串个数</span><br><span class="line">        for (string str : strs) &#123;</span><br><span class="line">            zero_num = 0; one_num = 0;</span><br><span class="line">            for (char c : str) &#123;</span><br><span class="line">                if (c == &#x27;0&#x27;) &#123;</span><br><span class="line">                    zero_num++;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    one_num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 实质就是比较原来的情况与必须加上这个字符串的情况，哪个装的字符串多</span><br><span class="line">            for (int i = m; i &gt;= zero_num; i--) &#123;</span><br><span class="line">                for (int j = n; j &gt;= one_num; j--) &#123;</span><br><span class="line">                    dp[i][j] = max(dp[i][j], dp[i-zero_num][j-one_num]+1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法周记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Weekly Algorithm】算法周记之《代码随想录》动态规划（一）</title>
      <link href="/posts/875acdbe.html"/>
      <url>/posts/875acdbe.html</url>
      
        <content type="html"><![CDATA[<h1 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h1><p>本周跟随《代码随想录》开始学习动态规划的相关题目，从基础的斐波那契数到爬楼梯，再到 01 背包问题，慢慢熟悉动态规划的五步法。<br>《代码随想录》还提醒，调试重点是检查递推公式是否举例，检查打印 dp 数组是否和自己设想一致。</p><ol><li>分析 dp 数组及其下标含义</li><li>确定递推公式</li><li>确定 dp 数组初始化</li><li>确定遍历顺序</li><li>举例分析 dp 数组是否如所想迭代</li></ol><p>此外除了寻常的二维数组动态规划，也尝试做滚动数组的练习。</p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><ul><li><h2 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a>斐波那契数</h2></li><li><p>题意，给一个数字 n，求斐波那契数中的第 n 个数</p></li><li><p>方法，虽然就算不看代码随想录也能轻易写出，但简单题的重点在于熟悉套路方法，下面按五步分析</p><ol><li>确定 dp 数组及其下标含义，这里的 dp[i] 代表斐波那契数中的第 i 个数</li><li>确认递推公式，题目给出 <code>dp[i]=dp[i-1]+dp[i-2]</code></li><li>dp 数组初始化，题目也给出<code>dp[0]=0;dp[1]=1;</code></li><li>确定遍历顺序，从递推公式可见，就是从前向后（0-n）遍历</li><li>举例推导 dp 公式，0 1 1 2 3 5 8 13 21 ……</li></ol></li><li><p>陆爻齐的解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int fib(int n) &#123;</span><br><span class="line">        if (n &lt;= 1) return n;</span><br><span class="line">        int dp[n+1]; // dp数组为斐波那契数列的存储</span><br><span class="line">        dp[0] = 0; // 初始化dp数组</span><br><span class="line">        dp[1] = 1;</span><br><span class="line">        for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i-1] + dp[i-2]; // 递推公式</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><h2 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h2></li><li><p><a href="https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p></li><li><p><a href="https://leetcode.cn/problems/climbing-stairs/description/">70. 爬楼梯 - 力扣（LeetCode）</a></p></li><li><p>题目，设定你一次能爬 1 或 2 层台阶，给你 n 个台阶，求上去的方式数量</p></li><li><p>方法，简单举例可见，上第 3 层台阶是根据第 1 层台阶和第 2 层台阶的状态决定的，那么就按五步法</p><ol><li>确认 dp 数组及其下标含义，这里的 dp[i] 表示上到第 i 个台阶的方法；</li><li>确认递推公式，从上面简单举例可见，dp[i]&#x3D;dp[i-1]+dp[i-2];也就是从 i-1 上一阶和 i-2 上两阶，若 i-2 上一阶就到 i-1 而不是 i 了；</li><li>dp 数组初始化，由于题目也没说 0 层的初始化，那么直接初始化 dp[1]&#x3D;1;dp[2]&#x3D;2;应当是无异议的；</li><li>确认遍历顺序，爬楼梯也是从前往后的  </li><li>举例推导 dp 数组， 1 2 3 5 8 13 ……</li></ol></li><li><p>参考代码随想录思路的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int climbStairs(int n) &#123;</span><br><span class="line">        int dp[n+1]; // 爬到第 i 楼梯的方法数</span><br><span class="line">        if (n &lt;= 2) return n;</span><br><span class="line">        dp[1]=1;</span><br><span class="line">        dp[2]=2;</span><br><span class="line">        for (int i = 3; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i-1] + dp[i-2]; // 递推式</span><br><span class="line">        &#125; </span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><h2 id="使用最小花费爬楼梯"><a href="#使用最小花费爬楼梯" class="headerlink" title="使用最小花费爬楼梯"></a>使用最小花费爬楼梯</h2></li><li><p><a href="https://programmercarl.com/0746.%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p></li><li><p><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯 - 力扣（LeetCode）</a></p></li><li><p>题意，类似[[爬楼梯]]，但从一级楼梯向上爬一或二级都会消耗体力值，要求爬到顶的最小花费</p></li><li><p>方法，五步法</p><ol><li>确认 dp 数组及其下标含义，dp[i] 是到达第 i 阶的最小体力花费</li><li>确认递推公式，dp[i] &#x3D; min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])</li><li>确认初始化，由于上第一级或第二级不需要体力值，dp[0]&#x3D;0;dp[1]&#x3D;1;</li><li>确定遍历顺序，爬楼梯从前往后</li><li>举例，……</li></ol></li><li><p>参考代码随想录思路解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123;</span><br><span class="line">        int dp[cost.size()+1]; // dp[i]到达第i阶所需最小体力</span><br><span class="line">        dp[0] = 0; dp[1] = 0; // 初始化，第一步不用体力</span><br><span class="line">        for (int i = 2; i &lt; cost.size()+1; i++) &#123; // 遍历顺序从前到后</span><br><span class="line">            dp[i] = min(dp[i-2]+cost[i-2], dp[i-1]+cost[i-1]); // 递推公式，可从下两阶上两阶或下一阶上一阶</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[cost.size()];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><h2 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h2></li><li><p><a href="https://programmercarl.com/0062.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p></li><li><p><a href="https://leetcode.cn/problems/unique-paths/description/">62. 不同路径 - 力扣（LeetCode）</a></p></li><li><p>题意，有一个 [m][n] 的数组，问题从左上角只能向右或向下移动，右下角有几条路径</p></li><li><p>方法，五步法</p><ol><li><p>确认 dp 数组及其下标含义，dp[i][j] 表示到达 i，j 的路径和</p></li><li><p>确认递推式，由于一个格子可由上或左来，故 dp[i][j] &#x3D; dp[i-1][j]+dp[i][j-1];  </p></li><li><p>确认初始化，陆爻齐在递推过程中判别了边界，所以只初始化 dp[0][0]&#x3D;1; 不过要是不想在中间做判别，可以把边缘初始化了在递推，即 dp[0][<em>]&#x3D;0;dp[</em>][0]&#x3D;0;（这里的 * 泛指数字）</p></li><li><p>确认遍历顺序，从上向下，从左向右</p></li><li><p>举例……</p></li></ol></li><li><p>陆爻齐的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePaths(int m, int n) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp = vector(m,vector&lt;int&gt;(n, 0)); // dp[i][j] 代表从左上角到 i，j 的路径数</span><br><span class="line">        dp[0][0] = 1; // 由于递推是取上和左路径和，故得取 1</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123; // 从上往下</span><br><span class="line">            for (int j = 0; j &lt; n; j++) &#123; // 从左往右</span><br><span class="line">                if (i &gt; 0) &#123;</span><br><span class="line">                    dp[i][j] += dp[i-1][j];</span><br><span class="line">                &#125;</span><br><span class="line">                if (j &gt; 0) &#123;</span><br><span class="line">                    dp[i][j] += dp[i][j-1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m-1][n-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参考滚动数组的改进，即二维数组转一维数组  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePaths(int m, int n) &#123;</span><br><span class="line">        vector&lt;int&gt; dp = vector&lt;int&gt;(n, 0); // dp[j] 代表从左上角第 i 轮循环到 i，j 的路径数</span><br><span class="line">        dp[0] = 1; // 由于递推是取上和左路径和，故得取 1</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123; // 从上往下</span><br><span class="line">            for (int j = 0; j &lt; n; j++) &#123; // 从左往右</span><br><span class="line">                if (j &gt; 0) &#123;</span><br><span class="line">                    dp[j] += dp[j-1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码随想录的解法  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePaths(int m, int n) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0));</span><br><span class="line">        for (int i = 0; i &lt; m; i++) dp[i][0] = 1;</span><br><span class="line">        for (int j = 0; j &lt; n; j++) dp[0][j] = 1;</span><br><span class="line">        for (int i = 1; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m - 1][n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h2 id="不同路径II"><a href="#不同路径II" class="headerlink" title="不同路径II"></a>不同路径II</h2></li><li><p><a href="https://programmercarl.com/0063.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p></li><li><p><a href="https://leetcode.cn/problems/unique-paths-ii/description/">63. 不同路径 II - 力扣（LeetCode）</a></p></li><li><p>题意，与[[不同路径]]类似，不过数组中可能有障碍物</p></li><li><p>方法，也类似，不过对于障碍物的那一格，就设置为零</p></li><li><p>参考代码随想录思路的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123;</span><br><span class="line">        int m = obstacleGrid.size();</span><br><span class="line">        int n = obstacleGrid[0].size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n,0)); // dp[i][j] 为从 0，0 到 i，j 的路径数和</span><br><span class="line">        </span><br><span class="line">        for (int i = 0; i &lt; m &amp;&amp; obstacleGrid[i][0] == 0; i++) &#123;</span><br><span class="line">            dp[i][0] = 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int j = 0; j &lt; n &amp;&amp; obstacleGrid[0][j] == 0; j++) &#123;</span><br><span class="line">            dp[0][j] = 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; n; j++) &#123;</span><br><span class="line">                if (obstacleGrid[i][j] == 1) continue; // 障碍物处路线为 0</span><br><span class="line">                dp[i][j] += dp[i-1][j] + dp[i][j-1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m-1][n-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><h2 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a>整数拆分</h2></li><li><p><a href="https://programmercarl.com/0343.%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p></li><li><p><a href="https://leetcode.cn/problems/integer-break/description/">343. 整数拆分 - 力扣（LeetCode）</a></p></li><li><p>题意，给一个正整数，求其拆分为多个(大于等于2)正整数的最大乘积</p></li><li><p>方法，</p><ol><li>确认 dp[i] 的含义，为对 i 拆分多个正整数的最大乘积</li><li>确认递推式，dp[i] &#x3D; max(j * (i-j), j * dp[i-j], dp[i])，一是普通情况，拆分两数，三是原本值，二则是利用历史乘积，为拆分多个值的乘积</li><li>确认初始化，dp[0], dp[1] &#x3D; 0, 0; dp[2] &#x3D; 1；起码拆两数</li><li>遍历顺序，从前往后，虽然前面这些都是前-&gt;后，不过后面有些就不是了</li><li>举例……</li></ol></li><li><p>参考代码随想录思路的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int integerBreak(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(n+1, 0); // dp[i] 表示对 i 拆分后的最大乘积</span><br><span class="line">        dp[0] = 0; dp[1] = 0; // 这两没法拆两正整数</span><br><span class="line">        dp[2] = 1;</span><br><span class="line"></span><br><span class="line">        for (int i = 3; i &lt;= n; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= i/2; j++) &#123;</span><br><span class="line">                // 第一个是拆分为 2 个，第二个是拆分为大于 2 个的情况的乘积</span><br><span class="line">                dp[i] = max(j * (i-j), max(j * dp[i-j], dp[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><h2 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a>不同的二叉搜索树</h2></li><li><p><a href="https://programmercarl.com/0096.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p></li><li><p><a href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树 - 力扣（LeetCode）</a></p></li><li><p>问题，给你数字 n，要求返回 n 个节点能组成的二叉搜索树个数</p></li><li><p>方法，一开始难以下手，总之先看看例子，n &#x3D; 0时，无节点算一个；n&#x3D;1时，也算一个；n&#x3D;2时，算两个，如下图所示<br><img src="/../assets/image_1731631111478_0.png" alt="image.png"><br>n&#x3D;3时，有五个，如下图所示<br><img src="/../assets/image_1731631134171_0.png" alt="image.png"><br>可见，n &#x3D; 3中，其实可分三类，左边两个为一类，是左子树 0 节点，右子树 2 节点，2 * 1 有 2 种； 中间一类，左子树和右子树各 1 节点，有 1 * 1 共 1 种； 右侧一类，左子树 2 节点，右子树 0 节点，有 2 * 1 共 2 种。一共五种。  </p></li><li><p>五步法：</p><ol><li>dp[i] 是 i 个节点组成的二叉搜索树的种类数</li><li>递推公式： dp[i] +&#x3D; dp[j-1]*dp[i-j]; 右边 i-1 个点，符合题意，毕竟固定有个点放根，不参与左右子树的方案</li><li>初始化，0 个节点二叉搜索树有 1 个，dp[0] &#x3D; 1;</li><li>遍历顺序，从前往后</li><li>举例 ……</li></ol></li><li><p>参考代码随想录思路的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numTrees(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(n+1, 0); // dp[i] 是 i 个节点组成的二叉搜索树的种类数</span><br><span class="line">        dp[0] = 1; // 0个节点算二叉搜索树、</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= i; j++) &#123;</span><br><span class="line">                dp[i] += dp[j-1] * dp[i-j]; // 左子树方案数 * 右子树方案数</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><h2 id="01-背包理论"><a href="#01-背包理论" class="headerlink" title="01 背包理论"></a>01 背包理论</h2></li><li><p><a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p></li><li><p><a href="https://kamacoder.com/problempage.php?pid=1046">46. 携带研究材料（第六期模拟笔试）</a></p></li><li><p>题意，01 背包通常不会直接考，更多时候是把情景题转化为 01 背包问题，正如研究材料中，研究材料价值和重量也对应 01 背包</p></li><li><p>方法，</p><ol><li>确认 dp数组以及下标含义，dp[i][j] 的意思是当背包大小为 j，从0-i下标材料任选组合价值最大的值</li><li>确认递推公式, 若剩余重量不足 dp[i][j] &#x3D; dp[i-1][j] ,剩余重量充足就是 dp[i][j] &#x3D; max(dp[i-1][j], dp[i-1][j-weigh[i]]+val[i])，也就是不加入当前物品的最大价值和加入当前物品的价值与剩余重量最大价值之和相比较。</li><li>初始化，第一行和第一列都下应先为 0，再判断第一个物品在第一行是否能放入</li><li>遍历顺序，先遍历物品，其中遍历背包容量</li><li>举例……</li></ol></li><li><p>但此题还有一点，那就是滚动数组的解法，可以将二维数组转为一维数组，降低空间复杂度，具体可继续按上述五步法</p><ol><li>确定 dp 数组及其下标含义，dp[j] 的意思是背包空间为 j 时的最大价值容量</li><li>递推公式，由于压缩后，每层遍历相当于新值与原坐标的数值比较，dp[j] &#x3D; max(dp[j], dp[j-weigh[i]] + val[i])</li><li>初始化，dp[*]&#x3D;0,毕竟可从第一个物品开始做起</li><li>遍历顺序，这是该方法重点，必须在遍历空间时倒序，也就是 j 的值必须先取大值到小，从数组的角度，就是从右向左。原因是，每个值的更新可能与其更小坐标相关，如果先更新了小坐标，那么就会影响到大坐标的更新。</li><li>举例……</li></ol></li><li><p>参考代码随想录思路的二维数组解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // init</span><br><span class="line">    int m, n; // 材料个数和背包大小</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    vector&lt;int&gt; weigh(m);// 分别是所占空间和价值</span><br><span class="line">    vector&lt;int&gt; val(m);</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; weigh[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; val[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n+1, 0)); </span><br><span class="line">    // dp[i][j] 为当背包大小为 j，从0-i下标材料任选组合价值最大的值</span><br><span class="line">    // dp[0][*]和dp[*][0]皆已初始化为0，还差第一个材料的初始化</span><br><span class="line">    for (int i = 0; i &lt;= n; i++) &#123;</span><br><span class="line">        if (i &gt;= weigh[0]) dp[0][i] = val[0];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 递推顺序，物品中遍历背包容量（本题反过来貌似也可）</span><br><span class="line">    for (int i = 1; i &lt; m; i++) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= n; j++) &#123;</span><br><span class="line">            if (j &lt; weigh[i]) dp[i][j] = dp[i-1][j];</span><br><span class="line">            else dp[i][j] = max(dp[i-1][j], dp[i-1][j-weigh[i]] + val[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n+1;j++) &#123;</span><br><span class="line">            cout &lt;&lt; dp[i][j] &lt;&lt; &quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    */</span><br><span class="line">    cout &lt;&lt; dp[m-1][n] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>滚动数组的解法  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // init</span><br><span class="line">    int m, n; // 材料个数和背包大小</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    vector&lt;int&gt; weigh(m);// 分别是所占空间和价值</span><br><span class="line">    vector&lt;int&gt; val(m);</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; weigh[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; val[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; dp(n+1, 0); </span><br><span class="line">    // dp[j] 为当背包大小为 j，从0-i下标材料任选组合价值最大的值</span><br><span class="line">    // dp[*]皆已初始化为0</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    // 递推顺序，物品中遍历背包容量（本题反过来貌似也可）</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        for (int j = n; j &gt; 0; j--) &#123;</span><br><span class="line">            if (j &gt;= weigh[i]) dp[j] = max(dp[j] ,dp[j-weigh[i]] + val[i]);</span><br><span class="line">            /*</span><br><span class="line">            for (int j = 0; j &lt; n+1;j++) &#123;</span><br><span class="line">                cout &lt;&lt; dp[j] &lt;&lt; &quot; &quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">            */</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; dp[n] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法周记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Weekly Algorithm】算法周记之《代码随想录》回溯（二）</title>
      <link href="/posts/4ea07c12.html"/>
      <url>/posts/4ea07c12.html</url>
      
        <content type="html"><![CDATA[<h1 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h1><p>本周跟随《代码随想录》学习回溯的剩余题目，如八皇后，全排列等问题，当初看上去可怕的题目，在回溯的套路下，显得也没那么难，重点在于理解整个回溯的树遍历过程。</p><p>通常回溯部分的函数无返回值，但当回溯只求全树唯一一个解时，比如[[全排列]][[解数独]]，可将回溯函数返回值设为 bool 类型，在一个叶子为 true，层层上传，避免无用遍历。</p><h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><ul><li><h2 id="组合总和II"><a href="#组合总和II" class="headerlink" title="组合总和II"></a>组合总和II</h2></li><li><a href="https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html#%E6%80%9D%E8%B7%AF">代码随想录</a></li><li><a href="https://leetcode.cn/problems/combination-sum-ii/description/">40. 组合总和 II - 力扣（LeetCode）</a></li><li>题意，与[[组合总和III]]类似，但待选数组内出现重复元素，且结果的组合不能重复</li><li>方法，重点是分清两种去重，一种是同一树支的去重（纵向），一种是同一树层的去重（横向），两者都可以通过用 used 数组实现，前者要求 used 中同值点不可同时 true 才能加入结果，后者要求同值点必须 true 该点才能加入结果；换句话，used 中 ture 的点说明在同一树支（路径）上</li><li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">    vector&lt;int&gt; path;</span><br><span class="line">    void back_track(vector&lt;int&gt; &amp;candidates, int target, vector&lt;int&gt; &amp;used, int sum, int start_index) &#123;</span><br><span class="line">        // 终止条件，和过大或相等</span><br><span class="line">        if (sum &gt; target) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (sum == target) &#123;</span><br><span class="line">            result.push_back(path);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        for (int i = start_index; i &lt; candidates.size(); i++) &#123;</span><br><span class="line">            // 去重，used[i-1] true 说明在同一个路径上</span><br><span class="line">            // used[i-1] flase 说明在同一层，属于要去除的情况</span><br><span class="line">            if (i &gt; 0 &amp;&amp; candidates[i] == candidates[i-1] &amp;&amp; used[i-1] == false) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            used[i] = true;</span><br><span class="line">            path.push_back(candidates[i]);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            back_track(candidates, target, used, sum, i+1);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.pop_back();</span><br><span class="line">            used[i] = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;</span><br><span class="line">        vector&lt;int&gt; used = vector&lt;int&gt;(candidates.size());</span><br><span class="line">        result.clear();</span><br><span class="line">        path.clear();</span><br><span class="line">        sort(candidates.begin(), candidates.end()); // 使数组有序</span><br><span class="line">        back_track(candidates, target, used, 0, 0);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h2 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h2></li><li><a href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></li><li><a href="https://leetcode.cn/problems/palindrome-partitioning/description/">131. 分割回文串 - 力扣（LeetCode）</a></li><li>题意，给一个字符串，把字符串分成多个回文串组成的字符串数组，返回所有组合</li><li>方法，难点有两，一是如何分割字符串，二是如何判断回文串。<br>对于一，采用 start_index 作为本层分割字符串的起点，用 for 循环决定重点，递归更新 start_index；对于二，就用 for 循环前后检测是否相等，可以用动态规划优化速度，但太麻烦了，等dp学完再回来罢：）  </li><li>参照代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    bool isRevStr(string s) &#123; // 判断回文串，前读和后读一样，其实前半和后半一样就行</span><br><span class="line">        for (int i = 0, j = s.size()-1; i &lt; j; i++,j--) &#123;</span><br><span class="line">            if (s[i] != s[j]) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line">    vector&lt;string&gt; path;</span><br><span class="line"></span><br><span class="line">    void back_track(string s, int start_index) &#123;</span><br><span class="line">        if (start_index &gt;= s.size()) &#123; // start_index 为分割线，分割到字符串外说明前面都割好了</span><br><span class="line">            result.push_back(path);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = start_index; i &lt; s.size(); i++) &#123; </span><br><span class="line">            // 从 start_index 到 i 割串，检测</span><br><span class="line">            string tmp = s.substr(start_index, i-start_index+1);</span><br><span class="line">            //cout &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line">            if (isRevStr(tmp)) &#123;</span><br><span class="line">                path.push_back(tmp);</span><br><span class="line">                back_track(s, i+1);</span><br><span class="line">                path.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123;</span><br><span class="line">        result.clear();</span><br><span class="line">        path.clear();</span><br><span class="line">        back_track(s, 0);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h2 id="复原IP地址"><a href="#复原IP地址" class="headerlink" title="复原IP地址"></a>复原IP地址</h2></li><li><a href="https://programmercarl.com/0093.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></li><li><a href="https://leetcode.cn/problems/restore-ip-addresses/description/">93. 复原 IP 地址 - 力扣（LeetCode）</a></li><li>题意，有一串数字，可能是 IP 地址，要求返回该数字可能组成所有有效的 IP 地址（最少4位、最多12位，中间有三个点分隔的数字字符串）</li><li>方法，与[[分割回文串]]类似，但这里限制了分割的个数，所以需要变量记录，且注意前导0和把字符串转整数的操作</li><li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line"></span><br><span class="line">    bool isValid(const string &amp;s, int start_index, int end_index) &#123;</span><br><span class="line">        // 满足字符串是0-255，无前导0，且是数字</span><br><span class="line">        if (start_index &gt; end_index) &#123; // 去除最后 i+2 后 start_index 比 end 大的情况，下面代码没考虑</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (s[start_index] == &#x27;0&#x27; &amp;&amp; start_index != end_index) &#123; // 前导0</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int num = 0; // 记录数值</span><br><span class="line">        for (int i = start_index; i &lt;= end_index; i++) &#123;</span><br><span class="line">            num *=10;</span><br><span class="line">            char c = s[i];</span><br><span class="line">            if (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            num += int(c - &#x27;0&#x27;);</span><br><span class="line">            if (num &gt; 255) &#123;// 过大</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void backTrack(string s, int start_index, int point_num) &#123;</span><br><span class="line">        if (point_num == 3 &amp;&amp; isValid(s, start_index, s.size()-1)) &#123;</span><br><span class="line">            result.push_back(s);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">        for (int i = start_index; i &lt; s.size(); i++) &#123;</span><br><span class="line">            if (isValid(s, start_index, i)) &#123;</span><br><span class="line">                s.insert(s.begin()+i+1, &#x27;.&#x27;); // 采用插点的方式来分割字符串，插入点的下标为 i+1</span><br><span class="line">                point_num++;</span><br><span class="line">                backTrack(s, i+2, point_num);</span><br><span class="line">                point_num--;</span><br><span class="line">                s.erase(s.begin()+i+1);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                break; // 要么数组过大，要么有非法字符，后面的都一定不符合</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; restoreIpAddresses(string s) &#123;</span><br><span class="line">        result.clear();</span><br><span class="line">        if (s.size() &lt; 4 || s.size() &gt; 12) &#123; // ip 地址最少4位，每处最多3位，共12位</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        backTrack(s, 0, 0);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h2 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h2></li><li><a href="https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></li><li><a href="https://leetcode.cn/problems/subsets/description/">78. 子集 - 力扣（LeetCode）</a></li><li>题意，给一个整数数组，求其所有子集</li><li>方法，回溯，注意由于集合内无序性，元素不能重复；该题其实遍历了树上所有节点，而之前的组合、分割则是收集树中的叶子节点。</li><li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">    vector&lt;int&gt; path;</span><br><span class="line"></span><br><span class="line">    void backTrack(vector&lt;int&gt; &amp;nums, int start_index) &#123;</span><br><span class="line">        if (start_index &gt; nums.size()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        result.push_back(path);</span><br><span class="line">        for (int i = start_index; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            path.push_back(nums[i]);</span><br><span class="line">            backTrack(nums, i+1);</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        result.clear();</span><br><span class="line">        path.clear();</span><br><span class="line">        backTrack(nums, 0);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h2 id="子集II"><a href="#子集II" class="headerlink" title="子集II"></a>子集II</h2></li><li><a href="https://programmercarl.com/0090.%E5%AD%90%E9%9B%86II.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></li><li><a href="https://leetcode.cn/problems/subsets-ii/description/">90. 子集 II - 力扣（LeetCode）</a></li><li>题意，相比[[子集]]，数组中会有重复的数字元素，求的结果子集仍然要求一样</li><li>方法，类似[[组合总和II]]，通过 used 去除同层同值的节点造成子集重复的问题</li><li>陆爻齐自己解法（与代码随想录思路相近）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">    vector&lt;int&gt; path;</span><br><span class="line"></span><br><span class="line">    void backTrack(vector&lt;int&gt; &amp;nums, int start_index, vector&lt;int&gt; &amp;used) &#123;</span><br><span class="line">        // 记录结果，遍历每个节点</span><br><span class="line">        result.push_back(path);</span><br><span class="line">        if (start_index &gt;= nums.size()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = start_index; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            // 排除那些同层同值的节点</span><br><span class="line">            if (i&gt;0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; used[i-1] == false) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            used[i] = true;</span><br><span class="line">            path.push_back(nums[i]);</span><br><span class="line">            backTrack(nums, i+1, used);</span><br><span class="line">            path.pop_back();</span><br><span class="line">            used[i] = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        result.clear();</span><br><span class="line">        path.clear();</span><br><span class="line">        // 需要有序才能方便去除同层相同数，不排序的话需要哈希表</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        vector&lt;int&gt; used = vector&lt;int&gt;(nums.size());</span><br><span class="line">        backTrack(nums, 0, used);</span><br><span class="line">        return result; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><h2 id="非递减子序列"><a href="#非递减子序列" class="headerlink" title="非递减子序列"></a>非递减子序列</h2></li><li><a href="https://programmercarl.com/0491.%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></li><li><a href="https://leetcode.cn/problems/non-decreasing-subsequences/description/">491. 非递减子序列 - 力扣（LeetCode）</a></li><li>题意，给一个数组，要求返回其中所有至少长度为2的递增子序列</li><li>方法，看似与[[子集II]]相似，只要排下序，回溯即可；其实不行，因为一旦排序，整个序列都是递增的，那么如何去重呢？那就要用到 hash。不过本地的数字大小在 -100 到 100，所以用大小为 201 的数组把数字映射上去即可</li><li>参考代码随想录思路的代码<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">    vector&lt;int&gt; path;</span><br><span class="line"></span><br><span class="line">    void backTrack(vector&lt;int&gt; &amp;nums, int start_index) &#123;</span><br><span class="line">        if (path.size() &gt;= 2) &#123;</span><br><span class="line">            result.push_back(path); // 添加结果条件</span><br><span class="line">            // 不需要 return，因为需要遍历整个树的节点</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; used = vector&lt;int&gt;(201); // 把-100至100两个个数，映射到0-200 的数组上</span><br><span class="line">        for (int i = start_index; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            if (used[nums[i]+100] == 1) continue; // 去重</span><br><span class="line">            if (path.size() &gt; 0 &amp;&amp; nums[i] &lt; path[path.size()-1]) continue; // 使得新加值不小于path末值</span><br><span class="line">            used[nums[i]+100] = 1; // 只管本层去重，所以记录有就行，不需要恢复0</span><br><span class="line">            path.push_back(nums[i]);</span><br><span class="line">            backTrack(nums, i+1);</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        result.clear();</span><br><span class="line">        path.clear();</span><br><span class="line">        backTrack(nums, 0);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2></li><li><a href="https://programmercarl.com/0046.%E5%85%A8%E6%8E%92%E5%88%97.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></li><li><a href="https://leetcode.cn/problems/permutations/description/">46. 全排列 - 力扣（LeetCode）</a></li><li>题意，把一个无重复数字的数组所有可能的全排列按任意顺序返回答案</li><li>方法，运用回溯，不过由于要求全排列，也就是可能之前的值在下面也用得到，所以不用 start_index</li><li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">    vector&lt;int&gt; path;</span><br><span class="line"></span><br><span class="line">    void backTrack(vector&lt;int&gt; &amp;nums,vector&lt;int&gt; &amp;used) &#123;</span><br><span class="line">        if (path.size() == nums.size()) &#123; // 到叶子节点，说明全排列完成</span><br><span class="line">            result.push_back(path);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            if (used[i] == 1) continue; // 排除用过数字的情况</span><br><span class="line">            used[i] = 1;</span><br><span class="line">            path.push_back(nums[i]);</span><br><span class="line">            backTrack(nums, used);</span><br><span class="line">            path.pop_back();</span><br><span class="line">            used[i] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        result.clear();</span><br><span class="line">        path.clear();</span><br><span class="line">        vector&lt;int&gt; used = vector&lt;int&gt;(nums.size());</span><br><span class="line">        backTrack(nums, used);</span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><h2 id="全排列II"><a href="#全排列II" class="headerlink" title="全排列II"></a>全排列II</h2></li><li><a href="https://programmercarl.com/0047.%E5%85%A8%E6%8E%92%E5%88%97II.html#%E6%80%9D%E8%B7%AF">代码随想录</a></li><li><a href="https://leetcode.cn/problems/permutations-ii/">47. 全排列 II - 力扣（LeetCode）</a></li><li>题意，与[[全排列]]类似，但数组中出现重复元素</li><li>方法，在[[全排列]]的基础上，加入去重，不过这个去重其实在树枝去重和树层去重都是可以的，但对树层去重效率会高很多，可以举个【1，1，1】的例子试试</li><li>参考代码随想录思路的代码<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">    vector&lt;int&gt; path;</span><br><span class="line">    void backTrack(vector&lt;int&gt; &amp;nums, vector&lt;int&gt; &amp;used) &#123;</span><br><span class="line">        if (path.size() == nums.size()) &#123;</span><br><span class="line">            result.push_back(path);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            if (i&gt;0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; used[i-1]==0) continue;</span><br><span class="line">            if (used[i] == 0) &#123;</span><br><span class="line">                used[i] = 1;</span><br><span class="line">                path.push_back(nums[i]);</span><br><span class="line">                backTrack(nums, used);</span><br><span class="line">                path.pop_back();</span><br><span class="line">                used[i] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        result.clear();</span><br><span class="line">        path.clear();</span><br><span class="line">        vector&lt;int&gt; used(nums.size());// 映射这个值是否用过</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        backTrack(nums, used);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><h2 id="重新安排行程"><a href="#重新安排行程" class="headerlink" title="重新安排行程"></a>重新安排行程</h2></li><li><a href="https://programmercarl.com/0332.%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B.html#%E6%80%9D%E8%B7%AF">代码随想录</a></li><li><a href="https://leetcode.cn/problems/reconstruct-itinerary/description/">332. 重新安排行程 - 力扣（LeetCode）</a></li><li>题意，给一系列大小为 2 的字符串数组，当作机票的出发地和目的地，要求从 JFK 出发，每张票要用且只能使用一次，要求最后返回一条有效路程，若有多个有效路程则返回字典序最小的那条</li><li>方法，主要是如何在回溯过程中记录回溯历程，这里使用了一个 unordered_map&lt;string, map&lt;string, int&gt;&gt; 来记录，翻译为自然语言，就是 unordered_map&lt;出发地, map&lt;目的地，票数&gt;&gt;，map是有序的，直接遍历就是字典序从小到大</li><li>参考代码随想录思路的方法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line"></span><br><span class="line">    unordered_map&lt;string,map&lt;string, int&gt;&gt; rec_tic;</span><br><span class="line"></span><br><span class="line">    bool backTrack(int ticket_num) &#123;</span><br><span class="line">        if (ticket_num + 1 == result.size()) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        map&lt;string, int&gt; &amp;target = rec_tic[result[result.size()-1]];</span><br><span class="line">        for (pair&lt;const string, int&gt; &amp;travel : target) &#123;</span><br><span class="line">            if (travel.second &gt; 0) &#123;</span><br><span class="line">                travel.second--;</span><br><span class="line">                result.push_back(travel.first);</span><br><span class="line">                if (backTrack(ticket_num)) return true;</span><br><span class="line">                result.pop_back();</span><br><span class="line">                travel.second++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; findItinerary(vector&lt;vector&lt;string&gt;&gt;&amp; tickets) &#123;</span><br><span class="line">        result.clear();</span><br><span class="line">        rec_tic.clear();</span><br><span class="line"></span><br><span class="line">        for (vector&lt;string&gt; tic : tickets) &#123;</span><br><span class="line">            rec_tic[tic[0]][tic[1]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        result.push_back(&quot;JFK&quot;);</span><br><span class="line">        backTrack(tickets.size());</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><h2 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h2></li><li><a href="https://programmercarl.com/0051.N%E7%9A%87%E5%90%8E.html#%E6%80%9D%E8%B7%AF">代码随想录</a></li><li><a href="https://leetcode.cn/problems/n-queens/">51. N 皇后 - 力扣（LeetCode）</a></li><li>题意，国际棋盘上，皇后这个棋子同行、同列、两斜线上都是唯一，给棋盘大小，要求摆皇后的所有方案</li><li>方法，把行作为递归深度，到底就是得出结果，然后代入回溯模板即可，由于在二维数组上（棋盘）从上往下遍历，故检查下棋位置是否合法只要检测上面即可</li><li>参考代码随想录思路的方法，时隔许久再做，好像也没那么恐怖哈<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line">    vector&lt;string&gt; chess_board;</span><br><span class="line"></span><br><span class="line">    bool isValid(int row, int col, int n) &#123;</span><br><span class="line"></span><br><span class="line">        // 检查同列</span><br><span class="line">        for (int i = 0; i &lt; row; i++) &#123;</span><br><span class="line">            if (chess_board[i][col] == &#x27;Q&#x27;) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        // 由于由上向下，故向上检查斜角即可</span><br><span class="line">        // 检查左上方的，45度</span><br><span class="line">        for (int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) &#123;</span><br><span class="line">            if (chess_board[i][j] == &#x27;Q&#x27;) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 检查右上方，135度</span><br><span class="line">        for (int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">            if (chess_board[i][j] == &#x27;Q&#x27;) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void backTrack(int n, int row) &#123;</span><br><span class="line">        if (row == n) &#123;</span><br><span class="line">            result.push_back(chess_board);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int col = 0; col &lt; n; col++) &#123;</span><br><span class="line">            if (isValid(row, col, n)) &#123;</span><br><span class="line">                chess_board[row][col] = &#x27;Q&#x27;;</span><br><span class="line">                backTrack(n, row+1);</span><br><span class="line">                chess_board[row][col] = &#x27;.&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;</span><br><span class="line">        result.clear();</span><br><span class="line">        chess_board.clear();</span><br><span class="line">        chess_board = vector&lt;string&gt;(n, string(n, &#x27;.&#x27;));</span><br><span class="line">        backTrack(n, 0);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><h2 id="解数独"><a href="#解数独" class="headerlink" title="解数独"></a>解数独</h2></li><li><a href="https://programmercarl.com/0037.%E8%A7%A3%E6%95%B0%E7%8B%AC.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></li><li><a href="https://leetcode.cn/problems/sudoku-solver/submissions/579312550/">37. 解数独 - 力扣（LeetCode）</a></li><li>题意，给出一个二维数组，其中待填部分为 .，要求填入合适数字完成数独</li><li>方法，和[[八皇后]]类似的棋盘问题，也是需要二重回溯，区别就是在判断终止条件，由于该题需要遍历一整棵树找一个合理方案，故让回溯方法返回布尔值，以去除不必要的遍历。</li><li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    bool isValid(int row, int col, char k, vector&lt;vector&lt;char&gt;&gt; &amp;board, int size) &#123;</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123; // 同列是否有相同值</span><br><span class="line">            if (board[i][col] == k) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int j = 0; j &lt; size; j++) &#123; // 同行是否有相同值</span><br><span class="line">            if (board[row][j] == k) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int start_row = row/3*3; // 同九方格起始坐标</span><br><span class="line">        int start_col = col/3*3;</span><br><span class="line">        for (int i = start_row; i &lt; start_row + 3; i++) &#123;</span><br><span class="line">            for (int j = start_col; j &lt; start_col + 3; j++)</span><br><span class="line">            if (board[i][j] == k) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool backTrack(vector&lt;vector&lt;char&gt;&gt; &amp;board, int size) &#123;</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; size; j++) &#123;</span><br><span class="line">                if (board[i][j] != &#x27;.&#x27;) continue;</span><br><span class="line">                for (char k = &#x27;1&#x27;; k &lt;= &#x27;9&#x27;; k++) &#123;</span><br><span class="line">                    if (isValid(i, j, k, board, size)) &#123;</span><br><span class="line">                        board[i][j] = k;</span><br><span class="line">                        if (backTrack(board, size)) return true;</span><br><span class="line">                        board[i][j] = &#x27;.&#x27;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                return false; // 如果有一个可填处 9 个值都填不了，那么这个方案不可行</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true; // 如果全填完了，说明必定出现答案了</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;</span><br><span class="line">        backTrack(board, board.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法周记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Weekly Algorithm】算法周记之《代码随想录》二叉树（四）与回溯（一）</title>
      <link href="/posts/20b866e1.html"/>
      <url>/posts/20b866e1.html</url>
      
        <content type="html"><![CDATA[<h1 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h1><p>本周跟随《代码随想录》学习二叉树和二叉搜索树的相关题目，还在递归中主要学习了关于组合的一部分题目。</p><p>回溯，用代码随想录中的一句话概括：- for 循环横向遍历，递归纵向遍历，回溯调整结果集。</p><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><ul><li><h2 id="二叉搜索树的最小绝对差"><a href="#二叉搜索树的最小绝对差" class="headerlink" title="二叉搜索树的最小绝对差"></a>二叉搜索树的最小绝对差</h2></li><li><a href="https://programmercarl.com/0530.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></li><li><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/description/">530. 二叉搜索树的最小绝对差 - 力扣（LeetCode）</a></li><li>题意，找二叉搜索树中任意两个节点两值之差的最小值</li><li>方法，由于二叉搜索树的本质是有序数组，按中序遍历比较相邻节点之差</li><li>陆爻齐的解法 与代码随想录思路相近<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode *pre = nullptr;</span><br><span class="line">    int getMinimumDifference(TreeNode* root) &#123;</span><br><span class="line">        int result = INT32_MAX;</span><br><span class="line">        travel_cal(result, root);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void travel_cal(int &amp;result, TreeNode *root) &#123;</span><br><span class="line">        if (root == nullptr) return;</span><br><span class="line"></span><br><span class="line">        // 下面是中序</span><br><span class="line">        travel_cal(result, root-&gt;left);</span><br><span class="line">        if (pre != nullptr &amp;&amp; (root-&gt;val - pre-&gt;val) &lt; result) &#123;</span><br><span class="line">            result = (root-&gt;val - pre-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line">        travel_cal(result, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h2 id="二叉搜索树的众数"><a href="#二叉搜索树的众数" class="headerlink" title="二叉搜索树的众数"></a>二叉搜索树的众数</h2></li><li><a href="https://programmercarl.com/0501.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0.html#%E6%80%9D%E8%B7%AF">代码随想录</a></li><li><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">501. 二叉搜索树中的众数 - 力扣（LeetCode）</a></li><li>题意就是找二叉搜索树的众数，但可能有多个众数</li><li>方法，寻常方法便是遍历，hash 记录频次，转为 vector 排序取众数，时间复杂度 O(n^2)；但由于是二叉搜索树，可以用 O(n) 的方法，即中序遍历时就直接记录频次和当前最高频次的数字，更新频次时清空已记录的数字</li><li>陆爻齐参考代码随想录的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // 准备</span><br><span class="line">    vector&lt;int&gt; result;</span><br><span class="line">    int max_count = INT32_MIN;</span><br><span class="line">    int count = 1;</span><br><span class="line">    TreeNode *pre = nullptr;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; findMode(TreeNode* root) &#123;</span><br><span class="line">        travel_val(root);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void travel_val(TreeNode *root) &#123;</span><br><span class="line">        if (root == nullptr) return;</span><br><span class="line"></span><br><span class="line">        // 总体依旧按中序遍历</span><br><span class="line">        travel_val(root-&gt;left);</span><br><span class="line">        if (pre != nullptr) &#123; // 更新频次计数</span><br><span class="line">            if (pre-&gt;val == root-&gt;val) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                count = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root; // 更新上一个点</span><br><span class="line">        if (count == max_count) &#123;</span><br><span class="line">            result.push_back(root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (count &gt; max_count) &#123;</span><br><span class="line">            max_count = count;</span><br><span class="line">            result.clear();</span><br><span class="line">            result.push_back(root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        travel_val(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h2 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h2></li><li><a href="https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html#%E6%80%9D%E8%B7%AF">代码随想录</a></li><li><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/">236. 二叉树的最近公共祖先 - 力扣（LeetCode）</a></li><li>题意，二叉树中无 val 相同点，给两个 val 不同点，找到它们的公共祖先</li><li>方法，要找公共祖先，最好能自底向上遍历，最类似的遍历是后序遍历，让找到的两个 val 和公共祖先返回上去</li><li>陆爻齐参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        // 终止条件，使得上面的点可知道是否子树有 p q</span><br><span class="line">        if (root == nullptr || root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val) return root;</span><br><span class="line">        </span><br><span class="line">        // 遍历左右子树</span><br><span class="line">        TreeNode *left = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">        TreeNode *right = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line"></span><br><span class="line">        // 若有 q 或 p，则返回</span><br><span class="line">        if (left == nullptr || right == nullptr) &#123;</span><br><span class="line">            if (left != nullptr) return left;</span><br><span class="line">            else return right;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123; // 若 q p都有了，那就返回公共祖先</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h2 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h2></li><li><a href="https://programmercarl.com/0235.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html#%E6%80%9D%E8%B7%AF">代码随想录</a></li><li><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先 - 力扣（LeetCode）</a></li><li>题意，与[[二叉树的最近公共祖先]]类似，不过环岛路二叉搜索树上</li><li>方法，[[二叉树的最近公共祖先]]的解法也能用，不过二叉搜索树的有序特性能使得代码更简单。由于二叉搜索树中的节点值大于左子树所有节点并小于右子树所有节点，所以两节点的公共祖先的左子树有较小点而右子树有较大点。而从上往下，第一个值在 q 和 p之间的节点就是最近的祖先节点，暂时不知如何证明，姑且作为特性</li><li>陆爻齐参照代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        if (p-&gt;val &lt; q-&gt;val) swap(p, q); // 确保 p 总是更大的那个</span><br><span class="line">        return findAncestor(root, p, q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode *findAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        // 终止条件，防止空，虽然本题无太大必要</span><br><span class="line">        if (root == nullptr) return root;</span><br><span class="line"></span><br><span class="line">        if (root-&gt;val &lt; q-&gt;val) &#123;</span><br><span class="line">            return findAncestor(root-&gt;right, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(root-&gt;val &gt; p-&gt;val) &#123;</span><br><span class="line">            return findAncestor(root-&gt;left, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h2 id="二叉搜索树中的插入操作"><a href="#二叉搜索树中的插入操作" class="headerlink" title="二叉搜索树中的插入操作"></a>二叉搜索树中的插入操作</h2></li><li><a href="https://programmercarl.com/0701.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC">代码随想录</a></li><li><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/description/">701. 二叉搜索树中的插入操作 - 力扣（LeetCode）</a></li><li>题意，在二叉搜索树中插入点，并返回插入后的树</li><li>方法，在[[二叉搜索树的搜索]]后的结束处插入即可，这是最简单朴实直观的办法，无需重构二叉搜索树</li><li>陆爻齐参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* insertIntoBST(TreeNode* root, int val) &#123;</span><br><span class="line">        // 终止条件，找到插入地方</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            TreeNode *result = new TreeNode(val);</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 不会有相同值点的插入寻找</span><br><span class="line">        if (val &gt; root-&gt;val) &#123;</span><br><span class="line">            root-&gt;right = insertIntoBST(root-&gt;right, val);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            root-&gt;left = insertIntoBST(root-&gt;left, val);</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h2 id="删除二叉搜索树中的节点"><a href="#删除二叉搜索树中的节点" class="headerlink" title="删除二叉搜索树中的节点"></a>删除二叉搜索树中的节点</h2></li><li><a href="https://programmercarl.com/0450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></li><li><a href="https://leetcode.cn/problems/delete-node-in-a-bst/description/">450. 删除二叉搜索树中的节点 - 力扣（LeetCode）</a></li><li>题意，如题要删点后的树</li><li>方法，删点有五种情况，1. 没找到，2. 点无子树，3.点只有左子树，4.点只有右子树，5.点左右子树都有。重点是第五种情况，需要把左子树放到右子树的最左节点的左子树，然后用右子树代替</li><li>陆爻齐参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* deleteNode(TreeNode* root, int key) &#123;</span><br><span class="line">        if (root == nullptr) return nullptr;</span><br><span class="line">        </span><br><span class="line">        if (root-&gt;val != key) &#123; // 没找到</span><br><span class="line">            root-&gt;left = deleteNode(root-&gt;left, key);</span><br><span class="line">            root-&gt;right = deleteNode(root-&gt;right, key);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr) &#123; // 都为空，直接返空</span><br><span class="line">            delete root;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(root-&gt;left != nullptr &amp;&amp; root-&gt;right == nullptr) &#123; // 只有左</span><br><span class="line">            TreeNode *result = root-&gt;left;</span><br><span class="line">            delete root;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(root-&gt;left == nullptr &amp;&amp; root-&gt;right != nullptr) &#123; // 只有右</span><br><span class="line">            TreeNode *result = root-&gt;right;</span><br><span class="line">            delete root;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123; // 左右都有，把左放右的最左，返右</span><br><span class="line">            TreeNode *cur = root-&gt;right;</span><br><span class="line">            while(cur-&gt;left != nullptr) cur = cur-&gt;left;</span><br><span class="line">            cur-&gt;left = root-&gt;left;</span><br><span class="line">            cur = root-&gt;right;</span><br><span class="line">            delete root;</span><br><span class="line">            return cur;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h2 id="修剪二叉搜索树"><a href="#修剪二叉搜索树" class="headerlink" title="修剪二叉搜索树"></a>修剪二叉搜索树</h2></li><li><a href="https://programmercarl.com/0669.%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html">代码随想录</a></li><li><a href="https://leetcode.cn/problems/trim-a-binary-search-tree/submissions/577278029/">669. 修剪二叉搜索树 - 力扣（LeetCode）</a></li><li>题意，给出一个数值范围，要求二叉搜索树内的节点都得在这个范围内</li><li>方法，直观一点可以转为数组重建二叉搜索树，略复杂；其实可以利用二叉搜索树性质，递归返回符合条件的节点来构建二叉搜索树</li><li>陆爻齐参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* trimBST(TreeNode* root, int low, int high) &#123;</span><br><span class="line">        if (root == nullptr) return nullptr; // 一个终止条件</span><br><span class="line"></span><br><span class="line">        // 由于二叉搜索树有序，当前根过小或过大就可以直接向另一方向搜索</span><br><span class="line">        if (root-&gt;val &lt; low) &#123;</span><br><span class="line">            return trimBST(root-&gt;right, low, high);</span><br><span class="line">        &#125; </span><br><span class="line">        else if (root-&gt;val &gt; high) &#123;</span><br><span class="line">            return trimBST(root-&gt;left, low, high);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 即使根符合要求，不保证子树所有节点也符合</span><br><span class="line">        root-&gt;left = trimBST(root-&gt;left, low, high);</span><br><span class="line">        root-&gt;right = trimBST(root-&gt;right, low, high);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h2 id="将有序数组转换为二叉搜索树"><a href="#将有序数组转换为二叉搜索树" class="headerlink" title="将有序数组转换为二叉搜索树"></a>将有序数组转换为二叉搜索树</h2></li><li><a href="https://programmercarl.com/0108.%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html#%E6%80%9D%E8%B7%AF">代码随想录</a></li><li><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树 - 力扣（LeetCode）</a></li><li>题意：将有序的升序数组转化为平衡二叉搜索树</li><li>方法，平衡，要求点得从中间取，由于升序，故不断取中点递归即可</li><li>陆爻齐参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        return buildTree(nums, 0, nums.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode *buildTree(vector&lt;int&gt;&amp; nums, int left, int right) &#123;</span><br><span class="line">        // 终止条件区间长度为0</span><br><span class="line">        if (left == right) &#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 中间，也就是当前的节点</span><br><span class="line">        int middle = (left + right) / 2;</span><br><span class="line">        TreeNode *cur = new TreeNode(nums[middle]);</span><br><span class="line">        cur-&gt;left = buildTree(nums, left, middle);</span><br><span class="line">        cur-&gt;right = buildTree(nums, middle + 1, right);</span><br><span class="line">        return cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h2 id="把二叉搜索树转换为累加树"><a href="#把二叉搜索树转换为累加树" class="headerlink" title="把二叉搜索树转换为累加树"></a>把二叉搜索树转换为累加树</h2></li><li><a href="https://programmercarl.com/0108.%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></li><li><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树 - 力扣（LeetCode）</a></li><li>题意，在二叉搜索树上，从右向左，从下向上，把点的值累加上去</li><li>方法，经观察，点加值的情况符合“右中左”的遍历顺序，故用一个变量记录遍历过的点的累加值，并按右中左来遍历</li><li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int pre = 0;</span><br><span class="line">    TreeNode* convertBST(TreeNode* root) &#123;</span><br><span class="line">        if (root == nullptr) return nullptr;</span><br><span class="line">        root-&gt;right = convertBST(root-&gt;right);</span><br><span class="line">        pre += root-&gt;val;</span><br><span class="line">        root-&gt;val = pre;</span><br><span class="line">        root-&gt;left = convertBST(root-&gt;left);</span><br><span class="line"></span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><ul><li><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2></li><li><a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html#%E6%80%9D%E8%B7%AF">代码随想录</a></li><li><a href="https://leetcode.cn/problems/combinations/description/">77. 组合 - 力扣（LeetCode）</a></li><li>题意，在 1-n 个数中，取 k 个数的所有组合</li><li>方法，采用普通的回溯方法，注意优化方法，由于限制要 k 个，所以如果一层的 for 循环最多只要遍历到 n-(k-层数)+1 即可，加一是因为自己要求了左闭区间</li><li>陆爻齐参考代码随想录思路的剪枝代码<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">    vector&lt;int&gt; path;</span><br><span class="line">    void backtrack(int n, int k, int start_index) &#123;</span><br><span class="line">        // 终止条件保存结果</span><br><span class="line">        if (k == path.size()) &#123;</span><br><span class="line">            result.push_back(path);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 寻找组合</span><br><span class="line">        for (int i = start_index; i &lt;= (n - (k - path.size()) + 1); i++) &#123;</span><br><span class="line">            path.push_back(i);</span><br><span class="line">            backtrack(n, k, i+1);</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;</span><br><span class="line">        // 两个clear是为了保险</span><br><span class="line">        result.clear();</span><br><span class="line">        path.clear();</span><br><span class="line">        backtrack(n, k , 1);</span><br><span class="line">        return result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h2 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和 |||"></a>组合总和 |||</h2></li><li><a href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html#%E6%80%9D%E8%B7%AF">代码随想录</a></li><li><a href="https://leetcode.cn/problems/combination-sum-iii/description/">216. 组合总和 III - 力扣（LeetCode）</a></li><li>该题要求，收集所有从1-9中选取 k 个不重复的数字组成和为 n 的组合</li><li>方法，就是在[[组合]]上简单改造终止条件为和为n，剪枝可从和入手，过大就剪</li><li>陆爻齐的剪枝思路，和代码随想录思路差不多<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">    vector&lt;int&gt; path;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    void backTrack(int k, int n, int start_index) &#123;</span><br><span class="line">        if(sum &gt; n) &#123; // 剪枝</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (path.size() == k) &#123; // 终止条件</span><br><span class="line">            if(sum == n) result.push_back(path);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 单层处理</span><br><span class="line">        for (int i = start_index; i &lt; 10; i++) &#123;</span><br><span class="line">            path.push_back(i);</span><br><span class="line">            sum += i;</span><br><span class="line">            backTrack(k, n, i+1);</span><br><span class="line">            path.pop_back();</span><br><span class="line">            sum -= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123;</span><br><span class="line">        result.clear();</span><br><span class="line">        path.clear();</span><br><span class="line">        backTrack(k, n, 1);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h2 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h2></li><li><a href="https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></li><li><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/">17. 电话号码的字母组合 - 力扣（LeetCode）</a></li><li>题意，电话号码中的2-9各对应几个字母，要求根据一串2-9的数字来排列出所有字母组合</li><li>方法，在[[组合]]的基础上，该题有多个字母区间，可先用数组存下下标数字与字符串的对应，再做单层遍历</li><li>陆爻齐参照代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    string path;</span><br><span class="line">    vector&lt;string&gt; str_map = &#123;</span><br><span class="line">        &quot;&quot;,</span><br><span class="line">        &quot;&quot;,</span><br><span class="line">        &quot;abc&quot;,</span><br><span class="line">        &quot;def&quot;,</span><br><span class="line">        &quot;ghi&quot;,</span><br><span class="line">        &quot;jkl&quot;,</span><br><span class="line">        &quot;mno&quot;,</span><br><span class="line">        &quot;pqrs&quot;,</span><br><span class="line">        &quot;tuv&quot;,</span><br><span class="line">        &quot;wxyz&quot;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    void back_track(const string &amp;digits, int start_index) &#123;</span><br><span class="line">        if (start_index == digits.size()) &#123;</span><br><span class="line">            result.push_back(path);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string range = str_map[int(digits[start_index] - &#x27;0&#x27;)];</span><br><span class="line">        for (auto c : range) &#123;</span><br><span class="line">            path += c;</span><br><span class="line">            back_track(digits, start_index+1);</span><br><span class="line">            path = path.substr(0, path.size()-1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; letterCombinations(string digits) &#123;</span><br><span class="line">        result.clear();</span><br><span class="line">        path.clear();</span><br><span class="line">        if (digits.size() == 0) return result;</span><br><span class="line">        back_track(digits, 0);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h2 id="组合总和-1"><a href="#组合总和-1" class="headerlink" title="组合总和"></a>组合总和</h2></li><li><a href="https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html#%E6%80%9D%E8%B7%AF">代码随想录</a></li><li><a href="https://leetcode.cn/problems/combination-sum/description/">39. 组合总和 - 力扣（LeetCode）</a></li><li>题意，从无重复元素且数字大于零的整形数组中可重复选取元素，选出所有和为 target 的组合</li><li>方法，由于可重复选取，故在递归下一层时，不用令选值区间左侧+1来避免重复，且可通过排序然后剪去和大于目标的部分剪枝</li><li>陆爻齐参考代码随想录思路的方法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">    vector&lt;int&gt; path;</span><br><span class="line"></span><br><span class="line">    void back_track(vector&lt;int&gt; &amp;candidates, int target, int sum, int start_index) &#123;</span><br><span class="line">        // 终止条件</span><br><span class="line">        if (sum &gt; target) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (sum == target) result.push_back(path);</span><br><span class="line">        // 排序后，可根据和大于目标来剪枝</span><br><span class="line">        for (int i = start_index; i &lt; candidates.size() &amp;&amp; sum + candidates[i] &lt;= target; i++) &#123;</span><br><span class="line">            path.push_back(candidates[i]);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            back_track(candidates, target, sum, i);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;</span><br><span class="line">        result.clear();</span><br><span class="line">        path.clear();</span><br><span class="line">        sort(candidates.begin(), candidates.end()); // 便于剪枝的排序</span><br><span class="line">        back_track(candidates, target, 0, 0);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法周记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【软考】下午题13-试题1-4，6-中级软件设计师备考笔记</title>
      <link href="/posts/81063a50.html"/>
      <url>/posts/81063a50.html</url>
      
        <content type="html"><![CDATA[<h1 id="试题一-数据流图"><a href="#试题一-数据流图" class="headerlink" title="试题一 数据流图"></a>试题一 数据流图</h1><ul><li><h1 id="数据流图"><a href="#数据流图" class="headerlink" title="数据流图"></a>数据流图</h1></li><li>英文名 DFD</li><li><img src="/../assets/image_1726317543197_0.png" alt="image.png"></li><li>本质上就是描述数据流动的图</li><li><img src="/../assets/image_1726317598402_0.png" alt="image.png">{:height 283, :width 512}</li><li><img src="/../assets/image_1726319661979_0.png" alt="image.png"></li><li><img src="/../assets/image_1726319849105_0.png" alt="image.png"></li><li><img src="/../assets/image_1726319899917_0.png" alt="image.png"></li><li><h2 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h2></li><li>问图中的实体是什么 E1……</li><li>方法：对着子图和说明找</li><li></li><li><h2 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h2></li><li>问图中的数据是什么 D1……</li><li>方法：对着子图和说明找</li><li>如果是问数据存储，在没有找到对应名字时，可以自拟符合名称</li><li></li><li><h2 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h2></li><li>补充数据流，看分值，可能一分一条或两分一条</li><li>方法：</li><li>父图子图平衡<br>logseq.order-list-type:: number<br>对比父图和子图的数据流  </li><li>加工既有输入数据流也有输出数据流<br>logseq.order-list-type:: number</li><li>根据说明检查子图<br>logseq.order-list-type:: number</li><li></li><li><h2 id="问题四"><a href="#问题四" class="headerlink" title="问题四"></a>问题四</h2></li><li>拓展题，随缘得分</li><li>有问父图与子图的平衡，也就是数据流的属性、名字相同，数量相同，若父图有一条对应子图多条数据流，则也算平衡</li></ul><h1 id="试题二-数据库设计"><a href="#试题二-数据库设计" class="headerlink" title="试题二 数据库设计"></a>试题二 数据库设计</h1><ul><li><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2></li><li>父实体与子实体<br><img src="/../assets/image_1730987529472_0.png" alt="image.png">  </li><li>属性简单了解，比较少考<br><img src="/../assets/image_1730987683365_0.png" alt="image.png">{:height 338, :width 518}  </li><li>联系<br><img src="/../assets/image_1730987739200_0.png" alt="image.png"><br>分别是1对1，1对多，多对多<br><img src="/../assets/image_1730987957895_0.png" alt="image.png"><br>多对多对多 1对多对多  </li><li>关系模式<br><img src="/../assets/image_1730988571111_0.png" alt="image.png">  </li><li><img src="/../assets/image_1730988793699_0.png" alt="image.png"><br><img src="/../assets/image_1730988849479_0.png" alt="image.png"><br><img src="/../assets/image_1730988938800_0.png" alt="image.png"><br><img src="/../assets/image_1730989018407_0.png" alt="image.png">  </li><li></li><li><h2 id="问题一-1"><a href="#问题一-1" class="headerlink" title="问题一"></a>问题一</h2></li><li>补充 ER 图中缺失的联系，注意联系类型与自行补充名字</li><li><h2 id="问题二-1"><a href="#问题二-1" class="headerlink" title="问题二"></a>问题二</h2></li><li>补全关系模式，注意，一个空可能有多个要填的属性</li><li></li><li><h2 id="问题三-1"><a href="#问题三-1" class="headerlink" title="问题三"></a>问题三</h2></li><li>拓展问题</li><li>问一个实体是否为弱实体，弱实体的存在需要以某个实体的存在为前提，即依附于某个实体</li></ul><h1 id="试题三-UML图"><a href="#试题三-UML图" class="headerlink" title="试题三 UML图"></a>试题三 UML图</h1><ul><li><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2></li><li>依赖，关联（聚合组合）、泛化</li><li><h2 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h2></li><li>包含，拓展、泛化</li><li><img src="/../assets/image_1731073922738_0.png" alt="image.png"></li><li><h2 id="问题类型"><a href="#问题类型" class="headerlink" title="问题类型"></a>问题类型</h2></li><li>近年都只考类图和用例图，故下面也是对应题目</li><li>一个是补充类图类名</li><li>一个是补充用例图的用例和用例之间的关系</li><li>剩下一题是拓展题</li></ul><h1 id="试题四-算法"><a href="#试题四-算法" class="headerlink" title="试题四 算法"></a>试题四 算法</h1><ul><li>C语言+算法</li><li>第一题代码填空（8-10分）</li><li>第二题时间空间复杂度&#x2F;算法策略</li><li>第三题拓展题（如得出参数解）</li></ul><h1 id="试题六-C-面向对象"><a href="#试题六-C-面向对象" class="headerlink" title="试题六 C++ 面向对象"></a>试题六 C++ 面向对象</h1><ul><li>和试题五一样，只是五是C++，六是JAVA，大家都只讲JAVA</li><li>就是没啥好讲的，JAVA的基本语法+设计模式，不过懒得学，就写c++吧</li><li>纯代码填空，比设计模式简单多了</li></ul>]]></content>
      
      
      <categories>
          
          <category> 备战软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【软考】上午题12-数据结构与算法&amp;操作系统-中级软件设计师备考笔记</title>
      <link href="/posts/3598ae64.html"/>
      <url>/posts/3598ae64.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><ul><li>由于时间不太充足，最后这部分就不看视频了，有什么不在原本知识库内的点就直接记录就好</li><li><h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2></li><li>只有度为 0 和度为 2 的节点</li><li>度 2 的点比度 0 的点少一个</li><li></li><li><h2 id="森林转二叉树"><a href="#森林转二叉树" class="headerlink" title="森林转二叉树"></a>森林转二叉树</h2></li><li>首先，每个树分别转为二叉树，每层兄弟连，父节点只连第一个大儿子节点；然后第二课树做第一个树右节点，第三树做第二树右子树，以此类推</li><li><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2></li><li><img src="/../assets/image_1731161768872_0.png" alt="image.png"></li><li><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2></li><li>装填因子越小，冲突可能性越小</li></ul><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><ul><li>与 [[软考_数据结构与算法]] 类似，都是补充，没时间全学</li><li><h2 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h2></li><li><h3 id="移臂调度"><a href="#移臂调度" class="headerlink" title="移臂调度"></a>移臂调度</h3></li><li>先来先服务，就是先序位序考前的位置，随时改方向</li><li>最短寻道时间优先，优先找最近的，随时改方向</li><li>电梯调度，先向一边方向扫完在向另一边扫</li><li>单向扫描，电梯，但向一边扫完只会从另一边重新同方向再扫</li></ul>]]></content>
      
      
      <categories>
          
          <category> 备战软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【软考】上午题11-计算机网络-中级软件设计师备考笔记</title>
      <link href="/posts/abf352b0.html"/>
      <url>/posts/abf352b0.html</url>
      
        <content type="html"><![CDATA[<ul><li><h2 id="网络设备"><a href="#网络设备" class="headerlink" title="网络设备"></a>网络设备</h2></li><li><h3 id="物理层互连设备"><a href="#物理层互连设备" class="headerlink" title="物理层互连设备"></a>物理层互连设备</h3></li><li><p>中继器、集线器（一种特殊多路中继器，可检测发送冲突）</p></li><li><h3 id="数据链路层互连设备"><a href="#数据链路层互连设备" class="headerlink" title="数据链路层互连设备"></a>数据链路层互连设备</h3></li><li><p>网桥、交换机（多端口网桥）</p></li><li><h3 id="网络层互连设备"><a href="#网络层互连设备" class="headerlink" title="网络层互连设备"></a>网络层互连设备</h3></li><li><p>路由器</p></li><li><h3 id="应用层互连设备"><a href="#应用层互连设备" class="headerlink" title="应用层互连设备"></a>应用层互连设备</h3></li><li><p>网关</p></li><li><h3 id="广播域和冲突域"><a href="#广播域和冲突域" class="headerlink" title="广播域和冲突域"></a>广播域和冲突域</h3></li><li><p>在对应层能否划分<br><img src="/../assets/image_1730816308385_0.png" alt="image.png">  </p></li><li><h2 id="协议簇"><a href="#协议簇" class="headerlink" title="协议簇"></a>协议簇</h2></li><li><p><img src="/../assets/image_1730816798084_0.png" alt="image.png"><br>ICMP属于网络层协议，用 IP 传送报文（差错报文）  </p></li><li><p><img src="/../assets/image_1730816852449_0.png" alt="image.png">{:height 236, :width 412}</p><ol><li>所有带T的除了TFTP其他都是TCP，所有不带T的除了POP3其他都是UDP​</li><li>默认情况，FTP 服务器控制端口21，上传文件端口20</li><li>TCP 和 UDP 都是建立在 IP 协议上的</li><li>SNMP 是应用层协议，基于 UDP</li><li>Telnet 是不太安全的远程登录协议（应用层），基于 TCP</li><li>ICMP IP ARP RARP 都是网络层的</li></ol></li><li><h2 id="网络层协议-IP"><a href="#网络层协议-IP" class="headerlink" title="网络层协议 IP"></a>网络层协议 IP</h2></li><li><p>提供服务通常是 无连接 和 不可靠 的</p></li><li><p>无连接：没确定目标系统做好接收数据准备就发送数据<br>与此相对就是面向连接的传输  </p></li><li><p>不可靠，目的系统不对成功接收分组确认</p></li><li><p>差错检测、流量控制、拥塞控制授权给其它各类协议</p></li><li><h3 id="传输层协议-TCP"><a href="#传输层协议-TCP" class="headerlink" title="传输层协议 TCP"></a>传输层协议 TCP</h3></li><li><p>可靠的、面向连接的、全双工的数据传输服务</p></li><li><p>其序号单位是字节，传递的信息单位是报文</p></li><li><p>功能：可靠传输、差错检验和重传、流量控制、拥塞控制、端口寻址</p></li><li><p>建立连接的三次握手协议</p></li><li><p>流量控制用可变大小的滑动窗口协议</p></li><li><h3 id="传输层协议-UDP"><a href="#传输层协议-UDP" class="headerlink" title="传输层协议 UDP"></a>传输层协议 UDP</h3></li><li><p>不可靠、无连接的协议，提高传输的高速率性，也提供端口寻址的功能</p></li><li><h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h2></li><li><p>本地回送地址 127.0.0.1</p></li><li><h2 id="电子邮件服务"><a href="#电子邮件服务" class="headerlink" title="电子邮件服务"></a>电子邮件服务</h2></li><li><p>基于客户端&#x2F;服务器模式（C&#x2F;S模式）</p></li><li><h3 id="SMTP-端口号：25-简单邮件传输协议"><a href="#SMTP-端口号：25-简单邮件传输协议" class="headerlink" title="SMTP 端口号：25 简单邮件传输协议"></a>SMTP 端口号：25 简单邮件传输协议</h3></li><li><p>只能传输 ASCII 文本 和 文字附件，后来由 MIME（邮件拓展协议）才能传 非 ASCII 的附件</p></li><li><p>主要发信，收信比较困难</p></li><li><h3 id="POP3-端口号：110-一种简单传文本协议"><a href="#POP3-端口号：110-一种简单传文本协议" class="headerlink" title="POP3 端口号：110 一种简单传文本协议"></a>POP3 端口号：110 一种简单传文本协议</h3></li><li><p>以整个 Email 为单位，不能部分传输，可以和SMTP一起使用，也可单独使用来传输和接收电子邮件</p></li><li><h3 id="PS-1"><a href="#PS-1" class="headerlink" title="PS"></a>PS</h3></li><li><p>上面两协议都用 TCP 端口</p></li><li><h2 id="ARP-地址解析协议"><a href="#ARP-地址解析协议" class="headerlink" title="ARP 地址解析协议"></a>ARP 地址解析协议</h2></li><li><p>IP 地址转为 物理地址（MAC）</p></li><li><p>有一个 ARP 高速缓存，计算机与其它计算机通信时，会先在缓存中查询，查到了就直接把信息发到对应的物理网卡，没找到就找到好把 IP 和 MAC 对应放缓存里</p></li><li><p>广播发送请求，单播发送响应</p></li><li><h2 id="RARP-反地址解析协议"><a href="#RARP-反地址解析协议" class="headerlink" title="RARP 反地址解析协议"></a>RARP 反地址解析协议</h2></li><li><p>物理地址 转为 IP 地址（MAC）</p></li><li><h2 id="DHCP-动态主机配置协议"><a href="#DHCP-动态主机配置协议" class="headerlink" title="DHCP 动态主机配置协议"></a>DHCP 动态主机配置协议</h2></li><li><p>集中管理、分配 IP 地址，让主机动态获得 IP地址、DNS服务器地址、DHCP服务器地址、默认网关地址等</p></li><li><p>Windows 无效地址：169.254.X.X   Linux无效地址：0.0.0.0</p></li><li><h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2></li><li><p>注意，地理模式是<strong>顶级域</strong><br>域名后缀也是域名的一部分<br>abc.com 不一定会到 <a href="http://www.abc.com,看配置/">www.abc.com，看配置</a><br><img src="/../assets/image_1730898142590_0.png" alt="image.png">  </p></li><li><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2></li><li><p>（在浏览器输入一个正确网址，会先查DNS域名）DNS域名查询次序：本地 hosts 文件-&gt;本地DNS缓存-&gt;本地DNS服务器-&gt;根域名服务器</p></li><li><p>主域名服务器接收请求，查询顺序是本地缓存、本地hosts文件、本地服务器、转发域名服务器</p></li><li><p>注意，HTTP请求时，先断开 TCP 连接，再渲染浏览器界面</p></li><li><h2 id="IP地址和子网掩码-（16年起没考过）"><a href="#IP地址和子网掩码-（16年起没考过）" class="headerlink" title="IP地址和子网掩码 （16年起没考过）"></a>IP地址和子网掩码 （16年起没考过）</h2></li><li><p>IP地址分类，全 0 代表网络，全 1 代表广播<br><img src="/../assets/image_1730900030024_0.png" alt="image.png"><br><img src="/../assets/image_1730900415626_0.png" alt="image.png">  </p></li><li><p><img src="/../assets/image_1730901566536_0.png" alt="image.png"><br>每在多一个1，就多一个次方的子网，多的主机地址得减去全0和全1，故此题选 D（前26位网络地址，划分64个子网，多了6个1，2^6，64-2&#x3D;62）  </p></li><li><h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2></li><li><p>有128位地址空间，彻底解决 IPv4 地址不足的问题（IPv4是32位）</p></li><li><h2 id="无线网络"><a href="#无线网络" class="headerlink" title="无线网络"></a>无线网络</h2></li><li><p>蓝牙的覆盖范围最小，通信距离最短</p></li><li><h2 id="Windows命令"><a href="#Windows命令" class="headerlink" title="Windows命令"></a>Windows命令</h2></li><li><p><img src="/../assets/image_1730904314213_0.png" alt="image.png"><br>ipconfig&#x2F;release: DHCP客户手工释放 IP 地址<br>ipconfig&#x2F;renew:DHCP客户端手工向服务器刷新请求（重新申请IP地址）  </p></li><li><p>ping 由近及远 127.0.0.1、本地主机、本地网关、远程主机</p></li><li><p>netstat 显示网络连接</p></li><li><p>tracert 路由跟踪实用程序，确定一个主机到网络其它主机的路由</p></li><li><p>nslookup 查询域名信息或诊断DNS服务器问题的工具</p></li><li><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2></li><li><p>服务器收到一个IP数据包，先找主机路由，再找网络路由（直连网络和远程网络），这些查找失败再找默认路由</p></li><li><p>主机路由子网掩码 255.255.255.255，默认路由目标网络和子网掩码都是 0.0.0.0</p></li><li><p>若有多条路由，应采用管理距离小的路由来源提供的路由信息</p></li><li><p>路由协议让数据包在主机间传送路由信息</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 备战软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【软考】上午题10-信息安全-中级软件设计师备考笔记</title>
      <link href="/posts/67ebce46.html"/>
      <url>/posts/67ebce46.html</url>
      
        <content type="html"><![CDATA[<ul><li><h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2></li><li><p>内部网络是安全的、可信赖的，外部网络是不安全、不可信赖的</p></li><li><p>安全处理：控制、审计、报警和反应等</p></li><li><p>发展阶段：</p></li><li><p>包过滤防火墙，在网络层和数据链路层之间，检查网络层包的源地址、目的地址、协议和端口等<br>logseq.order-list-type:: number</p><p>对应用、用户完全透明，速度较快，实行低水平控制  </p><p>缺点，不能防范黑客攻击、不能处理新的安全威胁  </p></li><li><p>应用代理网关防火墙，彻底隔绝直接通信，必须经应用层代理软件转发<br>logseq.order-list-type:: number</p><p>缺点，难以配置，处理速度非常慢  </p></li><li><h2 id="网络攻击"><a href="#网络攻击" class="headerlink" title="网络攻击"></a>网络攻击</h2></li><li><h3 id="拒绝服务攻击（Dos攻击）"><a href="#拒绝服务攻击（Dos攻击）" class="headerlink" title="拒绝服务攻击（Dos攻击）"></a>拒绝服务攻击（Dos攻击）</h3></li><li><p>不断向计算机发起请求来实现，使计算机或网络无法提供正常服务</p></li><li><h3 id="重放攻击"><a href="#重放攻击" class="headerlink" title="重放攻击"></a>重放攻击</h3></li><li><p>盗取认证凭据，重新发送认证服务器，破坏认证正确性</p></li><li><h3 id="Sql注入攻击"><a href="#Sql注入攻击" class="headerlink" title="Sql注入攻击"></a>Sql注入攻击</h3></li><li><p>对数据库进行攻击的常用手段，获取权限</p></li><li><h2 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h2></li><li><h3 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h3></li><li><p>安全协议，端口号443，传输层</p></li><li><h3 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h3></li><li><p>SSL 3.0 后续版本</p></li><li><h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3></li><li><p>终端设备和远程站点建立安全连接的协议，防止信息泄露</p></li><li><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3></li><li><p>使用 SSL 的 HTTP，安全通道（用 443端口，普通HTTP用80）</p></li><li><h3 id="MIME"><a href="#MIME" class="headerlink" title="MIME"></a>MIME</h3></li><li><p>邮件附件类型拓展协议，支持非文本格式、非 ASCII 字符等拓展，与安全无关</p></li><li><h3 id="PGP"><a href="#PGP" class="headerlink" title="PGP"></a>PGP</h3></li><li><p>基于 RSA 公钥加密体系的邮件加密软件</p></li><li><h3 id="IPSec"><a href="#IPSec" class="headerlink" title="IPSec"></a>IPSec</h3></li><li><p>IP数据报文加密</p></li><li><h3 id="PP2P"><a href="#PP2P" class="headerlink" title="PP2P"></a>PP2P</h3></li><li><p>链路层加密</p></li><li></li><li><h2 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h2></li><li><p>列表技术，把合法方可记录</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 备战软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【软考】上午题9-软件工程-中级软件设计师备考笔记</title>
      <link href="/posts/919d55f0.html"/>
      <url>/posts/919d55f0.html</url>
      
        <content type="html"><![CDATA[<ul><li><h2 id="软件过程"><a href="#软件过程" class="headerlink" title="软件过程"></a>软件过程</h2></li><li><h3 id="能力成熟度模型-CMM"><a href="#能力成熟度模型-CMM" class="headerlink" title="能力成熟度模型 CMM"></a>能力成熟度模型 CMM</h3></li><li><p>五个成熟度级别：</p><ol><li>初始级，杂乱无章，混乱，靠英雄式核心人物</li></ol><p>2.可重复级，基本项目管理过程和实践<strong>跟踪</strong>，有必要的过程准则<br>3.已定义级，软件过程文档化、标准化，<strong>标准</strong>软件过程<br>4.已管理级，软件过程的产品<strong>质量</strong>被理解和控制<br>5.优化级，加强定量分析，通过过程质量反馈、新观念、新技术持续<strong>改进</strong>  </p></li><li><h3 id="能力成熟度模型集成-CMMI"><a href="#能力成熟度模型集成-CMMI" class="headerlink" title="能力成熟度模型集成 CMMI"></a>能力成熟度模型集成 CMMI</h3></li><li><p>阶段式模型，类似 CMM</p></li><li><p>连续式模型，有六个等级，0-5</p></li><li><ol start="0"><li>CL0，未完成的，未执行或未得到</li></ol></li><li><p>已执行的，共性目标：可标识输入转换可标识输出工作产品<br>logseq.order-list-type:: number</p></li><li><p>已管理的，共性目标：已管理过程的制度化<br>logseq.order-list-type:: number</p></li><li><p>已定义级的，共性目标：已定义过程的制度化<br>logseq.order-list-type:: number</p></li><li><p>定量管理的，共性目标：可定量管理的制度化<br>logseq.order-list-type:: number</p></li><li><p>优化的，使用量化手段改变和优化过程域<br>logseq.order-list-type:: number</p></li><li><h2 id="软件过程模型"><a href="#软件过程模型" class="headerlink" title="软件过程模型"></a>软件过程模型</h2></li><li><h3 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h3></li><li><p>包括需求分析、设计、编码、测试、运行与维护</p></li><li><p>以项目阶段评审和文档控制为手段有效地对整个开发过程进行指导，文档驱动，适用于软件需求很明确的软件项目模型</p></li><li><p>优点，容易理解，管理成本低</p></li><li><p>缺点，客户要完整<strong>清晰</strong>地表达需要；开始的两个或三个阶段，很难评估真正的进度状态；错误往往后期才能发现，项目风险控制能力弱</p></li><li><p><img src="/../assets/image_1730643176431_0.png" alt="image.png"></p></li><li><h3 id="V模型"><a href="#V模型" class="headerlink" title="V模型"></a>V模型</h3></li><li><p>瀑布模型变体，基本作为干扰项出现，看到基本可选瀑布模型</p></li><li><p>就是用一系列测试（质量保证活动）</p></li><li><h3 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h3></li><li><p>将需求分段为一系列增量产品，客户对每个增量的使用和评估作为下个增量开发</p></li><li><p>第一个增量往往是<strong>核心产品</strong></p></li><li><p><img src="/../assets/image_1730643517405_0.png" alt="image.png"></p></li><li><p>优点：瀑布模型<strong>所有优点</strong>，第一个可交付版本需要成本和时间很少，风险不大，减少用户需求变更</p></li><li><p>不足，若没有对用户变更需求进行规划，初始增量可能要重新开发、发布，成本、进度和复杂度失控。</p></li><li><h3 id="演化模型"><a href="#演化模型" class="headerlink" title="演化模型"></a>演化模型</h3></li><li><p>是迭代的过程模型，使用户对软件需求缺乏准确认识的情况</p></li><li><p>典型的有原型模型和螺旋模型</p></li><li><h3 id="原型模型（快速原型）"><a href="#原型模型（快速原型）" class="headerlink" title="原型模型（快速原型）"></a>原型模型（快速原型）</h3></li><li><p>适用于用户需求不清、经常变化的情况；系统规模不是很大，也不太复杂<br><img src="/../assets/image_1730725580713_0.png" alt="image.png">{:height 289, :width 344}  </p></li><li><p>快速低成本构建原型（易于理解的框架），可有效<strong>捕获系统需求</strong></p></li><li><p>注意，该模式使不断改进后才部署使用，演化（迭代）模型则是投入使用后，再迭代</p></li><li><h3 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h3></li><li><p>瀑布模型和演化模型结合，并加入风险分析，特别适合庞大、复杂且有高风险的系统，风险驱动<br><img src="/../assets/image_1730726336888_0.png" alt="image.png">  </p></li><li><p>相比瀑布模型，优点：能适应需求动态变化，提高软件适应能力；</p></li><li><p>缺点：但需求开发人员有丰富的风险评估经验和专门知识，过多迭代次数会增加开发成本、延迟交付时间</p></li><li><h3 id="喷泉模型"><a href="#喷泉模型" class="headerlink" title="喷泉模型"></a>喷泉模型</h3></li><li><p>用户需求为动力，以对象作为驱动的模型，适用<strong>面向对象</strong>开发方法<br><img src="/../assets/image_1730727394753_0.png" alt="image.png">  </p></li><li><p>克服瀑布模型不支持软件重用和多项开发活动集成的局限性。无间隙，允许各开发活动交叉、迭代进行（<strong>无明显界限</strong>）</p></li><li><p>优点：提高开发效率</p></li><li><p>缺点，需要大量开发人员，要求严格管理文档，审核难度加大</p></li><li><h3 id="统一过程（UP）模型"><a href="#统一过程（UP）模型" class="headerlink" title="统一过程（UP）模型"></a>统一过程（UP）模型</h3></li><li><p>用例和风险驱动，以架构为中心，迭代且增量的开发过程</p></li><li><p>起始阶段，项目初始活动，目标</p></li><li><p>精化阶段，需求分析和架构演进</p></li><li><p>构建阶段，系统构建，产生实现模型，功能</p></li><li><p>移交阶段，软件移交，产品发布</p></li><li><p>典型代表是 RUP，是 UP 更完整更详细</p></li><li><h3 id="基于构件的开发模型"><a href="#基于构件的开发模型" class="headerlink" title="基于构件的开发模型"></a>基于构件的开发模型</h3></li><li><p>用预先打包好的软件构件（内部开发或商品化的成本软件构件）来开发系统，有螺旋模型的优点，本质上是演化模型，不要求面向对象方法</p></li><li><h3 id="敏捷方法"><a href="#敏捷方法" class="headerlink" title="敏捷方法"></a>敏捷方法</h3></li><li><p>尽可能早、持续地对有价值的软件交付</p></li><li><p>每个方法基于一套原则，实现了敏捷宣言（敏捷方法的理念）</p></li><li><h4 id="极限编程-XP"><a href="#极限编程-XP" class="headerlink" title="极限编程 XP"></a>极限编程 XP</h4></li><li><p>4个价值观：沟通、简单性、反馈和勇气</p></li><li><p>5个原则</p></li><li><p>12个最佳实践：计划游戏（快速制定计划）、小型发布（尽快交付系统设计）、隐喻（用合适比喻传达信息）、简单设计（只处理当前请求，使设计保持简单）、测试先行（先写测试再写程序）、重构（重新审视需求和设计，重新描述以满足需求）、结对编程（相当于两个人，一个人写一个人看着写，可轮流）、集体代码所有制、持续集成（按日甚至按小时为客户提供可运行的版本）、每周工作40小时、现场客户和编码标准</p></li><li><h4 id="水晶法"><a href="#水晶法" class="headerlink" title="水晶法"></a>水晶法</h4></li><li><p>认为不同项目需要一套不同的策略、约定、方法论</p></li><li><h4 id="并列争求法"><a href="#并列争求法" class="headerlink" title="并列争求法"></a>并列争求法</h4></li><li><p>迭代，30天一次迭代叫冲刺</p></li><li><h4 id="自适应软件开发-ASD"><a href="#自适应软件开发-ASD" class="headerlink" title="自适应软件开发 ASD"></a>自适应软件开发 ASD</h4></li><li><p>有6个基本原则，暂时懒得背</p></li><li><h4 id="敏捷统一过程-AUP"><a href="#敏捷统一过程-AUP" class="headerlink" title="敏捷统一过程 AUP"></a>敏捷统一过程 AUP</h4></li><li><p>采用在大型连续，在小型迭代的原理构建，采用经典的 UP 阶段性活动</p></li><li><h3 id="软件需求"><a href="#软件需求" class="headerlink" title="软件需求"></a>软件需求</h3></li><li><p>功能需求，考虑系统做什么，何时做，如何升级等</p></li><li><p>性能需求，考虑系统技术性指标，储存容量限制、执行速度、响应时间及吞吐量</p></li><li><p>数据需求，考虑输入输出数据格式，发送数据频率、数据流量等</p></li><li><p>共十二需求，其余几乎不考</p></li><li><h2 id="概要设计-设计软件系统总体结构"><a href="#概要设计-设计软件系统总体结构" class="headerlink" title="概要设计-设计软件系统总体结构"></a>概要设计-设计软件系统总体结构</h2></li><li><p>把复杂系统按功能分成模块，确定模块功能、模块间调用关系、接口、传递信息</p></li><li><p>是概要设计关键一步，直接影响到详细设计和编码的工作</p></li><li><h4 id="编写概要设计文档"><a href="#编写概要设计文档" class="headerlink" title="编写概要设计文档"></a>编写概要设计文档</h4></li><li><p>概要设计说明书、数据库设计说明书、用户手册及修订计划</p></li><li><h3 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h3></li><li><p>对每个模块算法设计<br>logseq.order-list-type:: number</p></li><li><p>对模块内数据结构设计<br>logseq.order-list-type:: number</p></li><li><p>数据库物理设计<br>logseq.order-list-type:: number</p></li><li><p>其他设计<br>logseq.order-list-type:: number</p></li><li><p>编写详细设计说明书<br>logseq.order-list-type:: number</p></li><li><p>评审<br>logseq.order-list-type:: number</p></li><li><p>设计结果是一系列文档，是实现一个信息系统的重要基础</p></li><li><h2 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h2></li><li><p>意义，为发现错误而执行程序</p></li><li><p>目的，尽可能少的人力和时间找出错误</p></li><li><p>八个基本原则</p></li><li><p><strong>应尽早不断测试</strong><br>logseq.order-list-type:: number</p></li><li><p>测试避免由开发人员承担<br>logseq.order-list-type:: number</p></li><li><p><strong>要比对预期结果和实际输出结果</strong><br>logseq.order-list-type:: number</p></li><li><p><strong>要包含不合理、异常的情况的测试用例</strong><br>logseq.order-list-type:: number</p></li><li><p><strong>检验程序是否做了不该做的事</strong><br>logseq.order-list-type:: number</p></li><li><p>严格按照测试计划进行<br>logseq.order-list-type:: number</p></li><li><p>妥善保存设计计划、用例<br>logseq.order-list-type:: number</p></li><li><p><strong>测试例子是精心设计的，在系统完善后，重新测试时，可复用以前的测试用例</strong><br>logseq.order-list-type:: number</p></li><li><p>系统测试阶段的测试目标来自于<strong>需求分析</strong>阶段<br>logseq.order-list-type:: number</p></li><li><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3></li><li><p>模块编写完成无编译错误就可以进行，一般用白盒测试法</p></li><li><p>过程：有个驱动模块（主程序），和桩模块（存根模块）检验入口、输出调用和返回的信息</p></li><li><p>提高模块内聚度有助于单元测试</p></li><li><h3 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h3></li><li><h4 id="自顶向下集成测试"><a href="#自顶向下集成测试" class="headerlink" title="自顶向下集成测试"></a>自顶向下集成测试</h4></li><li><p>以DFS或BFS把从属于主控模块的模块集成结构中</p></li><li><p>不用编写驱动模块，要编写桩模块</p></li><li><h4 id="自底向上集成测试"><a href="#自底向上集成测试" class="headerlink" title="自底向上集成测试"></a>自底向上集成测试</h4></li><li><p>从原子模块（最底层）开始构造测试</p></li><li><p>不用编写桩模块，要编写驱动模块</p></li><li><h4 id="回归测试"><a href="#回归测试" class="headerlink" title="回归测试"></a>回归测试</h4></li><li><p>重新测试已测试过的某些子集，保证变更没有传播不期望、引入无意识行为或额外的错误</p></li><li><h4 id="冒烟测试"><a href="#冒烟测试" class="headerlink" title="冒烟测试"></a>冒烟测试</h4></li><li><p>频繁评估</p></li><li><h2 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h2></li><li><p>分静态测试（人工检测和计算机辅助静态分析，没考过）和动态分析（通过<strong>运行程序</strong>发现错误，重点）</p></li><li><p>测试用例由测试输入数据和对应的预期输出结果组成，测试用例应包含合理和不合理的输入条件</p></li><li><h3 id="黑盒测试（把程序当黑盒）"><a href="#黑盒测试（把程序当黑盒）" class="headerlink" title="黑盒测试（把程序当黑盒）"></a>黑盒测试（把程序当黑盒）</h3></li><li><p>等价类划分，把输入划分法若干等价类，从每个等价类选取代表性测试用例，等价类分有效等价类（符合规则）和无效等价类（不同角度违反规则）</p></li><li><p>边界值分析，既注重输入条件边界，又适用于输出域测试用例</p></li><li><p>错误推测，用经验和直觉推测程序中所有可能存在各种错误</p></li><li><p>因果图，找因（输入）和果（输出）画图</p></li><li><h3 id="McCabe度量法"><a href="#McCabe度量法" class="headerlink" title="McCabe度量法"></a>McCabe度量法</h3></li><li><p>计算图 G 的环路复杂性, V(G)&#x3D;m-n+2，m是有向弧个数，n是节点个数</p></li><li><p>（或是闭合区域个数+1）</p></li><li><p>注意每个边都应有两节点，像下面这样的线要么不算，要么补一个点<br><img src="/../assets/image_1730787420537_0.png" alt="image.png">  </p></li><li><h3 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h3></li><li><p>根据程序的内部结构设计</p></li><li><h4 id="逻辑覆盖-重要"><a href="#逻辑覆盖-重要" class="headerlink" title="逻辑覆盖(重要)"></a>逻辑覆盖(重要)</h4></li><li><p>语句覆盖，被测试语句每条程序至少执行一次，<br>logseq.order-list-type:: number</p></li><li><p>判定覆盖（分支覆盖），每个判定表达式的真和假至少通过一次<br>logseq.order-list-type:: number</p></li><li><p>条件覆盖，使每个逻辑条件的各种可能的值至少满足一次<br>logseq.order-list-type:: number<br><img src="/../assets/image_1730788106497_0.png" alt="image.png">  </p></li><li><p>判定&#x2F;条件覆盖：判定覆盖+条件覆盖<br>logseq.order-list-type:: number</p></li><li><p>条件组合覆盖，使每个判定中条件的各种组合都至少出现一次<br>logseq.order-list-type:: number<br><img src="/../assets/image_1730788258890_0.png" alt="image.png">  </p></li><li><p>路径覆盖，覆盖被测试程序中的所有路径<br>logseq.order-list-type:: number</p></li><li><h4 id="循环覆盖"><a href="#循环覆盖" class="headerlink" title="循环覆盖"></a>循环覆盖</h4></li><li><p>执行足够测试用例</p></li><li><h4 id="基本路径测试"><a href="#基本路径测试" class="headerlink" title="基本路径测试"></a>基本路径测试</h4></li><li><p>分析环路复杂性，从可执行路径测试</p></li><li><h2 id="系统维护"><a href="#系统维护" class="headerlink" title="系统维护"></a>系统维护</h2></li><li><h3 id="系统可维护性评价指标"><a href="#系统可维护性评价指标" class="headerlink" title="系统可维护性评价指标"></a>系统可维护性评价指标</h3></li><li><p>可理解性、可测试性、可修改性</p></li><li><h3 id="软件维护"><a href="#软件维护" class="headerlink" title="软件维护"></a>软件维护</h3></li><li><p>文档是软件可维护性的决定因素，文档十分重要，分用户文档、系统文档</p></li><li><p>软件工程每个阶段都应考虑软件维护性</p></li><li><h3 id="软件文档"><a href="#软件文档" class="headerlink" title="软件文档"></a>软件文档</h3></li><li><p>高质量文档能提高软件开发的质量</p></li><li><p>文档是软件产品的一部分没有文档的软件不能称为软件</p></li><li><p>几乎只好不坏</p></li><li><h3 id="软件维护内容"><a href="#软件维护内容" class="headerlink" title="软件维护内容"></a>软件维护内容</h3></li><li><p>正确性维护，改开发阶段发生而系统测试阶段尚未发生的错误，占17-21%，有的错误非常重要<br>logseq.order-list-type:: number</p></li><li><p>适应性维护，使软件适应信息技术变化和管理需求变化的修改<br>logseq.order-list-type:: number</p></li><li><p>完善性维护，扩充功能和改善性能，50%-60%，比重较大<br>logseq.order-list-type:: number</p></li><li><p>预防性维护，主动增加预防性新功能，占4%左右<br>logseq.order-list-type:: number</p></li><li><h3 id="软件质量属性"><a href="#软件质量属性" class="headerlink" title="软件质量属性"></a>软件质量属性</h3></li><li><p>可靠性、可用性、可维护性，用0-1的数字度量</p></li><li><p>可靠性 系统无失效运行概率 MTTF&#x2F;(1+MTTF)  MTTF 平均无故障时间</p></li><li><p>可用性 系统正确运行概率 MTBF&#x2F;(1+MTBF)  MTBF 平均失效间隔时间</p></li><li><p>可维护性 完成维护的概率 1&#x2F;(1+MTTR)  MTTR平均修复时间</p></li><li><p>mean time to failure<br>mean time between failures<br>mean time to repair  </p></li><li><h2 id="沟通路径"><a href="#沟通路径" class="headerlink" title="沟通路径"></a>沟通路径</h2></li><li><p>n个人，若两两连接，则有 n*(n-1)&#x2F;2 条沟通路径；若有一个主程序员，则 n-1 条沟通路径</p></li><li><h2 id="软件项目估算"><a href="#软件项目估算" class="headerlink" title="软件项目估算"></a>软件项目估算</h2></li><li><h3 id="COCOMO-估算模型"><a href="#COCOMO-估算模型" class="headerlink" title="COCOMO 估算模型"></a>COCOMO 估算模型</h3></li><li><p>基本 COCOMO 模型，静态单变量模型</p></li><li><p>中级 COCOMO 模型，静态多变量模型</p></li><li><p>详细 COCOMO 模型，分三个模块</p></li><li><h3 id="COCOMO-模型"><a href="#COCOMO-模型" class="headerlink" title="COCOMO|| 模型"></a>COCOMO|| 模型</h3></li><li><p>分为三个阶段性模型，应用组装模型、早期设计阶段模型、体系结构阶段模型，对应三种规模估算选择：对象点、功能点、代码行（功能点可以转为代码行）</p></li><li></li><li><h2 id="进度管理"><a href="#进度管理" class="headerlink" title="进度管理"></a>进度管理</h2></li><li><p>项目活动图很可能考，其它几个近几年不考</p></li><li><h3 id="Gantt-图-（甘特图）"><a href="#Gantt-图-（甘特图）" class="headerlink" title="Gantt 图 （甘特图）"></a>Gantt 图 （甘特图）</h3></li><li><p>描述任务何时开始、结束、进展情况和并行性，但不能描述任务之间的依赖关系<br><img src="/../assets/image_1730795666988_0.png" alt="image.png">  </p></li><li><h3 id="PERT图"><a href="#PERT图" class="headerlink" title="PERT图"></a>PERT图</h3></li><li><p>箭头是任务，可标上任务所需时间，但不能反应任务的并行关系<br><img src="/../assets/image_1730796263397_0.png" alt="image.png">  </p></li><li><h3 id="项目活动图"><a href="#项目活动图" class="headerlink" title="项目活动图"></a>项目活动图</h3></li><li><p>顶点是项目里程碑，边是活动，值为完成活动所需时间<br><img src="/../assets/image_1730796610493_0.png" alt="image.png">  </p></li><li><p>缩短关键路径上活动才能缩短整体工期</p></li><li><p>记住！！！算关键路径长度别忘了结束的一段</p></li><li><h2 id="软件配置管理"><a href="#软件配置管理" class="headerlink" title="软件配置管理"></a>软件配置管理</h2></li><li><p>主要目标（活动），变更标识、变更控制、版本控制、确保变更正确实现，变更报告</p></li><li><p>配置数据库三类：开发库、受控库、产品库</p></li><li><h2 id="风险管理"><a href="#风险管理" class="headerlink" title="风险管理"></a>风险管理</h2></li><li><p>软件风险特性，不确定性（风险可能发生也可能不发生）和损失（风险发生的后果）</p></li><li><p>风险优先级通常由风险暴露设定（风险影响*风险概率）</p></li><li><p>项目风险，可能拖延项目进度，增加项目成本（项目复杂度、规模和结构的不确定性也算因素）</p></li><li><p>技术风险，威胁发开软件质量以及交付时间（问题比设想更难解决）</p></li><li><p>商业风险，威胁开发软件生存能力</p></li><li><h3 id="风险识别"><a href="#风险识别" class="headerlink" title="风险识别"></a>风险识别</h3></li><li><p>风险不能全部避免，可以尽可能干预。一种方法是简历风险条目检查表</p></li><li><h3 id="风险预测（风险估计）"><a href="#风险预测（风险估计）" class="headerlink" title="风险预测（风险估计）"></a>风险预测（风险估计）</h3></li><li><h3 id="风险评估"><a href="#风险评估" class="headerlink" title="风险评估"></a>风险评估</h3></li><li><p>一种方法是定义风险参照水准</p></li><li><h3 id="风险控制"><a href="#风险控制" class="headerlink" title="风险控制"></a>风险控制</h3></li><li><p>风险避免，在风险发生前，分析并采取措施<br>logseq.order-list-type:: number</p></li><li><p>风险监管<br>logseq.order-list-type:: number</p></li><li><p>RMMM 计划（风险环节、监控和管理计划）<br>logseq.order-list-type:: number</p></li><li><h2 id="软件质量"><a href="#软件质量" class="headerlink" title="软件质量"></a>软件质量</h2></li><li><h3 id="ISO-IEC9126-软件质量模型"><a href="#ISO-IEC9126-软件质量模型" class="headerlink" title="ISO&#x2F;IEC9126 软件质量模型"></a>ISO&#x2F;IEC9126 软件质量模型</h3></li><li><p>虽然必考，但要背的太多，这一分不值<br><img src="/../assets/image_1730812124918_0.png" alt="image.png">  </p></li><li><h3 id="Me-Call-软件质量模型"><a href="#Me-Call-软件质量模型" class="headerlink" title="Me Call 软件质量模型"></a>Me Call 软件质量模型</h3></li><li><p>三个方面确认十一个质量特性，同上不值得<br><img src="/../assets/image_1730812256100_0.png" alt="image.png">{:height 390, :width 544}  </p></li><li><h2 id="软件工具"><a href="#软件工具" class="headerlink" title="软件工具"></a>软件工具</h2></li><li><h3 id="软件维护工具"><a href="#软件维护工具" class="headerlink" title="软件维护工具"></a>软件维护工具</h3></li><li><p>版本更新工具<br>logseq.order-list-type:: number</p></li><li><p>文档分析工具<br>logseq.order-list-type:: number</p></li><li><p>开发信息库工具<br>logseq.order-list-type:: number</p></li><li><p><strong>逆向工程工具</strong><br>logseq.order-list-type:: number</p></li><li><p>再工程工具<br>logseq.order-list-type:: number</p></li><li><h2 id="项目估算"><a href="#项目估算" class="headerlink" title="项目估算"></a>项目估算</h2></li><li><p>主要因素，规模、工作量、成本</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 备战软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Weekly Algorithm】算法周记之《代码随想录》二叉树（三）</title>
      <link href="/posts/c9ad525.html"/>
      <url>/posts/c9ad525.html</url>
      
        <content type="html"><![CDATA[<h1 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h1><p>本周跟随《代码随想录》学习二叉树和二叉搜索树的算法题目，比如完全二叉树的节点个数，平衡二叉树，二叉树的路径、二叉树的合并，二叉搜索树的检索和验证等。</p><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><ul><li><h2 id="完全二叉树的节点个数"><a href="#完全二叉树的节点个数" class="headerlink" title="完全二叉树的节点个数"></a>完全二叉树的节点个数</h2></li><li><a href="https://programmercarl.com/0222.%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0.html#%E6%80%9D%E8%B7%AF">代码随想录</a></li><li><a href="https://leetcode.cn/problems/count-complete-tree-nodes/description/">222. 完全二叉树的节点个数 - 力扣（LeetCode）</a></li><li>题意就是让你求一个完全二叉树的节点个数</li><li>方法有大致两种，一种是把这个当普通二叉树求，直接先序、中序、后序遍历都行，统计节点，时间复杂度 O(n)；第二种是利用完全二叉树的特性，由于完全二叉树可视作是满二叉树组成的二叉树，满二叉树的节点由深度 n，经 2^n - 1 计算得出。</li><li>陆爻齐的先序求法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int result = 0;</span><br><span class="line">    int countNodes(TreeNode* root) &#123;</span><br><span class="line">        pre_val(root);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void pre_val(TreeNode *root) &#123;</span><br><span class="line">        if (root == nullptr) return;</span><br><span class="line"></span><br><span class="line">        result++;</span><br><span class="line">        pre_val(root-&gt;left);</span><br><span class="line">        pre_val(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>陆爻齐参照代码随想录思路写的利用完全二叉树特性解法  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    int countNodes(TreeNode* root) &#123;</span><br><span class="line">        int result = full_val(root);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int full_val(TreeNode *root) &#123;</span><br><span class="line">        // 空指针的情况</span><br><span class="line">        if (root == nullptr) return 0;</span><br><span class="line"></span><br><span class="line">        // 满二叉树的情况</span><br><span class="line">        int left_depth = 0, right_depth = 0;</span><br><span class="line">        TreeNode *left = root, *right = root;</span><br><span class="line">        while (left) &#123;</span><br><span class="line">            left = left-&gt;left;</span><br><span class="line">            left_depth++;</span><br><span class="line">        &#125;</span><br><span class="line">        while (right) &#123;</span><br><span class="line">            right = right-&gt;right;</span><br><span class="line">            right_depth;</span><br><span class="line">        &#125;</span><br><span class="line">        if (left_depth == right_depth) &#123; // 左边深度与右边相等是满二叉树</span><br><span class="line">            return (2 &lt;&lt; left_depth) - 1; // 节点数量为 2 的深度次方 - 1</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 非满二叉树，可递归下去</span><br><span class="line">        int left_nodes = full_val(root-&gt;left);</span><br><span class="line">        int right_nodes = full_val(root-&gt;right);</span><br><span class="line">        return left_nodes + right_nodes + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2></li><li><a href="https://programmercarl.com/0110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E6%9C%AC%E9%A2%98%E6%80%9D%E8%B7%AF">代码随想录</a></li><li><a href="https://leetcode.cn/problems/balanced-binary-tree/description/">110. 平衡二叉树 - 力扣（LeetCode）</a></li><li>题意，判断该二叉树是否为平衡二叉树，即左右子树高度差小于等于一，高度为节点到叶子节点的最远距离</li><li>方法就是利用递归求两侧高度，若有非平衡二叉树情况，则使得整棵树不是即可</li><li>陆爻齐参照代码随想录思路解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isBalanced(TreeNode* root) &#123;</span><br><span class="line">        return getHeight(root) == -1 ? false : true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int getHeight(TreeNode *root) &#123;</span><br><span class="line">        // 叶子节点高度为 0</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 左右子树若有非平衡二叉树，则该二叉树非平衡二叉树</span><br><span class="line">        int left_height = getHeight(root-&gt;left);</span><br><span class="line">        if (left_height == -1) return -1;</span><br><span class="line">        int right_height = getHeight(root-&gt;right);</span><br><span class="line">        if (right_height == -1) return -1;</span><br><span class="line"></span><br><span class="line">        return abs(left_height - right_height) &gt; 1 ? -1 : max(left_height, right_height) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h2 id="二叉树的所有路径"><a href="#二叉树的所有路径" class="headerlink" title="二叉树的所有路径"></a>二叉树的所有路径</h2></li><li><a href="https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html#%E6%80%9D%E8%B7%AF">代码随想录</a></li><li><a href="https://leetcode.cn/problems/binary-tree-paths/description/">257. 二叉树的所有路径 - 力扣（LeetCode）</a></li><li>题意，找到二叉树从根节点到叶子节点的所有路径</li><li>方法，回溯递归，最重要的点在于，传的 string path 最好不要引用传递，因为每个节点放进去的数字可能有好几位，传引用需要精确去除数字，比较麻烦，传值的话就不用担心后面加的数字影响到这一层的 path。</li><li>陆爻齐参照代码随想录修复了 path 引用bug的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123;</span><br><span class="line">        string path;</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        all_val(root, path, result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 这个path用复制非常重要，引用很难去除本点值</span><br><span class="line">    void all_val(TreeNode *root, string path, vector&lt;string&gt; &amp;result) &#123;</span><br><span class="line">        // 防第一个点就是空</span><br><span class="line">        if (root == nullptr) return;</span><br><span class="line">        </span><br><span class="line">        // 非空时，加入该点值</span><br><span class="line">        path += to_string(root-&gt;val);</span><br><span class="line">        //cout &lt;&lt; path &lt;&lt; endl;</span><br><span class="line">        path += &quot;-&gt;&quot;;</span><br><span class="line">        if (root-&gt;left != nullptr) &#123; // 左子树</span><br><span class="line">            all_val(root-&gt;left, path, result); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (root-&gt;right != nullptr) &#123; // 右子树</span><br><span class="line">            all_val(root-&gt;right, path, result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        path = path.substr(0, path.size() - 2); // 去除-》</span><br><span class="line">        // 加入叶子节点的路径</span><br><span class="line">        if (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr) &#123;</span><br><span class="line">            result.push_back(path);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>代码随想录的解法  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    void traversal(TreeNode* cur, string path, vector&lt;string&gt;&amp; result) &#123;</span><br><span class="line">        path += to_string(cur-&gt;val); // 中，中为什么写在这里，因为最后一个节点也要加入到path中</span><br><span class="line">        if (cur-&gt;left == NULL &amp;&amp; cur-&gt;right == NULL) &#123;</span><br><span class="line">            result.push_back(path);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (cur-&gt;left) &#123;</span><br><span class="line">            path += &quot;-&gt;&quot;;</span><br><span class="line">            traversal(cur-&gt;left, path, result); // 左</span><br><span class="line">            path.pop_back(); // 回溯 &#x27;&gt;&#x27;</span><br><span class="line">            path.pop_back(); // 回溯 &#x27;-&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        if (cur-&gt;right) &#123;</span><br><span class="line">            path += &quot;-&gt;&quot;;</span><br><span class="line">            traversal(cur-&gt;right, path, result); // 右</span><br><span class="line">            path.pop_back(); // 回溯&#x27;&gt;&#x27;</span><br><span class="line">            path.pop_back(); // 回溯 &#x27;-&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        string path;</span><br><span class="line">        if (root == NULL) return result;</span><br><span class="line">        traversal(root, path, result);</span><br><span class="line">        return result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><h2 id="左叶子之和"><a href="#左叶子之和" class="headerlink" title="左叶子之和"></a>左叶子之和</h2></li><li><a href="https://programmercarl.com/0404.%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C.html#%E6%80%9D%E8%B7%AF">代码随想录</a></li><li><a href="https://leetcode.cn/problems/sum-of-left-leaves/description/">404. 左叶子之和 - 力扣（LeetCode）</a></li><li>题意，找出二叉树中的所有左叶子节点，求其和</li><li>方法，不难，重点是左叶子的定义，若 A 点的左节点非空为 B，B 无左节点和右节点，那么 B 为左叶子，由此便可直接遍历找左叶子即可</li><li>陆爻齐的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int sumOfLeftLeaves(TreeNode* root) &#123;</span><br><span class="line">        int result = 0;</span><br><span class="line">        pre_val_pro(root, result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void pre_val_pro(TreeNode *root, int &amp;result) &#123;</span><br><span class="line">        if (root == nullptr) return; // 排除空的场景</span><br><span class="line"></span><br><span class="line">        // 添加左叶子节点</span><br><span class="line">        if (root-&gt;left != nullptr &amp;&amp; root-&gt;left-&gt;left == nullptr &amp;&amp; root-&gt;left-&gt;right == nullptr) &#123;</span><br><span class="line">            result+=root-&gt;left-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 遍历左右子树</span><br><span class="line">        pre_val_pro(root-&gt;left, result);</span><br><span class="line">        pre_val_pro(root-&gt;right, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>代码随想录的解法  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int sumOfLeftLeaves(TreeNode* root) &#123;</span><br><span class="line">        if (root == NULL) return 0;</span><br><span class="line">        if (root-&gt;left == NULL &amp;&amp; root-&gt;right== NULL) return 0; //陆爻齐注释后也可AC，这是加速进程的</span><br><span class="line"></span><br><span class="line">        int leftValue = sumOfLeftLeaves(root-&gt;left);    // 左</span><br><span class="line">        if (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) &#123; // 左子树就是一个左叶子的情况</span><br><span class="line">            leftValue = root-&gt;left-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        int rightValue = sumOfLeftLeaves(root-&gt;right);  // 右</span><br><span class="line"></span><br><span class="line">        int sum = leftValue + rightValue;               // 中</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><h2 id="找树左下角的值"><a href="#找树左下角的值" class="headerlink" title="找树左下角的值"></a>找树左下角的值</h2></li><li><a href="https://programmercarl.com/0513.%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></li><li><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/description/">513. 找树左下角的值 - 力扣（LeetCode）</a></li><li>题意，找出一棵二叉树最底边最左边的值</li><li>方法，迭代的方法好说，只要层序遍历取最左边，也就是第一个点就可以；但是递归的方法没那么好理解，其实只要在递归时优先遍历下一层就可以保证：第一个深度最深的点，就是最左边的。</li><li>陆爻齐参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int result = 0;</span><br><span class="line">    int max_depth = INT32_MIN;</span><br><span class="line">    int findBottomLeftValue(TreeNode* root) &#123;</span><br><span class="line">        search_left(root, 0);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void search_left(TreeNode *root, int depth) &#123;</span><br><span class="line">        if (root == nullptr) return;</span><br><span class="line"></span><br><span class="line">        // 由于总是先遍历左边，故第一个大深度必为最左</span><br><span class="line">        if (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr) &#123;</span><br><span class="line">            if (depth &gt; max_depth) &#123;</span><br><span class="line">                max_depth = depth;</span><br><span class="line">                result = root-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 先左后右</span><br><span class="line">        search_left(root-&gt;left, depth+1);</span><br><span class="line">        search_left(root-&gt;right, depth+1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h2 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h2></li><li><a href="https://programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></li><li><a href="https://leetcode.cn/problems/path-sum/">112. 路径总和 - 力扣（LeetCode）</a></li><li>题意，给一个目标和，要求判断二叉树中是否有一条根节点到叶节点的路径和恰好为目标和</li><li>方法，DFS，递归或迭代</li><li>陆爻齐的解法，比较冗余，不过不用多改下一题也能用：）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; path; // 记录路径，主要是记上一层的数字</span><br><span class="line">    bool result = false; // 记录结果</span><br><span class="line">    int sum = 0; // 记录和</span><br><span class="line">    bool hasPathSum(TreeNode* root, int targetSum) &#123;</span><br><span class="line">        val(root, targetSum);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void val(TreeNode *root, int targetSum) &#123;</span><br><span class="line">        if (root == nullptr) return; // 空节点的终止条件</span><br><span class="line">        path.push_back(root-&gt;val); // 加入路径并更新路径和</span><br><span class="line">        sum += root-&gt;val;</span><br><span class="line">        if (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr &amp;&amp; sum == targetSum) &#123; // 到了叶节点且和恰好相同才行</span><br><span class="line">            result = true;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        val(root-&gt;left, targetSum); </span><br><span class="line">        val(root-&gt;right, targetSum);</span><br><span class="line"></span><br><span class="line">        sum -= path[path.size()-1]; // 去除路径</span><br><span class="line">        path.erase(path.end()-1); // 去除和</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>代码随想录的解法  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    bool traversal(TreeNode* cur, int count) &#123;</span><br><span class="line">        if (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; count == 0) return true; // 遇到叶子节点，并且计数为0</span><br><span class="line">        if (!cur-&gt;left &amp;&amp; !cur-&gt;right) return false; // 遇到叶子节点直接返回</span><br><span class="line"></span><br><span class="line">        if (cur-&gt;left) &#123; // 左</span><br><span class="line">            count -= cur-&gt;left-&gt;val; // 递归，处理节点;</span><br><span class="line">            if (traversal(cur-&gt;left, count)) return true;</span><br><span class="line">            count += cur-&gt;left-&gt;val; // 回溯，撤销处理结果</span><br><span class="line">        &#125;</span><br><span class="line">        if (cur-&gt;right) &#123; // 右</span><br><span class="line">            count -= cur-&gt;right-&gt;val; // 递归，处理节点;</span><br><span class="line">            if (traversal(cur-&gt;right, count)) return true;</span><br><span class="line">            count += cur-&gt;right-&gt;val; // 回溯，撤销处理结果</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    bool hasPathSum(TreeNode* root, int sum) &#123;</span><br><span class="line">        if (root == NULL) return false;</span><br><span class="line">        return traversal(root, sum - root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h2 id="路径总和ii"><a href="#路径总和ii" class="headerlink" title="路径总和ii"></a>路径总和ii</h2></li><li><a href="https://leetcode.cn/problems/path-sum-ii/submissions/574988363/">113. 路径总和 II - 力扣（LeetCode）</a></li><li>题意，基本同上一题，但要求返回所有和为目标和的路径</li><li>方法，用vector记路径，再递归即可</li><li>陆爻齐的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; path; // 记录路径，主要是记上一层的数字</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; result; // 记录结果</span><br><span class="line">    int sum = 0; // 记录和</span><br><span class="line"></span><br><span class="line">    void val(TreeNode *root, int targetSum) &#123;</span><br><span class="line">        if (root == nullptr) return; // 空节点的终止条件</span><br><span class="line">        path.push_back(root-&gt;val); // 加入路径并更新路径和</span><br><span class="line">        sum += root-&gt;val;</span><br><span class="line">        if (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr &amp;&amp; sum == targetSum) &#123; // 到了叶节点且和恰好相同才行</span><br><span class="line">            result.push_back(path);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        val(root-&gt;left, targetSum); </span><br><span class="line">        val(root-&gt;right, targetSum);</span><br><span class="line"></span><br><span class="line">        sum -= path[path.size()-1]; // 去除路径</span><br><span class="line">        path.erase(path.end()-1); // 去除和</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123;</span><br><span class="line">        val(root, targetSum);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>代码随想录的解法  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">    vector&lt;int&gt; path;</span><br><span class="line">    // 递归函数不需要返回值，因为我们要遍历整个树</span><br><span class="line">    void traversal(TreeNode* cur, int count) &#123;</span><br><span class="line">        if (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; count == 0) &#123; // 遇到了叶子节点且找到了和为sum的路径</span><br><span class="line">            result.push_back(path);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!cur-&gt;left &amp;&amp; !cur-&gt;right) return ; // 遇到叶子节点而没有找到合适的边，直接返回</span><br><span class="line"></span><br><span class="line">        if (cur-&gt;left) &#123; // 左 （空节点不遍历）</span><br><span class="line">            path.push_back(cur-&gt;left-&gt;val);</span><br><span class="line">            count -= cur-&gt;left-&gt;val;</span><br><span class="line">            traversal(cur-&gt;left, count);    // 递归</span><br><span class="line">            count += cur-&gt;left-&gt;val;        // 回溯</span><br><span class="line">            path.pop_back();                // 回溯</span><br><span class="line">        &#125;</span><br><span class="line">        if (cur-&gt;right) &#123; // 右 （空节点不遍历）</span><br><span class="line">            path.push_back(cur-&gt;right-&gt;val);</span><br><span class="line">            count -= cur-&gt;right-&gt;val;</span><br><span class="line">            traversal(cur-&gt;right, count);   // 递归</span><br><span class="line">            count += cur-&gt;right-&gt;val;       // 回溯</span><br><span class="line">            path.pop_back();                // 回溯</span><br><span class="line">        &#125;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123;</span><br><span class="line">        result.clear();</span><br><span class="line">        path.clear();</span><br><span class="line">        if (root == NULL) return result;</span><br><span class="line">        path.push_back(root-&gt;val); // 把根节点放进路径</span><br><span class="line">        traversal(root, sum - root-&gt;val);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h2 id="从中序与后序遍历序列构造二叉树"><a href="#从中序与后序遍历序列构造二叉树" class="headerlink" title="从中序与后序遍历序列构造二叉树"></a>从中序与后序遍历序列构造二叉树</h2></li><li><a href="https://programmercarl.com/0106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></li><li><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/">106. 从中序与后序遍历序列构造二叉树 - 力扣（LeetCode）</a></li><li>题意便是根据一颗二叉树的中序和后序来构造二叉树</li><li>方法，利用后序遍历的最后一个点为根，且中序的根左侧为左子树，右侧为右子树，递归下来可得唯一二叉树</li><li>陆爻齐参照代码随想录思路的复制 vector 的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;</span><br><span class="line">        if (postorder.size() == 0) return nullptr;</span><br><span class="line"></span><br><span class="line">        int mid_val = postorder[postorder.size()-1]; // 取当前的中点</span><br><span class="line">        TreeNode *root = new TreeNode(mid_val);</span><br><span class="line"></span><br><span class="line">        int mid_index = 0; // 找中序里面中点位置</span><br><span class="line">        for (int i = 0; i &lt; inorder.size(); i++) &#123;</span><br><span class="line">            if (inorder[i] == mid_val) &#123;</span><br><span class="line">                mid_index = i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 下面切割按左闭右开来算</span><br><span class="line">        // 中序切割顺便去除中点</span><br><span class="line">        vector&lt;int&gt; left_inorder = vector&lt;int&gt;(inorder.begin(), inorder.begin()+mid_index);</span><br><span class="line">        vector&lt;int&gt; right_inorder = vector&lt;int&gt;(inorder.begin()+mid_index+1, inorder.end());</span><br><span class="line">        // 后序要去除最后一个</span><br><span class="line">        vector&lt;int&gt; left_postorder = vector&lt;int&gt;(postorder.begin(), postorder.begin()+mid_index);</span><br><span class="line">        vector&lt;int&gt; right_postorder = vector&lt;int&gt;(postorder.begin()+mid_index, postorder.end()-1);</span><br><span class="line"></span><br><span class="line">        root-&gt;left = buildTree(left_inorder, left_postorder);</span><br><span class="line">        root-&gt;right = buildTree(right_inorder, right_postorder);</span><br><span class="line"></span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>陆爻齐根据上述思路不复制vector只传坐标的优化办法：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;int&gt;inorder;</span><br><span class="line">    vector&lt;int&gt;postorder;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;</span><br><span class="line">        this-&gt;inorder = inorder;</span><br><span class="line">        this-&gt;postorder = postorder;</span><br><span class="line">        TreeNode *root = travel_build(0, inorder.size(), 0, postorder.size());</span><br><span class="line"></span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode *travel_build(int inorder_left, int inorder_right, int postorder_left, int postorder_right) &#123;</span><br><span class="line">        if (inorder_right == inorder_left) return nullptr; // 说明该子树无节点</span><br><span class="line"></span><br><span class="line">        int root_val = this-&gt;postorder[postorder_right-1];</span><br><span class="line">        TreeNode *root = new TreeNode(root_val); // 取本子树的根</span><br><span class="line"></span><br><span class="line">        int left_inorder_count = 0; // 相当于左子树有几个节点</span><br><span class="line">        for (int i = inorder_left; i &lt; inorder_right; i++) &#123;</span><br><span class="line">            if (inorder[i] == root_val) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            left_inorder_count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 中序去中点，后序去末点</span><br><span class="line">        root-&gt;left = travel_build(inorder_left, inorder_left+left_inorder_count, postorder_left, postorder_left+left_inorder_count);</span><br><span class="line">        root-&gt;right = travel_build(inorder_left+left_inorder_count+1, inorder_right, postorder_left+left_inorder_count, postorder_right-1);</span><br><span class="line">        </span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h2 id="从前序与中序遍历序列构造二叉树"><a href="#从前序与中序遍历序列构造二叉树" class="headerlink" title="从前序与中序遍历序列构造二叉树"></a>从前序与中序遍历序列构造二叉树</h2></li><li><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/">105. 从前序与中序遍历序列构造二叉树 - 力扣（LeetCode）</a></li><li>题意，如题</li><li>方法，基本同上，只不过找中点是什么值换成了前序而已，前序的中点在第一个</li><li>陆爻齐在上面方法改出来的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; inorder;</span><br><span class="line">    vector&lt;int&gt; preorder;</span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;</span><br><span class="line">        this-&gt;inorder = inorder;</span><br><span class="line">        this-&gt;preorder = preorder;</span><br><span class="line">        TreeNode *root = travel_build(0, inorder.size(), 0, preorder.size());</span><br><span class="line"></span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode *travel_build(int inorder_left, int inorder_right, int preorder_left, int preorder_right) &#123;</span><br><span class="line">        if (inorder_right == inorder_left) return nullptr; // 说明该子树无节点</span><br><span class="line">        //if (preorder_right &lt;= preorder_left) return nullptr; // 说明该子树无节点</span><br><span class="line">        //cout &lt;&lt; &quot;il:&quot; &lt;&lt; inorder_left &lt;&lt; &quot;; ir:&quot; &lt;&lt; inorder_right &lt;&lt; &quot;; pl:&quot; &lt;&lt; preorder_left &lt;&lt; &quot;; pr:&quot; &lt;&lt; preorder_right &lt;&lt; endl;</span><br><span class="line">        int root_val = this-&gt;preorder[preorder_left];</span><br><span class="line">        TreeNode *root = new TreeNode(root_val); // 取本子树的根</span><br><span class="line">        //cout &lt;&lt; &quot;root:&quot; &lt;&lt; root_val &lt;&lt; endl;</span><br><span class="line">        //cout &lt;&lt; &quot;il:&quot; &lt;&lt; inorder_left &lt;&lt; &quot;; ir:&quot; &lt;&lt; inorder_right &lt;&lt; &quot;; pl:&quot; &lt;&lt; preorder_left &lt;&lt; &quot;; pr:&quot; &lt;&lt; preorder_right &lt;&lt; endl;</span><br><span class="line">        int left_inorder_count = 0; // 相当于左子树有几个节点</span><br><span class="line">        for (int i = inorder_left; i &lt; inorder_right; i++) &#123;</span><br><span class="line">            if (inorder[i] == root_val) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            left_inorder_count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 中序去中点，先序去首个点</span><br><span class="line">        root-&gt;left = travel_build(inorder_left, inorder_left+left_inorder_count, preorder_left+1, preorder_left+1+left_inorder_count);</span><br><span class="line">        root-&gt;right = travel_build(inorder_left+left_inorder_count+1, inorder_right, preorder_left+1+left_inorder_count, preorder_right);</span><br><span class="line">        </span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h2 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h2></li><li><a href="https://programmercarl.com/0654.%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></li><li><a href="https://leetcode.cn/problems/maximum-binary-tree/description/">654. 最大二叉树 - 力扣（LeetCode）</a></li><li>题意：像大顶堆一样，二叉树的根为最大值，左子树根为数组中左边的最大值，右子树同理</li><li>方法，递归取大放根即可，陆爻齐直接写出了下标的简洁解法</li><li>陆爻齐的解法，与代码随想录的优化解法相近<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        // 根据下标构造二叉树，按照左闭右开原则</span><br><span class="line">        TreeNode *result = find_max_build_tree(nums, 0, nums.size());</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode *find_max_build_tree(vector&lt;int&gt; &amp;nums, int left, int right) &#123;</span><br><span class="line">        if (right &lt;= left) return nullptr; //终止条件，即判断的区间为0</span><br><span class="line"></span><br><span class="line">        // 从下标范围找最大值以及下标</span><br><span class="line">        int max_num = INT32_MIN;</span><br><span class="line">        int max_index = left;</span><br><span class="line">        for (int i = left; i &lt; right; i++) &#123;</span><br><span class="line">            if (nums[i] &gt; max_num) &#123;</span><br><span class="line">                max_num = nums[i];</span><br><span class="line">                max_index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 构造本节点下标</span><br><span class="line">        TreeNode *result = new TreeNode(max_num);</span><br><span class="line"></span><br><span class="line">        // 左子树与右子树</span><br><span class="line">        result-&gt;left = find_max_build_tree(nums, left, max_index);</span><br><span class="line">        result-&gt;right = find_max_build_tree(nums, max_index+1, right);</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h2 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h2></li><li><a href="https://programmercarl.com/0617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></li><li><a href="https://leetcode.cn/problems/merge-two-binary-trees/description/">617. 合并二叉树 - 力扣（LeetCode）</a></li><li>题意，两个二叉树相同位置的节点值相加（int），相当于重合一起</li><li>方法，递归算重合，陆爻齐写得繁琐，其实一边为空时，可以直接返回非空部分</li><li>陆爻齐的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) &#123;</span><br><span class="line">        TreeNode *result = nullptr;</span><br><span class="line">        if (root1 || root2) &#123; // 两边有一个非空，那么该节点非空</span><br><span class="line">            if (root1 == nullptr) &#123;</span><br><span class="line">                result = new TreeNode(root2-&gt;val);</span><br><span class="line">                result-&gt;left = mergeTrees(root1, root2-&gt;left);</span><br><span class="line">                result-&gt;right = mergeTrees(root1, root2-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (root2 == nullptr) &#123;</span><br><span class="line">                result = new TreeNode(root1-&gt;val);</span><br><span class="line">                result-&gt;left = mergeTrees(root1-&gt;left, root2);</span><br><span class="line">                result-&gt;right = mergeTrees(root1-&gt;right, root2);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                result = new TreeNode(root1-&gt;val + root2-&gt;val);</span><br><span class="line">                result-&gt;left = mergeTrees(root1-&gt;left, root2-&gt;left);</span><br><span class="line">                result-&gt;right = mergeTrees(root1-&gt;right, root2-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>代码随想录解法  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) &#123;</span><br><span class="line">        if (t1 == NULL) return t2; // 如果t1为空，合并之后就应该是t2</span><br><span class="line">        if (t2 == NULL) return t1; // 如果t2为空，合并之后就应该是t1</span><br><span class="line">        // 修改了t1的数值和结构</span><br><span class="line">        t1-&gt;val += t2-&gt;val;                             // 中</span><br><span class="line">        t1-&gt;left = mergeTrees(t1-&gt;left, t2-&gt;left);      // 左</span><br><span class="line">        t1-&gt;right = mergeTrees(t1-&gt;right, t2-&gt;right);   // 右</span><br><span class="line">        return t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h2 id="二叉搜索树的搜索"><a href="#二叉搜索树的搜索" class="headerlink" title="二叉搜索树的搜索"></a>二叉搜索树的搜索</h2></li><li><a href="https://programmercarl.com/0700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></li><li><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/description/">700. 二叉搜索树中的搜索 - 力扣（LeetCode）</a></li><li>题意：在二叉搜索树上找对应值的节点</li><li>方法，重点是认识二叉搜索树的概念，二叉搜索树的根左子树小于根，右子树大于根，且子树皆满足这个性质，所以搜索很简单，大了就向右，小了向左</li><li>陆爻齐的递归方法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* searchBST(TreeNode* root, int val) &#123;</span><br><span class="line">        if (root == nullptr) return nullptr; // 说明没有这个val 的节点</span><br><span class="line"></span><br><span class="line">        if (root-&gt;val == val) return root;// 找到了</span><br><span class="line">        else if (root-&gt;val &lt; val) return searchBST(root-&gt;right, val); // val偏大</span><br><span class="line">        else return searchBST(root-&gt;left, val); // val偏小</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>陆爻齐的迭代方法  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* searchBST(TreeNode* root, int val) &#123;</span><br><span class="line">        while (root != nullptr) &#123;</span><br><span class="line">            if (root-&gt;val == val) break;</span><br><span class="line">            else if (root-&gt;val &gt; val) root = root-&gt;left;</span><br><span class="line">            else root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h2 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h2></li><li><a href="https://programmercarl.com/0098.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html#%E6%80%9D%E8%B7%AF">代码随想录</a></li><li><a href="https://leetcode.cn/problems/validate-binary-search-tree/description/">98. 验证二叉搜索树 - 力扣（LeetCode）</a></li><li>题意，验证一个二叉树是否为二叉搜索树</li><li>方法，递归查</li><li>陆爻齐参考代码随想录的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    TreeNode *pre = nullptr; // 记录上一个访问节点，由于中序，所以会按二叉搜索左到右</span><br><span class="line">    bool travelTree(TreeNode *root) &#123;</span><br><span class="line">        if (root == nullptr) return true; // 空树也算二叉搜索树</span><br><span class="line"></span><br><span class="line">        bool left = travelTree(root-&gt;left); // 中序</span><br><span class="line">        if (pre != nullptr &amp;&amp; pre-&gt;val &gt;= root-&gt;val) return false;</span><br><span class="line">        pre = root;</span><br><span class="line">        bool right = travelTree(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        return left &amp;&amp; right;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    bool isValidBST(TreeNode* root) &#123;</span><br><span class="line">        return travelTree(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法周记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【软考】上午题8-结构化开发-中级软件设计师备考笔记</title>
      <link href="/posts/4452af47.html"/>
      <url>/posts/4452af47.html</url>
      
        <content type="html"><![CDATA[<ul><li><h2 id="模块独立"><a href="#模块独立" class="headerlink" title="模块独立"></a>模块独立</h2></li><li><p>衡量模块独立程度标准：耦合性、内聚性</p></li><li><p>尽量高内聚，低耦合，提高模块独立性</p></li><li><h2 id="耦合（与模块独立性反比）"><a href="#耦合（与模块独立性反比）" class="headerlink" title="耦合（与模块独立性反比）"></a>耦合（与模块独立性反比）</h2></li><li><p>无直接耦合：无直接关系，耦合性最弱，独立性最高</p></li><li><p>数据耦合，两个模块有调用关系，传递简单数据</p></li><li><p>标记模块，传递数据结构</p></li><li><p>控制耦合，调用另一模块时，传递控制变量</p></li><li><p>外部耦合，通过软件外部环境连接</p></li><li><p>公共耦合，公共数据环境</p></li><li><p>内容耦合，直接用另一模块内的数据，或通过非正常入口转入另一模块内</p></li><li><h2 id="内聚（与模块独立性正比）"><a href="#内聚（与模块独立性正比）" class="headerlink" title="内聚（与模块独立性正比）"></a>内聚（与模块独立性正比）</h2></li><li><p>偶然内聚（巧合内聚），模块内元素之间无联系</p></li><li><p>逻辑内聚，有若干逻辑相似功能，用参数决定哪个</p></li><li><p>时间内聚，把同时执行动作组合</p></li><li><p>过程内聚，按执行过程</p></li><li><p>通信内聚，各元素在同一个数据结构操作</p></li><li><p>顺序内聚，必须顺序执行</p></li><li><p>功能内聚，所用元素共同完成一个功能，缺一不可</p></li><li><h2 id="系统结构设计原则（有个印象）"><a href="#系统结构设计原则（有个印象）" class="headerlink" title="系统结构设计原则（有个印象）"></a>系统结构设计原则（有个印象）</h2></li><li><p>分解协调原则<br>logseq.order-list-type:: number</p></li><li><p>自顶向下的原则<br>logseq.order-list-type:: number</p></li><li><p>信息隐蔽、抽象的原则<br>logseq.order-list-type:: number</p></li><li><p>一致性原则，统一规范、统一标准……<br>logseq.order-list-type:: number</p></li><li><p>明确性原则， 功能明确，接口明确，消除多重功能和无用接口<br>logseq.order-list-type:: number</p></li><li><p>模块耦合应尽可能小，内聚度应尽可能高<br>logseq.order-list-type:: number</p></li><li><p>模块的扇入系数和扇出系数合理（一个模块调用其它模块个数扇出系数），通常3或4，一般不应过7，否则出错概率增大<br>logseq.order-list-type:: number</p></li><li><p>模块规模适当，过大模块使系统分解不充分，过小模块降低模块独立性<br>logseq.order-list-type:: number</p></li><li><p>模块作用范围应在控制范围之内<br>logseq.order-list-type:: number</p></li><li><h2 id="数据流图-DFD"><a href="#数据流图-DFD" class="headerlink" title="数据流图 DFD"></a>数据流图 DFD</h2></li><li><p>顶层数据流图描述系统的输入输出</p></li><li><p>加工必须有输入数据流和输出数据流</p></li><li><p>数据流起点和重点至少一个是加工</p></li><li><p>找错的题，可能出现名字相同的错误</p></li><li><p>数据流类型往往有多种</p></li><li><h2 id="数据字典-DD"><a href="#数据字典-DD" class="headerlink" title="数据字典 DD"></a>数据字典 DD</h2></li><li><p>对DFD中的数据流、文件、加工、构成数据流或文件的数据项做说明，可称为<strong>加工逻辑说明</strong></p></li><li><p>有四类条目，数据流、数据项、数据存储、基本加工（无外部实体）</p></li><li><p>数据项是组成数据流和数据存储的最小项目，起点终点不在系统内，一般不在字典说明。</p></li><li><p>加工逻辑，也称小说明，不用说明具体流程</p><ol><li>结构化语言，外层（顺序、选择、重复）内层</li><li>判定表</li><li>判定树</li></ol></li><li><h2 id="结构化分析结果"><a href="#结构化分析结果" class="headerlink" title="结构化分析结果"></a>结构化分析结果</h2></li><li><p>数据流图、数据字典、小说明、实体联系图</p></li><li><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2></li><li><p>基本元素：模块，调用、数据</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 备战软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【软考】上午题7-设计模式-中级软件设计师备考笔记</title>
      <link href="/posts/4d01a364.html"/>
      <url>/posts/4d01a364.html</url>
      
        <content type="html"><![CDATA[<ul><li>为复用成功的设计采用设计模式</li><li><h2 id="创建型设计模式"><a href="#创建型设计模式" class="headerlink" title="创建型设计模式"></a>创建型设计模式</h2></li><li><h3 id="工厂方法模式（类模式）"><a href="#工厂方法模式（类模式）" class="headerlink" title="工厂方法模式（类模式）"></a>工厂方法模式（类模式）</h3></li><li>意图，定义使类的实例化延迟到子表<br><img src="/../assets/image_1730619622803_0.png" alt="image.png">  </li><li><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3></li><li>意图，创造一系列接口，无需执行他们具体的类，以便让一系列对象联合使用<br><img src="/../assets/image_1730620229122_0.png" alt="image.png">  </li><li>系统独立于产品创建、组成和表示</li><li><h3 id="建造者模式-Builder"><a href="#建造者模式-Builder" class="headerlink" title="建造者模式 Builder"></a>建造者模式 Builder</h3></li><li>意图，将复杂对象的构建和表示分离，同样的构建过程创建不同表示<br><img src="/../assets/image_1730622345220_0.png" alt="image.png">  </li><li><h3 id="原型模式-Prototype"><a href="#原型模式-Prototype" class="headerlink" title="原型模式 Prototype"></a>原型模式 Prototype</h3></li><li>让对象复制自身<br><img src="/../assets/image_1730622524176_0.png" alt="image.png">  </li><li>系统独立于对象创建、构成和表示</li><li><h3 id="单例模式-Singleton"><a href="#单例模式-Singleton" class="headerlink" title="单例模式 Singleton"></a>单例模式 Singleton</h3></li><li>保证类仅有一个实例，提供一个全局访问点</li><li></li><li><h2 id="结构型设计模式"><a href="#结构型设计模式" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h2></li><li><h3 id="适配器模式（可能有类模式，会用的多重继承，但很少）-Adapter"><a href="#适配器模式（可能有类模式，会用的多重继承，但很少）-Adapter" class="headerlink" title="适配器模式（可能有类模式，会用的多重继承，但很少） Adapter"></a>适配器模式（可能有类模式，会用的多重继承，但很少） Adapter</h3></li><li>意图，把一个类接口转换成客户希望的例外一个接口<br><img src="/../assets/image_1730622937283_0.png" alt="image.png">  </li><li>想使用一个已有类的接口，但接口不符合要求</li><li><h3 id="桥接模式-Bridge"><a href="#桥接模式-Bridge" class="headerlink" title="桥接模式 Bridge"></a>桥接模式 Bridge</h3></li><li>意图，将<strong>抽象部分与实现部分</strong>分离<br><img src="/../assets/image_1730623070355_0.png" alt="image.png">  </li><li><h3 id="组合模式-Composite"><a href="#组合模式-Composite" class="headerlink" title="组合模式 Composite"></a>组合模式 Composite</h3></li><li>意图，把对象组合成树型结构表现<strong>部分-整体</strong>的层次结构，使用具有一致性（一个方法处理不同对象）<br><img src="/../assets/image_1730629014485_0.png" alt="image.png">  </li><li><h3 id="装饰模式-Decorator"><a href="#装饰模式-Decorator" class="headerlink" title="装饰模式 Decorator"></a>装饰模式 Decorator</h3></li><li>意图，动态给对象添加一些<strong>额外职责</strong><br><img src="/../assets/image_1730629245920_0.png" alt="image.png">  </li><li>不影响其他对象，动态、透明地给对象添加职责</li><li><h3 id="外观模式-Facade"><a href="#外观模式-Facade" class="headerlink" title="外观模式 Facade"></a>外观模式 Facade</h3></li><li>意图，给子系统的一组接口提供一个一致的界面<br><img src="/../assets/image_1730629619085_0.png" alt="image.png">  </li><li>适用给复杂子系统提供简单接口，以及客户与抽象类实现部分有很大依赖性，还有定义子系统每层入口点</li><li><h3 id="享元模式-Flyweight"><a href="#享元模式-Flyweight" class="headerlink" title="享元模式 Flyweight"></a>享元模式 Flyweight</h3></li><li>意图，支持大量细粒度（细分）对象</li><li>适用使用大量对象，有很大存储开销，删除外部状态，用较少的共享对象代替多组对象</li><li><h3 id="代理模式-Proxy"><a href="#代理模式-Proxy" class="headerlink" title="代理模式 Proxy"></a>代理模式 Proxy</h3></li><li>意图，为其他对象提供代理控制对这个对象的<strong>访问</strong></li><li>适用于用通用复杂的对象指针代替简单的指针</li><li><h2 id="行为型设计模式"><a href="#行为型设计模式" class="headerlink" title="行为型设计模式"></a>行为型设计模式</h2></li><li>PS：解释器和模板方法是类模式</li><li><h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3></li><li>意图，避免请求的发送者和接收者的耦合关系，延链传递请求<br><img src="/../assets/image_1730630606846_0.png" alt="image.png">  </li><li>适用于不明确接收者，自动确定处理请求的对象</li><li><h3 id="命令模式-Command"><a href="#命令模式-Command" class="headerlink" title="命令模式 Command"></a>命令模式 Command</h3></li><li>意图，把请求封装对象，用不同请求对对象<strong>参数化</strong>，对请求排队、日志、撤回操作<br><img src="/../assets/image_1730630922427_0.png" alt="image.png">  </li><li>适用于参数化对象、不同时刻指定排列执行请求、取消操作、修改日志</li><li><h3 id="中介者模式-Mediator"><a href="#中介者模式-Mediator" class="headerlink" title="中介者模式 Mediator"></a>中介者模式 Mediator</h3></li><li>意图，封装一系列<strong>交互</strong><br><img src="/../assets/image_1730631175645_0.png" alt="image.png">  </li><li>适用于对象通信方式复杂</li><li><h3 id="备忘录模式-Memento"><a href="#备忘录模式-Memento" class="headerlink" title="备忘录模式 Memento"></a>备忘录模式 Memento</h3></li><li>意图，不破坏封装性的前提下，捕获对象内部状态，方便回复<br><img src="/../assets/image_1730631377689_0.png" alt="image.png">  </li><li>保存状态，方便恢复</li><li><h3 id="观察者模式-Observer"><a href="#观察者模式-Observer" class="headerlink" title="观察者模式 Observer"></a>观察者模式 Observer</h3></li><li>意图，定义一种一对多的依赖关系，状态改变时，依赖的对象都得到通知并更新（PS subject知道它的观察者）<br><img src="/../assets/image_1730631645526_0.png" alt="image.png">  </li><li>适用于一个对象要改变&#x2F;通知其他对象，不知具体多少对象</li><li><h3 id="状态模式-State"><a href="#状态模式-State" class="headerlink" title="状态模式 State"></a>状态模式 State</h3></li><li>意图，让一个对象在内部状态改变时改变行为<br><img src="/../assets/image_1730632137954_0.png" alt="image.png">  </li><li>适用于用庞大多分支的条件语句，依赖于该对象的状态</li><li><h3 id="策略模式-Strategy"><a href="#策略模式-Strategy" class="headerlink" title="策略模式 Strategy"></a>策略模式 Strategy</h3></li><li>意图，定义一系列算法，封装起来，是算法可以独立于客户端变化<br><img src="/../assets/image_1730632603934_0.png" alt="image.png">  </li><li>适用于相关类仅行为有异，使用一个算法不同变体</li><li><h3 id="模板方法模式-Template-Method"><a href="#模板方法模式-Template-Method" class="headerlink" title="模板方法模式 Template Method"></a>模板方法模式 Template Method</h3></li><li>意图，定义操作的算法骨架<br><img src="/../assets/image_1730632747791_0.png" alt="image.png">  </li><li>父类定义抽象原语操作（基本操作）<br>适用于实现算法不变部分，可变部分子类实现，子类可拓展  </li><li><h3 id="访问者模式-Vistor"><a href="#访问者模式-Vistor" class="headerlink" title="访问者模式 Vistor"></a>访问者模式 Vistor</h3></li><li>意图，对某对象结构中各元素的操作<br><img src="/../assets/image_1730633139947_0.png" alt="image.png">  </li><li>适用于一个对象结构有很多类，有不同的接口，用户对对象实施依赖具体类的操作（多态accept）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 备战软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【软考】上午题6-UML-中级软件设计师备考笔记</title>
      <link href="/posts/6b7d9b2.html"/>
      <url>/posts/6b7d9b2.html</url>
      
        <content type="html"><![CDATA[<ul><li><h2 id="事物（少）"><a href="#事物（少）" class="headerlink" title="事物（少）"></a>事物（少）</h2></li><li>四种：结构事物（静态）、行为事物（动态）、分组事物（其他食物可以放成包）、注释事物（解释部分）</li><li><h2 id="关系（中）"><a href="#关系（中）" class="headerlink" title="关系（中）"></a>关系（中）</h2></li><li>依赖关系，虚线箭头 — &gt; ，若 A依赖B，则A为依赖事物，B为独立事物，A调用 func(B)，也就是独立事物的变化影响依赖事物的语义， 比较偶然一点，比如人依赖食物，吃完就暂时不依赖了</li><li>关联关系，实线箭头 —&gt;，是链，可以标注多重度（0..*）和角色，比依赖更强的关系，比如人关联氧气<br><img src="/../assets/image_1730465661023_0.png" alt="image.png"><br>聚集关系，描述了整体和部分的结构关系，整体和部分生命周期不一致，空心菱形箭头表示<br>组合关系，更强的聚合，整体和部分生命周期一致，实心菱形实线箭头表示  </li><li>泛化关系，父类泛化子类，有带空心箭头的实线，子类指向父类</li><li>实现关系，实现内容实现接口，带空心箭头的虚线</li><li><h2 id="图（多）"><a href="#图（多）" class="headerlink" title="图（多）"></a>图（多）</h2></li><li><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3></li><li>最常见，静态设计视图</li><li>+：public<br>-：private<br>#：protected<br>~：package  </li><li>支持系统功能建模，对<strong>词汇、协作、逻辑数据库</strong>模式建模</li><li><h3 id="对象图"><a href="#对象图" class="headerlink" title="对象图"></a>对象图</h3></li><li>类图的实例的静态快照<br><img src="/../assets/image_1730466935870_0.png" alt="image.png">  </li><li><h3 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h3></li><li>用例、参与者和她们之间关系，静态，对<strong>系统语境&#x2F;需求</strong>建模<br><img src="/../assets/image_1730467128907_0.png" alt="image.png">  </li><li>包含关系：用例和用例之间的关系，一个用例包含另一个用例<br><img src="/../assets/image_1730467388436_0.png" alt="image.png">  </li><li>拓展关系：用例和用例之间的关系，一个用例执行时可能会发生补充用例<br><img src="/../assets/image_1730467560106_0.png" alt="image.png">  </li><li>泛化关系，用例与用例、参与者与参与者的关系<br><img src="/../assets/image_1730467614515_0.png" alt="image.png">  </li><li><h3 id="序列图（顺序图）"><a href="#序列图（顺序图）" class="headerlink" title="序列图（顺序图）"></a>序列图（顺序图）</h3></li><li>描述时间顺序组织的对象交互活动，动态<br><img src="/../assets/image_1730468240834_0.png" alt="image.png"><br>箭头上的函数是调用箭头所指的函数  </li><li>对象生命线，是对象向下的虚线</li><li>控制焦点，是一个瘦高矩形，是执行动作的时间段</li><li><h3 id="通信图（协作图）"><a href="#通信图（协作图）" class="headerlink" title="通信图（协作图）"></a>通信图（协作图）</h3></li><li>强调收发消息对象的结构组织<br><img src="/../assets/image_1730469149338_0.png" alt="image.png"><br>中间是有消息的，消息还有序号  </li><li><h3 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h3></li><li>通常对于一个反应型对象，展现状态机，由状态、转换、时间和活动组成</li><li>状态（圆角矩形）与活动（由若干动作组成）：<br><img src="/../assets/image_1730546331880_0.png" alt="image.png">  </li><li>转换（别名迁移）和事件<br>转换若无事件标注，则内部动作执行完后自动转换，满足监护条件就执行转换<br><img src="/../assets/image_1730547093280_0.png" alt="image.png">  </li><li>组合状态（超状态）：<br>即有一个大状态里面有子状态，即有嵌套的圆角矩形  </li><li>并发状态：<br><img src="/../assets/image_1730547536960_0.png" alt="image.png">  </li><li><h3 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h3></li><li>对工作流、操作建模。从一个活动到另一个活动的流程<br><img src="/../assets/image_1730551060509_0.png" alt="image.png">{:height 494, :width 512}  </li><li><h3 id="构件图（组件图）"><a href="#构件图（组件图）" class="headerlink" title="构件图（组件图）"></a>构件图（组件图）</h3></li><li>一组构件之间的组织和依赖，通常映射为一个或多个类，物理建模，系统静态实现视图<br><img src="/../assets/image_1730552457680_0.png" alt="image.png"><br><img src="/../assets/image_1730552553294_0.png" alt="image.png">  </li><li><h3 id="部署图"><a href="#部署图" class="headerlink" title="部署图"></a>部署图</h3></li><li>对物理方面建模的方法，展现软件和硬件的关系，在实施阶段使用。图记得是立体的就行<br><img src="/../assets/image_1730552676121_0.png" alt="image.png">  </li><li><h3 id="包图"><a href="#包图" class="headerlink" title="包图"></a>包图</h3></li><li>包里可以是类、接口、构件、用例、图，嵌套其它包。<br>一个元素只能被一个包拥有，同一种元素名称唯一<br><img src="/../assets/image_1731070048533_0.png" alt="image.png">  </li><li><h3 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h3></li><li>有个印象比较好<br><img src="/../assets/image_1730552783131_0.png" alt="image.png"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 备战软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【软考】上午题5-面向对象-中级软件设计师备考笔记</title>
      <link href="/posts/cb739acb.html"/>
      <url>/posts/cb739acb.html</url>
      
        <content type="html"><![CDATA[<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ul><li>实体类：核心类，储存信息<br>接口类（边界类）：媒介<br>控制类：控制活动流，协调者  </li><li>一组对象的抽象定义</li><li></li><li><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2></li><li>通常由对象名，属性（状态）、方法（行为）组成</li><li>从属一个类的对象，共享属性与行为</li><li></li><li><h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h2></li><li>对象之间通信的构造（用 set 之类设置对象中的属性也算吧）</li><li></li><li><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2></li><li>是一种信息隐藏技术</li><li>对象是封装数据与行为的整体</li><li></li><li><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2></li><li>父类和子类之间共享非私有化数据和方法的机制</li><li>多重继承可能使成员产生二义性，即父母同时有的属性和方法不知调用哪个</li><li></li><li><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2></li><li>父类指针指子类对象，编译时视作父类，运行时视为子类（继承支持）</li><li>调用时发通用消息，调用不同方法</li><li>参数多态：最纯的多态<br>包含多态：很多语言存在，最常见的是子类型化（一个类型是另一个类型的子类型）<br>过载多态：同一个名字在不同的上下文中代表的含义不同<br>强制多态  </li><li></li><li><h2 id="静态绑定和动态绑定"><a href="#静态绑定和动态绑定" class="headerlink" title="静态绑定和动态绑定"></a>静态绑定和动态绑定</h2></li><li>前者编译时进行的，后者运行时运行的</li><li></li><li><h2 id="面向对象设计的原则"><a href="#面向对象设计的原则" class="headerlink" title="面向对象设计的原则"></a>面向对象设计的原则</h2></li><li>五大原则：<br>单一职责原则：一个类一个责任<br>开放封闭原则：软件实体对拓展开放，对修改封闭<br>里氏替换原则：基类能出现，子类也应该能出现<br>依赖倒置原则：细节应依赖抽象（高层模块和底层模块都依赖细节）<br>接口分离原则：不应给客户不需要的接口  </li><li>补充：<br>共同重用原则：重用包中一个类，应重用包中所有类<br>共同封闭原则：一个变化对一个包有影响，那么包中所有类都应受影响，其他包不受影响<br>稳定抽象原则：包的抽象程度与稳定程度一致<br>稳定依赖原则：所依赖的包比自己更稳定  </li><li></li><li><h2 id="面向对象分析-OOA"><a href="#面向对象分析-OOA" class="headerlink" title="面向对象分析 OOA"></a>面向对象分析 OOA</h2></li><li>认定对象、组织对象、描述对象间相互作用、确定对象操作、定义对象内部信息</li><li>第一步：确认问题域</li><li></li><li><h2 id="面向对象设计-OOD"><a href="#面向对象设计-OOD" class="headerlink" title="面向对象设计 OOD"></a>面向对象设计 OOD</h2></li><li>识别类及对象、定义属性、定义服务、识别关系、识别包</li><li></li><li><h2 id="面向对象测试"><a href="#面向对象测试" class="headerlink" title="面向对象测试"></a>面向对象测试</h2></li><li>四个层次：算法层、类层、模板层、系统层</li><li>算法层：测试类中定义的每个方法，基本相当于传统软件测试的单元测试。<br>类层：测试封装在同一个类中的所有方法与属性之间的相互作用。可以认为是面向对象测试中特有的模块测试。<br>模板层：测试一组协调工作的类之间的相互作用。大体上相当于传统软件测试中的集成测试。<br>系统层：把各个子系统组装成完整的面向对象软件系统-</li></ul>]]></content>
      
      
      <categories>
          
          <category> 备战软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【软考】上午题4-数据库-中级软件设计师备考笔记</title>
      <link href="/posts/a0ba0f45.html"/>
      <url>/posts/a0ba0f45.html</url>
      
        <content type="html"><![CDATA[<ul><li><h1 id="结构数据模型"><a href="#结构数据模型" class="headerlink" title="结构数据模型"></a>结构数据模型</h1></li><li><p>层次模型，用树结构</p></li><li><p>网状模型，用图结构</p></li><li><p>关系模型，用二维表格结构</p></li><li></li><li><h1 id="三级模式结构"><a href="#三级模式结构" class="headerlink" title="三级模式结构"></a>三级模式结构</h1></li><li><p>概念模式（模式） 基本表</p></li><li><p>外模式（用户模式，子模式） 视图</p></li><li><p>内模式 存储文件</p></li><li><p>表示层、业务层、数据层</p></li><li></li><li><h1 id="两级映像"><a href="#两级映像" class="headerlink" title="两级映像"></a>两级映像</h1></li><li><p>模式&#x2F;内模式映像，与物理有关，改物理改映像</p></li><li><p>外模式&#x2F;模式映像，与逻辑有关，改逻辑改映像</p></li><li><p>保证逻辑独立性和物理独立性</p></li><li></li><li><h1 id="关系模式基本知识"><a href="#关系模式基本知识" class="headerlink" title="关系模式基本知识"></a>关系模式基本知识</h1></li><li><p><img src="/../assets/image_1726752375131_0.png" alt="image.png">{:height 338, :width 597}</p></li><li><p>重点是：什么是候选码、主码、主属性</p></li><li></li><li><h1 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h1></li><li><p>实体完整性：主码不能为空或部分为空</p></li><li><p>参照完整性：外码在主码对应，要么找到，要么为空值</p></li><li></li><li><h1 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h1></li><li><p>西塔连接，也就是在笛卡尔积的基础上有比较的筛选</p></li><li><p>等值连接，也就是西塔连接中，&#x3D;</p></li><li><p>自然连接，去除重复属性的等值连接（相同属性相等）</p></li><li><p>外连接：<br>左外连接，沙漏左边有长横，左边信息必须有留，对应右侧若无信息可留空<br>右外连接和全外连接同理  </p></li><li></li><li><p><img src="/../assets/image_1726838414935_0.png" alt="image.png"></p></li><li><p><a href="https://www.bilibili.com/video/BV1LZ4y1k7ma?p=32&vd_source=0e55873fcd6a0d01839a7f7f37c36254">答案</a></p></li><li></li><li><h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1></li><li><p>数据定义语言 DDL</p></li><li><p>数据操纵语言 DML</p></li><li><p>数据查询语言 DQL</p></li><li><p>数据控制语言 DCL</p></li><li></li><li><p>一堆 SQL 的简单填空</p></li><li></li><li><h1 id="SQL-访问控制"><a href="#SQL-访问控制" class="headerlink" title="SQL 访问控制"></a>SQL 访问控制</h1></li><li><p>grant 权限 on 对象 to 用户<br>要是有 with grant option ，那么获取权限的用户还能赋予其他用户权限  </p></li><li><p>revoke 权限 on 对象 from 用户</p></li><li><p>public 是全体用户</p></li><li></li><li><h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1></li><li><p>with check option 操作后保证更新</p></li><li><p>这是个虚拟表，可从一个或多个基本表或视图中导出</p></li><li></li><li><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1></li><li><p>对内模式做修改（存储文件内容）</p></li><li></li><li><h1 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h1></li><li><p>R&lt;U,F&gt; U 是一组属性，F 是一组函数依赖</p></li><li><p>函数依赖 X-&gt;Y<br>非平凡函数依赖 X-&gt;Y, Y不包含于X<br>平凡函数依赖 X-&gt;Y,Y包含于X<br>完全函数依赖 X-&gt;Y,但 X 中任意真子集都不能决定 Y，比如（学号，课程号）-&gt; 成绩<br>传递依赖 X-&gt;Y, Y-&gt;Z，则 Z 对 X 传递依赖  </p></li><li><p>候选码 能决定 U 的最小属性组，可能有多组，多组时选一个为主码，也可说是最小超码<br>超码 能决定 U 的属性组合，比如全码也算，不唯一  </p></li><li><p>阿姆斯特朗公理<br><img src="/../assets/image_1726844503556_0.png" alt="image.png">  </p></li><li></li><li><h1 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h1></li><li><p>第一范式：1NF 要求值域都是原子项，即不可分割的数据项（比如工资还可以分为基础工资和绩效的情况下则不能说是不可分割），不过不能排除数据冗余和更新异常的问题，因为非主属性对候选码可能存在部分函数依赖</p><p>比如：<br><img src="/../assets/image_1727415765983_0.png" alt="image.png"><br>各属性皆为原子项。  </p><p>成绩完全依赖于学号和课程号，但姓名、学院、院长部分依赖于学号，而课程名部分依赖于课程号，存在部分函数依赖  </p></li><li><p>第二范式，在 1NF 的基础上，要求每个非主属性都完全函数依赖于候选码，但仍可能有删除异常或修改异常，因为非主属性对候选码可能有传递函数依赖</p><p>比如<br><img src="/../assets/image_1727416216753_0.png" alt="image.png"><br>在确定学号和课程号为主属性后，就把完全依赖他们的属性分离出来成一个表  </p></li><li><p>第三范式，在 2NF 的基础上，把传递函数依赖的部分取出，再多生成一个表，但主属性对码可能存在部分函数依赖、传递函数依赖</p><p>比如<br><img src="/../assets/image_1727416384831_0.png" alt="image.png">{:height 178, :width 512}<br>发现学院-&gt;院长属于传递数据依赖，可以分离出来  </p></li><li><p>BC范式，BCNF，在3NF的基础上，消除了主属性的部分函数依赖和传递函数依赖</p></li><li><p>例题：<br><img src="/../assets/image_1727443130575_0.png" alt="image.png"><br>判断此题的范式等级，易得满足 2NF，候选码为 （时间，学生），由于伪传递律，（时间，学生）-&gt;课程-&gt;教师，不满足 3NF  </p></li><li></li><li><h2 id="无损连接"><a href="#无损连接" class="headerlink" title="无损连接"></a>无损连接</h2></li><li><p>可以用自然连接恢复</p></li><li></li><li><h2 id="保持函数依赖"><a href="#保持函数依赖" class="headerlink" title="保持函数依赖"></a>保持函数依赖</h2></li><li><p>从题目的角度，只要分离后的关系模式都各自满足已有的函数依赖就行</p></li><li></li><li><p><img src="/../assets/image_1727700514392_0.png" alt="image.png"><br>从此题巩固上面两个点的知识好力，首先，两个分解后的关系模式没有 A4，可见并不能用自然连接恢复，故为有损链接；然后，（A1，A2）两个函数依赖都不满足，（A1，A3）只满足第一个函数依赖，故不保持函数依赖  </p></li><li></li><li><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2></li><li><p>步骤：</p><ol><li>用户需求分析， 确定系统边界，成果为系统需求分析树，包括请求说明文档，数据字典，数据流图</li><li>概念设计 ER图</li><li>逻辑设计 ER图转关系模式，关系规范化</li><li>物理设计 几乎不考</li></ol></li><li></li><li><h2 id="ER图冲突"><a href="#ER图冲突" class="headerlink" title="ER图冲突"></a>ER图冲突</h2></li><li><p>属性冲突，同一属性，在不同的分ER图的类型，数据范围等不一样，需要统一</p></li><li><p>命名冲突，相同含义的数据在不同的分 ER图 有不同的名字，或同一名字的属性在不同的分 ER图 有不同的含义</p></li><li><p>结构冲突，比如某 ER图的属性在另一个 ER 图中分为实体，需要统一</p></li><li></li><li><h2 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h2></li><li><p>原子性，事务要么完成，要么不完成，无中间状态</p></li><li><p>一致性，数据库从一个一致性状态到另一个一致性状态</p></li><li><p>隔离性，事务之间是隔离的</p></li><li><p>持久性，一个提交的事务带来的改变即使数据库崩溃也存在</p></li><li></li><li><h2 id="并发控制技术"><a href="#并发控制技术" class="headerlink" title="并发控制技术"></a>并发控制技术</h2></li><li><p>X锁 排他锁，若事务 T 对数据对象 A 施加排他锁，在该锁被释放前，只有 T 能对 A 做读写操作</p></li><li><p>S锁 共享锁，若事务 T 对数据对象 A 施加共享锁，那么在锁释放前，T 只能读取 A，其它事务也能对 A 加 S 锁来读</p></li><li></li><li><h2 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h2></li><li><p>*分片透明，用户不需要知道访问的表如何分块存放<br>复制透明，用户不需要知道复制过程<br>*位置透明，用户不需要知道数据存放物理位置<br>*逻辑透明，用户不需要知道使用的数据模型  </p></li><li><p>共享性，数据存储在不同节点共享<br>自治性，每节点在本地独立管理<br>*可用性，某个场地故障时，可使用其它场地副本，避免瘫痪<br>分布性，数据在不同场地存储  </p></li><li><h2 id="故障"><a href="#故障" class="headerlink" title="故障"></a>故障</h2></li><li><p>事务故障，事务内程序故障，比如除0</p></li><li><p>系统故障（软故障），造成系统停机的故障，停电等</p></li><li><p>介质故障，可能性最小，破坏性最大，硬盘损坏等</p></li><li><p>计算机病毒</p></li><li></li><li><h2 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h2></li><li><p>存对应视图定义</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 备战软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【软考】上午题3-知识产权-中级软件设计师备考笔记</title>
      <link href="/posts/406184a8.html"/>
      <url>/posts/406184a8.html</url>
      
        <content type="html"><![CDATA[<ul><li><h1 id="著作权"><a href="#著作权" class="headerlink" title="著作权"></a>著作权</h1></li><li><p>有人身权和财产权</p></li><li><p>人身权：署名权、修改权和保护作品完整权等（永久）</p></li><li><p>发表权（时间限制：作者终身及其死亡后五十年）</p></li><li></li><li><h1 id="专利地域性"><a href="#专利地域性" class="headerlink" title="专利地域性"></a>专利地域性</h1></li><li><p>知识产权只在本国领域受法律保护</p></li><li></li><li><h1 id="计算机软件著作权"><a href="#计算机软件著作权" class="headerlink" title="计算机软件著作权"></a>计算机软件著作权</h1></li><li><p>基本法律文件《中华人民共和国著作权法》 《计算机软件保护条例》</p></li><li><p>保护计算机程序及其有关文档</p></li><li><p>计算机程序包括源程序和目标程序</p></li><li><p>文档有流程图啥的</p></li><li><p>《条例》规定著作权人有发表权和发表者身份权（署名权）（无时间限制），还有翻译权（是翻译语言问题，不是换程序设计语言）……</p></li><li><p>软件著作权，保护期为五十年，除开发者身份权，其它权利终止，自作品完成产生</p></li><li><p>若是职务开发（做打工人），开发者只有署名权，其余权力归公司所有（单凡用了公司的设备，也算公司的）</p><ol><li>作品不是执行本职工作的结果</li><li>与工作内容无直接联系</li><li>未使用单位的物质技术条件</li></ol></li><li></li><li><h1 id="委托开发软件著作归属"><a href="#委托开发软件著作归属" class="headerlink" title="委托开发软件著作归属"></a>委托开发软件著作归属</h1></li><li><p>由书面合同约定，若无明确规定，著作权由受托方所有（即实际开发者）</p></li><li></li><li><h1 id="商业秘密权"><a href="#商业秘密权" class="headerlink" title="商业秘密权"></a>商业秘密权</h1></li><li><p>技术信息和经营信息</p></li><li></li><li><h1 id="专利申请"><a href="#专利申请" class="headerlink" title="专利申请"></a>专利申请</h1></li><li><p>两个人及以上向同一个发明申请专利，专利授给最先申请人</p></li><li><p>一个申请一个发明</p></li><li></li><li><h1 id="商标权"><a href="#商标权" class="headerlink" title="商标权"></a>商标权</h1></li><li><p>我国商标权十年有效，但可在期满前六个月内无限申请续展注册10年。</p></li><li></li><li><h1 id="商标申请"><a href="#商标申请" class="headerlink" title="商标申请"></a>商标申请</h1></li><li><p>先申请的得，同时申请的，先使用的得</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 备战软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【软考】上午题2-程序设计语言-中级软件设计师备考笔记</title>
      <link href="/posts/eca642eb.html"/>
      <url>/posts/eca642eb.html</url>
      
        <content type="html"><![CDATA[<ul><li><h1 id="低级语言和高级语言"><a href="#低级语言和高级语言" class="headerlink" title="低级语言和高级语言"></a>低级语言和高级语言</h1></li><li>汇编和机器语言是低级语言</li><li></li><li><h1 id="编译程序和解释程序"><a href="#编译程序和解释程序" class="headerlink" title="编译程序和解释程序"></a>编译程序和解释程序</h1></li><li>解释器：解释源程序不产生独立的目标程序，解释程序和源程序要参与到程序运行过程中<br>编译器：解释源程序产生独立的目标程序，解释程序和源程序不参与到程序运行过程中  </li><li></li><li><h1 id="基本成分"><a href="#基本成分" class="headerlink" title="基本成分"></a>基本成分</h1></li><li>结构：顺序结构、选择结构、循环结构</li><li></li><li><h1 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h1></li><li>词法分析<br>语法分析<br>语义分析<br>中间代码生成<br>代码优化<br>目标代码生成  </li><li>前三步不可省略，前三也是解释器的步骤</li><li>符号表辅助语义正确检查和代码生成，存源程序一些符号的类型、特征等信息</li><li><h2 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h2></li><li>输入源程序视为多行字符串，根据语言词法规则识别符号是否符合规定，输出记号流</li><li></li><li><h2 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h2></li><li>输入记号流，检测语句有无语法错误，分析正确后构造语法树（分析树）</li><li>可以发现所有语法错误</li><li></li><li><h2 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h2></li><li>输入语法树，检测静态语义错误，比如把字符串赋值给整数变量（类型不匹配）</li><li>不能发现所有语义错误，动态语义错误运行时才能发现（比如除法除0）</li><li></li><li><h2 id="目标代码生成"><a href="#目标代码生成" class="headerlink" title="目标代码生成"></a>目标代码生成</h2></li><li>该阶段工作与具体极其密切相关</li><li></li><li><h2 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h2></li><li>与机器无关，可以跨平台，有利于做与机器无关优化处理和提高编译程序可移植性</li><li>最常用与汇编语言相似的三地址码，实现方式为四元式；其他有后缀式，树（图）等形式，三元式</li><li></li><li><h2 id="正规式"><a href="#正规式" class="headerlink" title="正规式"></a>正规式</h2></li><li>语法分析工具</li><li>有点像正则表达式，*会代表闭包（可有0次或多次），|表或</li><li></li><li><h2 id="有限自动机"><a href="#有限自动机" class="headerlink" title="有限自动机"></a>有限自动机</h2></li><li>词法分析工具</li><li>初态：被箭头指向的<br>终态：有两层圈  </li><li>确定的有限自动机（DFA）每个状态识别字符后转移状态唯一<br>不确定的有限自动机（NFA）状态转移可不唯一  </li><li></li><li><h2 id="上下文无关文法"><a href="#上下文无关文法" class="headerlink" title="上下文无关文法"></a>上下文无关文法</h2></li><li>大多数程序设计语言的语法规则</li><li></li><li><h2 id="后缀式-中缀式"><a href="#后缀式-中缀式" class="headerlink" title="后缀式 中缀式"></a>后缀式 中缀式</h2></li><li>中缀式 1 + 2</li><li>后缀式 1 2 +</li><li>优先级相同，从右向左处理</li><li></li><li><h2 id="语法树"><a href="#语法树" class="headerlink" title="语法树"></a>语法树</h2></li><li>这树中序遍历得中缀式，后序遍历得后缀式</li><li></li><li><h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1></li><li>反编译不能得到源程序，只能得到汇编</li><li>可视化程序设计可能要写少量程序代码</li></ul>]]></content>
      
      
      <categories>
          
          <category> 备战软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Weekly Algorithm】算法周记之《代码随想录》二叉树（二）</title>
      <link href="/posts/41847677.html"/>
      <url>/posts/41847677.html</url>
      
        <content type="html"><![CDATA[<h1 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h1><p>本周跟随《代码随想录》学习二叉树的层序遍历，以及对于二叉树的翻转、对称，深度问题等。</p><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><ul><li><h2 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h2></li><li><a href="https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录 (programmercarl.com)</a></li><li><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/">102. 二叉树的层序遍历 - 力扣（LeetCode）</a></li><li>题意就是一层层地从左到右遍历二叉树</li><li>方法就是利用队列，把一层层排进去，一层层遍历，陆爻齐用两个队列实现这个操作，不过通过 for 循环，其实只要一个队列就行</li><li></li><li>陆爻齐的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; rec; // 记录当前要遍历的层</span><br><span class="line">        if (root != nullptr) rec.push(root);</span><br><span class="line"></span><br><span class="line">        while(!rec.empty()) &#123;</span><br><span class="line">            vector&lt;int&gt; rec_val;</span><br><span class="line">            queue&lt;TreeNode*&gt; rec_nextlevel;</span><br><span class="line">            // 遍历一层</span><br><span class="line">            while(!rec.empty()) &#123;</span><br><span class="line">                TreeNode *cur = rec.front();</span><br><span class="line">                rec.pop();</span><br><span class="line"></span><br><span class="line">                if (cur-&gt;left != nullptr) rec_nextlevel.push(cur-&gt;left); // 存储下一层</span><br><span class="line">                if (cur-&gt;right != nullptr) rec_nextlevel.push(cur-&gt;right);</span><br><span class="line"></span><br><span class="line">                rec_val.push_back(cur-&gt;val); // 记录当前层遍历的数值</span><br><span class="line">            &#125;</span><br><span class="line">            result.push_back(rec_val); // 记录一层</span><br><span class="line">            rec = rec_nextlevel; // 准备遍历下一层</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>代码随想录的解法  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        if (root != NULL) que.push(root);</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">        while (!que.empty()) &#123;</span><br><span class="line">            int size = que.size();</span><br><span class="line">            vector&lt;int&gt; vec;</span><br><span class="line">            // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的</span><br><span class="line">            for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                vec.push_back(node-&gt;val);</span><br><span class="line">                if (node-&gt;left) que.push(node-&gt;left);</span><br><span class="line">                if (node-&gt;right) que.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.push_back(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li></li><li><h2 id=""><a href="#" class="headerlink" title=""></a></h2></li><li><h2 id="二叉树的层次遍历-II"><a href="#二叉树的层次遍历-II" class="headerlink" title="二叉树的层次遍历 II"></a>二叉树的层次遍历 II</h2></li><li><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层序遍历 II - 力扣（LeetCode）</a></li><li>题意，在层序遍历的基础上，要求从下向上遍历</li><li>方法，在层序遍历后，把结果翻转下就可以了</li><li>陆爻齐的解法（和代码随想录差不多）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; rec; // 记录当前要遍历的层</span><br><span class="line">        if (root != nullptr) rec.push(root);</span><br><span class="line"></span><br><span class="line">        while(!rec.empty()) &#123;</span><br><span class="line">            vector&lt;int&gt; rec_val;</span><br><span class="line">            queue&lt;TreeNode*&gt; rec_nextlevel;</span><br><span class="line">            // 遍历一层</span><br><span class="line">            while(!rec.empty()) &#123;</span><br><span class="line">                TreeNode *cur = rec.front();</span><br><span class="line">                rec.pop();</span><br><span class="line"></span><br><span class="line">                if (cur-&gt;left != nullptr) rec_nextlevel.push(cur-&gt;left); // 存储下一层</span><br><span class="line">                if (cur-&gt;right != nullptr) rec_nextlevel.push(cur-&gt;right);</span><br><span class="line"></span><br><span class="line">                rec_val.push_back(cur-&gt;val); // 记录当前层遍历的数值</span><br><span class="line">            &#125;</span><br><span class="line">            result.push_back(rec_val); // 记录一层</span><br><span class="line">            rec = rec_nextlevel; // 准备遍历下一层</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(result.begin(),result.end());</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li></li><li><h2 id="二叉树的右视图"><a href="#二叉树的右视图" class="headerlink" title="二叉树的右视图"></a>二叉树的右视图</h2></li><li><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图 - 力扣（LeetCode）</a></li><li>题意，要求输出一个二叉树右边看到的第一层数值，从上往下</li><li>方法，层序遍历时，只保留最后一个值即可</li><li>陆爻齐的解法（代码随想录也差不多）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; rightSideView(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; result;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; rec; // 记录当前要遍历的层</span><br><span class="line">        if (root != nullptr) rec.push(root);</span><br><span class="line"></span><br><span class="line">        while(!rec.empty()) &#123;</span><br><span class="line">            vector&lt;int&gt; rec_val;</span><br><span class="line">            queue&lt;TreeNode*&gt; rec_nextlevel;</span><br><span class="line">            // 遍历一层</span><br><span class="line">            while(!rec.empty()) &#123;</span><br><span class="line">                TreeNode *cur = rec.front();</span><br><span class="line">                rec.pop();</span><br><span class="line"></span><br><span class="line">                if (cur-&gt;left != nullptr) rec_nextlevel.push(cur-&gt;left); // 存储下一层</span><br><span class="line">                if (cur-&gt;right != nullptr) rec_nextlevel.push(cur-&gt;right);</span><br><span class="line"></span><br><span class="line">                rec_val.push_back(cur-&gt;val); // 记录当前层遍历的数值</span><br><span class="line">            &#125;</span><br><span class="line">            result.push_back(rec_val.back()); // 记录一层的最后一个</span><br><span class="line">            rec = rec_nextlevel; // 准备遍历下一层</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li></li><li><h2 id="二叉树的层平均值"><a href="#二叉树的层平均值" class="headerlink" title="二叉树的层平均值"></a>二叉树的层平均值</h2></li><li><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/description/">637. 二叉树的层平均值 - 力扣（LeetCode）</a></li><li>题意，即求每一层的均值</li><li>方法，层序遍历基础上，记录每层均值保存即可</li><li>陆爻齐解法（和代码随想录差不多）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;double&gt; averageOfLevels(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;double&gt; result;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; rec; // 记录当前要遍历的层</span><br><span class="line">        if (root != nullptr) rec.push(root);</span><br><span class="line"></span><br><span class="line">        while(!rec.empty()) &#123;</span><br><span class="line">            vector&lt;int&gt; rec_val;</span><br><span class="line">            queue&lt;TreeNode*&gt; rec_nextlevel;</span><br><span class="line">            double sum = 0;</span><br><span class="line">            double count = 0;</span><br><span class="line">            // 遍历一层</span><br><span class="line">            while(!rec.empty()) &#123;</span><br><span class="line">                TreeNode *cur = rec.front();</span><br><span class="line">                </span><br><span class="line">                rec.pop();</span><br><span class="line"></span><br><span class="line">                if (cur-&gt;left != nullptr) rec_nextlevel.push(cur-&gt;left); // 存储下一层</span><br><span class="line">                if (cur-&gt;right != nullptr) rec_nextlevel.push(cur-&gt;right);</span><br><span class="line"></span><br><span class="line">                //rec_val.push_back(cur-&gt;val); // 记录当前层遍历的数值</span><br><span class="line">                sum += cur-&gt;val;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            result.push_back(sum / count); // 记录一层</span><br><span class="line">            rec = rec_nextlevel; // 准备遍历下一层</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li></li><li><h2 id="N-叉树的层序遍历"><a href="#N-叉树的层序遍历" class="headerlink" title="N 叉树的层序遍历"></a>N 叉树的层序遍历</h2></li><li>题意，如题</li><li>方法，把普通二叉树的层序遍历，中下一层的添加，换成遍历其孩子就行</li><li>陆爻齐的解法（和代码随想录相近）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">// Definition for a Node.</span><br><span class="line">class Node &#123;</span><br><span class="line">public:</span><br><span class="line">    int val;</span><br><span class="line">    vector&lt;Node*&gt; children;</span><br><span class="line"></span><br><span class="line">    Node() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Node(int _val) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        children = _children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line"></span><br><span class="line">        queue&lt;Node*&gt; rec; // 记录当前要遍历的层</span><br><span class="line">        if (root != nullptr) rec.push(root);</span><br><span class="line"></span><br><span class="line">        while(!rec.empty()) &#123;</span><br><span class="line">            vector&lt;int&gt; rec_val;</span><br><span class="line">            queue&lt;Node*&gt; rec_nextlevel;</span><br><span class="line">            // 遍历一层</span><br><span class="line">            while(!rec.empty()) &#123;</span><br><span class="line">                Node *cur = rec.front();</span><br><span class="line">                rec.pop();</span><br><span class="line">                // 存储下一层</span><br><span class="line">                for (Node *tmp : cur-&gt;children) &#123;</span><br><span class="line">                    if (tmp != nullptr) &#123;</span><br><span class="line">                        rec_nextlevel.push(tmp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                rec_val.push_back(cur-&gt;val); // 记录当前层遍历的数值</span><br><span class="line">            &#125;</span><br><span class="line">            result.push_back(rec_val); // 记录一层</span><br><span class="line">            rec = rec_nextlevel; // 准备遍历下一层</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li></li><li><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2></li><li><h2 id="在每个树行中找最大值"><a href="#在每个树行中找最大值" class="headerlink" title="在每个树行中找最大值"></a>在每个树行中找最大值</h2></li><li><a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/submissions/573871357/">515. 在每个树行中找最大值 - 力扣（LeetCode）</a></li><li>题意，找出二叉树中每层的最大值</li><li>方法，就是在层序遍历的基础上，去记录每层的最大值</li><li>陆爻齐的解法（与代码随想录差不多）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; largestValues(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; result;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; rec; // 记录当前要遍历的层</span><br><span class="line">        if (root != nullptr) rec.push(root);</span><br><span class="line"></span><br><span class="line">        while(!rec.empty()) &#123;</span><br><span class="line">            vector&lt;int&gt; rec_val;</span><br><span class="line">            queue&lt;TreeNode*&gt; rec_nextlevel;</span><br><span class="line">            int max_num = INT32_MIN;</span><br><span class="line">            // 遍历一层</span><br><span class="line">            while(!rec.empty()) &#123;</span><br><span class="line">                TreeNode *cur = rec.front();</span><br><span class="line">                </span><br><span class="line">                rec.pop();</span><br><span class="line"></span><br><span class="line">                if (cur-&gt;left != nullptr) rec_nextlevel.push(cur-&gt;left); // 存储下一层</span><br><span class="line">                if (cur-&gt;right != nullptr) rec_nextlevel.push(cur-&gt;right);</span><br><span class="line"></span><br><span class="line">                //rec_val.push_back(cur-&gt;val); // 记录当前层遍历的数值</span><br><span class="line">                if (cur-&gt;val &gt; max_num) &#123;</span><br><span class="line">                    max_num = cur-&gt;val;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.push_back(max_num); // 记录一层</span><br><span class="line">            rec = rec_nextlevel; // 准备遍历下一层</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li></li><li><h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2></li><li><h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2></li><li><h2 id="填充每个节点的下一个右侧节点指针"><a href="#填充每个节点的下一个右侧节点指针" class="headerlink" title="填充每个节点的下一个右侧节点指针"></a>填充每个节点的下一个右侧节点指针</h2></li><li><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针 - 力扣（LeetCode）</a></li><li>题意，让二叉树的每个节点都指向其右侧节点，无则指空</li><li>方法，在层序遍历中，取点让其指右即可，代码随想录中用 for 循环看着挺复杂的样子，其实只是他专门区分了第一个点和其它点</li><li>陆爻齐的解法（这次和代码随想录有点差别）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">// Definition for a Node.</span><br><span class="line">class Node &#123;</span><br><span class="line">public:</span><br><span class="line">    int val;</span><br><span class="line">    Node* left;</span><br><span class="line">    Node* right;</span><br><span class="line">    Node* next;</span><br><span class="line"></span><br><span class="line">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Node(int _val, Node* _left, Node* _right, Node* _next)</span><br><span class="line">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    Node* connect(Node* root) &#123;</span><br><span class="line">        //vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line"></span><br><span class="line">        queue&lt;Node*&gt; rec; // 记录当前要遍历的层</span><br><span class="line">        if (root != nullptr) rec.push(root);</span><br><span class="line"></span><br><span class="line">        while(!rec.empty()) &#123;</span><br><span class="line">            vector&lt;int&gt; rec_val;</span><br><span class="line">            queue&lt;Node*&gt; rec_nextlevel;</span><br><span class="line">            // 遍历一层</span><br><span class="line">            while(!rec.empty()) &#123;</span><br><span class="line">                Node *cur = rec.front();</span><br><span class="line">                rec.pop();</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">                if (cur-&gt;left != nullptr) rec_nextlevel.push(cur-&gt;left); // 存储下一层</span><br><span class="line">                if (cur-&gt;right != nullptr) rec_nextlevel.push(cur-&gt;right);</span><br><span class="line"></span><br><span class="line">                rec_val.push_back(cur-&gt;val); // 记录当前层遍历的数值</span><br><span class="line">                </span><br><span class="line">                // 让每个节点指右边（无则指空）</span><br><span class="line">                if (!rec.empty()) &#123;</span><br><span class="line">                    cur-&gt;next = rec.front();</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    cur-&gt;next = nullptr;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //result.push_back(rec_val); // 记录一层</span><br><span class="line">            rec = rec_nextlevel; // 准备遍历下一层</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>代码随想录的解法  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    Node* connect(Node* root) &#123;</span><br><span class="line">        queue&lt;Node*&gt; que;</span><br><span class="line">        if (root != NULL) que.push(root);</span><br><span class="line">        while (!que.empty()) &#123;</span><br><span class="line">            int size = que.size();</span><br><span class="line">            // vector&lt;int&gt; vec;</span><br><span class="line">            Node* nodePre;</span><br><span class="line">            Node* node;</span><br><span class="line">            for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">                if (i == 0) &#123;</span><br><span class="line">                    nodePre = que.front(); // 取出一层的头结点</span><br><span class="line">                    que.pop();</span><br><span class="line">                    node = nodePre;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    node = que.front();</span><br><span class="line">                    que.pop();</span><br><span class="line">                    nodePre-&gt;next = node; // 本层前一个节点next指向本节点</span><br><span class="line">                    nodePre = nodePre-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                if (node-&gt;left) que.push(node-&gt;left);</span><br><span class="line">                if (node-&gt;right) que.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            nodePre-&gt;next = NULL; // 本层最后一个节点指向NULL</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li></li><li><h2 id="-4"><a href="#-4" class="headerlink" title=""></a></h2></li><li><h2 id="填充每个节点的下一个右侧节点指针II"><a href="#填充每个节点的下一个右侧节点指针II" class="headerlink" title="填充每个节点的下一个右侧节点指针II"></a>填充每个节点的下一个右侧节点指针II</h2></li><li>题意，和上一题差不多，不过面对的二叉树不是完美二叉树</li><li>方法，和上一题一样，不知此题有何意义</li><li>解法略，同上</li><li></li><li><h2 id="-5"><a href="#-5" class="headerlink" title=""></a></h2></li><li><h2 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h2></li><li>题意，即找出二叉树的根节点与其最远叶节点的距离</li><li>方法，层序遍历时，记录层数即可</li><li>陆爻齐的解法（和代码随想录差不多）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxDepth(TreeNode* root) &#123;</span><br><span class="line">        int depth = 0;</span><br><span class="line">        queue&lt;TreeNode*&gt; rec; // 记录当前要遍历的层</span><br><span class="line">        if (root != nullptr) &#123;</span><br><span class="line">            rec.push(root);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        while(!rec.empty()) &#123;</span><br><span class="line">            vector&lt;int&gt; rec_val;</span><br><span class="line">            queue&lt;TreeNode*&gt; rec_nextlevel;</span><br><span class="line">            depth++;</span><br><span class="line">            // 遍历一层</span><br><span class="line">            while(!rec.empty()) &#123;</span><br><span class="line">                TreeNode *cur = rec.front();</span><br><span class="line">                rec.pop();</span><br><span class="line"></span><br><span class="line">                if (cur-&gt;left != nullptr) rec_nextlevel.push(cur-&gt;left); // 存储下一层</span><br><span class="line">                if (cur-&gt;right != nullptr) rec_nextlevel.push(cur-&gt;right);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            rec = rec_nextlevel; // 准备遍历下一层</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li></li><li><h2 id="-6"><a href="#-6" class="headerlink" title=""></a></h2></li><li><h2 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h2></li><li><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度 - 力扣（LeetCode）</a></li><li>题目要求，找到最小深度，即第一个叶子节点出现的层数</li><li>方法，每个点检测下，若是叶子节点，则返回当前层数，代码随想录的解法相对陆爻齐的解法重复检测孩子是否为空，陆爻齐 win ：）</li><li>陆爻齐的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minDepth(TreeNode* root) &#123;</span><br><span class="line">        int depth = 0;</span><br><span class="line">        queue&lt;TreeNode*&gt; rec; // 记录当前要遍历的层</span><br><span class="line">        if (root != nullptr) &#123;</span><br><span class="line">            rec.push(root);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        while(!rec.empty()) &#123;</span><br><span class="line">            vector&lt;int&gt; rec_val;</span><br><span class="line">            queue&lt;TreeNode*&gt; rec_nextlevel;</span><br><span class="line">            depth++;</span><br><span class="line">            // 遍历一层</span><br><span class="line">            while(!rec.empty()) &#123;</span><br><span class="line">                TreeNode *cur = rec.front();</span><br><span class="line">                rec.pop();</span><br><span class="line">                int count = 0; // 记录有无孩子</span><br><span class="line"></span><br><span class="line">                // 存储下一层</span><br><span class="line">                if (cur-&gt;left != nullptr) &#123;</span><br><span class="line">                    rec_nextlevel.push(cur-&gt;left); </span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                if (cur-&gt;right != nullptr) &#123;</span><br><span class="line">                    rec_nextlevel.push(cur-&gt;right);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 找到了第一个叶子节点</span><br><span class="line">                if (count == 0) &#123;</span><br><span class="line">                    return depth;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            rec = rec_nextlevel; // 准备遍历下一层</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>代码随想录的解法  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minDepth(TreeNode* root) &#123;</span><br><span class="line">        if (root == NULL) return 0;</span><br><span class="line">        int depth = 0;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.push(root);</span><br><span class="line">        while(!que.empty()) &#123;</span><br><span class="line">            int size = que.size();</span><br><span class="line">            depth++; // 记录最小深度</span><br><span class="line">            for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                if (node-&gt;left) que.push(node-&gt;left);</span><br><span class="line">                if (node-&gt;right) que.push(node-&gt;right);</span><br><span class="line">                if (!node-&gt;left &amp;&amp; !node-&gt;right) &#123; // 当左右孩子都为空的时候，说明是最低点的一层了，退出</span><br><span class="line">                    return depth;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><ul><li><a href="https://programmercarl.com/0226.%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E6%8B%93%E5%B1%95">代码随想录</a></li><li><a href="https://leetcode.cn/problems/invert-binary-tree/description/">226. 翻转二叉树 - 力扣（LeetCode）</a></li><li>题意，把整个二叉树左右翻转</li><li>方法，其实把每个节点的左右子树交换即可</li><li>陆爻齐的方法（类似前序）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* invertTree(TreeNode* root) &#123;</span><br><span class="line">        // 终止条件</span><br><span class="line">        if (root == nullptr) return root;</span><br><span class="line"></span><br><span class="line">        // 交换左右子树</span><br><span class="line">        TreeNode *tmp = root-&gt;left;</span><br><span class="line">        root-&gt;left = root-&gt;right;</span><br><span class="line">        root-&gt;right = tmp;</span><br><span class="line">        // 递归翻转</span><br><span class="line">        if (root-&gt;left != nullptr) invertTree(root-&gt;left);</span><br><span class="line">        if (root-&gt;right != nullptr) invertTree(root-&gt;right);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>代码随想录补充的类中序方法  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* invertTree(TreeNode* root) &#123;</span><br><span class="line">        if (root == NULL) return root;</span><br><span class="line">        invertTree(root-&gt;left);         // 左</span><br><span class="line">        swap(root-&gt;left, root-&gt;right);  // 中</span><br><span class="line">        invertTree(root-&gt;left);         // 注意 这里依然要遍历左孩子，因为中间节点已经翻转了</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><ul><li><a href="https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E6%80%9D%E8%B7%AF">代码随想录</a></li><li><a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树 - 力扣（LeetCode）</a></li><li>题意，判断二叉树是否沿中间水平对称</li><li>方法，注意不是判断一个节点的左右子树是否相等，而是判断左子树的右子树与右子树的左子树以及左子树的左子树和右子树的右子树是否相等。</li><li>陆爻齐参照代码随想录的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSymmetric(TreeNode* root) &#123;</span><br><span class="line">        if (root == nullptr) return true;</span><br><span class="line">        return compare(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool compare(TreeNode *left, TreeNode *right) &#123;</span><br><span class="line">        // 判断两节点是否空的相同情况或值不同的情况</span><br><span class="line">        if (left == nullptr &amp;&amp; right == nullptr) return true;</span><br><span class="line">        else if (left != nullptr &amp;&amp; right == nullptr) return false;</span><br><span class="line">        else if (left == nullptr &amp;&amp; right != nullptr) return false;</span><br><span class="line">        else if (left-&gt;val != right-&gt;val) return false;</span><br><span class="line"></span><br><span class="line">        // 剩下已是两个节点存在且数值相同，因此要判断他们子树情况</span><br><span class="line">        bool inSide = compare(left-&gt;right, right-&gt;left);</span><br><span class="line">        bool outSide = compare(left-&gt;left, right-&gt;right);</span><br><span class="line">        bool isSame = inSide &amp;&amp; outSide;</span><br><span class="line">        return isSame;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="浅谈二叉树的深度和高度"><a href="#浅谈二叉树的深度和高度" class="headerlink" title="浅谈二叉树的深度和高度"></a>浅谈二叉树的深度和高度</h2><ul><li><p><a href="https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p></li><li><p>二叉树的深度指根节点到叶子节点的最大距离，计算时相当于从上往下，1、2、3……这么数；</p><p>二叉树的高度，指一个节点到叶子节点的最大距离，计算时相当于从下往上数  </p></li><li><p>易得，深度适合用前序遍历，而高度适合用后序遍历</p></li><li><p>根节点的高度就是二叉树的深度</p></li></ul><h2 id="二叉树的最大深度-1"><a href="#二叉树的最大深度-1" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h2><ul><li><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/">104. 二叉树的最大深度 - 力扣（LeetCode）</a></li><li>题意，即求根节点到叶节点的最长距离</li><li>方法，此题在[[二叉树的层序遍历]]有所描述，用层序遍历即可解决，但这里再介绍下递归方法</li><li>陆爻齐参照代码随想录的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxDepth(TreeNode* root) &#123;</span><br><span class="line">        if (root == nullptr) return 0;</span><br><span class="line">        int left_depth = maxDepth(root-&gt;left);</span><br><span class="line">        int right_depth = maxDepth(root-&gt;right);</span><br><span class="line">        int max_depth = max(left_depth,right_depth);</span><br><span class="line">        return 1+max_depth;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="N-叉树的最大深度"><a href="#N-叉树的最大深度" class="headerlink" title="N 叉树的最大深度"></a>N 叉树的最大深度</h2><ul><li>题意，求 N 叉树的最大深度</li><li>方法，和上题类似，只要把遍历孩子时用循环遍历完即可</li><li>陆爻齐的解法（和代码随想录类似）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">// Definition for a Node.</span><br><span class="line">class Node &#123;</span><br><span class="line">public:</span><br><span class="line">    int val;</span><br><span class="line">    vector&lt;Node*&gt; children;</span><br><span class="line"></span><br><span class="line">    Node() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Node(int _val) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        children = _children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int max_depth = 0;</span><br><span class="line">    int maxDepth(Node* root) &#123;</span><br><span class="line">        search_depth(root, 0);</span><br><span class="line">        return max_depth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    void search_depth(Node *root, int depth) &#123;</span><br><span class="line">        if (root == nullptr) return;</span><br><span class="line">        depth++; // 当前层非零，深度加一</span><br><span class="line"></span><br><span class="line">        // 遍历孩子，算 DFS</span><br><span class="line">        for (Node *child : root-&gt;children) &#123;</span><br><span class="line">            search_depth(child, depth);</span><br><span class="line">        &#125;</span><br><span class="line">        // 更新层数</span><br><span class="line">        if (depth &gt; max_depth) &#123;</span><br><span class="line">            max_depth = depth;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="二叉树的最小深度-1"><a href="#二叉树的最小深度-1" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h2><ul><li><a href="https://programmercarl.com/0111.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6.html#%E6%80%9D%E8%B7%AF">代码随想录</a></li><li><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/">111. 二叉树的最小深度 - 力扣（LeetCode）</a></li><li>题意：求二叉树的最小深度，最小深度就是根节点到叶子节点（无左子树和右子树的节点）</li><li>方法：也可用层序遍历解决，[[二叉树的层序遍历]]，这里也要介绍下递归方法，与[[二叉树的最大深度]]有些许差别，在于对待非叶子节点的方式需要单独设置，尤其是有一侧空的节点，只要另一侧的深度即可</li><li>陆爻齐参考代码随想录的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minDepth(TreeNode* root) &#123;</span><br><span class="line">        return getDepth(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int getDepth(TreeNode *root) &#123;</span><br><span class="line">        if (root == nullptr) return 0;</span><br><span class="line">        int left_depth = getDepth(root-&gt;left);</span><br><span class="line">        int right_depth = getDepth(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        // 对于有一个点位空的点，不算叶节点，故只传另一侧的深度</span><br><span class="line">        if (left_depth == 0 &amp;&amp; right_depth &gt; 0) return 1 + right_depth;</span><br><span class="line">        if(left_depth &gt; 0 &amp;&amp; right_depth == 0) return 1 + left_depth;</span><br><span class="line"></span><br><span class="line">        int min_depth = min(left_depth, right_depth);</span><br><span class="line">        return 1 + min_depth; // 加上本层的点（+1）</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法周记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【软考】上午题1_计算机系统_中级软件设计师备考笔记</title>
      <link href="/posts/f0940df9.html"/>
      <url>/posts/f0940df9.html</url>
      
        <content type="html"><![CDATA[<ul><li><h1 id="计算机系统硬件"><a href="#计算机系统硬件" class="headerlink" title="计算机系统硬件"></a>计算机系统硬件</h1></li><li><p>由运算器，控制器，存储器，和输入输出设备五大部件组成</p></li><li></li><li><h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1></li><li><p>是硬件系统核心</p></li><li></li><li><h2 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h2></li><li><p>*算术逻辑单元（ALU），可以算术运算和逻辑运算<br>*累加寄存器（AC），简称累加器，暂存运算中的数字<br>数据缓冲寄存器（DR）作为 CPU 和内存、外部设备的中转站，也可兼做寄存器<br>状态条件寄存器（PSW），保存运算结果建立各种条件码内容  </p></li><li></li><li><h2 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h2></li><li><p>不仅保证程序（指令）的正确执行，也要能够处理异常事件</p></li><li><p>指令寄存器（IR）暂存正在执行指令，指令从内存先到 DR，再到 IR （对用户完全透明，不能访问）（注意所存的是指令，不是指令地址）<br>*程序计数器（PC）有寄存信息和计数两个功能，保存要执行下一条指令地址<br>地址寄存器（AR）保存 CPU 正在访问内存地址<br>指令译码器（ID）翻译指令的操作码来执行  </p></li><li><p><img src="/../assets/image_1725456321433_0.png" alt="image.png"></p></li><li><p><a href="https://www.bilibili.com/video/BV1ym4y1D7RW/?p=15&vd_source=0e55873fcd6a0d01839a7f7f37c36254">答案</a></p></li><li></li><li><h1 id="计算机基本单位"><a href="#计算机基本单位" class="headerlink" title="计算机基本单位"></a>计算机基本单位</h1></li><li><p>位（比特） bit b</p></li><li><p>字节 byte B</p></li><li><p>1B &#x3D; 8b</p></li><li><p>最小数据单位 bit</p></li><li><p>最小存储单位 byte</p></li><li></li><li><h1 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h1></li><li><p>十（D）</p></li><li><p>二（B）</p></li><li><p>八（O）</p></li><li><p>十六（H）</p></li><li><p>计算区域时，记得求其大小，要大数减小数加一</p></li><li><p><img src="/../assets/image_1725539546802_0.png" alt="image.png">{:height 132, :width 717}</p></li><li><p><a href="https://www.bilibili.com/video/BV1ym4y1D7RW/?p=25&vd_source=0e55873fcd6a0d01839a7f7f37c36254">答案</a></p></li><li></li><li><h1 id="原码-反码-补码"><a href="#原码-反码-补码" class="headerlink" title="原码 反码 补码"></a>原码 反码 补码</h1></li><li><p>原码最高位是符号位，分+0和-0</p></li><li><p>反码最高位也符号位，其余位正数与原码相同，负数与原码相反</p></li><li><p>补码最高位也符号位，其余位正数与原码相同，负数为反码加一</p></li><li><p>补码的补码是原码</p></li><li><p>当 n&#x3D;8<br>原码和反码皆为 -127<del>127<br>补码和移码皆为 -128</del>127（补码和移码可以多一个最小负数）  </p></li><li><p>补码和移码各自+-0编码相同</p></li><li><p>计算机采用补码可以简化计算机运算部件的设计</p></li><li><p><img src="/../assets/image_1726138527915_0.png" alt="image.png"></p></li><li></li><li></li><li><h1 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h1></li><li><p>计算先对阶，小阶对大阶（大阶对小阶误差会大）</p></li><li><p>表示范围由阶码决定，精度由尾数决定、</p></li><li><p>规格化，位数绝对值在0.5到1之间</p></li><li><p>阶符+阶码+数符+尾数</p></li><li><p><img src="/../assets/image_1725890341364_0.png" alt="image.png">{:height 149, :width 512}</p></li><li><p><a href="https://www.bilibili.com/video/BV1ym4y1D7RW/?p=47&spm_id_from=pageDriver&vd_source=0e55873fcd6a0d01839a7f7f37c36254">答案</a></p></li><li></li><li><h1 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h1></li><li><p>常考<br>立即寻址<br>直接寻址<br>寄存器寻址<br>寄存器间接寻址<br>间接寻址  </p></li><li></li><li><h1 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h1></li><li><p>码距为2，可检错，不能纠错（码距&gt;&#x3D;3有纠错能力）</p></li><li><p>有水平、垂直和水平垂直奇偶校验码</p></li><li></li><li><h1 id="海明码"><a href="#海明码" class="headerlink" title="海明码"></a>海明码</h1></li><li><p>码距为 3</p></li><li><p>有 n 位数据位， k 位校验位，满足 2^k - 1 &gt;&#x3D; n + k</p></li><li></li><li><h1 id="循环冗余校验码"><a href="#循环冗余校验码" class="headerlink" title="循环冗余校验码"></a>循环冗余校验码</h1></li><li><p>码距为2，可检错，不能纠错</p></li><li><p>在 k 为信息码后直接拼接 r 位校验位</p></li><li><p>k 位数据位和 r 位校验位，编码长度 k+r</p></li><li><p>求 CRC 编码采用模 2 运算</p></li><li></li><li><h1 id="RISC-和-CISC"><a href="#RISC-和-CISC" class="headerlink" title="RISC 和 CISC"></a>RISC 和 CISC</h1></li><li><p>名字：精简指令计算机 和 复杂指令计算机</p></li><li><p>指令长度：指令长度固定 指令长度变化</p></li><li><p>寄存器数量：大量通用寄存器 一般数量通用寄存器</p></li><li><p>寻址方式：少 多</p></li><li><p>实现（编码）方式：硬布线控制逻辑（组合逻辑控制器） 微程序控制技术</p></li><li><p>流水线：支持 不支持（待定）</p></li><li></li><li><h1 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h1></li><li><p>公式：一条指令时间 + （n-1）* 最长时间段（好几条指令中，用时最长的）</p></li><li><p>加速比：不采用流水线时间 &#x2F; 采用流水线时间</p></li><li><p>操作周期：最长时间段</p></li><li><p>吞吐率：指令条数 &#x2F; 流水线执行时间</p></li><li><p>异步控制不会提高性能</p></li><li></li><li><h1 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h1></li><li><p>层次结构：<br>CPU（通用寄存器）<br>Cache<br>主存 （DRAM SRAM）<br>外存  </p></li><li><p>分类：<br>RAM 可读可写<br>ROM 可读<br>闪存为块为单位，整块闪存可以数秒内删除，快于 EPROM（可替ROM）  </p></li><li><p>SRAM 集成度低 价格高 速度快<br>DRAM 集成度高 价格低 速度稍慢 要动态刷新  </p></li><li><p>相联存储器是一种按内容访问存储器（与之相对，大部分按地址访问）</p></li><li><p>寻址方式：随机存储器（RAM）顺序存储器（SAM）直接存储器（DAM）</p></li><li><p>虚拟存储器由主存 辅存构成</p></li><li></li><li><h1 id="高速缓存-Cache"><a href="#高速缓存-Cache" class="headerlink" title="高速缓存 Cache"></a>高速缓存 Cache</h1></li><li><p>对程序员是透明的</p></li><li><p>用替换算法提高命中率</p></li><li><p>地址映像：<br>直接映射：一个主存固定对应一部分块<br>全相联映像：各个主存块可对应各个块<br>组相联映像：各组 Cache 与主存直接映像，组内全相联映像  </p></li><li><p>*Cache 与主存地址的映射是由硬件自动完成</p></li><li></li><li><h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1></li><li><p>中断向量（中断服务程序的入口地址）</p></li><li><p>（所有中断服务程序的入口地址汇集为中断向量表）</p></li><li><p>中断响应时间：发出中断请求开始，到进入中断服务程序</p></li><li><p>保护现场：返回执行源程序</p></li><li></li><li><h1 id="输入输出控制方式"><a href="#输入输出控制方式" class="headerlink" title="输入输出控制方式"></a>输入输出控制方式</h1></li><li><p>程序执行方式<br>logseq.order-list-type:: number<br>CPU 与 IO 串行工作，CPU 长期处于忙等状态，CPU 利用率低，一次读写一个字（8bit）  </p></li><li><p>中断驱动方式<br>logseq.order-list-type:: number<br>IO 用中断报告操作完成，IO 与 CPU 可并行工作  </p></li><li><p>直接存储器方式（DMA）<br>logseq.order-list-type:: number<br>CPU 与 IO 并行工作，传输数据块的开始和结束才需要 CPU 干预，一次读写单位为块（比字大），数据由 DMA 放入内存  </p></li><li></li><li><h1 id="总线（很杂，1-分，还不一定考）"><a href="#总线（很杂，1-分，还不一定考）" class="headerlink" title="总线（很杂，1 分，还不一定考）"></a>总线（很杂，1 分，还不一定考）</h1></li><li><p>数据总线、地址总线、控制总线</p></li><li><p>PCI，目前微型机最广泛采用的内总线，采用并行传输方式</p></li><li><p>SCSI总线，是一条并行外总线</p></li><li></li><li><h1 id="加密技术与认证技术"><a href="#加密技术与认证技术" class="headerlink" title="加密技术与认证技术"></a>加密技术与认证技术</h1></li><li><p>窃听（加密）篡改（摘要）假冒、否认（数字签名）</p></li><li><p>加密：</p><ol><li>对称加密，只有一把密钥，加密和解密用同一把，密钥分发有缺陷，但加密解密速度快，适合加密大量明文数据</li><li>非对称加密，有两把密钥，公钥和私钥，公钥分发出去，用公钥加密只能私钥解密，用私钥加密只能用公钥解密（比如 A 可以用 B 的公钥加密内容给 B，B 用 B 的私钥解密）</li><li>混合加密，先对称加密，再把密文和密钥做非对称加密，效率高且安全（了解即可）</li></ol></li><li><p>认证技术：<br>根据明文，做哈希值成摘要，再用发送方私钥做成数字签名，一起加密传过去，在接收方做对比，检测是否被篡改，用发送方的公钥验证数字签名，防止假冒和否认  </p></li><li><p>数字证书，就是由可信的第三方用私钥加密发送方公钥，保证公钥能正确传达</p></li><li></li><li><h1 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h1></li><li><p>对称加密：DES 3DES RC-5 IDEA AES RC4<br>（公开密钥加密算法）非对称加密：RSA ECC DSA  </p></li><li><p>MD5 是摘要算法</p></li><li><p>SHA-1 安全散列算法</p></li><li></li><li><h1 id="杂题"><a href="#杂题" class="headerlink" title="杂题"></a>杂题</h1></li><li><p>主动攻击：拒绝服务……<br>被动攻击：流量分析 会话拦截……  </p></li><li><p>漏洞属于系统安全</p></li><li></li><li><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1></li><li><p>x&#x3D;(1)不能定义元组，元组内必须用逗号分割，所以x&#x3D;(1,)为元组</p></li><li><p>input 默认返回字符串</p></li><li><p>列表相乘是重复列表，如[1,2]*2&#x3D;&#x3D;[1,2,1,2]</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 备战软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Weekly Algorithm】算法周记之《代码随想录》栈与队列与二叉树（一）</title>
      <link href="/posts/9bec6b3.html"/>
      <url>/posts/9bec6b3.html</url>
      
        <content type="html"><![CDATA[<h1 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h1><p>本周跟随《代码随想录》学习栈与队列和二叉树遍历的一部分，学到了栈和队列在算法中的应用，以及优先级队列的使用；此外还有二叉树的前中后序的递归、迭代、统一迭代方法。</p><h1 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h1><h2 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h2><ul><li><a href="https://programmercarl.com/0232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></li><li>题意就是用栈实现队列的一部分功能</li><li>核心就是通过两栈，一个管输入，一个管输出，输出空了时，执行输出操作需从输入中把数字倒入输出的栈中</li><li>陆爻齐参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class MyQueue &#123;</span><br><span class="line">public:</span><br><span class="line">    stack&lt;int&gt; in;</span><br><span class="line">    stack&lt;int&gt; out;</span><br><span class="line"></span><br><span class="line">    MyQueue() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void push(int x) &#123;</span><br><span class="line">        in.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int pop() &#123;</span><br><span class="line">        int num = this-&gt;peek();</span><br><span class="line">        out.pop();</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int peek() &#123;</span><br><span class="line">        // 这个判空很重要，意味着如果在两次push中有pop，下次pop不会得到刚push进去的数字，而是按队列下去</span><br><span class="line">        if (out.empty()) &#123;</span><br><span class="line">            while(!in.empty()) &#123;</span><br><span class="line">            out.push(in.top());</span><br><span class="line">            in.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return out.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool empty() &#123;</span><br><span class="line">        return in.empty() &amp;&amp; out.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your MyQueue object will be instantiated and called as such:</span><br><span class="line"> * MyQueue* obj = new MyQueue();</span><br><span class="line"> * obj-&gt;push(x);</span><br><span class="line"> * int param_2 = obj-&gt;pop();</span><br><span class="line"> * int param_3 = obj-&gt;peek();</span><br><span class="line"> * bool param_4 = obj-&gt;empty();</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></li></ul><h2 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h2><ul><li><a href="https://programmercarl.com/0225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录 (programmercarl.com)</a></li><li>如题，用队列实现栈，强调是单向队列</li><li>乍一看，还想用 [[用栈实现队列]] 的方法，两个队列，一个模拟输入，一个模拟输出，但其实不行，因为队列先进先出，不会改变输入顺序，另一个队列只能起到备份作用，甚至乎，只要一个队列就行，在 pop（）时先获取队列长度 size，把前面 size-1 个元素放后面，再把最前面拿出来就行。</li><li>陆爻齐参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class MyStack &#123;</span><br><span class="line">public:</span><br><span class="line">    queue&lt;int&gt; q;</span><br><span class="line">    queue&lt;int&gt; backup;</span><br><span class="line">    MyStack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void push(int x) &#123;</span><br><span class="line">        q.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int pop() &#123;</span><br><span class="line">    // 备份</span><br><span class="line">        while(q.size() &gt; 1) &#123;</span><br><span class="line">            backup.push(q.front());</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        int top = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        // 恢复</span><br><span class="line">        while (!backup.empty()) &#123;</span><br><span class="line">            q.push(backup.front());</span><br><span class="line">            backup.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return top;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int top() &#123;</span><br><span class="line">        int top = this-&gt;pop();</span><br><span class="line">        this-&gt;push(top);</span><br><span class="line">        return top;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool empty() &#123;</span><br><span class="line">        return q.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your MyStack object will be instantiated and called as such:</span><br><span class="line"> * MyStack* obj = new MyStack();</span><br><span class="line"> * obj-&gt;push(x);</span><br><span class="line"> * int param_2 = obj-&gt;pop();</span><br><span class="line"> * int param_3 = obj-&gt;top();</span><br><span class="line"> * bool param_4 = obj-&gt;empty();</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></li></ul><h2 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h2><ul><li><a href="https://programmercarl.com/0020.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></li><li>题意是给一个只有小中大括号的字符串，判断其是否正确地两两匹配</li><li>方法是利用栈，若两两匹配则弹出，后面的判断陆爻齐简单地判断栈是否空作为结果，毕竟陆爻齐是把无法匹配的括号也放进去了，代码随想录则分别判断了情况并处理，更为周全</li><li>陆爻齐的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    stack&lt;char&gt; rec;</span><br><span class="line">    bool isValid(string s) &#123;</span><br><span class="line">        if (s.size() % 2 != 0) return false;</span><br><span class="line"></span><br><span class="line">        for (auto c : s) &#123;</span><br><span class="line">            char top_c = get_top();</span><br><span class="line">            // 匹配成功则弹栈，否则压栈</span><br><span class="line">            if ((c == &#x27;)&#x27; &amp;&amp; &#x27;(&#x27; == top_c) ||</span><br><span class="line">                (c == &#x27;]&#x27; &amp;&amp; &#x27;[&#x27; == top_c) ||</span><br><span class="line">                (c == &#x27;&#125;&#x27; &amp;&amp; &#x27;&#123;&#x27; == top_c)) &#123;</span><br><span class="line">                rec.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                rec.push(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">        if (rec.empty()) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;*/</span><br><span class="line">        // 若全部匹配成功，则有效</span><br><span class="line">        return rec.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inline char get_top() &#123;</span><br><span class="line">        if (!rec.empty()) &#123;</span><br><span class="line">            return rec.top();</span><br><span class="line">        &#125;</span><br><span class="line">        return &#x27; &#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>代码随想录的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isValid(string s) &#123;</span><br><span class="line">        if (s.size() % 2 != 0) return false; // 如果s的长度为奇数，一定不符合要求</span><br><span class="line">        stack&lt;char&gt; st;</span><br><span class="line">        for (int i = 0; i &lt; s.size(); i++) &#123;</span><br><span class="line">            if (s[i] == &#x27;(&#x27;) st.push(&#x27;)&#x27;);</span><br><span class="line">            else if (s[i] == &#x27;&#123;&#x27;) st.push(&#x27;&#125;&#x27;);</span><br><span class="line">            else if (s[i] == &#x27;[&#x27;) st.push(&#x27;]&#x27;);</span><br><span class="line">            // 第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号 return false</span><br><span class="line">            // 第二种情况：遍历字符串匹配的过程中，发现栈里没有我们要匹配的字符。所以return false</span><br><span class="line">            else if (st.empty() || st.top() != s[i]) return false;</span><br><span class="line">            else st.pop(); // st.top() 与 s[i]相等，栈弹出元素</span><br><span class="line">        &#125;</span><br><span class="line">        // 第一种情况：此时我们已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false，否则就return true</span><br><span class="line">        return st.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="删除字符串中的所有相邻重复项"><a href="#删除字符串中的所有相邻重复项" class="headerlink" title="删除字符串中的所有相邻重复项"></a>删除字符串中的所有相邻重复项</h2><ul><li><a href="https://programmercarl.com/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.html">代码随想录 (programmercarl.com)</a></li><li>如题，比如“abbaac”，先去 “bb”，得 “aaac”，再去 “aa”，得 “ac”。</li><li>方法就是用栈，来了与栈顶相同的字符就弹栈，否则压栈</li><li>陆爻齐参考代码随想录思路的解法</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string removeDuplicates(string s) &#123;</span><br><span class="line">        string result;</span><br><span class="line">        for(auto c : s) &#123;</span><br><span class="line">            if (result.empty() || c != result.back()) &#123;</span><br><span class="line">                result.push_back(c);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                result.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="逆波兰表达式求值"><a href="#逆波兰表达式求值" class="headerlink" title="逆波兰表达式求值"></a>逆波兰表达式求值</h2><ul><li><a href="https://programmercarl.com/0150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录 (programmercarl.com)</a></li><li>题意，就是对后缀表达式计算求值，比如 [“2”, “1”, “+”, “3”, “ * “]</li><li>方法，就是用栈去保存遍历到的值，一旦遍历到符号，就取出两次顶来做计算然后压栈，具体实现，可以先判断是否符号再处理，也可分别判断，前者代码更简洁，后者判断少一次</li><li>代码随想录，简洁点<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;</span><br><span class="line">        // 力扣修改了后台测试数据，需要用longlong</span><br><span class="line">        stack&lt;long long&gt; st; </span><br><span class="line">        for (int i = 0; i &lt; tokens.size(); i++) &#123;</span><br><span class="line">            if (tokens[i] == &quot;+&quot; || tokens[i] == &quot;-&quot; || tokens[i] == &quot;*&quot; || tokens[i] == &quot;/&quot;) &#123;</span><br><span class="line">                long long num1 = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                long long num2 = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                if (tokens[i] == &quot;+&quot;) st.push(num2 + num1);</span><br><span class="line">                if (tokens[i] == &quot;-&quot;) st.push(num2 - num1);</span><br><span class="line">                if (tokens[i] == &quot;*&quot;) st.push(num2 * num1);</span><br><span class="line">                if (tokens[i] == &quot;/&quot;) st.push(num2 / num1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                st.push(stoll(tokens[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int result = st.top();</span><br><span class="line">        st.pop(); // 把栈里最后一个元素弹出（其实不弹出也没事）</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>陆爻齐，判断少一次<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;</span><br><span class="line">        stack&lt;int&gt; s;</span><br><span class="line">        for (auto c : tokens) &#123;</span><br><span class="line">            if (c == &quot;+&quot;) &#123;</span><br><span class="line">                int top1 = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                int top2 = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                s.push(top1 + top2);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (c == &quot;-&quot;) &#123;</span><br><span class="line">                int top1 = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                int top2 = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                s.push(top2 - top1);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (c == &quot;*&quot;) &#123;</span><br><span class="line">                int top1 = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                int top2 = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                s.push(top1 * top2);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (c == &quot;/&quot;) &#123;</span><br><span class="line">                int top1 = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                int top2 = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                s.push(top2 / top1);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                s.push(stoi(c));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h2><ul><li><a href="https://programmercarl.com/0239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录 (programmercarl.com)</a></li><li>题意，设定一个窗口大小，然后在 vector 上从左向右滑动，每次都计算一次窗口内最大值并保存</li><li>方法，最简单的暴力解法，O(n^2)，每次窗口都遍历下窗口内；想让时间复杂度变 O(n)，就需要一个叫做单调队列的数据结构，该队列保证内部数值按降序或升序排列，在 C++ 无标准库实现，本题中可让其按降序，每次找最大值仅需取 front 即可</li><li>PS: 单调队列实现不唯一，本题只看最大值，故把较小的数值直接弹栈，不做保存</li><li>陆爻齐参考代码随想录思路的解法</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // 实现单调队列</span><br><span class="line">    class MyQueue &#123;</span><br><span class="line">    private:</span><br><span class="line">        deque&lt;int&gt; q;</span><br><span class="line">    public:</span><br><span class="line">        void push(int num) &#123;</span><br><span class="line">            // 由于只关心大值，故小值可直接pop</span><br><span class="line">            while(!q.empty() &amp;&amp; num &gt; q.back()) &#123;</span><br><span class="line">                q.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            q.push_back(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void pop(int num) &#123;</span><br><span class="line">            if (!q.empty() &amp;&amp; num == q.front()) &#123;</span><br><span class="line">                q.pop_front();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 保证 front 是最大值</span><br><span class="line">        int front() &#123;</span><br><span class="line">            return q.front();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        MyQueue q;</span><br><span class="line">        vector&lt;int&gt; result;</span><br><span class="line">        int size = nums.size();</span><br><span class="line">        // 先处理前面 k 个值，并记录一次</span><br><span class="line">        for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">            q.push(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        result.push_back(q.front());</span><br><span class="line">        // 滑动窗口</span><br><span class="line">        for (int i = k; i &lt; size; i++) &#123;</span><br><span class="line">            q.push(nums[i]);</span><br><span class="line">            q.pop(nums[i - k]);</span><br><span class="line">            result.push_back(q.front());</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="前K个高频元素"><a href="#前K个高频元素" class="headerlink" title="前K个高频元素"></a>前K个高频元素</h2><ul><li><p><a href="https://programmercarl.com/0347.%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录 (programmercarl.com)</a></p></li><li><p>题意就是给一个整型数组，要求给出其中出现频率最高的前 K 个元素</p></li><li><p>最直观的解法，就是用 map 记录频率，导入 vector 再用快速排序，但这么做时间复杂度就达到了 O(n*logn)，还有没有更快的方法呢？</p><p>这里就要引入优先级队列，在[[滑动窗口最大值]]其实就有所应用，这次不止要最大值，因此那次实现的优先级队列不好直接应用。  </p><p>优先级队列在 C++ 的 STL 中就有实现，priority_queue，本质为堆，默认大顶堆。和  </p><p>虽然直观上使用大顶堆来保存前 K 个元素比较合适，但是在本题中使用小顶堆更好，因为小顶堆意味着每次 pop 出的就是最小的元素，这么做就可以反复添加元素并去除多于元素来保证堆内都是最大的一批元素。  </p></li><li><p>陆爻齐参考代码随想录思路的解法</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // 自定义排序</span><br><span class="line">    class my_compare &#123;</span><br><span class="line">    public:</span><br><span class="line">        bool operator() (const pair&lt;int,int&gt; &amp;l, const pair&lt;int,int&gt; &amp;r) &#123;</span><br><span class="line">            return l.second &gt; r.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        // 统计所有数字的频率</span><br><span class="line">        unordered_map&lt;int, int&gt; rec;</span><br><span class="line">        for (auto i : nums) &#123;</span><br><span class="line">            rec[i]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 小顶堆</span><br><span class="line">        priority_queue&lt;pair&lt;int,int&gt;, vector&lt;pair&lt;int,int&gt;&gt;, my_compare&gt; pri_que;</span><br><span class="line"></span><br><span class="line">        for (unordered_map&lt;int,int&gt;::iterator it = rec.begin(); it != rec.end(); it++) &#123;</span><br><span class="line">            pri_que.push(*it);</span><br><span class="line">            // 对于小顶堆，总是保持非降序，故加入元素后弹出最小即可保持前 k 个最高频次元素</span><br><span class="line">            if (pri_que.size() &gt; k) &#123;</span><br><span class="line">                pri_que.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; result(k);</span><br><span class="line">        for (int i = k-1; i &gt;= 0; i--) &#123;</span><br><span class="line">            result[i] = pri_que.top().first;</span><br><span class="line">            pri_que.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a>二叉树的递归遍历</h2><ul><li><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></li><li>如题，用递归的方式完成二叉树的遍历</li><li>本题更多的是引入递归的写法，首先确认递归的参数和返回值，然后定好终止条件，最后写好单层递归逻辑</li><li>本质上不同的是输出结果的顺序，前序时，先输出结果再遍历，中序时输出结果再遍历之间，后序时输出结果在遍历后</li><li>前序遍历：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; result;</span><br><span class="line">    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        pre_val(root);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void pre_val(TreeNode* n) &#123;</span><br><span class="line">        if (n == nullptr) return;</span><br><span class="line">        result.push_back(n-&gt;val);</span><br><span class="line">        pre_val(n-&gt;left);</span><br><span class="line">        pre_val(n-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>中序遍历：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; result;</span><br><span class="line">    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        mid_val(root);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void mid_val(TreeNode *n) &#123;</span><br><span class="line">        if (n == nullptr) return;</span><br><span class="line">        mid_val(n-&gt;left);</span><br><span class="line">        result.push_back(n-&gt;val);</span><br><span class="line">        mid_val(n-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>后序遍历：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; result;</span><br><span class="line">    vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        back_val(root);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void back_val(TreeNode *root) &#123;</span><br><span class="line">        if (root == nullptr) return;</span><br><span class="line">        back_val(root-&gt;left);</span><br><span class="line">        back_val(root-&gt;right);</span><br><span class="line">        result.push_back(root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="二叉树的迭代遍历"><a href="#二叉树的迭代遍历" class="headerlink" title="二叉树的迭代遍历"></a>二叉树的迭代遍历</h2><ul><li><p><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录 (.com)</a></p></li><li><p>如题，要用迭代的方式来解决遍历二叉树的问题</p></li><li><p>不同于递归遍历的简洁明了，迭代方式需要用栈来模拟递归的方式</p><p>前序遍历则简单点，由于搜寻的点就是马上要处理的点，但中序遍历则要分两部分，一部分是一味地搜寻左子树，另一部分开始处理栈积攒的点并切换到右子树；后序遍历则把前序遍历的 “中右左” 换成 “中左右” 再反转成 “右左中” 即可  </p></li><li><p>前序遍历</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; result;</span><br><span class="line">    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        TreeNode *p = root;</span><br><span class="line">        stack&lt;TreeNode*&gt; rec;</span><br><span class="line">        if(root != nullptr) rec.push(root);</span><br><span class="line">        while(!rec.empty()) &#123;</span><br><span class="line">            p = rec.top();</span><br><span class="line">            rec.pop();</span><br><span class="line">            result.push_back(p-&gt;val);</span><br><span class="line">            // 由于是栈，所以先入右，就会有遍历时先左后右的效果</span><br><span class="line">            if (p-&gt;right != nullptr) rec.push(p-&gt;right);</span><br><span class="line">            if (p-&gt;left != nullptr) rec.push(p-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>中序遍历  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; result;</span><br><span class="line">    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        TreeNode *cur = root;</span><br><span class="line">        stack&lt;TreeNode *&gt; rec;</span><br><span class="line">        while (cur!= nullptr || !rec.empty()) &#123;</span><br><span class="line">            if (cur != NULL) &#123;</span><br><span class="line">                rec.push(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                cur = rec.top();</span><br><span class="line">                rec.pop();</span><br><span class="line">                result.push_back(cur-&gt;val);</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>后序遍历  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; result;</span><br><span class="line">    vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        TreeNode *cur = root;</span><br><span class="line">        stack&lt;TreeNode*&gt; rec;</span><br><span class="line">        if (cur != nullptr) rec.push(cur);</span><br><span class="line"></span><br><span class="line">        while(!rec.empty()) &#123;</span><br><span class="line">            cur = rec.top();</span><br><span class="line">            rec.pop();</span><br><span class="line">            result.push_back(cur-&gt;val);</span><br><span class="line">            if (cur-&gt;left != nullptr) rec.push(cur-&gt;left);</span><br><span class="line">            if (cur-&gt;right != nullptr) rec.push(cur-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(result.begin(), result.end());</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="二叉树的统一迭代遍历法"><a href="#二叉树的统一迭代遍历法" class="headerlink" title="二叉树的统一迭代遍历法"></a>二叉树的统一迭代遍历法</h2><ul><li><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></li><li>如题，就是用类似递归那样可比较通用的迭代遍历法</li><li>方法就是在压栈遍历过的节点时，再压入一个空指针，遍历到空指针就意味着要输出这个值了</li><li>前序遍历<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt;result;</span><br><span class="line">    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        if (root != nullptr) st.push(root);</span><br><span class="line">        while (!st.empty()) &#123;</span><br><span class="line">            TreeNode *cur = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            // 给遍历过的点一个标记，即在后面压一个空指针，遍历到则说明该读取了</span><br><span class="line">            if (cur != nullptr) &#123;</span><br><span class="line">                if (cur-&gt;right != nullptr) st.push(cur-&gt;right);</span><br><span class="line"></span><br><span class="line">                if (cur-&gt;left != nullptr) st.push(cur-&gt;left);</span><br><span class="line"></span><br><span class="line">                st.push(cur);</span><br><span class="line">                st.push(nullptr);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                cur = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                result.push_back(cur-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>中序遍历  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; result;</span><br><span class="line">    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        if (root != nullptr) st.push(root);</span><br><span class="line">        while (!st.empty()) &#123;</span><br><span class="line">            TreeNode *cur = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            // 给遍历过的点一个标记，即在后面压一个空指针，遍历到则说明该读取了</span><br><span class="line">            if (cur != nullptr) &#123;</span><br><span class="line">                if (cur-&gt;right != nullptr) st.push(cur-&gt;right);</span><br><span class="line"></span><br><span class="line">                st.push(cur);</span><br><span class="line">                st.push(nullptr);</span><br><span class="line"></span><br><span class="line">                if (cur-&gt;left != nullptr) st.push(cur-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                cur = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                result.push_back(cur-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>后序遍历  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; result;</span><br><span class="line">    vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        if (root != nullptr) st.push(root);</span><br><span class="line">        while (!st.empty()) &#123;</span><br><span class="line">            TreeNode *cur = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            // 给遍历过的点一个标记，即在后面压一个空指针，遍历到则说明该读取了</span><br><span class="line">            if (cur != nullptr) &#123;</span><br><span class="line">                st.push(cur);</span><br><span class="line">                st.push(nullptr);</span><br><span class="line"></span><br><span class="line">                if (cur-&gt;right != nullptr) st.push(cur-&gt;right);</span><br><span class="line"></span><br><span class="line">                if (cur-&gt;left != nullptr) st.push(cur-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                cur = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                result.push_back(cur-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法周记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Weekly Algorithm】 算法周记之《代码随想录》字符串</title>
      <link href="/posts/62f68aed.html"/>
      <url>/posts/62f68aed.html</url>
      
        <content type="html"><![CDATA[<h1 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h1><p>本周跟随《代码随想录》学习字符串部分，较深入地了解了字符串的相关算法题，除了双指针，还有 KMP 算法。</p><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="简评"><a href="#简评" class="headerlink" title="简评"></a>简评</h2><p>究其本质而言，就是数组，只不过内容换成了字母。</p><h2 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h2><ul><li><a href="https://programmercarl.com/0344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录 (programmercarl.com)</a></li><li>就是把字符串前后翻转，和[[翻转链表]]相似</li><li>由于字符串可以随机读取，可以简单很多，直接 <code>swap</code> i 和 str.size()-1-i 的字符即可</li><li>陆爻齐参照代码随想录的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void reverseString(vector&lt;char&gt;&amp; s) &#123;</span><br><span class="line">        int size = s.size();</span><br><span class="line">        for (int i = 0; i &lt; size / 2; i++) &#123;</span><br><span class="line">            swap(s[i],s[size - 1 - i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="反转字符串-1"><a href="#反转字符串-1" class="headerlink" title="反转字符串||"></a>反转字符串||</h2><ul><li><a href="https://programmercarl.com/0541.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></li><li>与 [[反转字符串]] 类似，不过要求每 2k 个字符的前 k 个字符反转</li><li>方法不难，可以像陆爻齐这样把两个阶段分开，也可像代码随想录这样合一起处理，不过还是要注意循环不变原则，比如反转字符串保持左闭右闭的区间</li><li>陆爻齐的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string reverseStr(string s, int k) &#123;</span><br><span class="line">        int begin = 0, end = s.size() - 1;</span><br><span class="line">        int size = s.size();</span><br><span class="line"></span><br><span class="line">        // 先处理了大于 2k 的情况</span><br><span class="line">        while(size &gt; 2 * k) &#123;</span><br><span class="line">            rev_str(s, begin, begin + k - 1);</span><br><span class="line">            begin += 2 * k;</span><br><span class="line">            size -= 2 * k;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 单独处理小于等于 k 的情况</span><br><span class="line">        if (size &gt;= k) &#123;</span><br><span class="line">            rev_str(s, begin, begin + k - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            rev_str(s, begin, begin + size - 1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 反转字符串单独实现，左闭右闭</span><br><span class="line">    void rev_str(string &amp;s, int begin, int end) &#123;</span><br><span class="line">        int size = end - begin + 1;</span><br><span class="line">        //cout &lt;&lt; &quot;rec: &quot;;</span><br><span class="line">        /*for (int i = begin; i &lt;= end; i++) &#123;</span><br><span class="line">            cout &lt;&lt; s[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">        &#125;*/</span><br><span class="line">        //cout &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">        for (int i = 0; i &lt; size / 2; i++) &#123;</span><br><span class="line">            swap(s[begin + i], s[end - i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>代码随想录的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void reverse(string&amp; s, int start, int end) &#123;</span><br><span class="line">        for (int i = start, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">            swap(s[i], s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    string reverseStr(string s, int k) &#123;</span><br><span class="line">        for (int i = 0; i &lt; s.size(); i += (2 * k)) &#123;</span><br><span class="line">            // 1. 每隔 2k 个字符的前 k 个字符进行反转</span><br><span class="line">            // 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符</span><br><span class="line">            if (i + k &lt;= s.size()) &#123;</span><br><span class="line">                reverse(s, i, i + k - 1);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            // 3. 剩余字符少于 k 个，则将剩余字符全部反转。</span><br><span class="line">            reverse(s, i, s.size() - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="替换数字"><a href="#替换数字" class="headerlink" title="替换数字"></a>替换数字</h2><ul><li><a href="https://programmercarl.com/kamacoder/0054.%E6%9B%BF%E6%8D%A2%E6%95%B0%E5%AD%97.html#%E6%80%9D%E8%B7%AF">替换数字 | 代码随想录 (programmercarl.com)</a></li></ul></li><li>题意是让字符串中的数字，替换为 “number”</li><li>最普通的方法是从前往后遍历，对于数字，则将后面的字母向后移位，插入 “number”，但时间复杂度为 O(n^2)，如果创建新的字符串来辅助，那么空间复杂度就高了（JAVA 好像不能对字符串直接修改，必须辅助来着）</li><li>比较好的方法是，先遍历字符串，确认其中数字个数，然后直接对字符串重定大小，从后向前填充，遇到数字就倒着写 number</li><li>陆爻齐参考代码随想录思路的解法</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string s;// 存储字符串</span><br><span class="line">    int count;// 记录字符串中数字个数</span><br><span class="line">    </span><br><span class="line">    while(cin &gt;&gt; s) &#123; //只要一直有输入就不会停止</span><br><span class="line">        int ori_size = s.size(); //记录原来大小</span><br><span class="line">        count = 0;</span><br><span class="line">        for(auto c : s) &#123; // 计算数字个数</span><br><span class="line">            if (int(c) &lt; int(&#x27;a&#x27;)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        s.resize(s.size() + 5 * count); // 重置字符串大小</span><br><span class="line">        </span><br><span class="line">        int index = ori_size - 1;// 对原内容遍历下标</span><br><span class="line">        int input_ind = s.size() - 1;// 插入下标</span><br><span class="line">        </span><br><span class="line">        while(input_ind &gt; 0) &#123; // 从后向前遍历</span><br><span class="line">            if (int(s[index]) &lt; int(&#x27;a&#x27;)) &#123;  // 对数字从后向前替换numver</span><br><span class="line">                s[input_ind--] = &#x27;r&#x27;;</span><br><span class="line">                s[input_ind--] = &#x27;e&#x27;;</span><br><span class="line">                s[input_ind--] = &#x27;b&#x27;;</span><br><span class="line">                s[input_ind--] = &#x27;m&#x27;;</span><br><span class="line">                s[input_ind--] = &#x27;u&#x27;;</span><br><span class="line">                s[input_ind--] = &#x27;n&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                s[input_ind--] = s[index]; // 对非数字直接替换</span><br><span class="line">            &#125;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="翻转字符串里的单词"><a href="#翻转字符串里的单词" class="headerlink" title="翻转字符串里的单词"></a>翻转字符串里的单词</h2><ul><li><p><a href="https://programmercarl.com/0151.%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></p></li><li><p>本题要求只是翻转字符串中每个单词，单词内不翻转，若遇到多个空格，则合并一个</p></li><li><p>整体分三步：</p><ol><li>去除多余空格</li><li>整体翻转</li><li>局部翻转单词</li></ol></li><li><p>第一步可以遍历然后erase，但erase时间复杂度O(n)，这样第一步复杂度O(n^2)，虽然也能过，但有更好的方法；这里就要用到[[移除元素]]中用到的双指针，同样的方法可以消除多余空格，区别就是每次消除前，先自己补个空格</p></li><li><p>第二步和第三步用[[反转字符串]]即可，注意第三步对每个单词反转时，由于默认用左闭右闭的反转函数，遍历的变量 i 是可以取到 s.size() 的。</p></li><li><p>陆爻齐参考代码随想录思路的解法</p></li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string reverseWords(string s) &#123;</span><br><span class="line">        removeExactSpaces(s);</span><br><span class="line">        reverseStr(s, 0, s.size() - 1);</span><br><span class="line"></span><br><span class="line">        int start = 0;</span><br><span class="line">        for (int i = 0; i &lt;= s.size(); i++) &#123; // 由于反转对i-1，i可以取s.size()</span><br><span class="line">            if (s[i] == &#x27; &#x27; || i == s.size()) &#123;</span><br><span class="line">                reverseStr(s, start, i - 1);</span><br><span class="line">                start = i+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 左闭右闭区间交换</span><br><span class="line">    void reverseStr(string &amp;s, int begin, int end) &#123;</span><br><span class="line">        for (int i = begin, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">            swap(s[i], s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void removeExactSpaces(string &amp;s) &#123;</span><br><span class="line">        // 参考此前的移除元素，双指针O(n)</span><br><span class="line">        int slow = 0;</span><br><span class="line">        int size = s.size();</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            if (s[i] != &#x27; &#x27;) &#123;</span><br><span class="line">                if (slow != 0) &#123;</span><br><span class="line">                    s[slow++] = &#x27; &#x27;;</span><br><span class="line">                &#125;</span><br><span class="line">                while (i &lt; size &amp;&amp; s[i] != &#x27; &#x27;) &#123;</span><br><span class="line">                    s[slow++] = s[i++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //cout &lt;&lt; slow &lt;&lt; endl;</span><br><span class="line">        s.resize(slow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="右旋字符串"><a href="#右旋字符串" class="headerlink" title="右旋字符串"></a>右旋字符串</h2><ul><li><a href="https://programmercarl.com/kamacoder/0055.%E5%8F%B3%E6%97%8B%E5%AD%97%E7%AC%A6%E4%B8%B2.html">右旋字符串 | 代码随想录 (programmercarl.com)</a></li><li>题意就是要求将一个字符串的后 k 个字符放前面</li><li>不难，最容易想到的方法就是新建个字符串，先把后 k 个放前面，再回头放前面；BUT！！如果不准用辅助空间呢？（又是排除 JAVA 的一集）</li><li>答案是通过 [[反转字符串]]，整体反转，再将前 k 个（也就是后面 k 个字符反转过来的部分）和后面部分分别反转即可</li><li>陆爻齐参考代码随想录思路的解法</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 左闭右闭反转</span><br><span class="line">void reverse_str(string &amp;s, int begin, int end) &#123;</span><br><span class="line">    for (int i = begin, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">        swap(s[i], s[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string s;</span><br><span class="line">    int k;</span><br><span class="line">    cin &gt;&gt; k &gt;&gt; s;</span><br><span class="line">    int size = s.size();</span><br><span class="line">    reverse_str(s, 0, size-1); // 整体反转</span><br><span class="line">    // 两部分分别反转</span><br><span class="line">    reverse_str(s, 0, k-1);</span><br><span class="line">    reverse_str(s, k, size-1);</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现strStr"><a href="#实现strStr" class="headerlink" title="实现strStr()"></a>实现strStr()</h2><ul><li><a href="https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></li><li>即求出一个文本串中模板串第一次出现的首字母下标</li><li>本题利用暴力解法也可 AC，即对每个字符起都循环遍历模板串是否匹配，但想比较好地完成此题，就不得不提到 [[KMP算法]]，本题也就可是KMP匹配成功后立即返回即可</li><li>陆爻齐参考代码随想录思路的解法</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void getNext(int *next, string s) &#123;</span><br><span class="line">        int j = -1;</span><br><span class="line">        next[0] = j;</span><br><span class="line">        int size = s.size();</span><br><span class="line">        for (int i = 1; i &lt; size; i++) &#123; // 循环不变原则，i为后缀末下标，j为前缀末下标</span><br><span class="line">            while (j &gt;= 0 &amp;&amp; s[i] != s[j + 1]) &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">            if (s[i] == s[j + 1]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int strStr(string haystack, string needle) &#123;</span><br><span class="line">        if (needle.size() == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        vector&lt;int&gt; next(needle.size());</span><br><span class="line">        getNext(&amp;next[0], needle);</span><br><span class="line">        int j = -1;</span><br><span class="line">        for(int i = 0; i &lt; haystack.size(); i++) &#123;</span><br><span class="line">            while(j &gt;= 0 &amp;&amp; haystack[i] != needle[j + 1]) &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">            if (haystack[i] == needle[j + 1]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (j == (needle.size() - 1)) &#123; // 可理解为结果是 i -</span><br><span class="line">                return (i - needle.size() + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="重复的子字符串"><a href="#重复的子字符串" class="headerlink" title="重复的子字符串"></a>重复的子字符串</h2><ul><li><p><a href="https://programmercarl.com/0459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></p></li><li><p>即判断字符串是否由自身的子字符串组成</p></li><li><p>方法大致有三个</p><ol><li>暴力解法，O(n^2)时间复杂度，中间可以只遍历一半字符串优化</li></ol><p>2.移动匹配，把字符串*2拼一起，掐头去尾，若中间有字符串，则是<br>  3. [[KMP算法]] ，若KMP找到最长相同前后缀所不包含的串长度可整除字符串，则是</p></li><li><p>移动匹配：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool repeatedSubstringPattern(string s) &#123;</span><br><span class="line">        string ss = s + s;</span><br><span class="line">        // 掐头去尾</span><br><span class="line">        ss.erase(ss.begin());</span><br><span class="line">        ss.erase(ss.end() - 1);</span><br><span class="line">        // 如果中间出现原串，说明确实是</span><br><span class="line">        if (ss.find(s) != string::npos) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>KMP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void getNext(int *next, string s) &#123;</span><br><span class="line">        int j = -1;</span><br><span class="line">        next[0] = j;</span><br><span class="line">        for (int i = 1; i &lt; s.size(); i++) &#123;</span><br><span class="line">            while (j &gt;= 0 &amp;&amp; s[i] != s[j + 1]) &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">            if (s[i] == s[j + 1]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    bool repeatedSubstringPattern(string s) &#123;</span><br><span class="line">        if (s.size() == 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; next(s.size());</span><br><span class="line">        getNext(&amp;next[0], s);</span><br><span class="line">        int len = s.size();</span><br><span class="line">        // 只要最长前后缀在末尾大于零，且剩余部分长度整除字符串</span><br><span class="line">        if (next[len - 1] != -1 &amp;&amp; len % (len - (next[len - 1] + 1)) == 0) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法周记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Weekly Algorithm】 算法周记之《代码随想录》哈希表</title>
      <link href="/posts/1b785190.html"/>
      <url>/posts/1b785190.html</url>
      
        <content type="html"><![CDATA[<h1 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h1><p>本周跟随《代码随想录》学习哈希表部分，较深入地了解了哈希表的相关算法题，结合数组、set、map完成题目，并利用双指针解决部分题目。</p><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="简评"><a href="#简评" class="headerlink" title="简评"></a>简评</h2><p>究其本质而言，就是数组，但可以通过给元素编码得其索引，以 O(1) 的效率访存，最适合检测该元素是否存在。</p><h2 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h2><ul><li><a href="https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html">代码随想录 (programmercarl.com)</a></li><li>即检测一个字符串是否为另一个字符串的字母打散重组的单词</li><li>字符可以通过 ASCII 码表来存储，遍历某个字符串，对应字符++，再遍历另一个对应字符–，最后所有字符都为 0 即为字母异位词</li><li></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isAnagram(string s, string t) &#123;</span><br><span class="line">        // 记录每个字符对应次数，相当于哈希表</span><br><span class="line">        int word_rec[26] = &#123;0&#125;;</span><br><span class="line">        // 遍历某个字符串，记录对应字符出现次数</span><br><span class="line">        for (auto c : s) &#123;</span><br><span class="line">            word_rec[get_index(c)]++;</span><br><span class="line">        &#125;</span><br><span class="line">        // 遍历另一个字符串，把对应字符出现与上个字符串抵消</span><br><span class="line">        for (auto c : t) &#123;</span><br><span class="line">            word_rec[get_index(c)]--;</span><br><span class="line">        &#125;</span><br><span class="line">        // 若有字符没抵消干净，说明不是字母异位词</span><br><span class="line">        for (auto i : word_rec) &#123;</span><br><span class="line">            if (i != 0) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inline int get_index(char c) &#123;</span><br><span class="line">        return int(c)-97;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h2><ul><li><p><a href="https://programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录 (programmercarl.com)</a></p></li><li><p>本题与 [[有效的字母异位词]]，有点类似，不过检测的元素从字符变成数字，而且需要输出重合的部分</p></li><li><p>大致有两思路</p><ol><li>陆爻齐想到，用 unordered_map 先把某一个数组中有的数字记 1，随后遍历另一数组时，把当前 map 里有且值为 1 的部分改值到 2 并放到数组里；</li><li>代码随想录用两个 set，其中一个用来存储某个数组唯一的所有元素，另一个存放结果，由于 set 会保证元素唯一，一旦找到交集就可以无脑 insert 进去</li></ol></li><li><p>这里选择记录陆爻齐的思路</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">        unordered_map&lt;int,int&gt; num_rec;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        // 遍历某个数组，记录其中存在数字</span><br><span class="line">        for (auto c : nums1) &#123;</span><br><span class="line">            if (num_rec.find(c) == num_rec.end()) &#123;</span><br><span class="line">                num_rec[c] = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 遍历另一个数组，记录交集数字加入结果</span><br><span class="line">        for (auto c : nums2) &#123;</span><br><span class="line">            if (num_rec.find(c) != num_rec.end() &amp;&amp; num_rec[c] == 1) &#123;</span><br><span class="line">                num_rec[c]++;</span><br><span class="line">                res.push_back(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h2><ul><li><a href="https://programmercarl.com/0202.%E5%BF%AB%E4%B9%90%E6%95%B0.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></li><li>该题就是一个数字游戏，寻找一个整数是否存在一个其各元素平方和为 1 的情况，可能会无限循环</li><li>解决方法就是创建一个哈希表，把过程中产生的数字记录，若有重复，则陷入死循环，否则到了 1，则为快乐数</li><li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isHappy(int n) &#123;</span><br><span class="line">        // 记录过程中产生的数</span><br><span class="line">        unordered_map&lt;int, int&gt; record;</span><br><span class="line">        // map 中判断是否记录过的方法</span><br><span class="line">        while (record.find(n) == record.end()) &#123;</span><br><span class="line">            // 做记录</span><br><span class="line">            record[n] = 0;</span><br><span class="line">            n = get_happy(n);</span><br><span class="line">            // 得到快乐数的情况</span><br><span class="line">            if (n == 1) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            //cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 递归获取各位平方和</span><br><span class="line">    int get_happy(int n) &#123;</span><br><span class="line">        if (n &gt;= 10) &#123;</span><br><span class="line">            return (n % 10) * (n % 10) + get_happy(n / 10);</span><br><span class="line">        &#125;</span><br><span class="line">        return n * n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><ul><li><a href="https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html">代码随想录 (programmercarl.com)</a></li><li>该题给予了一个整数数组和目标数字，要求找到数组中一组两数和为目标值的下标</li><li>暴力解法为 O(n^2) 遍历两层数组，而运用哈希值就能快很多，通过 map，可以把遍历过的数字作为索引，其对应下标作为值存入 map 中，如此在得到数组中的一个数字时，就计算其与目标差值，在 map 中查找差值是否存在，存在则找到解，不存在则存入当前正在遍历的数字及其下标。</li><li></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        map&lt;int,int&gt; record; // 记录已遍历数字，索引为数值，值为下标</span><br><span class="line">        vector&lt;int&gt; result; // 要返回的结果</span><br><span class="line">        int index = 0; // 下标记录</span><br><span class="line"></span><br><span class="line">        // 遍历每个数</span><br><span class="line">        for (auto c : nums) &#123;</span><br><span class="line">            int cur = target - c; // 与目标值所差值</span><br><span class="line">            if (record.find(cur) != record.end()) &#123; // 若差值已遍历，则可调出凑出结果</span><br><span class="line">                result.push_back(record[cur]);</span><br><span class="line">                result.push_back(index);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123; // 否则记录当前值及其下标</span><br><span class="line">                record[c] = index;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            index++; // 更新下标</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="四数相加"><a href="#四数相加" class="headerlink" title="四数相加||"></a>四数相加||</h2><ul><li><a href="https://programmercarl.com/0454.%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II.html">代码随想录 (programmercarl.com)</a></li><li>与[[两数之和]]类似，不过这次有四个数组，要求找到四个数组各取一数之和为 0 的元组个数</li><li>方法是，把前两数组之和放 map，和值为 key，出现次数为 value，然后遍历后两数组和，对于其负数若 map 中有，则结果多一个该负数在 map 对应的 value 值</li><li></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int fourSumCount(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3, vector&lt;int&gt;&amp; nums4) &#123;</span><br><span class="line">        unordered_map&lt;int, int&gt; num_record; // 记录前两者和的情况和次数</span><br><span class="line">        int result = 0; // 记录结果元组个数</span><br><span class="line"></span><br><span class="line">        // 遍历前两数组，记录和</span><br><span class="line">        for (auto i : nums1) &#123;</span><br><span class="line">            for (auto j : nums2) &#123;</span><br><span class="line">                num_record[i + j]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 遍历后两数组和，检查是否有满足和为0的一对</span><br><span class="line">        for (auto i : nums3) &#123;</span><br><span class="line">            for (auto j : nums4) &#123;</span><br><span class="line">                if (num_record.find(-1 * (i + j)) != num_record.end()) &#123;</span><br><span class="line">                    result += num_record[-1 * (i + j)];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="赎金信"><a href="#赎金信" class="headerlink" title="赎金信"></a>赎金信</h2><ul><li><p><a href="https://programmercarl.com/0383.%E8%B5%8E%E9%87%91%E4%BF%A1.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></p></li><li><p>本题的意思与此前的 [[有效的字母异位词]]，很相近，不过 [[有效的字母异位词]] 需要两个字符串可以互相组成，而本题只需要字符串 a 能由字符串 b 组成即可</p></li><li><p>方法反而简单，可以用 map 记录字母对应次数，但由于本题目已说明字母串中皆为小写字母，所以通过 ASCII 码转换下标记录数组的效率更高，更简单</p></li><li><p>陆爻齐的思路是增加一个整形数字记录所需字母的总个数，一旦字符串 b 中出现所需字母，且所需字母的需要个数非零，则该数字减一，最后秩序检查该数字是否为零即可得知题意是否满足</p><p>代码随想录更直接些，先统计字符串b的字母，再用 a 的减去，若出现小于零的位，则说明有没有满足的字母存在  </p></li><li><p>陆爻齐的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int need_num = 0;   // 记录需要字母的总个数</span><br><span class="line">    int word_record[26] = &#123;0&#125;; // 记录需要字母的个数</span><br><span class="line"></span><br><span class="line">    bool canConstruct(string ransomNote, string magazine) &#123;</span><br><span class="line">        // 记录需要字母个数</span><br><span class="line">        for (auto c : ransomNote) &#123;</span><br><span class="line">            add_rec(get_char_num(c));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 削减需要字母个数</span><br><span class="line">        for (auto c : magazine) &#123;</span><br><span class="line">            cut_rec(get_char_num(c));</span><br><span class="line">        &#125;</span><br><span class="line">        // 若仍有需要字符未消减干净，则不满足题目条件</span><br><span class="line">        if (need_num &gt; 0)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 记录需要的字母及其数量</span><br><span class="line">    void add_rec(int index) &#123;</span><br><span class="line">        word_record[index]++;</span><br><span class="line">        need_num++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 削减magazine有的字符，但只有是需要的情况下才削减数量</span><br><span class="line">    void cut_rec(int index) &#123;</span><br><span class="line">        if (word_record[index] &gt; 0) &#123;</span><br><span class="line">            word_record[index]--;</span><br><span class="line">            need_num--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取字母对应的下标</span><br><span class="line">    inline int get_char_num(char c) &#123;</span><br><span class="line">        return int(c - 97);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>代码随想录的解法  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool canConstruct(string ransomNote, string magazine) &#123;</span><br><span class="line">        int record[26] = &#123;0&#125;;</span><br><span class="line">        //add</span><br><span class="line">        if (ransomNote.size() &gt; magazine.size()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; magazine.length(); i++) &#123;</span><br><span class="line">            // 通过record数据记录 magazine里各个字符出现次数</span><br><span class="line">            record[magazine[i]-&#x27;a&#x27;] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 0; j &lt; ransomNote.length(); j++) &#123;</span><br><span class="line">            // 遍历ransomNote，在record里对应的字符个数做--操作</span><br><span class="line">            record[ransomNote[j]-&#x27;a&#x27;]--;</span><br><span class="line">            // 如果小于零说明ransomNote里出现的字符，magazine没有</span><br><span class="line">            if(record[ransomNote[j]-&#x27;a&#x27;] &lt; 0) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><ul><li><p><a href="https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></p></li><li><p>即在一个数组中，找到下标互不重复且三个值不重复的所有三数之和为零的三元组</p></li><li><p>看起来与[[两数之和]]相近，可以把前两数之和放 map，最后一个数匹配，但由于题目要求返回不重三元组，所以去重将是大难题</p></li><li><p>所以本题采用双指针，先把数组排好序，用 i 确认第一个数 a，再用left 和 right 从 a 的右侧两旁逼近答案</p><p>思路不难，但去重难  </p><p>首先是 a 的去重，由于排好序了，只要让 a 与前一个值不同，就可以遍历到不同的 a；那么可以让 a 与后面一个不同吗？不能，因为可能有{1，1，-2} 这样的情况，若让 a 与后一个不同，那么由于前两个 1，该答案会被排除。  </p><p>然后是 b 和 c 的去重，由于排好序，在取到一个可用值后，让 left 和 right 各向中心去重  </p></li><li><p>参考代码随想录思路的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int size = nums.size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">        sort(nums.begin(), nums.end());// 先排好序</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line"></span><br><span class="line">            // 若最小的数都为正数，那么三数之和不可能为零</span><br><span class="line">            if (nums[i] &gt; 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 对第一个 a 的去重，若前一个与当前相等，那么有三数之和为零的话一定重用，没的话三数之和定不为零</span><br><span class="line">            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 双指针遍历</span><br><span class="line">            int left = i+1, right = size - 1;</span><br><span class="line">            while (left &lt; right) &#123;</span><br><span class="line">                int sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                // 若三数之和小了，让 left 变大</span><br><span class="line">                if (sum &lt; 0) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                // 大了，就让 right 变小</span><br><span class="line">                else if(sum &gt; 0) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    result.push_back(vector&lt;int&gt;&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line"></span><br><span class="line">                    // 对于 left 和 right 的去重</span><br><span class="line">                    while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    while(right &gt; left &amp;&amp; nums[right] == nums[right - 1]) &#123;</span><br><span class="line">                        right--;    </span><br><span class="line">                    &#125;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h2><ul><li><a href="https://programmercarl.com/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></li><li>本地算[[三数之和]]的拓展，习得这个拓展套路，便可解决类似的“五数之和”等</li><li>与 [[四数相加||]] 不同，该题要在与 [[三数之和]] 的一个数组下，找到四数之和为 target 的四元组</li><li>注意 target 可能为负，所以剪枝不能大于target就剪就差不多了罢</li><li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">            vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">            sort(nums.begin(), nums.end()); // 确保数组有序</span><br><span class="line">            int size = nums.size();</span><br><span class="line">            for (int k = 0; k &lt; size; k++) &#123; // 第一个数</span><br><span class="line">                if (nums[k] &gt;= 0 &amp;&amp; nums[k] &gt; target) &#123; //第一层剪枝，若往后只会更大则剪</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (k &gt; 0 &amp;&amp; nums[k-1] == nums[k]) &#123; // 第一层去重</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                for (int i = k + 1; i &lt; size; i++) &#123;</span><br><span class="line">                    int i_k_sum = nums[i] + nums[k];</span><br><span class="line">                    if (i_k_sum &gt;= 0 &amp;&amp; i_k_sum &gt; target) &#123; // 第二层剪枝</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (i &gt; k + 1 &amp;&amp; nums[i - 1] == nums[i]) &#123; //第二层去重</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    int left = i + 1, right = size - 1;</span><br><span class="line"></span><br><span class="line">                    while (left &lt; right) &#123;</span><br><span class="line">                        if ((long long)i_k_sum + nums[left] + nums[right] &gt; target) &#123; </span><br><span class="line">                            right--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else if((long long)i_k_sum + nums[left] + nums[right] &lt; target) &#123;</span><br><span class="line">                            left++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            result.push_back(vector&lt;int&gt;&#123;nums[k], nums[i], nums[left], nums[right]&#125;);</span><br><span class="line"></span><br><span class="line">                            while(left &lt; right &amp;&amp; nums[left] == nums[left+1]) &#123;</span><br><span class="line">                                left++;</span><br><span class="line">                            &#125;</span><br><span class="line">                            while(left &lt; right &amp;&amp; nums[right] == nums[right-1]) &#123;</span><br><span class="line">                                right--;</span><br><span class="line">                            &#125;</span><br><span class="line">                            left++;</span><br><span class="line">                            right--;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法周记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Weekly Algorithm】 算法周记之《代码随想录》链表</title>
      <link href="/posts/695632.html"/>
      <url>/posts/695632.html</url>
      
        <content type="html"><![CDATA[<h1 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h1><p>本周跟随《代码随想录》学习链表部分，较深入地了解了链表的相关算法题，并利用双指针解决部分题目。</p><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a>移除链表元素</h2><ul><li><a href="https://programmercarl.com/0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录 (programmercarl.com)</a></li><li>由于链表结构特殊，移除操作需要对指针操作，稍微复杂点</li><li>比较方便的方法是，用一个虚拟的指针头，将这个链表的删除操作转化为统一的链表中元素的移除</li><li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* removeElements(ListNode* head, int val) &#123;</span><br><span class="line">        ListNode* vir_head = new ListNode(0);</span><br><span class="line">        vir_head-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        // 用虚拟头统一操作</span><br><span class="line">        ListNode*p = vir_head;</span><br><span class="line"></span><br><span class="line">        while(p-&gt;next != nullptr) &#123;</span><br><span class="line">            // 下个符合就删</span><br><span class="line">            if (p-&gt;next-&gt;val == val) &#123;</span><br><span class="line">                ListNode *tmp = p-&gt;next;</span><br><span class="line">                p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">                delete tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            // 没删 next 的情况再更新到 next，若刚删了 next 且 null，会在循环那里停下来</span><br><span class="line">            else &#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return vir_head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h2><ul><li><a href="https://programmercarl.com/0707.%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></li><li>考察很综合，增删查改</li><li>TODO 独立单链表实现一次</li><li>TODO 双链表独立实现一次</li><li></li><li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _link &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct _link *next = nullptr;</span><br><span class="line">    //struct _link *pre = nullptr;</span><br><span class="line"></span><br><span class="line">    _link(int num) &#123;</span><br><span class="line">        val = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;link_node;</span><br><span class="line"></span><br><span class="line">class MyLinkedList &#123;</span><br><span class="line">public:</span><br><span class="line">    int size = 0;</span><br><span class="line">    link_node * head;</span><br><span class="line"></span><br><span class="line">    MyLinkedList() &#123;</span><br><span class="line">        this-&gt;size = 0;</span><br><span class="line">        head = new link_node(0);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int get(int index) &#123;</span><br><span class="line">        if (index &gt;= size || index &lt; 0) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        link_node *p = head-&gt;next;</span><br><span class="line">        for (int i = 0; i &lt; index; i++) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return p-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void addAtHead(int val) &#123;</span><br><span class="line">        link_node *p = new link_node(val);</span><br><span class="line">        p-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next = p;</span><br><span class="line">        this-&gt;size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void addAtTail(int val) &#123;</span><br><span class="line">        link_node *p = new link_node(val);</span><br><span class="line">        link_node *cur = head;</span><br><span class="line">        while(cur-&gt;next != nullptr) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = p;</span><br><span class="line">        this-&gt;size++;</span><br><span class="line">        </span><br><span class="line">        //addAtIndex(this-&gt;size, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void addAtIndex(int index, int val) &#123;</span><br><span class="line">        if(index &gt; this-&gt;size) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (index &lt; 0) &#123;</span><br><span class="line">            index = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        link_node *p = head;</span><br><span class="line">        for (int i = 0; i &lt; index; i++) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        link_node *new_node = new link_node(val);</span><br><span class="line">        new_node-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = new_node;</span><br><span class="line">        this-&gt;size++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void deleteAtIndex(int index) &#123;</span><br><span class="line">        if (index &gt;= this-&gt;size || index &lt; 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        link_node *p = head;</span><br><span class="line">        for (int i = 0; i &lt; index; i++) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;  </span><br><span class="line">        link_node *q = p-&gt;next;</span><br><span class="line">        p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">        delete  q;</span><br><span class="line">        this-&gt;size--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your MyLinkedList object will be instantiated and called as such:</span><br><span class="line"> * MyLinkedList* obj = new MyLinkedList();</span><br><span class="line"> * int param_1 = obj-&gt;get(index);</span><br><span class="line"> * obj-&gt;addAtHead(val);</span><br><span class="line"> * obj-&gt;addAtTail(val);</span><br><span class="line"> * obj-&gt;addAtIndex(index,val);</span><br><span class="line"> * obj-&gt;deleteAtIndex(index);</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></li></ul><h2 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h2><ul><li><p><a href="https://programmercarl.com/0206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html">代码随想录 (programmercarl.com)</a></p></li><li><p>本题要求，将一个单链表顺序翻转过来</p></li><li><p>有递归法、双指针法，时间复杂度皆为O（n），双指针空间复杂度O（1），递归O（n）</p></li><li><p>双指针法如下</p></li><li><p>参考代码随想录思路的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        ListNode *pre = nullptr;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        ListNode *tmp = nullptr;// 存储 cur 的下个节点</span><br><span class="line">        while(cur != nullptr) &#123;</span><br><span class="line">            tmp = cur-&gt;next; // 先存下个要操作的节点</span><br><span class="line">            cur-&gt;next = pre;// 翻转当前节点</span><br><span class="line">            pre = cur; // 整体右移一个</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h2><ul><li><a href="https://programmercarl.com/0024.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html">代码随想录 (programmercarl.com)</a></li></ul></li><li><p>该题就是要求把链表中每两个元素的顺序调换</p></li><li><p>方法就是选定锚点，然后以锚点后两个交换</p></li><li><p>参考代码随想录思路的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* swapPairs(ListNode* head) &#123;</span><br><span class="line">        // 建个哨兵以统一后面的交换进程</span><br><span class="line">        ListNode *setinel = new ListNode(0);</span><br><span class="line">        setinel-&gt;next = head;</span><br><span class="line">        ListNode *cur = setinel;</span><br><span class="line">        // 以cur为基准，交换后两个结点</span><br><span class="line">        while(cur-&gt;next != nullptr &amp;&amp; cur-&gt;next-&gt;next != nullptr) &#123;</span><br><span class="line">            ListNode *tmp1 = cur-&gt;next;</span><br><span class="line">            ListNode *tmp2 = cur-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">            // 先连接到后面，剩下两个随意换</span><br><span class="line">            tmp1-&gt;next = tmp2-&gt;next;</span><br><span class="line">            tmp2-&gt;next = tmp1;</span><br><span class="line">            cur-&gt;next = tmp2;</span><br><span class="line"></span><br><span class="line">            // 向右移动两节点</span><br><span class="line">            cur = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 由于head可能变了，传setinel回去</span><br><span class="line">        return setinel-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h2><ul><li><a href="https://programmercarl.com/0019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.html">代码随想录 (programmercarl.com)</a></li></ul></li><li><p>题意易见</p></li><li><p>一次遍历解决的方法是，用双指针，快指针先走N步，再两指针一起走，最后删除慢指针后面那个。</p></li><li><p>参考代码随想录思路的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;</span><br><span class="line">        // 哨兵节点统一处理</span><br><span class="line">        ListNode *sentinel = new ListNode(0);</span><br><span class="line">        sentinel-&gt;next = head;</span><br><span class="line">        ListNode *right = sentinel, *left = sentinel;</span><br><span class="line">        // 先走N步</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            right = right-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 一起走</span><br><span class="line">        while(right-&gt;next != nullptr) &#123;</span><br><span class="line">            right = right-&gt;next;</span><br><span class="line">            left = left-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 删慢指针后面那个</span><br><span class="line">        ListNode *tmp = left-&gt;next;</span><br><span class="line">        left-&gt;next = tmp-&gt;next;</span><br><span class="line">        delete tmp;</span><br><span class="line">        return sentinel-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h2><ul><li><a href="https://programmercarl.com/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4.html">代码随想录 (programmercarl.com)</a></li></ul></li><li><p>即有两条长短不一的链表，在后面某一点交会到一条，找到交汇的那个点</p></li><li><p>方法即是先找到两个链表的长度，然后让长短两条各有一指针从相同位置同时检测两指针是否相等，毕竟前面的长短不一的部分不可能交汇</p></li><li><p>参考代码随想录思路的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span><br><span class="line">        int len_a = 0, len_b = 0;</span><br><span class="line">        ListNode *cur_a = headA, *cur_b = headB;</span><br><span class="line"></span><br><span class="line">        // 分别测量 a 和 b 的长度</span><br><span class="line">        while(cur_a != nullptr) &#123;</span><br><span class="line">            cur_a = cur_a-&gt;next;</span><br><span class="line">            len_a++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while(cur_b != nullptr) &#123;</span><br><span class="line">            cur_b = cur_b-&gt;next;</span><br><span class="line">            len_b++;</span><br><span class="line">        &#125;</span><br><span class="line">        cur_a = headA;</span><br><span class="line">        cur_b = headB;</span><br><span class="line"></span><br><span class="line">        int len_dif = abs(len_a - len_b);</span><br><span class="line"></span><br><span class="line">        // 保证 a 是较长的一端</span><br><span class="line">        if (len_a &lt; len_b) &#123;</span><br><span class="line">            swap(cur_a, cur_b);</span><br><span class="line">            swap(len_a, len_b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 对齐 a 和 b</span><br><span class="line">        for (int i = 0; i &lt; len_dif; i++) &#123;</span><br><span class="line">            cur_a = cur_a-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 逐一检查是否相等</span><br><span class="line">        while(cur_a != nullptr) &#123;</span><br><span class="line">            if (cur_a == cur_b) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            cur_a = cur_a-&gt;next;</span><br><span class="line">            cur_b = cur_b-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return cur_a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表||"></a>环形链表||</h2><ul><li><a href="https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html">代码随想录 (programmercarl.com)</a></li></ul></li><li><p>即链表后面可能有个环，要求返回入环点</p></li><li><p>两个问题，一、有没有环；二、入环点怎么找</p></li><li><p>有没有环的问题，可以通过简单的双指针解决，即快指针走两步，慢指针走一步，若是有环，一定在某点相遇。倘若慢指针刚入环，无论快指针在环走多少，此时设快指针到慢指针距离 x，每次行动距离减一，迟早相遇。</p></li><li><p>接着是入环点的问题，接下来就是数学为主的时间，设 head 到入环点距离 x，入环点到相遇点距离 y，相遇点到入环点距离 z，慢指针就走了 x+y，快指针走了 x+n* (y+z) +y （毕竟可能走了几圈），快指针移速为慢指针两倍，可列式子 2*(x+y) &#x3D;  x+n* (y+z) +y，消减得 x &#x3D; n(y+z) - y，变换得 x &#x3D; (n-1)(y+z) + z，一看从相遇点开始走 z 步（可能加上好几圈）以及从头开始走的不就可以在入环点相遇了嘛。</p><p>假设 n&#x3D;1，x&#x3D;&#x3D;z，两边直接相遇；n&#x3D;2，相遇点处的指针多走一圈，也能相遇  </p></li><li><p>参考代码随想录思路的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *detectCycle(ListNode *head) &#123;</span><br><span class="line">        ListNode *fast = head, *slow = head;</span><br><span class="line"></span><br><span class="line">        // 探明是否有环</span><br><span class="line">        while(fast != nullptr &amp;&amp; fast-&gt;next != nullptr) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            if (fast == slow) &#123;</span><br><span class="line">                // 从交汇点与起点同时走，交汇于入环点</span><br><span class="line">                slow = head;</span><br><span class="line">                while (fast != slow) &#123;</span><br><span class="line">                    fast = fast-&gt;next;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                return fast;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nullptr;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法周记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Conda】 miniconda 使用手册</title>
      <link href="/posts/c5d31b94.html"/>
      <url>/posts/c5d31b94.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是陆爻齐平时经常使用 conda 的一些记录，且作为复习笔记罢</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="创建环境"><a href="#创建环境" class="headerlink" title="创建环境"></a>创建环境</h2><ul><li><code>conda create -n name python=3.9.*</code></li><li>这条语句的意思是创建名字为 name，python 版本为 3.9 中最新的版本的环境，-n 后面跟名字，python 也可先不确定，但还没试过后面安 python。</li></ul><h2 id="查看环境"><a href="#查看环境" class="headerlink" title="查看环境"></a>查看环境</h2><ul><li><code>conda env list</code></li><li>会列出所有已有的虚拟环境</li></ul><h2 id="删除环境"><a href="#删除环境" class="headerlink" title="删除环境"></a>删除环境</h2><ul><li><code>conda remove -n name --all</code></li><li>删除名字为 name 的环境</li></ul><h2 id="克隆环境"><a href="#克隆环境" class="headerlink" title="克隆环境"></a>克隆环境</h2><ul><li><code>conda create -n name --clone other</code></li><li>将名为 other 的环境复制到新环境 name 中</li></ul><h2 id="更改存储和环境的地方"><a href="#更改存储和环境的地方" class="headerlink" title="更改存储和环境的地方"></a>更改存储和环境的地方</h2><blockquote><p><a href="https://www.autodl.com/docs/miniconda/#:~:text=%E5%8F%96%E6%B6%88%E8%AE%BE%E7%BD%AE%E5%AE%89%E8%A3%85%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%88%B0%E6%95%B0%E6%8D%AE%E7%9B%98,%E7%BC%96%E8%BE%91%2Froot%2F.condarc%E6%96%87%E4%BB%B6%EF%BC%8C%E5%88%A0%E9%99%A4%E5%AF%B9%E5%BA%94%E7%9A%84%E8%B7%AF%E5%BE%84%E6%89%80%E5%9C%A8%E8%A1%8C%E5%8D%B3%E5%8F%AF">https://www.autodl.com/docs/miniconda/#:~:text=%E5%8F%96%E6%B6%88%E8%AE%BE%E7%BD%AE%E5%AE%89%E8%A3%85%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%88%B0%E6%95%B0%E6%8D%AE%E7%9B%98,%E7%BC%96%E8%BE%91%2Froot%2F.condarc%E6%96%87%E4%BB%B6%EF%BC%8C%E5%88%A0%E9%99%A4%E5%AF%B9%E5%BA%94%E7%9A%84%E8%B7%AF%E5%BE%84%E6%89%80%E5%9C%A8%E8%A1%8C%E5%8D%B3%E5%8F%AF</a></p></blockquote><ul><li>执行以下命令设置将虚拟环境安装到&#x2F;root&#x2F;autodl-tmp&#x2F;conda&#x2F;envs， 包缓存到&#x2F;root&#x2F;autodl-tmp&#x2F;conda&#x2F;pkgs</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /root/autodl-tmp/conda/pkgs</span><br><span class="line">conda config --add pkgs_dirs /root/autodl-tmp/conda/pkgs</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p /root/autodl-tmp/conda/envs</span><br><span class="line">conda config --add envs_dirs /root/autodl-tmp/conda/envs</span><br></pre></td></tr></table></figure><h2 id="打包环境"><a href="#打包环境" class="headerlink" title="打包环境"></a>打包环境</h2><blockquote><p><a href="https://zhuanlan.zhihu.com/p/540615230">https://zhuanlan.zhihu.com/p/540615230</a></p></blockquote><ul><li>构建环境的操作系统必须与目标的操作系统匹配。这意味着在Windows上构建的环境不能重新定位到Linux。</li></ul><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把虚拟环境 my_env 打包为 my_env.tar.gz</span></span><br><span class="line">conda pack -n my_env</span><br><span class="line"></span><br><span class="line"><span class="comment"># -o 参数指定打包路径和名称，把虚拟环境 my_env 打包为 out_name.tar.gz</span></span><br><span class="line">conda pack -n my_env -o out_name.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把某个特定路径的虚拟环境打包为 my_env.tar.gz</span></span><br><span class="line">conda pack -p /explicit/path/to/my_env</span><br></pre></td></tr></table></figure><h3 id="解压使用"><a href="#解压使用" class="headerlink" title="解压使用"></a>解压使用</h3><h4 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建目录 `my_env`，并将环境解压至该目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p my_env</span><br><span class="line">tar -xzf my_env.tar.gz -C my_env</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用python而不激活或修复前缀。</span></span><br><span class="line"><span class="comment"># 大多数 python 库可以正常工作，但需要处理前缀的部分将失败。</span></span><br><span class="line">./my_env/bin/python</span><br><span class="line"></span><br><span class="line"><span class="comment"># 激活环境，同时这步操作会将路径 `my_env/bin` 添加到环境变量 path</span></span><br><span class="line"><span class="built_in">source</span> my_env/bin/activate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在环境中运行python</span></span><br><span class="line">(my_env) $ python</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从激活环境中清除前缀。</span></span><br><span class="line"><span class="comment"># 请注意，也可以在不激活环境的情况下运行此命令</span></span><br><span class="line"><span class="comment"># 只要机器上已经安装了某个版本的python。</span></span><br><span class="line">(my_env) $ conda-unpack</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时，环境与您在此路径直接使用 conda 安装的环境完全相同。</span></span><br><span class="line"><span class="comment"># 所有脚本都应该工作正常。</span></span><br><span class="line">(my_env) $ ipython --version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停用环境以将其从环境变量 path 中删除</span></span><br><span class="line">(my_env) $ <span class="built_in">source</span> my_env/bin/deactivate</span><br></pre></td></tr></table></figure><h4 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h4><ul><li><p>新建 <code>my_env</code> 文件夹，将打包的 my_env.tar.gz 文件解压到该文件夹中。</p></li><li><p>使用 cmd 打开路径 <code>my_env</code> 所在路径</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入项目路径</span></span><br><span class="line"><span class="built_in">cd</span> C:\my_env</span><br><span class="line"></span><br><span class="line"><span class="comment"># 激活环境 </span></span><br><span class="line">.\Scripts\activate.bat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从激活环境中清除前缀。</span></span><br><span class="line">.\Scripts\conda-unpack.exe</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出环境</span></span><br><span class="line">.\Scripts\deactivate.bat</span><br></pre></td></tr></table></figure><h2 id="修复无法激活环境的问题"><a href="#修复无法激活环境的问题" class="headerlink" title="修复无法激活环境的问题"></a>修复无法激活环境的问题</h2><ul><li><p>问题发生情景：在 activate 环境时，报错如 <code>UnicodeDecodeError: &#39;gbk&#39; codec can&#39;t decode byte 0xae in position 790: illegal multibyte sequence Unexpected cygpath error (&#39;NoneType&#39; object has no attribute &#39;strip&#39;)</code></p></li><li><p>问题排查过程：经解读报错和查阅资料发现，该问题是由于 conda 在启动环境的过程中，读取到了非正常字符。想到最近安装了微信开发者工具，让环境变量的 Path 中出现了中文，故删除对应的环境路径，再启动环境就正常了</p></li><li><p>总结：环境变量 Path 中出现的中文让 conda 激活环境失败</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Conda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Weekly Algorithm】 算法周记之《代码随想录》数组</title>
      <link href="/posts/1709b771.html"/>
      <url>/posts/1709b771.html</url>
      
        <content type="html"><![CDATA[<h1 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h1><p>前两周跟随《代码随想录》，对数组的部分做学习，具体而言，学习了二分查找、前缀和、双指针、滑动窗口的方法，来解决相关数组问题。</p><p>也学到要坚持循环不变原则，即有些原则在循环中应保持不变，以统一后续操作，方便完成循环，具体可查看螺旋矩阵的部分。</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="正例"><a href="#正例" class="headerlink" title="正例"></a>正例</h3><ul><li><p><a href="https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E6%80%BB%E7%BB%93">代码随想录 (programmercarl.com)</a></p></li><li><p>二分查找重点是搞清楚边界，下面是左闭右开的写法</p></li><li><p>参考代码随想录思路的解法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int func(vector&lt;int&gt; nums, int target) &#123;</span><br><span class="line">int left = 0, right = nums.size(), middle;</span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">    middle = (left + right) / 2;</span><br><span class="line">        if (nums[middle] &gt; target) right = middle;</span><br><span class="line">        else if (nums[middle] &lt; target) left = middle + 1;</span><br><span class="line">        else return middle;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>左闭右开，即 num[left] 在搜索范围内（可能为 target），num[right] 刚好不在，所以中间更新时也有所区别，left 得是 middle + 1，因为 middle 处已确认不是 target</p></li><li><p>倘若考虑闭区间，将 while 改 <code>while (left &lt;= right)</code>, right 改 <code>right = nums.size() - 1</code>，<code>right = middle - 1</code>即可</p></li></ul><h3 id="补充例题"><a href="#补充例题" class="headerlink" title="补充例题"></a>补充例题</h3><h4 id="leetcode-查找数组中元素的第一个和最后一个位置"><a href="#leetcode-查找数组中元素的第一个和最后一个位置" class="headerlink" title="leetcode_查找数组中元素的第一个和最后一个位置"></a>leetcode_查找数组中元素的第一个和最后一个位置</h4><ul><li><p><a href="https://programmercarl.com/0034.%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE.html">代码随想录</a></p></li><li><p>首先，可以用两次二分法确认元素的左右边界</p><p>最重要的是，分清查找后的三种情况  </p><ol><li>元素大小在数组外，自然不在数组中，比如数组中最大的是9，target 是 12；</li><li>元素大小在数组内，但不在数组中，比如target 是 5，但数组为……4，6……；</li><li>元素在数组中</li></ol></li></ul><p>如此一来，可以设置变量，检测二分法找边界时，是否有更新边界，两次二分法有一次没有更新边界的情况，都说明元素大小在数组外  </p><p>当两次都更新了边界，就可以看看给出的边界是否时target，不是的话属于第二种情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int left = searchLeft(nums, target), right = searchRight(nums, target);</span><br><span class="line">        vector&lt;int&gt;result(2);</span><br><span class="line">        // 处理数在外的的情况</span><br><span class="line">        if (left == -2 || right == -2) &#123;</span><br><span class="line">            result[0] = -1; result[1] = -1;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        // 处理数在不在其中但大小在中间的情况</span><br><span class="line">        else if (nums[left] != target) &#123;</span><br><span class="line">            result[0] = -1; result[1] = -1;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        // 处理数在其中的情况</span><br><span class="line">        result[0] = left, result[1] = right - 1;</span><br><span class="line">        return result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 找到左边界的二分法</span><br><span class="line">    int searchLeft(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int left = 0, right = nums.size(), middle = 0;</span><br><span class="line">        int leftBoarder = -2;</span><br><span class="line"></span><br><span class="line">        while (left &lt; right) &#123;</span><br><span class="line">            middle = (left + right) / 2;</span><br><span class="line">            if (nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + 1; </span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                right = middle;</span><br><span class="line">                leftBoarder = right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //cout &lt;&lt; leftBoarder &lt;&lt; endl;</span><br><span class="line">        return leftBoarder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 找到右边界的二分法</span><br><span class="line">    int searchRight(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int left = 0, right = nums.size(), middle = 0;</span><br><span class="line">        int rightBoarder = -2;</span><br><span class="line"></span><br><span class="line">        while (left &lt; right) &#123;</span><br><span class="line">            middle = (left + right) / 2;</span><br><span class="line">            if (nums[middle] &lt;= target) &#123;</span><br><span class="line">                left = middle + 1;</span><br><span class="line">                rightBoarder = left;</span><br><span class="line">            &#125; </span><br><span class="line">            else right = middle; </span><br><span class="line">        &#125;</span><br><span class="line">        //cout &lt;&lt; rightBoarder &lt;&lt; endl;</span><br><span class="line">        return rightBoarder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="leetcode-x的平方根"><a href="#leetcode-x的平方根" class="headerlink" title="leetcode_x的平方根"></a>leetcode_x的平方根</h4><ul><li><a href="https://leetcode.cn/problems/sqrtx/description/">69. x 的平方根 - 力扣（LeetCode）</a></li><li>即找到平方为 x 的平方根的整数部分</li><li>毕竟就是算术平方根，就用二分法逼近即可，注意 middle * middle 可能超 int，用 long long 就行</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int mySqrt(int x) &#123;</span><br><span class="line">        int result = 0, left = 0, right = x + 1; </span><br><span class="line">        unsigned long long middle = 0;</span><br><span class="line">// 二分试那个数平方恰小于等于的</span><br><span class="line">        while(left &lt; right) &#123;</span><br><span class="line">            middle = (left + right) / 2;</span><br><span class="line">            if (middle * middle &gt; x) &#123;</span><br><span class="line">                right = middle;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                left = middle + 1;</span><br><span class="line">                result = middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="leetcode-有效的完全平方数"><a href="#leetcode-有效的完全平方数" class="headerlink" title="leetcode_有效的完全平方数"></a>leetcode_有效的完全平方数</h4><ul><li><a href="https://leetcode.cn/problems/valid-perfect-square/description/">367. 有效的完全平方数 - 力扣（LeetCode）</a></li><li>即判断当前数是否为完全平方数，二分法找个平方为该数即可</li><li>与上个平方类似，不多说， [[leetcode_x的平方根]]</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPerfectSquare(int num) &#123;</span><br><span class="line">        unsigned long long left = 0, right = num, middle = 0;</span><br><span class="line">        // 二分法试出那个平方为 num 的数</span><br><span class="line">        while (left &lt;= right) &#123;</span><br><span class="line">            middle = (left + right) / 2;</span><br><span class="line">            if (middle * middle &gt; num) &#123;</span><br><span class="line">                right = middle - 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (middle * middle &lt; num) &#123;</span><br><span class="line">                left = middle + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h2><h3 id="正例-1"><a href="#正例-1" class="headerlink" title="正例"></a>正例</h3><ul><li><a href="https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录 (programmercarl.com)</a></li><li>暴力解法<br>即每次遇到要删除的元素，就把数组后面每一位向左覆盖一位  </li><li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;</span><br><span class="line">        int size = nums.size();</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            if (nums[i] == val) &#123;</span><br><span class="line">                for (int j = i; j &lt; size - 1; j++) &#123;</span><br><span class="line">                    nums[j] = nums[j + 1];</span><br><span class="line">                &#125;</span><br><span class="line">                size--;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>双指针法<br>快指针去找元素，慢指针是新数组的元素  </li><li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;</span><br><span class="line">        int fast_p = 0, slow_p = 0;</span><br><span class="line">        int size = nums.size();</span><br><span class="line">        for (fast_p = 0; fast_p &lt; size; fast_p++) &#123;</span><br><span class="line">            if (nums[fast_p] != val) &#123;</span><br><span class="line">                nums[slow_p++] = nums[fast_p];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return slow_p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="补充例题-1"><a href="#补充例题-1" class="headerlink" title="补充例题"></a>补充例题</h3><h4 id="leetcode-重复删除有序数组中的重复项"><a href="#leetcode-重复删除有序数组中的重复项" class="headerlink" title="leetcode_重复删除有序数组中的重复项"></a>leetcode_重复删除有序数组中的重复项</h4><ul><li><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项 - 力扣（LeetCode）</a></li><li>即数组去重</li><li>双指针秒了</li><li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int size = nums.size(), slow = 0, fast = 0;</span><br><span class="line">        int counter = 1;</span><br><span class="line">        for (fast = 1; fast &lt; size; fast++) &#123;</span><br><span class="line">        // 不同的情况做个覆盖</span><br><span class="line">            if (nums[slow] != nums[fast]) &#123;</span><br><span class="line">                nums[++slow] = nums[fast];</span><br><span class="line">                counter++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="leetcode-移动零"><a href="#leetcode-移动零" class="headerlink" title="leetcode_移动零"></a>leetcode_移动零</h4><ul><li><a href="https://leetcode.cn/problems/move-zeroes/description/">283. 移动零 - 力扣（LeetCode）</a></li><li>即保持非零数字顺序，零全放右侧</li><li>双指针解决，记得有个 swap 函数可用于向量就方便些，简单地说，就是让快指针去找非零数，然后替换到慢指针所在的地方，若快指针遇到零就不换，跳过就是。</li><li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int size = nums.size();</span><br><span class="line">        int slow = 0, fast = 0;</span><br><span class="line">        for (fast = 0; fast &lt; size; fast++) &#123;</span><br><span class="line">        // 快指针不为 0 时，快慢指针换值并使慢指针右移</span><br><span class="line">            if (nums[fast] != 0) &#123;</span><br><span class="line">                swap(nums[slow++], nums[fast]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="leetcode-比较含退格的字符串"><a href="#leetcode-比较含退格的字符串" class="headerlink" title="leetcode_比较含退格的字符串"></a>leetcode_比较含退格的字符串</h4><ul><li><a href="https://leetcode.cn/problems/backspace-string-compare/description/">844. 比较含退格的字符串 - 力扣（LeetCode）</a></li></ul></li><li>该题思路挺多，不过还得是双指针</li><li>可以用栈来改两个字符串，陆爻齐选择用双指针来改两字符串，也就是用慢指针确认前面的字符是什么，快指针去找要放在字符串的字符，换到慢指针处，与移动零的区别是，遇到 ‘#’ 时，慢指针应向左一格，让下次的字符覆盖上个字符。</li><li>也有思路从后向前双指针同时比较（退格键的左侧不重要，右侧可确定）</li><li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool backspaceCompare(string s, string t) &#123;</span><br><span class="line">        work(s);</span><br><span class="line">        work(t);</span><br><span class="line">        return s==t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 使字符串变成处理完退格字符后的字符串</span><br><span class="line">    void work(string &amp;s) &#123;</span><br><span class="line">        int size = s.size(), slow = 0, fast = 0;</span><br><span class="line">        for (fast = 0; fast &lt; size; fast++) &#123;</span><br><span class="line">            if (s[fast] != &#x27;#&#x27;) &#123;</span><br><span class="line">                s[slow++] = s[fast];</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                if (slow &gt; 0) &#123;</span><br><span class="line">                    slow--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s = s.substr(0, slow);</span><br><span class="line">        //cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="leetcode-有序数组的平方"><a href="#leetcode-有序数组的平方" class="headerlink" title="leetcode_有序数组的平方"></a>leetcode_有序数组的平方</h4><ul><li><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/solutions/2806253/xiang-xiang-shuang-zhi-zhen-cong-da-dao-blda6/">977. 有序数组的平方 - 力扣（LeetCode）</a></li><li>即将非递减的数组（含负数），各位平方后再以非递减序列排成数组</li><li>从两侧向中间检测，也是双指针罢</li><li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int left = 0, size = nums.size(), right = size - 1;</span><br><span class="line">        vector&lt;int&gt; result(size);</span><br><span class="line">        for (int i = size - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        // 左右比较，选大者放后面，循环至尽</span><br><span class="line">            if (nums[left] * nums[left]&gt; nums[right] * nums[right]) &#123;</span><br><span class="line">                result[i] = nums[left] * nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                result[i] = nums[right] * nums[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><h3 id="正例-2"><a href="#正例-2" class="headerlink" title="正例"></a>正例</h3><ul><li><a href="https://programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></li><li>滑动窗口可以视为双指针的特殊形态，以 <a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">长度最小的子数组</a> 为例</li><li>该题要求一个数组中连续元素和大于 target 的最小长度是多少</li><li>暴力解法可以用两个 for 循环嵌套，一个相当于起始，一个相当于终止，穷举出所有可能，不过时间复杂度为 O(n^2)</li><li>那么接下来就是 O(n) 的滑动窗口啦，该方法用 for 循环遍历终止位置，当快指针已遍历的数值满足需求时，记录长度，同时慢指针也向右移动至不满足要求，此时快指针再向右移动找下一个满足需求的情况</li><li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int size = nums.size(), sum = 0, least_len = INT32_MAX, i = 0, sub_len;</span><br><span class="line">        for (int j = 0; j &lt; size; j++) &#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            while (sum &gt;= target) &#123;</span><br><span class="line">                sub_len = j - i + 1;</span><br><span class="line">                if (least_len &gt; sub_len) &#123;</span><br><span class="line">                    least_len = sub_len;</span><br><span class="line">                &#125;</span><br><span class="line">                sum -= nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return (least_len == INT32_MAX) ? 0 : least_len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="补充例子"><a href="#补充例子" class="headerlink" title="补充例子"></a>补充例子</h3><h4 id="leetcode-水果成篮"><a href="#leetcode-水果成篮" class="headerlink" title="leetcode_水果成篮"></a>leetcode_水果成篮</h4><ul><li><a href="https://leetcode.cn/problems/fruit-into-baskets/">904. 水果成篮 - 力扣（LeetCode）</a></li><li>该题就是求数组中最长的连续两数字序列长度</li><li>要点是运用哈希表来做查重记录工作</li><li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int totalFruit(vector&lt;int&gt;&amp; fruits) &#123;</span><br><span class="line">        unordered_map&lt;int,int&gt; cns;</span><br><span class="line">        int size = fruits.size();</span><br><span class="line">        int left = 0;</span><br><span class="line">        int max_len = 0;</span><br><span class="line">        for (int right = 0; right &lt; size; right++) &#123;</span><br><span class="line">        // 记录第一次遇到该数字</span><br><span class="line">            if (cns.find(fruits[right]) == cns.end()) &#123;</span><br><span class="line">                //cns.insert(&#123;fruits[right], 1&#125;);</span><br><span class="line">                cns[fruits[right]] = 1;</span><br><span class="line">            &#125;</span><br><span class="line">            // 重复计数</span><br><span class="line">            else &#123;</span><br><span class="line">                cns[fruits[right]]++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 当种类超过 2，开始去除一个</span><br><span class="line">            while (cns.size() &gt; 2) &#123;</span><br><span class="line">                cns[fruits[left]]--;</span><br><span class="line">                if (cns[fruits[left]] == 0) &#123;</span><br><span class="line">                    cns.erase(fruits[left]);</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 更新值</span><br><span class="line">            max_len = max(max_len, right - left + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return max_len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="leetcode-最小覆盖子串"><a href="#leetcode-最小覆盖子串" class="headerlink" title="leetcode_最小覆盖子串"></a>leetcode_最小覆盖子串</h4><ul><li><a href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串 - 力扣（LeetCode）</a></li><li>该题就是在字符串 s 上，找涵盖字符串 t 所有字符的最小字符子串</li><li>只好用两字典存已有字符和目标字符，其余还是沿用滑动窗口，不过效率很低</li><li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    unordered_map&lt;char, int&gt; cns, target;</span><br><span class="line">    string minWindow(string s, string t) &#123;</span><br><span class="line">        string result = &quot;&quot;;</span><br><span class="line">        int min_len = INT32_MAX, start_ind = 0;</span><br><span class="line"></span><br><span class="line">        // 初始化 target 和 cns</span><br><span class="line">        for(auto it : t) &#123;</span><br><span class="line">            target[it]++;</span><br><span class="line">            cns[it] = 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int left = 0, right = 0;</span><br><span class="line">        int size = s.size();</span><br><span class="line"></span><br><span class="line">        for (right = 0; right &lt; size; right++) &#123;</span><br><span class="line">            if (cns.find(s[right]) != cns.end()) &#123;</span><br><span class="line">                cns[s[right]]++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 满足就调整左边窗口</span><br><span class="line">            while (check()) &#123;</span><br><span class="line">                if (right - left + 1 &lt; min_len) &#123;</span><br><span class="line">                    //cout &lt;&lt; &quot;left &quot; &lt;&lt; left &lt;&lt; &quot;;&quot; &lt;&lt; &quot;right &quot; &lt;&lt; right &lt;&lt; endl;</span><br><span class="line">                    start_ind = left;</span><br><span class="line">                    min_len = right - left + 1;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                if (cns.find(s[left]) != cns.end()) &#123;</span><br><span class="line">                    cns[s[left]]--;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 排除无结果的错误</span><br><span class="line">        if (min_len == INT32_MAX) &#123;</span><br><span class="line">            min_len = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        result = s.substr(start_ind, min_len);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 检查已有条件是否满足</span><br><span class="line">    bool check() &#123;</span><br><span class="line">        for (auto &amp;it : cns) &#123;</span><br><span class="line">            if (it.second &lt; target[it.first]) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h2><h3 id="正例-3"><a href="#正例-3" class="headerlink" title="正例"></a>正例</h3><ul><li><a href="https://programmercarl.com/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></li><li>即将数组以某种特定方式赋值排列</li><li>没有特定的方法，重点是坚持循环不变原则，即有些处理时统一方法，比如螺旋矩阵换方向赋值时，可坚持左闭右开的原则赋值</li><li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res = vector(n, vector&lt;int&gt;(n, 0));</span><br><span class="line">        int loop = n / 2; // 主循环次数</span><br><span class="line">        int middle = n / 2; // 记录矩阵中间的值</span><br><span class="line">        int startx = 0, starty = 0; // 记录每次循环的起点/终点</span><br><span class="line">        int set_num = 1; // 每次放入的数字</span><br><span class="line">        int off_set = 1; // 控制每循环填数个数</span><br><span class="line">        int i, j;</span><br><span class="line"></span><br><span class="line">        while(loop-- &gt;= 0) &#123;</span><br><span class="line">            i = startx, j = starty;</span><br><span class="line">            // 左上到右上</span><br><span class="line">            for (;j &lt; n - off_set; j++) &#123;</span><br><span class="line">                res[i][j] = set_num++;</span><br><span class="line">            &#125;</span><br><span class="line">            // 右上到右下</span><br><span class="line">            for (;i &lt; n - off_set; i++) &#123;</span><br><span class="line">                res[i][j] = set_num++;</span><br><span class="line">            &#125;</span><br><span class="line">            // 右下到左下</span><br><span class="line">            for (;j &gt; starty; j--) &#123;</span><br><span class="line">                res[i][j] = set_num++;</span><br><span class="line">            &#125;</span><br><span class="line">            // 左下到左上</span><br><span class="line">            for (;i &gt; startx; i--) &#123;</span><br><span class="line">                res[i][j] = set_num++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line">            off_set++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 对奇数矩阵补中间</span><br><span class="line">        if (n % 2 != 0) &#123;</span><br><span class="line">            res[middle][middle] = set_num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="补充例子-1"><a href="#补充例子-1" class="headerlink" title="补充例子"></a>补充例子</h3><h4 id="leetcode-螺旋遍历二维数组"><a href="#leetcode-螺旋遍历二维数组" class="headerlink" title="leetcode_螺旋遍历二维数组"></a>leetcode_螺旋遍历二维数组</h4><ul><li><a href="https://leetcode.cn/problems/spiral-matrix/description/">54. 螺旋矩阵 - 力扣（LeetCode）</a></li><li>该题要将一个 m*n 的矩阵顺时针输出其中的内容</li><li>代码随想录没解，暂时也没想到那个思路的延申</li><li>可借鉴思路是，每次按向右，向下，向左，向上四次输出到头，每个方向走完，判断下下个方向是否还有路，无则马上退出</li><li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        int m = matrix.size(), n = matrix[0].size();</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        </span><br><span class="line">        int u = 0, d = m - 1; // 上下</span><br><span class="line">        int l = 0, r = n - 1; // 左右</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            for (int i = l; i &lt; r + 1; i++) &#123;</span><br><span class="line">                res.push_back(matrix[u][i]); // 向右</span><br><span class="line">            &#125;</span><br><span class="line">            if (++u &gt; d) break;// 上边界大于下边界</span><br><span class="line">            for (int i = u; i &lt; d + 1; i++) &#123;</span><br><span class="line">                res.push_back(matrix[i][r]); // 向下</span><br><span class="line">            &#125;</span><br><span class="line">            if (--r &lt; l) break; // 右边界左于左边界</span><br><span class="line">            for (int i = r; i &gt; l - 1; i--) &#123;</span><br><span class="line">                res.push_back(matrix[d][i]); // 向左</span><br><span class="line">            &#125;</span><br><span class="line">            if (--d &lt; u) break; // 下边界高于上边界</span><br><span class="line">            for (int i = d; i &gt; u - 1; i--) &#123;</span><br><span class="line">                res.push_back(matrix[i][l]); // 向上</span><br><span class="line">            &#125;</span><br><span class="line">            if (++l &gt; r) break; // 左边界右于右边界</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="区间和"><a href="#区间和" class="headerlink" title="区间和"></a>区间和</h2><h3 id="正例-4"><a href="#正例-4" class="headerlink" title="正例"></a>正例</h3><ul><li><a href="https://programmercarl.com/0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></li><li><a href="https://kamacoder.com/problempage.php?pid=1070">58. 区间和（第九期模拟笔试） (kamacoder.com)</a></li><li>就是要短时间内多次求一个数组上一段区间的数之和</li><li>要用到前缀和，也就是在初始化数组时，用另一个数组存当前下标之前所有数字的和（每次存新数就更新累加和即可）</li><li>最后求区间和时，用前缀和数组的右下标减左下标即可</li><li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int count = 0,left = 0, right = 0;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;count);</span><br><span class="line">    vector&lt;int&gt; num(count), pre_sum(count);</span><br><span class="line">    int store_sum = 0;</span><br><span class="line">    </span><br><span class="line">    // 记录数组同时计算前缀和</span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;num[i]);</span><br><span class="line">        store_sum += num[i];</span><br><span class="line">        pre_sum[i] = store_sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 持续接收左右下标至输入结束</span><br><span class="line">    while(~scanf(&quot;%d %d&quot;, &amp;left, &amp;right)) &#123;</span><br><span class="line">        if (left == 0) &#123;</span><br><span class="line">            printf(&quot;%d\n&quot;,pre_sum[right]);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, pre_sum[right] - pre_sum[left-1]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="补充例子-2"><a href="#补充例子-2" class="headerlink" title="补充例子"></a>补充例子</h3><h4 id="开发商购买土地"><a href="#开发商购买土地" class="headerlink" title="开发商购买土地"></a>开发商购买土地</h4><ul><li><a href="https://kamacoder.com/problempage.php?pid=1044">44. 开发商购买土地（第五期模拟笔试） (kamacoder.com)</a></li><li>给一个 m*n 的数组，可能对每行每列横切&#x2F;竖切，求两边差值最小值</li><li>可前缀和记录横向或者竖向的前缀和，然后就可方便大量计算差值</li><li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int m, n;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; block(n, vector&lt;int&gt;(m, 0));</span><br><span class="line">    vector&lt;int&gt; horizontal(n, 0);</span><br><span class="line">    vector&lt;int&gt; vertical(m, 0);</span><br><span class="line">    int result = INT32_MAX;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    </span><br><span class="line">    // 初始化，顺便把横向前缀和求完</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; block[i][j];</span><br><span class="line">            horizontal[i] += block[i][j];</span><br><span class="line">            sum += block[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 计算垂直前缀和</span><br><span class="line">    for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            vertical[j] += block[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int horizontal_cut = 0;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        horizontal_cut += horizontal[i];</span><br><span class="line">        result = min(result, abs(sum - horizontal_cut - horizontal_cut));// （sum - horizontal_cut）是一个公司的子区域价值，horizontal_cut是另一公司的子区域价值</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int vertical_cut = 0;</span><br><span class="line">    for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">        vertical_cut += vertical[j];</span><br><span class="line">        result = min(result, abs(sum - vertical_cut - vertical_cut));</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法周记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CS61A-Fall-2020】学习记录七 Homework2 题解思路分享</title>
      <link href="/posts/58db1e1b.html"/>
      <url>/posts/58db1e1b.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>观前提示，笔者写的代码答案放在 <a href="https://github.com/HSLix/CS61A-Fall-2020">GitHub仓库</a> 中，此处仅记录过程与心得。</p><p>此外，请最好在尝试独立完成该任务后再看本文，否则就很可能失去了体验本项目精华的机会</p><h2 id="Higher-Order-Functions"><a href="#Higher-Order-Functions" class="headerlink" title="Higher-Order Functions"></a>Higher-Order Functions</h2><h3 id="Q1-Product"><a href="#Q1-Product" class="headerlink" title="Q1: Product"></a>Q1: Product</h3><p>Write a function called product that returns the product of the first n terms of a sequence. Specifically, product takes in an integer n and term, a single-argument function that determines a sequence. (That is, term(i) gives the ith term of the sequence.) product(n, term) should return term(1) * … * term(n).</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def product(n, term):</span><br><span class="line">    &quot;&quot;&quot;Return the product of the first n terms in a sequence.</span><br><span class="line"></span><br><span class="line">    n: a positive integer</span><br><span class="line">    term:  a function that takes one argument to produce the term</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; product(3, identity)  # 1 * 2 * 3</span><br><span class="line">    6</span><br><span class="line">    &gt;&gt;&gt; product(5, identity)  # 1 * 2 * 3 * 4 * 5</span><br><span class="line">    120</span><br><span class="line">    &gt;&gt;&gt; product(3, square)    # 1^2 * 2^2 * 3^2</span><br><span class="line">    36</span><br><span class="line">    &gt;&gt;&gt; product(5, square)    # 1^2 * 2^2 * 3^2 * 4^2 * 5^2</span><br><span class="line">    14400</span><br><span class="line">    &gt;&gt;&gt; product(3, increment) # (1+1) * (2+1) * (3+1)</span><br><span class="line">    24</span><br><span class="line">    &gt;&gt;&gt; product(3, triple)    # 1*3 * 2*3 * 3*3</span><br><span class="line">    162</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    &quot;*** YOUR CODE HERE ***&quot;</span><br></pre></td></tr></table></figure><h3 id="A1"><a href="#A1" class="headerlink" title="A1"></a>A1</h3><p>题目大意是，用一个函数，计算从 1-n 经 term 函数处理之积</p><p>嘛，用循环可以轻松解决，不过陆爻齐用了递归</p><h3 id="Q2-Accumulate"><a href="#Q2-Accumulate" class="headerlink" title="Q2: Accumulate"></a>Q2: Accumulate</h3><p>Let’s take a look at how product is an instance of a more general function called accumulate, which we would like to implement:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def accumulate(fuse, start, n, term):</span><br><span class="line">    &quot;&quot;&quot;Return the result of fusing together the first n terms in a sequence </span><br><span class="line">    and start.  The terms to be fused are term(1), term(2), ..., term(n). </span><br><span class="line">    The function fuse is a two-argument commutative &amp; associative function.</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5</span><br><span class="line">    15</span><br><span class="line">    &gt;&gt;&gt; accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5</span><br><span class="line">    26</span><br><span class="line">    &gt;&gt;&gt; accumulate(add, 11, 0, identity) # 11 (fuse is never used)</span><br><span class="line">    11</span><br><span class="line">    &gt;&gt;&gt; accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2</span><br><span class="line">    25</span><br><span class="line">    &gt;&gt;&gt; accumulate(mul, 2, 3, square)    # 2 * 1^2 * 2^2 * 3^2</span><br><span class="line">    72</span><br><span class="line">    &gt;&gt;&gt; # 2 + (1^2 + 1) + (2^2 + 1) + (3^2 + 1)</span><br><span class="line">    &gt;&gt;&gt; accumulate(lambda x, y: x + y + 1, 2, 3, square)</span><br><span class="line">    19</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    &quot;*** YOUR CODE HERE ***&quot;</span><br></pre></td></tr></table></figure><p>accumulate has the following parameters:</p><p>fuse: a two-argument function that specifies how the current term is fused with the previously accumulated terms<br>start: value at which to start the accumulation<br>n: a non-negative integer indicating the number of terms to fuse<br>term: a single-argument function; term(i) is the ith term of the sequence<br>Implement accumulate, which fuses the first n terms of the sequence defined by term with the start value using the fuse function.</p><p>For example, the result of accumulate(add, 11, 3, square) is</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add(11,  add(square(1), add(square(2),  square(3)))) =</span><br><span class="line">    11 +     square(1) +    square(2) + square(3)    =</span><br><span class="line">    11 +     1         +    4         + 9            = 25</span><br></pre></td></tr></table></figure><p>Assume that fuse is commutative, fuse(a, b) &#x3D;&#x3D; fuse(b, a), and associative, fuse(fuse(a, b), c) &#x3D;&#x3D; fuse(a, fuse(b, c)).</p><p>Then, implement summation (from lecture) and product as one-line calls to accumulate.</p><p>Important: Both summation_using_accumulate and product_using_accumulate should be implemented with a single line of code starting with return.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">def summation_using_accumulate(n, term):</span><br><span class="line">    &quot;&quot;&quot;Returns the sum: term(1) + ... + term(n), using accumulate.</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; summation_using_accumulate(5, square) # square(0) + square(1) + ... + square(4) + square(5)</span><br><span class="line">    55</span><br><span class="line">    &gt;&gt;&gt; summation_using_accumulate(5, triple) # triple(0) + triple(1) + ... + triple(4) + triple(5)</span><br><span class="line">    45</span><br><span class="line">    &gt;&gt;&gt; # This test checks that the body of the function is just a return statement.</span><br><span class="line">    &gt;&gt;&gt; import inspect, ast</span><br><span class="line">    &gt;&gt;&gt; [type(x).__name__ for x in ast.parse(inspect.getsource(summation_using_accumulate)).body[0].body]</span><br><span class="line">    [&#x27;Expr&#x27;, &#x27;Return&#x27;]</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    return ____</span><br><span class="line"></span><br><span class="line">def product_using_accumulate(n, term):</span><br><span class="line">    &quot;&quot;&quot;Returns the product: term(1) * ... * term(n), using accumulate.</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; product_using_accumulate(4, square) # square(1) * square(2) * square(3) * square()</span><br><span class="line">    576</span><br><span class="line">    &gt;&gt;&gt; product_using_accumulate(6, triple) # triple(1) * triple(2) * ... * triple(5) * triple(6)</span><br><span class="line">    524880</span><br><span class="line">    &gt;&gt;&gt; # This test checks that the body of the function is just a return statement.</span><br><span class="line">    &gt;&gt;&gt; import inspect, ast</span><br><span class="line">    &gt;&gt;&gt; [type(x).__name__ for x in ast.parse(inspect.getsource(product_using_accumulate)).body[0].body]</span><br><span class="line">    [&#x27;Expr&#x27;, &#x27;Return&#x27;]</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    return ____</span><br></pre></td></tr></table></figure><h3 id="A2"><a href="#A2" class="headerlink" title="A2"></a>A2</h3><p>题目大意，是先完成 accumulate 函数，这是一个用 fuse 处理 start、term(1) … term(n) 之间的函数，再用 accumulate 函数实现两个衍生的函数。</p><p>没什么难点，想说的话同 A1</p><h3 id="Q3-Make-Repeater"><a href="#Q3-Make-Repeater" class="headerlink" title="Q3: Make Repeater"></a>Q3: Make Repeater</h3><p>Implement the function make_repeater which takes a one-argument function f and a positive integer n. It returns a one-argument function, where make_repeater(f, n)(x) returns the value of f(f(…f(x)…)) in which f is applied n times to x. For example, make_repeater(square, 3)(5) squares 5 three times and returns 390625, just like square(square(square(5))).</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def make_repeater(f, n):</span><br><span class="line">    &quot;&quot;&quot;Returns the function that computes the nth application of f.</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; add_three = make_repeater(increment, 3)</span><br><span class="line">    &gt;&gt;&gt; add_three(5)</span><br><span class="line">    8</span><br><span class="line">    &gt;&gt;&gt; make_repeater(triple, 5)(1) # 3 * (3 * (3 * (3 * (3 * 1))))</span><br><span class="line">    243</span><br><span class="line">    &gt;&gt;&gt; make_repeater(square, 2)(5) # square(square(5))</span><br><span class="line">    625</span><br><span class="line">    &gt;&gt;&gt; make_repeater(square, 3)(5) # square(square(square(5)))</span><br><span class="line">    390625</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    &quot;*** YOUR CODE HERE ***&quot;</span><br></pre></td></tr></table></figure><h3 id="A3"><a href="#A3" class="headerlink" title="A3"></a>A3</h3><p>题目大意是，写一个函数，传入一个单参函数和数字 n，分别是处理参数的方式和次数，返回一个可传一个参数的函数。</p><p>实现方式就是内部定个函数，把传入数字，用 f 执行 n 次即可，也不难</p><h2 id="Recursion"><a href="#Recursion" class="headerlink" title="Recursion"></a>Recursion</h2><h3 id="Q4-Digit-Distance"><a href="#Q4-Digit-Distance" class="headerlink" title="Q4: Digit Distance"></a>Q4: Digit Distance</h3><p>For a given integer, the digit distance is the sum of the absolute differences between consecutive digits. For example:</p><p>The digit distance of 6 is 0.<br>The digit distance of 61 is 5, as the absolute value of 6 - 1 is 5.<br>The digit distance of 71253 is 12 (6 + 1 + 3 + 2).<br>Write a function that determines the digit distance of a given positive integer. You must use recursion or the tests will fail.</p><p>Hint: There are multiple valid ways of solving this problem! If you’re stuck, try writing out an iterative solution first, and then convert your iterative solution into a recursive one.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def digit_distance(n):</span><br><span class="line">    &quot;&quot;&quot;Determines the digit distance of n.</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; digit_distance(3)</span><br><span class="line">    0</span><br><span class="line">    &gt;&gt;&gt; digit_distance(777)</span><br><span class="line">    0</span><br><span class="line">    &gt;&gt;&gt; digit_distance(314)</span><br><span class="line">    5</span><br><span class="line">    &gt;&gt;&gt; digit_distance(31415926535)</span><br><span class="line">    32</span><br><span class="line">    &gt;&gt;&gt; digit_distance(3464660003)</span><br><span class="line">    16</span><br><span class="line">    &gt;&gt;&gt; from construct_check import check</span><br><span class="line">    &gt;&gt;&gt; # ban all loops</span><br><span class="line">    &gt;&gt;&gt; check(HW_SOURCE_FILE, &#x27;digit_distance&#x27;,</span><br><span class="line">    ...       [&#x27;For&#x27;, &#x27;While&#x27;])</span><br><span class="line">    True</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    &quot;*** YOUR CODE HERE ***&quot;</span><br></pre></td></tr></table></figure><h3 id="A4"><a href="#A4" class="headerlink" title="A4"></a>A4</h3><p>题目大意是，计算一个数字各位差绝对值之和，且不准用循环的方式。</p><p>陆爻齐的思路是，每次取第一位和第二位数字差的绝对值加上 n 整除 10 后的数字，如此便可计算出各位差绝对值，与参考答案不谋而合捏。</p><h3 id="Q5-Interleaved-Sum"><a href="#Q5-Interleaved-Sum" class="headerlink" title="Q5: Interleaved Sum"></a>Q5: Interleaved Sum</h3><p>Write a function interleaved_sum, which takes in a number n and two one-argument functions: odd_func and even_func. It applies odd_func to every odd number and even_func to every even number from 1 to n inclusive and returns the sum.</p><p>For example, executing interleaved_sum(5, lambda x: x, lambda x: x * x) returns 1 + 2<em>2 + 3 + 4</em>4 + 5 &#x3D; 29.</p><p>Important: Implement this function without using any loops or directly testing if a number is odd or even – aka modulos (%) are not allowed! Instead of directly checking whether a number is even or odd, start with 1, which you know is an odd number.</p><p>Hint: Introduce an inner helper function that takes an odd number k and computes an interleaved sum from k to n (including n).</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">def interleaved_sum(n, odd_func, even_func):</span><br><span class="line">    &quot;&quot;&quot;Compute the sum odd_func(1) + even_func(2) + odd_func(3) + ..., up</span><br><span class="line">    to n.</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; identity = lambda x: x</span><br><span class="line">    &gt;&gt;&gt; square = lambda x: x * x</span><br><span class="line">    &gt;&gt;&gt; triple = lambda x: x * 3</span><br><span class="line">    &gt;&gt;&gt; interleaved_sum(5, identity, square) # 1   + 2*2 + 3   + 4*4 + 5</span><br><span class="line">    29</span><br><span class="line">    &gt;&gt;&gt; interleaved_sum(5, square, identity) # 1*1 + 2   + 3*3 + 4   + 5*5</span><br><span class="line">    41</span><br><span class="line">    &gt;&gt;&gt; interleaved_sum(4, triple, square)   # 1*3 + 2*2 + 3*3 + 4*4</span><br><span class="line">    32</span><br><span class="line">    &gt;&gt;&gt; interleaved_sum(4, square, triple)   # 1*1 + 2*3 + 3*3 + 4*3</span><br><span class="line">    28</span><br><span class="line">    &gt;&gt;&gt; from construct_check import check</span><br><span class="line">    &gt;&gt;&gt; check(HW_SOURCE_FILE, &#x27;interleaved_sum&#x27;, [&#x27;While&#x27;, &#x27;For&#x27;, &#x27;Mod&#x27;]) # ban loops and %</span><br><span class="line">    True</span><br><span class="line">    &gt;&gt;&gt; check(HW_SOURCE_FILE, &#x27;interleaved_sum&#x27;, [&#x27;BitAnd&#x27;, &#x27;BitOr&#x27;, &#x27;BitXor&#x27;]) # ban bitwise operators, don&#x27;t worry about these if you don&#x27;t know what they are</span><br><span class="line">    True</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    &quot;*** YOUR CODE HERE ***&quot;</span><br></pre></td></tr></table></figure><h3 id="A5"><a href="#A5" class="headerlink" title="A5"></a>A5</h3><p>题目大意，交错和，即对奇偶数各用奇偶的函数处理，再相加得和，不准使用循环和 %，以及位运算来禁止直接判断数字奇偶。</p><p>此题，陆爻齐用了取巧的办法越过了检查，仍然直接判断奇偶，即用递归判断，n 次递归，用另一个变量 1&#x2F;0，以得出奇偶，下面是看了参考答案总结的思路。</p><p>不知 n 的奇偶，但可以从 1 推到 n，于是可写个内部函数，计算 1 2 ……，两位两位地计算和，递归，最后返回结果即可</p><h3 id="Q6-Count-Coins"><a href="#Q6-Count-Coins" class="headerlink" title="Q6: Count Coins"></a>Q6: Count Coins</h3><p>Given a positive integer total, a set of coins makes change for total if the sum of the values of the coins is total. Here we will use standard US Coin values: 1, 5, 10, 25. For example, the following sets make change for 15:</p><p>15 1-cent coins<br>10 1-cent, 1 5-cent coins<br>5 1-cent, 2 5-cent coins<br>5 1-cent, 1 10-cent coins<br>3 5-cent coins<br>1 5-cent, 1 10-cent coin<br>Thus, there are 6 ways to make change for 15. Write a recursive function count_coins that takes a positive integer total and returns the number of ways to make change for total using coins.</p><p>You can use either of the functions given to you:</p><p>next_larger_coin will return the next larger coin denomination from the input, i.e. next_larger_coin(5) is 10.<br>next_smaller_coin will return the next smaller coin denomination from the input, i.e. next_smaller_coin(5) is 1.<br>Either function will return None if the next coin value does not exist<br>There are two main ways in which you can approach this problem. One way uses next_larger_coin, and another uses next_smaller_coin. It is up to you which one you want to use!</p><p>Important: Use recursion; the tests will fail if you use loops.</p><p>Hint: Refer to the implementation of count_partitions for an example of how to count the ways to sum up to a final value with smaller parts. If you need to keep track of more than one value across recursive calls, consider writing a helper function.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">def next_larger_coin(coin):</span><br><span class="line">    &quot;&quot;&quot;Returns the next larger coin in order.</span><br><span class="line">    &gt;&gt;&gt; next_larger_coin(1)</span><br><span class="line">    5</span><br><span class="line">    &gt;&gt;&gt; next_larger_coin(5)</span><br><span class="line">    10</span><br><span class="line">    &gt;&gt;&gt; next_larger_coin(10)</span><br><span class="line">    25</span><br><span class="line">    &gt;&gt;&gt; next_larger_coin(2) # Other values return None</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if coin == 1:</span><br><span class="line">        return 5</span><br><span class="line">    elif coin == 5:</span><br><span class="line">        return 10</span><br><span class="line">    elif coin == 10:</span><br><span class="line">        return 25</span><br><span class="line"></span><br><span class="line">def next_smaller_coin(coin):</span><br><span class="line">    &quot;&quot;&quot;Returns the next smaller coin in order.</span><br><span class="line">    &gt;&gt;&gt; next_smaller_coin(25)</span><br><span class="line">    10</span><br><span class="line">    &gt;&gt;&gt; next_smaller_coin(10)</span><br><span class="line">    5</span><br><span class="line">    &gt;&gt;&gt; next_smaller_coin(5)</span><br><span class="line">    1</span><br><span class="line">    &gt;&gt;&gt; next_smaller_coin(2) # Other values return None</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if coin == 25:</span><br><span class="line">        return 10</span><br><span class="line">    elif coin == 10:</span><br><span class="line">        return 5</span><br><span class="line">    elif coin == 5:</span><br><span class="line">        return 1</span><br><span class="line"></span><br><span class="line">def count_coins(total):</span><br><span class="line">    &quot;&quot;&quot;Return the number of ways to make change using coins of value of 1, 5, 10, 25.</span><br><span class="line">    &gt;&gt;&gt; count_coins(15)</span><br><span class="line">    6</span><br><span class="line">    &gt;&gt;&gt; count_coins(10)</span><br><span class="line">    4</span><br><span class="line">    &gt;&gt;&gt; count_coins(20)</span><br><span class="line">    9</span><br><span class="line">    &gt;&gt;&gt; count_coins(100) # How many ways to make change for a dollar?</span><br><span class="line">    242</span><br><span class="line">    &gt;&gt;&gt; count_coins(200)</span><br><span class="line">    1463</span><br><span class="line">    &gt;&gt;&gt; from construct_check import check</span><br><span class="line">    &gt;&gt;&gt; # ban iteration</span><br><span class="line">    &gt;&gt;&gt; check(HW_SOURCE_FILE, &#x27;count_coins&#x27;, [&#x27;While&#x27;, &#x27;For&#x27;])</span><br><span class="line">    True</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    &quot;*** YOUR CODE HERE ***&quot;</span><br></pre></td></tr></table></figure><h3 id="A6"><a href="#A6" class="headerlink" title="A6"></a>A6</h3><p>题目大意，就是将给定的数字划分成 1、5、10、25 的组合，给出组合个数，不可使用循环。可借助已写好的 next_larger_coin 等函数</p><p>此题可这么看，从一个数字向下蔓延分支，可大致分两类，一类是尝试用当前数字减去一次额度，一类是额度变化（变大变小都可），如此递归下去各种路线都可计算到。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Q5 和 Q6 都挺有思考的趣味，递归很早就学了，但体会递归的魅力，还是在此</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> CS61A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CS61A-Fall-2020】学习记录六 Lab2 题解思路分享</title>
      <link href="/posts/b47f5c1b.html"/>
      <url>/posts/b47f5c1b.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>观前提示，笔者写的代码答案放在 <a href="https://github.com/HSLix/CS61A-Fall-2020">GitHub仓库</a> 中，此处仅记录过程与心得。</p><p>此外，请最好在尝试独立完成该任务后再看本文，否则就很可能失去了体验本项目精华的机会</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="Q1-WWPD-Lambda-the-Free"><a href="#Q1-WWPD-Lambda-the-Free" class="headerlink" title="Q1: WWPD: Lambda the Free"></a>Q1: WWPD: Lambda the Free</h3><p>有两个问题有点意思。</p><h4 id="lambda-与参数"><a href="#lambda-与参数" class="headerlink" title="lambda 与参数"></a>lambda 与参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; b = lambda x: lambda: x  # Lambdas can return other lambdas!</span><br><span class="line">&gt;&gt;&gt; c = b(88)</span><br><span class="line">&gt;&gt;&gt; c</span><br><span class="line">______</span><br></pre></td></tr></table></figure><p>该问题看似只是普通的 lambda 中传 x，c 还传入了 x 参数值为 88</p><p>所以答案是 88 吗？</p><p>当然不是，这个问题结合下面这个问题就很显然了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; c()</span><br><span class="line">______</span><br></pre></td></tr></table></figure><p>那么想清楚这个问题的关键，就在于能否分辨 c 和 c() 的含义。</p><p>把 88 代入 c 的 lambda 式子，可以换成</p><p>c &#x3D; lambda : 88</p><p>本质上，c 其实还是个 lambda 式子，只不过无参数，所以直接调用 c 不会得到 88，还得象征性地传入无参数调用才行。</p><h4 id="print-与-lambda"><a href="#print-与-lambda" class="headerlink" title="print 与 lambda"></a>print 与 lambda</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print_lambda = lambda z: print(z)  # When is the return expression of a lambda expression executed?</span><br><span class="line">&gt;&gt;&gt; one_thousand = print_lambda(1000)</span><br><span class="line">______</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; one_thousand</span><br><span class="line">______</span><br></pre></td></tr></table></figure><p>这个 print_lambda 只是一个把传入参数直接 print 出来的函数罢了，那么第一个空当然是 1000 啦。</p><p>嗯嗯，对，不过重点是第二个空的答案，这个 print_lambda 到底把什么赋予给 one_thousand 了？</p><p>有同学会说，不是 1000 吗？</p><p>不是哟，之所以第一个空会是 1000，是因为在赋值的过程前，先执行尽右侧函数时，print 的。</p><p>排除了 1000，这又不是 Function（print_lambda 才是 Function，代入了参数后就不是啦），不是 Error，排除了所有可能，只能是 None 了。</p><p>想想也是，print 也没有返回，None 也是理所应当。</p><h3 id="Q2-WWPD-Higher-Order-Functions"><a href="#Q2-WWPD-Higher-Order-Functions" class="headerlink" title="Q2: WWPD: Higher Order Functions"></a>Q2: WWPD: Higher Order Functions</h3><p>值得注意的就一个点</p><p>如果有 return 而无变量承接，那 return * 就会相当于 print(*)。</p><h3 id="Q3-Lambdas-and-Currying"><a href="#Q3-Lambdas-and-Currying" class="headerlink" title="Q3: Lambdas and Currying"></a>Q3: Lambdas and Currying</h3><p>需要通过多个 () 调用，说明内部有几层 def。</p><h3 id="Q4-Count-van-Count"><a href="#Q4-Count-van-Count" class="headerlink" title="Q4: Count van Count"></a>Q4: Count van Count</h3><p>要仔细看好，在测试里面，输入的 condition 的输入参数情况如何，输出如何。</p><h3 id="Q5-Make-Adder"><a href="#Q5-Make-Adder" class="headerlink" title="Q5: Make Adder"></a>Q5: Make Adder</h3><p>不难，题目也说了，不会就放这个 <a href="https://pythontutor.com/cp/composingprograms.html#mode=edit">视觉化网站</a> 看看结果</p><h3 id="Q6-Lambda-the-Environment-Diagram"><a href="#Q6-Lambda-the-Environment-Diagram" class="headerlink" title="Q6: Lambda the Environment Diagram"></a>Q6: Lambda the Environment Diagram</h3><p>同 Q5</p><h3 id="Q7-Composite-Identity-Function"><a href="#Q7-Composite-Identity-Function" class="headerlink" title="Q7: Composite Identity Function"></a>Q7: Composite Identity Function</h3><p>本质就是让你写个函数，返回对于 n ，先 f 后 g 与 先 g 后 f 是否相等，同时用上题目里的 compose1 函数。</p><h3 id="Q8-I-Heard-You-Liked-Functions…Q8"><a href="#Q8-I-Heard-You-Liked-Functions…Q8" class="headerlink" title="Q8: I Heard You Liked Functions…Q8"></a>Q8: I Heard You Liked Functions…Q8</h3><p>这个问题有点意思，题目本质是要求给个函数，可以自定义循环对一个数字按顺序循环执行的次数和数字大小。</p><p>陆爻齐的思路是，先写一个可以根据循环次数，返回应该执行函数的函数，比如 i &#x3D;&#x3D; 1 时，返回 f1，i &#x3D;&#x3D; 4 时，也返回 f1 这样。暂且叫 get_todo。</p><p>然后写个循环，i &lt;&#x3D; n，对数字 num，代入执行 n 次 get_todo(i) 函数，结束。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>听完课可以锻炼英语听力，同时也对这个 higher order function 有了更深的感触，期待后续课程：）</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> CS61A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【播客笔记】《爱的艺术》我要如何学会爱，尤其是，学会爱自己 纵横四海</title>
      <link href="/posts/e936fe0a.html"/>
      <url>/posts/e936fe0a.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是陆爻齐收听了 <strong>纵横四海</strong> 的播客 <strong>《爱的艺术》我要如何学会爱，尤其是，学会爱自己 纵横四海</strong>，做的一点笔记</p><p>也就是对播客里一些内容的总结、思考和理解，权当作记录罢</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="爱的定义"><a href="#爱的定义" class="headerlink" title="爱的定义"></a>爱的定义</h3><p>爱是一种行动（activity），并不能用“激情”带来的生理性好感来完全指代，并非天定，而是用行动维护、培养出来的责任。</p><p>这种行动，必须是自发的。</p><p>倘若一名丈夫被妻子说了后，马上做了几件家务讨其欢心，后又疏懒，说一下动一下，则不算爱的行动；</p><p>若是该丈夫在认识到自己的疏忽后，在日常中主动分担部分家务，这个属于爱的行动。</p><h3 id="爱的意义"><a href="#爱的意义" class="headerlink" title="爱的意义"></a>爱的意义</h3><p>消除人生孤离感的“终极武器”。</p><p>作者认为，人生于家，成年断亲后，需要填补这份离开亲人的孤离感。有人沉迷酒色，用过度放纵自己，刺激感官麻木自己；有人趋同他人，在与小集团同化中寻求认同。</p><p>而爱，正是消除孤离感的良方妙药。</p><p>不拘泥于男女，亲人，人人皆可有爱，从细节处关心即可。</p><h3 id="爱的实质"><a href="#爱的实质" class="headerlink" title="爱的实质"></a>爱的实质</h3><p>提供创造性的互助</p><p>来个一个不算恰当、意会即可的例子</p><p>老师辅导时，最喜欢看到的情形是，学生经过主动思考，讲述自己的探索历程，遇到困难尝试客服，经讨论交流和老师一起探寻得到结果；</p><p>与之相对，最令老师头疼的是，毫无思考，只来问老师此题怎解，从头到尾跟着老师思路，不能创造性的吸收知识，而是被动地塞入，老师便会感到枯燥乏味。</p><p>总得来说，互相给予创造力便是。</p><p>再拿情侣为例</p><p>有人认为热恋期的“激情”才是爱，这段蜜月一过便分道扬镳，因为他无法从对方那里找到所谓的“新鲜感”。</p><p>如果两人相爱，互相在日常中关心对方，记住对方的喜好，近日安排，时不时安排小礼物、小惊喜，无数个这样感动的瞬间，是否能连成一生呢？（还在 go）</p><h3 id="爱的实践"><a href="#爱的实践" class="headerlink" title="爱的实践"></a>爱的实践</h3><p>自爱，就是关心自己的健康，不但身体，还有心理。平日是否过于忙碌，疏于放松；平日是否过于愤慨，没有发泄。适当安排假期或许不错，但这算奢望罢。</p><p>男女&#x2F;亲人之爱，是否设身处地为人着想，是否从小处都有关心对方，行动帮助对方。</p><h2 id="一点总结"><a href="#一点总结" class="headerlink" title="一点总结"></a>一点总结</h2><p>让陆爻齐对于爱确实有了一些新的想法，找到伴侣不应只是等待，爱是行动，培养出来的。</p><p>不过现阶段还是提升自己更为重要，这些经验或许大四闲暇就能用上呢。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 播客笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/4a17b156.html"/>
      <url>/posts/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>这是陆爻齐用 github page 和 hexo 搭建的自己的博客！</p><p>是参考了 <a href="https://0xffff.one/d/544">0xffff</a>、<a href="https://www.bilibili.com/video/BV1dt4y1Q7UE/?share_source=copy_web&vd_source=1423ba210b588816e333b03a9060d0b0">b站视频教程</a> 和 <a href="https://hexo.fluid-dev.com/docs/guide/#%E6%96%87%E7%AB%A0%E6%8E%92%E5%BA%8F">fluid 使用手册</a> 慢慢开始完善的</p><p>陆爻齐后续也写一篇 blog 来总结下博客的配置好了</p><p>总之，先把博客园的文章按时间顺序慢慢搬过来好了</p><p>Hello，World！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【播客笔记】《我们为什么会受骗》强烈建议每个女生看完这本书再去恋爱！ 纵横四海</title>
      <link href="/posts/14b72e37.html"/>
      <url>/posts/14b72e37.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是陆爻齐收听了 <strong>纵横四海</strong> 的播客 <strong>《我们为什么会受骗》强烈建议每个女生看完这本书再去恋爱！</strong>，做的一点笔记</p><p>也就是一些内容的总结和思考理解，权当作记录罢</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="被骗者与骗者"><a href="#被骗者与骗者" class="headerlink" title="被骗者与骗者"></a>被骗者与骗者</h3><p>有两点比较重要</p><ol><li>人往往是很感性化的，难以理性地处理每件事</li><li>骗者之所以能得手，很可能是因为其自身生理特性，以及社会环境的滋养</li></ol><p>对于第一点，主持人是以自己出售二手家居为例子说明，原本认为麻烦不想自己做打包发邮件，后因与一个顾客聊天而改变主意。</p><p>还介绍了一种现象，即一个人当接收了过多的信息，会本能地放弃选择，进入容易被操控的状态。这点很容易理解，高考是选择题怎么都不会，就开始放弃用理智选择了，“三长一短选最短”……</p><p>而第二点有两个小点</p><ol><li>生理特性，主持人介绍骗者的脑部很可能与普通人有差别，比如缺少共情能力，使其不会因欺骗他人而产生内疚等道德约束；接近黑暗三角人格（自恋、心理变态、马基雅维利主义）什么的</li><li>社会环境，不是因为环境“坏”，恰恰是因为环境“好”，当大多数人都互相信任时，欺骗者往往可以从中轻松获利</li></ol><h3 id="有趣的打断效应"><a href="#有趣的打断效应" class="headerlink" title="有趣的打断效应"></a>有趣的打断效应</h3><p>名字是瞎编的，但理论确实存在。例子便是金牌销售员的一个策略，在顾客对一件商品的购买踌躇不定时，不断用言语打断思考，用“此外，该商品还有***好处”之类的话，阻止顾客深入思考，往往能促进购买</p><h3 id="被骗的必要条件"><a href="#被骗的必要条件" class="headerlink" title="被骗的必要条件"></a>被骗的必要条件</h3><ol><li>渴望某项事务</li><li>相信某项事务的发生</li><li>坚定自己不会受骗</li></ol><p>以普通父母被骗买保健药品为例，父母退休后清闲又有点空虚，听到周围亲戚、同事、朋友逝去的消息，渴望健康，满足条件一；</p><p>接触骗者，建立信任关系，开始逐渐相信保健药品的功效，相信购买并使用保健药品能得到健康，满足条件二；</p><p>面对子女的劝说，摆出“我是你爸，不用你教”坚定自己没有受骗，拒绝事实，这与和骗者的信任关系产生冲突引发“认知失调”，容易受到操控，满足条件三；</p><p>不过这只是个简陋的经典模型，实际上的骗局大致会像下一个小节一样</p><h3 id="欺骗“万用术”流程"><a href="#欺骗“万用术”流程" class="headerlink" title="欺骗“万用术”流程"></a>欺骗“万用术”流程</h3><ol><li>搜寻猎物，很难有一种能骗所有人的骗局，骗者往往是搜集到足够的情报，找到最适合的猎物，量身制定骗局才下手；</li><li>建立情感交流，如第一部分所说，人往往是感性的，一旦产生情感交流，就能够提升骗者的信任关系，并泄露更多情报；<br>而骗者实现该步骤并不会太困难，毕竟第一步就已经找好猎物，并有猎物的大量情报，而猎物一无所知，只会认为面前的人很懂自己，是命运的“挚友”。</li><li>讲故事，比如经典的“卖茶女”，讲述自己困苦的经历博取同情，随后请求经济帮助，无经验者确实容易中招；</li><li>一般来说，在上一步就能收网，但还可以继续等待受骗者加码，这一点陆爻齐也难以理解但也存在；<br>比如一个人被骗转去 20000 元救急，过了一个月没声响，开始模糊认为自己被骗了，产生痛苦的感情且渴望弥补，此时骗者突然联系过来，用看似合适的理由稳住受骗者，随后进一步索取钱财还是什么的就另说了</li></ol><h3 id="防骗手段"><a href="#防骗手段" class="headerlink" title="防骗手段"></a>防骗手段</h3><p>难，因为这是与本能对抗，简单的说就是，不满足受骗的必要条件，从而避免被选为猎物</p><p>其中主持人认为，相信某项事务的发生 相对容易处理，可以通过日常熏陶自己谨慎行事改善；对于父母，只能不断反复强调，熏陶。</p><p>陆爻齐认为，还是欲望被利用的问题，“贪”，所以陆爻齐对于别人的建议回想两件事</p><ol><li>这么好的东西，为什么你自己不搞，告诉我让我搞呢？</li><li>你是与这件事有什么关系，站在什么立场说的话？（既得利益者……）</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 播客笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CS61A-Fall-2020】学习记录五 Project1 The Game of Hog 中有意思的点</title>
      <link href="/posts/6547af2a.html"/>
      <url>/posts/6547af2a.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>观前提示，笔者写的代码答案放在 <a href="https://github.com/HSLix/CS61A-Fall-2020">GitHub仓库</a> 中，此处仅记录过程与心得。</p><p>此外，请最好在尝试独立完成该任务后再看本文，否则就很可能失去了体验本项目精华的机会</p><h2 id="函数参数前的"><a href="#函数参数前的" class="headerlink" title="函数参数前的*"></a>函数参数前的*</h2><p>在项目原文件中的dice.py 里的 make_test_dice函数采用这样的方式传参</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def make_test_dice(*outcomes):</span><br><span class="line">  # 省略内容</span><br><span class="line">  pass</span><br></pre></td></tr></table></figure><p>我记得python中没像c那样的指针，于是查询资料，小结如下<br>函数参数前一颗*会识别为元组，两颗则识别为字典</p><p>比如我要是传 make_test_dice(1, 2, 4, 3)，outcomes就是元组(1, 2, 4, 3)</p><p>举一个稍微复合一点点的例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def foo(a, b=10, *args, **kwargs):</span><br><span class="line">    print (a)</span><br><span class="line">    print (b)</span><br><span class="line">    print (args)</span><br><span class="line">    print (kwargs)</span><br><span class="line"></span><br><span class="line">foo(1, 2, 3, 4, e=5, f=6, g=7)</span><br></pre></td></tr></table></figure><p>上述例子来自菜鸟教程，运行结果为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">(3, 4)</span><br><span class="line">&#123;&#x27;e&#x27;: 5, &#x27;f&#x27;: 6, &#x27;g&#x27;:7&#125;</span><br></pre></td></tr></table></figure><p>可发现除了定好的a、b，c和d都纳入元组中，而efg有&#x3D;赋值，作为字典看待</p><p>上面的例子都发生在定义函数参数列表，如果在调用时有*说明什么呢？</p><p>再看一个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def func(num1, num2):</span><br><span class="line">  print(num1, num2)</span><br><span class="line"></span><br><span class="line">num = [1, 2]</span><br><span class="line">func(*num)</span><br></pre></td></tr></table></figure><p>运行结果为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2</span><br></pre></td></tr></table></figure><p>一个参数变两，*在这里起到了解压参数列表的作用<br>但笔者尚未想到该功能应用的方便之处</p><h2 id="Higher-Order-Function-高阶函数"><a href="#Higher-Order-Function-高阶函数" class="headerlink" title="Higher Order Function 高阶函数"></a>Higher Order Function 高阶函数</h2><p>这是一个让陆爻齐觉得十分精妙的功能，以函数为参数并返回函数，从 C 初学者的角度来说，太抽象了</p><p>就是在 Problem 7 的答案代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">def announce_highest(who, last_score=0, running_high=0):</span><br><span class="line">    &quot;&quot;&quot;Return a commentary function that announces when WHO&#x27;s score</span><br><span class="line">    increases by more than ever before in the game.</span><br><span class="line"></span><br><span class="line">    NOTE: the following game is not possible under the rules, it&#x27;s just</span><br><span class="line">    an example for the sake of the doctest</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; f0 = announce_highest(1) # Only announce Player 1 score gains</span><br><span class="line">    &gt;&gt;&gt; f1 = f0(12, 0)</span><br><span class="line">    &gt;&gt;&gt; f2 = f1(12, 9)</span><br><span class="line">    9 point(s)! The most yet for Player 1</span><br><span class="line">    &gt;&gt;&gt; f3 = f2(20, 9)</span><br><span class="line">    &gt;&gt;&gt; f4 = f3(20, 30)</span><br><span class="line">    21 point(s)! The most yet for Player 1</span><br><span class="line">    &gt;&gt;&gt; f5 = f4(20, 47) # Player 1 gets 17 points; not enough for a new high</span><br><span class="line">    &gt;&gt;&gt; f6 = f5(21, 47)</span><br><span class="line">    &gt;&gt;&gt; f7 = f6(21, 77)</span><br><span class="line">    30 point(s)! The most yet for Player 1</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    assert who == 0 or who == 1, &#x27;The who argument should indicate a player.&#x27;</span><br><span class="line">    # BEGIN PROBLEM 7</span><br><span class="line">    &quot;*** YOUR CODE HERE ***&quot;</span><br><span class="line">    def say(new_score_0, new_score_1, last_running_high = running_high):</span><br><span class="line">        if who == 0:</span><br><span class="line">            new_score = new_score_0</span><br><span class="line">            new_running_high = new_score_0 - last_score</span><br><span class="line">        else:</span><br><span class="line">            new_score = new_score_1</span><br><span class="line">            new_running_high = new_score_1 - last_score</span><br><span class="line"></span><br><span class="line">        if new_running_high &gt; last_running_high:</span><br><span class="line">            last_running_high = new_running_high</span><br><span class="line">            print(str(new_running_high),&quot;point(s)! The most yet for Player &quot; + str(who))</span><br><span class="line">        </span><br><span class="line">        new_run_high = last_running_high</span><br><span class="line">        </span><br><span class="line">        return announce_highest(who, new_score, new_run_high)</span><br><span class="line">        </span><br><span class="line">    return say</span><br><span class="line">    # END PROBLEM 7</span><br></pre></td></tr></table></figure><p>这段代码就是记录玩家 1 或 2 分数变化的幅度，并在最大幅度记录更新时 print 的函数。</p><p>传统函数（指 C&#x2F;C++ 这种）要实现这种记录更新，必须在外部存储，用类或者其它外部变量什么的，因为函数一旦执行完毕，内部空间将全部释放。</p><p>下面对该代码做点拆解，忽略 say 的内容、断言、测试和注释，可看成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">def announce_highest(who, last_score=0, running_high=0):</span><br><span class="line">    # BEGIN PROBLEM 7</span><br><span class="line">    &quot;*** YOUR CODE HERE ***&quot;</span><br><span class="line">    def say(new_score_0, new_score_1, last_running_high = running_high):</span><br><span class="line">        pass</span><br><span class="line">        </span><br><span class="line">    return say</span><br><span class="line">    # END PROBLEM 7</span><br></pre></td></tr></table></figure><p>可见，调用 announce_highest 的本质是获取到一个 say 函数，每次调用 say 函数，我们都期待它能检测是否要更新记录，而不断地更新最大幅度，则要不断地获取并调用 say 函数，那让 say 返回获取 say 函数的函数就解决了这个问题，即下面代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">def announce_highest(who, last_score=0, running_high=0):</span><br><span class="line">    # BEGIN PROBLEM 7</span><br><span class="line">    &quot;*** YOUR CODE HERE ***&quot;</span><br><span class="line">    def say(new_score_0, new_score_1, last_running_high = running_high):</span><br><span class="line"> </span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">        return announce_highest(who, new_score, new_run_high)</span><br><span class="line">        </span><br><span class="line">    return say</span><br><span class="line">    # END PROBLEM 7</span><br></pre></td></tr></table></figure><p>再看测试代码就清晰多了</p><p><code>&gt;&gt;&gt; f0 = announce_highest(1) # Only announce Player 1 score gains</code> 这里的 f0 实际上是 who 为 1 时的 say 函数</p><p><code>&gt;&gt;&gt; f1 = f0(12, 0)</code> f1 的本质是代入 new_score_0 &#x3D; 12 和 new_score_1 &#x3D; 0 的 say 函数执行后，返回的新的 say 函数。你问 announce_highest 去哪了？announce_highest 也返回的 say 函数，只是没有参数代入的 say 函数而已</p><p>其它测试语句以上述类推</p><p>后面在 <a href="https://www.geeksforgeeks.org/higher-order-functions-in-python/">geek for geek</a> 进行了更深入的学习，发现此前在 LALC 用的迭代器就是高阶函数的运用</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> CS61A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Datawhale AI 夏令营】 机器学习 Task1 体验记录 思考 补充</title>
      <link href="/posts/9297ccf9.html"/>
      <url>/posts/9297ccf9.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>首先感谢 Datawhale 组织这个活动，让我有机会入门机器学习。</p><p>嘛，不过这个 Task1 只要跟着速通手册运行给定程序，再拿结果去提交，体验下过程而已，于我而言，更为宝贵的地方是后续的“加餐”，也就是分析题目，精读代码的部分</p><h1 id="“加餐”小结"><a href="#“加餐”小结" class="headerlink" title="“加餐”小结"></a>“加餐”小结</h1><h2 id="分析题目"><a href="#分析题目" class="headerlink" title="分析题目"></a>分析题目</h2><p>赛题任务是：通过多个房屋历史电力消耗数据等信息，预测房屋对应电力的消耗。</p><p>这是所谓的“时间序列问题”，简单地说就是分析数据和预测趋势。</p><p>说起来，大一的课程设计也简单做过所谓的“酒吧销量预测”功能，当时是采用“线性回归”来着。</p><p>而要解决这样的问题，就大致有建立传统时间序列模型、机器学习模型、深度学习模型的方法。</p><p>这三种方法各有利弊，按适合处理数据集规模大小和预测能力升序，按解释性和计算资源降序。</p><h2 id="分析代码"><a href="#分析代码" class="headerlink" title="分析代码"></a>分析代码</h2><p>先贴出代码好了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 1. 导入需要用到的相关库</span><br><span class="line"># 导入 pandas 库，用于数据处理和分析</span><br><span class="line">import pandas as pd</span><br><span class="line"># 导入 numpy 库，用于科学计算和多维数组操作</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># 2. 读取训练集和测试集</span><br><span class="line"># 使用 read_csv() 函数从文件中读取训练集数据，文件名为 &#x27;train.csv&#x27;</span><br><span class="line">train = pd.read_csv(&#x27;train.csv&#x27;)</span><br><span class="line"># 使用 read_csv() 函数从文件中读取测试集数据，文件名为 &#x27;train.csv&#x27;</span><br><span class="line">test = pd.read_csv(&#x27;test.csv&#x27;)</span><br><span class="line"></span><br><span class="line"># 3. 计算训练数据最近11-20单位时间内对应id的目标均值</span><br><span class="line"></span><br><span class="line">target_mean = train[train[&#x27;dt&#x27;]&lt;=20].groupby([&#x27;id&#x27;])[&#x27;target&#x27;].mean().reset_index()</span><br><span class="line"></span><br><span class="line"># 4. 将target_mean作为测试集结果进行合并</span><br><span class="line">test = test.merge(target_mean, on=[&#x27;id&#x27;], how=&#x27;left&#x27;)</span><br><span class="line"></span><br><span class="line"># 5. 保存结果文件到本地</span><br><span class="line">test[[&#x27;id&#x27;,&#x27;dt&#x27;,&#x27;target&#x27;]].to_csv(&#x27;submit.csv&#x27;, index=None)</span><br></pre></td></tr></table></figure><p>如果只是想了解思路，那么看完速通手册，大致读读注释即可，不过陆爻齐喜欢再深入一点点。</p><p>比如，为啥只要11-20天数据，1-20不行吗，reset_index()是什么函数？</p><p>要理解处理数据的方式，可以看看数据本身的样子，不过这里吐槽下，我还是第一次见到 WPS 会说太大了，受不了：）</p><p><img src="https://img2024.cnblogs.com/blog/3207177/202407/3207177-20240711214834025-1250283106.png" alt="WPS说太大了"></p><p>回到正题，来看看这数据集究竟长啥样</p><p><img src="https://img2024.cnblogs.com/blog/3207177/202407/3207177-20240711215329507-2023937455.png" alt="train pic 1"></p><p>……………………………………………………</p><p><img src="https://img2024.cnblogs.com/blog/3207177/202407/3207177-20240711215338956-1671382801.png" alt="train pic 2"></p><p>显然，图中 id 是房子编号，dt 是日期，type 是房子类型（暂且用不到），target 是用电量。</p><p>所以，代码<code>target_mean = train[train[&#39;dt&#39;]&lt;=20].groupby([&#39;id&#39;])[&#39;target&#39;].mean().reset_index()</code>翻译为自然语言，就是：以 id 为分组标识（想起了 mysql ），选择其中日期 dt 小于等于 20 的数据，计算均值并重置索引。</p><p>重置索引的具体解释，可以参考 <a href="https://www.cnblogs.com/keye/p/11229863.html">这篇文章</a>。</p><p>如此，target_mean 相当于下面数据</p><p>id          target<br>00037f39cf  39.6543<br>……</p><p>而代码<code>test = test.merge(target_mean, on=[&#39;id&#39;], how=&#39;left&#39;)</code>则将上面刚得的 target_mean 与 test 左外连接。</p><p>先看看test长啥样好了</p><p><img src="https://img2024.cnblogs.com/blog/3207177/202407/3207177-20240711222938772-1741838916.png" alt="test"></p><p>图片不用多加解释，其实所谓的左外连接（又想起 mysql 了），就是把 test 以 id 为组，连到右边的 target_mean，离散数学的映射中算是“满射”</p><p>举个栗子，test 中，id 00037f39cf 有十条，区别只有 id 1-10，而target_mean 中，id 00037f39cf 只有一条数据，也就是上面的</p><p>id          target<br>00037f39cf  39.6543</p><p>于是按 id 连接，将相同 id 对应进行连接，也就是在 test 的基础上，把 target_mean 同 id 那条数据中，除 id 自己外的属性，连接到 test 上，如</p><p>id          dt     type     target<br>00037f39cf  1      2        39.6543<br>00037f39cf  2      2        39.6543<br>00037f39cf  3      2        39.6543<br>……</p><p>最后一条代码，即只保留该数据的id dt target，保存为新的表格 csv 文件，也就是那个 submit.csv。</p><p><img src="https://img2024.cnblogs.com/blog/3207177/202407/3207177-20240711223939047-1629152698.png" alt="submit example"></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Task1 本身操作很简单，要理解也不难，对于陆爻齐这样稍微有点基础知识也算有趣，后续推荐的 Pandas 学习的第十章也是时序预测（笑，期待 Task2。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CINTA】 具体数论与代数阅读笔记——第一章 整数和二进制（含加、乘、除）</title>
      <link href="/posts/7f4d8767.html"/>
      <url>/posts/7f4d8767.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这本书说自己是计算机专业数学入门之入门,成为读者攻读其他经典著作的垫脚石，但个人以为足矣替换掉本校内不知所云的、抽象的、让学生考完后马上全忘的那些课程。本书的 GitHub 仓库在<a href="https://github.com/lbwang/CINTA-cn">这里</a>。</p><p>该笔记并非单纯的整理归纳，而是记录陆爻齐在书中找到的对自己很有感触的部分。</p><p>闲话少说，下面是笔记正文。</p><h1 id="第一章-整数与二进制"><a href="#第一章-整数与二进制" class="headerlink" title="第一章 整数与二进制"></a>第一章 整数与二进制</h1><h2 id="1-1-二进制"><a href="#1-1-二进制" class="headerlink" title="1.1 二进制"></a>1.1 二进制</h2><h3 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h3><p>首先，有两条基本的性质</p><ol><li>偶数二进制最末尾的比特是 0;奇数二进制最末尾的比特是 1；</li><li>在一个二进制数末尾增加一个 0 等同于在十进制中对这个数乘 2。<br>反过来说,对一个十进制数进行乘 2 操作等同于对其二进制表达左移一个比特。</li></ol><p>显然，比如 2 的二进制表示为 0010，3 为 0011， 4即 2*2 为0100。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>随后提出<strong>思考</strong>：请问,你认为对一个十进制数进行除 2 等于对其二进制表达右移一个比特吗?</p><p>陆爻齐的回答是：是的，对 3，出 2 得 1.5，0011 右移一个比特得 0001.1，正好为 1.5。对 2， 除 2 得 1，0010 右移一个比特得 0001，正好为1。</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>接着在基于“考虑任意自然数 n,所谓 2 的 n 次方 (2^n) 只是不断对 1 乘 n 次 2”给出了两条性质<br>3、给定任意自然数 n, 十进制数 2^n 的二进制数表达就是在 1 后加 n 个 0；<br>4、给定任意自然数 n, 十进制数 2^n − 1 的二进制数表达就是 n 个 1；</p><p>结合一点例子就能认同，4 是 2 的 2 次方，即 1 后加 2 个 0，即 0100。1 是 2 的 0 次方，为 1 后加 0 个 0，即 0001。4 减 1 得 3，0011，就是 2 的 1 次方和 0 次方相加所得， 0011 &#x3D; 0010 + 0001；2^2 - 1 &#x3D; 2^1 + 2^0。</p><h3 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h3><p>接下来是作者给的<strong>思考</strong>，请将以上计算过程的结论归纳成一个定理,并证明。你可以使用任何的证明方法。<br>请问,以上“硬”算的方法能否推广为一种证明方法?</p><p>陆爻齐认为，可以归纳为，对任意自然数 n+1（n&gt;&#x3D;0)，有$2^{(n+1)} &#x3D; \sum_0^n 2^n$</p><h3 id="位置计数法"><a href="#位置计数法" class="headerlink" title="位置计数法"></a>位置计数法</h3><p>如此，便引入了位置计数法，即对任意整数 b，有 $b&#x3D;\sum_{i&#x3D;0}^{n-1}b_i2^i$，其中$b_i\in{0,1}$</p><p>显然，取 10，即 1010，可以视为 $1010 &#x3D; 1<em>2^3 + 0</em>2^2 + 1<em>2^1 + 0</em>2^0$，换句话 10 &#x3D; 1<em>8 + 0</em>4 + 1<em>2 + 0</em>1。</p><h2 id="加法与乘法"><a href="#加法与乘法" class="headerlink" title="加法与乘法"></a>加法与乘法</h2><h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><p>加法，大家都能想到 a+b，但要是不准用 + 呢？</p><p>于是有下面这个加法的算法，C++ 实现如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入：两个整数a和b的和</span></span><br><span class="line"><span class="comment">// 输出：a与b的和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add</span>(a^b, (a&amp;b)&lt;&lt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作者想表达计算机的本质是bit的异或、与及移位操作。</p><h3 id="思考-2"><a href="#思考-2" class="headerlink" title="思考"></a>思考</h3><p>这里又是<strong>思考</strong>：要理解这个加法算法只需要地正确回答出以下三个问题:</p><ol><li>a ∧ b 得到的是什么?</li><li>(b&amp;a) &lt;&lt; 1 得到的是什么?</li><li>该算法为什么会终止?</li></ol><p>陆爻齐的回答是，</p><ol><li>a ^ b 得到的是 a 和 b 相加后，移位之后且还没计算进位的部分。异或操作是 10 和 01 得 1，11 或 00 得 0，1 与 0 相加，那位不用进位，留 1；而 0 + 0 或 1 + 1，则会在原地留 0，这正好符合异或操作的结果。</li><li>(b&amp;a) &lt;&lt; 1 得到进位的部分，a&amp;b 的与操作就可以得到 1 + 1 的位，&lt;&lt; 1 是移位操作，根据上文，二进制乘 2，靠后面加个 0， 故向左移一位。</li><li>算法之所以会终止，是因为从右向左，每次执行完进位操作一定能保证该位以右不会有可进位的位，如设第 1 位要进位，那么进位后第一位就确认为 1 或 0，但进位后可能导致下一位需要进位，若此时第二位要进位，那么就处理进位并确认第二位为 1 或 0，以此类推，处理至尽。因处理的数字是有限位数字，故算法一定能终止。</li></ol><h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><p>作者介绍了一种朴素乘法，即 a*b 的本质，是 b 个 a 相加。下面作者以此为例，从正确性、效率、优化三个角度分析该算法。</p><p>显然，这种不断加的乘法时间复杂度为O（n）。</p><p>然后是重点，递归版的“简单乘法”，C++ 实现如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">is_even</span>(b)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">multiply</span>(a, b &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">multiply</span>(a, b &gt;&gt; <span class="number">1</span>) + a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这个程序可以这么理解，返 0 不用说，如果 b 是偶数，比如 0b100 是 8，a 随便取个数，比如 3，即 0b11，用 100 * 11 相当于 2 * （10 * 11），也等于 2 * （ 2 * （ 1 * 11）），最后省个 1，也就加个 a，综上。</p><p>换个复杂点的例子，让 b 为 1010，那就可以看为 (1<em>2^4 + 0</em>2^3 + 1<em>2^2 + 0</em>2^1) * 3 。</p><p>同时作者还补充，在附录 A 有更高效的乘法实现。</p><h2 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h2><h3 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h3><p>首先得有个除法定理，对任意给定的整数 a 和 b,其中 b &gt; 0,存在唯一的整数对 q(商)和 r(余数)，使得 a &#x3D; qb + r 且 0 ≤ r &lt; b。</p><p>然后，介绍了下良序原则和单射、满射、一一映射等概念，不过感觉在下面没啥用。</p><p>然后是除法的实现，朴素除法与朴素乘法类似，是不断减去除数，至被除数比除数小时，相减次数为“商”，剩下的被除数为“余数”。</p><h3 id="简单除法"><a href="#简单除法" class="headerlink" title="简单除法"></a>简单除法</h3><p>而简单除法的 C++ 实现如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">m_divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; result = <span class="built_in">m_divide</span>(a &gt;&gt; <span class="number">1</span>, b);</span><br><span class="line"></span><br><span class="line">    result.first &lt;&lt;= <span class="number">1</span>; result.second &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        result.second += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result.second &gt;= b) &#123;</span><br><span class="line">        result.first += <span class="number">1</span>;</span><br><span class="line">        result.second -= b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>某种程度就是那个简单除法的逆运算捏，但我觉得我也不是那么明白，只能感受到，这是在不断对背除数除二，然后从左至右确认“商”，最后消除还不明白如何产生的误差来确认“余数”。</p><h1 id="第一章-习题"><a href="#第一章-习题" class="headerlink" title="第一章 习题"></a>第一章 习题</h1><p>嘛，又不是正式上课，就选两道做做罢</p><h2 id="1-判断奇偶的函数，c语言实现"><a href="#1-判断奇偶的函数，c语言实现" class="headerlink" title="1 判断奇偶的函数，c语言实现"></a>1 判断奇偶的函数，c语言实现</h2><p>判断奇数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span> <span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a &amp; <span class="number">1</span>) <span class="keyword">return</span> True;</span><br><span class="line">  <span class="keyword">return</span> False;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断偶数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span> <span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a &amp; <span class="number">1</span>) <span class="keyword">return</span> False;</span><br><span class="line">  <span class="keyword">return</span> True;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思想是，奇数的二进制表示中，最右位总为 1，只要 &amp; 上 1，就只会保留最右位，1 则奇数，0 则偶数。</p><h2 id="2-判断-v-是否为-2-的某次方"><a href="#2-判断-v-是否为-2-的某次方" class="headerlink" title="2 判断 v 是否为 2 的某次方"></a>2 判断 v 是否为 2 的某次方</h2><p>两个思路</p><ol><li>若 v 为 2 的某次方，必表现为 100……0 的形式，那么用 while 循环从右至左判断，是否只有最后（最左）为 1 则是；</li><li>若 v 为 2 的某次方，必在减 1 后，为 111……11 的形式，那么用相同位数的 111……11 与之异或，若最后得 0，则是；</li></ol><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>CINTA 第一章下来，我想我还是更优先看看 CSAPP 或许更好些，不过其中部分内容真是有意思，从二进制的角度看待加、乘、除，别有一番风味。另外也庆幸不是学校的专业课，不然又是一门备考时令人头疼的科目力</p>]]></content>
      
      
      
        <tags>
            
            <tag> CINTA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JLU】 数据结构与算法上机题解思路分享-课程设计第三次和第四次上机 吉林大学</title>
      <link href="/posts/6682ef88.html"/>
      <url>/posts/6682ef88.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>首先</strong>，请务必自己尽全力尝试实现题目，直接看成品代码，思维就被拘束了，也很容易被查重。</p><p>这里只是思路解析的博客，代码仓库在 <a href="https://github.com/HSLix/JLU_Data_Structures_Record.git">JLU_Data_Structures_Record</a></p><p>希望你能在这里找到你想要的:)</p><h1 id="第三次上机"><a href="#第三次上机" class="headerlink" title="第三次上机"></a>第三次上机</h1><hr><h2 id="A-手撕BST"><a href="#A-手撕BST" class="headerlink" title="A 手撕BST"></a>A 手撕BST</h2><p>分数 50<br>作者 朱允刚<br>单位 吉林大学<br>对一棵初始为空的二叉查找树（Binary Search Tree, BST）进行若干插入或删除操作，请输出最后的二叉查找树。</p><p>bst.png</p><p>输入格式:<br>输入第一行为一个整数 T，表示操作数目。随后 T 行，每行为Insert K（表示插入关键词为K的结点，若树中已有关键词为K的结点，则不插入）或Remove K（表示删除关键词为K的结点，若树中无关键词为K的结点，则不删除），其中K为整数。 T 不超过2×10^5，树高不超过10^4。</p><p>输出格式:<br>输出经上述操作后得到的二叉查找树的中根序列和先根序列，序列中每个整数后一个空格，两个序列之间用空行间隔。</p><p>输入样例:<br>16<br>Insert 17<br>Insert 31<br>Insert 13<br>Insert 11<br>Insert 20<br>Insert 35<br>Insert 25<br>Insert 8<br>Insert 4<br>Insert 11<br>Insert 24<br>Insert 40<br>Insert 27<br>Insert 9<br>Remove 17<br>Remove 13</p><p>输出样例:<br>4 8 9 11 20 24 25 27 31 35 40 </p><p>20 11 8 4 9 31 25 24 27 35 40 </p><p>代码长度限制<br>16 KB<br>时间限制<br>500 ms<br>内存限制<br>64 MB<br>栈限制<br>8192 KB</p><hr><p>二叉查找树的插入和查找都不算难，但删除需要注意的是，如果要删的节点有两个子节点，则将该节点的右子树中最小的节点与之交换，并执行从右子树中删除该最小点的任务。其余与普通的二叉树一样操作。</p><hr><h2 id="B-手撕AVL树（基础版）"><a href="#B-手撕AVL树（基础版）" class="headerlink" title="B 手撕AVL树（基础版）"></a>B 手撕AVL树（基础版）</h2><p>分数 50<br>作者 朱允刚<br>单位 吉林大学<br>对一棵初始为空的高度平衡树（AVL树）进行若干插入或删除操作，请输出最后得到的AVL树。</p><p>备注：<br>（1）当有多种旋转方案时，优先选择旋转次数少的方案。<br>（2）70%的测试点只包含插入操作，如果你只实现插入操作，也能获得70%的分数。</p><p>输入格式:<br>输入第一行为一个整数 T，表示操作数目。随后 T 行，每行为Insert K（表示插入关键词为K的结点，若树中已有关键词为K的结点，则不插入）或Remove K（表示删除关键词为K的结点，若树中无关键词为K的结点，则不删除），其中K为整数。 T 不超过2×10<br>5<br> 。</p><p>输出格式:<br>输出经上述操作后得到的高度平衡树的中根序列和先根序列，序列中每个整数后一个空格，两个序列之间用空行间隔。</p><p>输入样例:<br>16<br>Insert 17<br>Insert 31<br>Insert 13<br>Insert 11<br>Insert 20<br>Insert 35<br>Insert 25<br>Insert 8<br>Insert 4<br>Insert 11<br>Insert 24<br>Insert 40<br>Insert 27<br>Insert 9<br>Remove 17<br>Remove 13<br>输出样例:<br>4 8 9 11 20 24 25 27 31 35 40 </p><p>20 8 4 11 9 31 25 24 27 35 40<br>代码长度限制<br>16 KB<br>时间限制<br>100 ms<br>内存限制<br>64 MB<br>栈限制<br>8192 KB</p><hr><p>二叉平衡树的插入和删除也是思维不复杂，但实现很麻烦的东西，我只能说，为了使程序的逻辑尽可能清晰，尽量把功能打包成函数，比如一个节点的高度什么的</p><hr><h2 id="C-手撕红黑树"><a href="#C-手撕红黑树" class="headerlink" title="C 手撕红黑树"></a>C 手撕红黑树</h2><p>分数 50<br>作者 朱允刚<br>单位 吉林大学<br>对一棵初始为空的红黑树（Red-Black Tree, RBT）进行若干插入或删除操作，请输出最后的红黑树。</p><p>rbt.png</p><p>备注：<br>（1）当有多种旋转方案时，优先选择旋转次数少的方案。<br>（2）70%的测试点只包含插入操作，如果你只实现插入操作，也能获得70%的分数。</p><p>输入格式:<br>输入第一行为一个整数 T，表示操作数目。随后 T 行，每行为Insert K（表示插入关键词为K的结点，若树中已有关键词为K的结点，则不插入）或Remove K（表示删除关键词为K的结点，若树中无关键词为K的结点，则不删除），其中K为整数。 T 不超过2×10<br>5<br> 。</p><p>输出格式:<br>输出经上述操作后得到的红黑树的中根序列和先根序列，序列中对于每个结点输出其关键词和颜色（红色用R表示，黑色用B表示），每个元素后一个空格，两个序列之间用空行间隔。</p><p>输入样例:<br>5<br>Insert 8<br>Insert 9<br>Insert 3<br>Insert 4<br>Insert 5</p><p>输出样例:<br>3 R 4 B 5 R 8 B 9 B </p><p>8 B 4 B 3 R 5 R 9 B </p><p>代码长度限制<br>16 KB<br>时间限制<br>100 ms<br>内存限制<br>64 MB<br>栈限制<br>8192 KB</p><hr><p>红黑树这题，也差一个点没过，故不作思路解析</p><hr><h1 id="第四次上机"><a href="#第四次上机" class="headerlink" title="第四次上机"></a>第四次上机</h1><hr><h2 id="A-手撕STL-sort（进阶版）"><a href="#A-手撕STL-sort（进阶版）" class="headerlink" title="A 手撕STL sort（进阶版）"></a>A 手撕STL sort（进阶版）</h2><p>分数 100<br>作者 朱允刚<br>单位 吉林大学<br>事实上，STL的sort函数在上一题（基础版）的基础上，还采用了下列优化手段，以进一步提升快速排序算法的效率。</p><p>（3）“三数取中”选基准元素。不是选取第一个元素作为基准元素，而是在当前子数组中选取3个元素，取中间大的那个元素作为基准元素。从而保证选出的基准元素不是子数组的最小元素，也不是最大元素，避免Partition分到子数组最边上，以降低最坏情况发生的概率。<br>为确保本题答案唯一，本算法的实现请以教材为准，即普林斯顿大学Sedgewick教授给出的方法：若当前子数组是R[m]…R[n]，选取R[m]、R[(m+n)&#x2F;2]和R[n]的中位数作为基准元素。先将R[(m+n)&#x2F;2]与R[m+1]交换；若R[m+1]比R[n]大，交换二者；若R[m]比R[n]大，交换二者；若R[m+1]比R[m]大，交换二者。</p><p>（4）尾递归转为循环。即将传统快速排序代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void QuickSort(int R[],int m,int n)&#123;</span><br><span class="line">   if(n - m + 1 &gt; threshold)&#123;</span><br><span class="line">        int j = Partition(R, m, n); </span><br><span class="line">        QuickSort(R, m, j-1);  //递归处理左区间</span><br><span class="line">        QuickSort(R, j+1, n);  //递归处理右区间，尾递归</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void QuickSort(int R[],int m,int n)&#123;</span><br><span class="line">   while(n - m + 1 &gt; threshold)&#123;    //注意此处不是if，而是while</span><br><span class="line">        int j = Partition(R, m, n); </span><br><span class="line">        QuickSort(R, m, j-1);  //递归处理左区间</span><br><span class="line">        m = j+1;  //通过while循环处理右区间，从而消除尾递归</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即先递归处理左区间，后循环处理右区间，从而消除一个尾递归，以减少递归调用带来的时空消耗。<br>这里需注意，尾递归转循环后，转入堆排序的时机不仅仅是递归深度达到2logn，而是递归深度和while循环迭代的次数加一起达到2logn时转入堆排序。</p><p>（5）优先处理短区间。在上述策略（4）的基础上进一步改进，不是按固定次序处理左右子区间（每次都先处理左区间、后处理右区间），而是先（通过递归）处理左右两个子区间中“较短的那个区间”，然后再（通过循环）处理两个子区间中“较长的那个区间”。从而使每次递归处理的子数组长度至少缩减一半，使最坏情况下递归深度（算法最坏情况空间复杂度）为logn。</p><p>（6）三路分划（3-Way Partition）。当重复元素很多时，传统快速排序效率较低。可修改Partition操作，不是把当前数组划分为两部分，而是三部分：小于基准元素K的元素放在左边，等于K的元素放在中间，大于K的元素在右边。接下来仅需对小于K的左半部分子数组和大于K的右半部分子数组进行排序。中间等于K的所有元素都已就位，无需处理。<br>为确保本题答案唯一，此处请采用如下做法：若当前子数组是R[m]…R[n]，可设置3个指针，前指针i，中指针j，后指针k。初始时i和j指向第一个元素，k指向最后一个元素；指针j从左往右扫描数组：</p><p>若R[j]小于基准元素，交换R[j]和R[i], i++, j++；<br>若R[j]大于基准元素，交换R[j]和R[k], k–；<br>若R[j]等于基准元素，j++；<br>通过指针j的遍历，使小于基准元素的元素换到当前子数组左侧，大于基准元素的元素换到右侧。当j扫描完当前子数组后，R[m]…R[i-1]即小于基准元素的元素，R[i]…R[k]即等于基准元素的元素，R[k+1]…R[n]即大于基准元素的元素。</p><p>在本题中，请你在之前实现的STL sort()初级版的基础上，进一步实现上述优化策略。</p><p>提示：本题只需把原来的Partition改为3-way Partition，并使用“三数取中”法选择基准元素。<br>在快速排序函数里，改为“尾递归转循环 + 先处理短区间”。你可以在Visual Studio里对sort函数右键点击“转到定义”，查看VS中STL的sort()实现细节<br>vstudio sort转到定义图片.jpg</p><p>函数接口定义：<br>void sort(int *R, int n);<br>功能为对整数R[1]…R[n]递增排序。</p><p>裁判测试程序样例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int threshold;</span><br><span class="line"></span><br><span class="line">// 请在这里补充你的代码，即你所实现的sort函数</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,i;</span><br><span class="line">    int a[50010];</span><br><span class="line">    scanf(&quot;%d %d&quot;, &amp;n, &amp;threshold);</span><br><span class="line">    for (i = 1; i &lt;= n; i++)</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    sort(a,n);</span><br><span class="line">    </span><br><span class="line">    printf(&quot;Final:&quot;);</span><br><span class="line">    for (i = 1; i &lt;= n; i++)</span><br><span class="line">        printf(&quot;%d &quot;,a[i]);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：提交代码时，只需提交sort函数以及你自定义的其他函数，不用提交#include或者main函数等内容。</p><p>输入格式:<br>输入第一行为2个正整数n和threshold，n为待排序的元素个数，不超过50000，threshold为改用插入排序的阈值，不超过20，含义如上所述。第二行为n个空格间隔的整数。本题中读入数据的操作无需你来实现，而由框架程序完成。</p><p>输出格式:<br>输出第一行为以depth_limit:开头的整数，表示转为堆排序的递归深度，即⌊2log<br>2n⌋。从第二行开始，输出对某子数组转为堆排序后，该子数组初始建堆的结果，每个元素后一个空格，每个堆占一行，以Heap:开头。注意，可能不止一个堆。接下来下一行，输出n个整数，每个整数后一个空格，为快速排序所有递归退出后，插入排序执行前的数组元素，以Intermediate:开头。最后一行为n整数，每个整数后一个空格，表示排序后的数组，以Final:开头（最后一行由框架程序完成，无需你来输出）。</p><p>输入样例1：<br>10 2<br>10 9 8 7 6 5 4 3 2 1</p><p>输出样例1：<br>depth_limit:6<br>Intermediate:1 2 3 5 4 6 7 8 9 10<br>Final:1 2 3 4 5 6 7 8 9 10 </p><p>输入样例2：<br>60 2<br>66 61 92 22 50 80 39 2 25 60 49 17 37 19 24 57 40 82 11 52 45 0 33 78 32 25 19 42 92 50 39 87 74 87 56 79 63 63 80 83 50 3 87 2 91 77 87 10 59 23 25 6 49 85 9 95 60 16 28 1<br>输出样例2：<br>depth_limit:11<br>Intermediate:1 0 2 2 3 6 9 10 11 16 17 19 19 22 23 24 25 25 25 32 28 33 37 39 39 40 42 45 49 49 50 50 50 52 56 57 59 60 60 61 63 63 66 74 77 78 79 80 80 82 83 85 87 87 87 87 91 92 92 95<br>Final:0 1 2 2 3 6 9 10 11 16 17 19 19 22 23 24 25 25 25 28 32 33 37 39 39 40 42 45 49 49 50 50 50 52 56 57 59 60 60 61 63 63 66 74 77 78 79 80 80 82 83 85 87 87 87 87 91 92 92 95 </p><p>代码长度限制<br>16 KB<br>时间限制<br>100 ms<br>内存限制<br>64 MB</p><hr><p>此题基于课程设计第二次上机A题，而且改进方法都在题目里，是在不行，朱老师的ppt里有来着？</p><hr><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>好像又没啥可结的，总之就这样罢</p>]]></content>
      
      
      <categories>
          
          <category> 吉林大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JLU </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JLU】 数据结构与算法上机题解思路分享-课程设计第一次与第二次上机 吉林大学</title>
      <link href="/posts/a76db678.html"/>
      <url>/posts/a76db678.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>首先</strong>，请务必自己尽全力尝试实现题目，直接看成品代码，思维就被拘束了，也很容易被查重。</p><p>这里只是思路解析的博客，代码仓库在 <a href="https://github.com/HSLix/JLU_Data_Structures_Record.git">JLU_Data_Structures_Record</a></p><p>希望你能在这里找到你想要的:)</p><h1 id="第一次上机"><a href="#第一次上机" class="headerlink" title="第一次上机"></a>第一次上机</h1><hr><h2 id="A-网络布线"><a href="#A-网络布线" class="headerlink" title="A 网络布线"></a>A 网络布线</h2><p>分数 50<br>作者 朱允刚<br>单位 吉林大学<br>2024年亚洲杯足球赛刚刚落下帷幕，赛前人们普遍预测：本届比赛中日韩是最强的，冠军也会从日韩中产生……随着东道主卡塔尔队的夺冠，这一预言未能成真。</p><p>但我们这里要研究的是另一个问题，亚洲杯赛期间需要保证运动员公寓网络畅通，以使运动员都能正常上网。</p><p>假定公寓楼内有n个房间，编号为0…n−1，每个房间都需要网络连接。房间 i 有网络，当且仅当满足如下2个条件之一：</p><p>（1）房间 i 安装了路由器（成本为 ri&gt;0）</p><p>（2）房间 i 和房间 j 有网线连接且房间 j 有网络（在房间 i 和房间 j 之间布置网线的成本为 fij&gt;0）</p><p>假定你是赛事组委会的网络工程师，请编写程序设计一个网络布线方案（哪些房间安装路由器，哪些房间之间布置网线），使得所有房间都有网络，且总成本最小。</p><p>例如下图包含7个房间和10个可能的连接，安装路由器的成本为括号内数字，房间之间布置网线的成本为边的权值。其解决方案为右下图，即在房间1和4安装路由器，并进行图中的网线布置。总成本为120。</p><p>img.png</p><p>输入格式:<br>输入第一行为两个正整数n和e；n为房间数，不超过600；e为可能的连接数，不超过2×10^5。接下来一行为n个空格间隔的正整数，第i个整数(i≥0)表示在房间i安装路由器的成本。接下来e行，每行为3个非负整数i、j、f，表示在房间i和房间j之间布置网线的成本为f。</p><p>输出格式:<br>输出为一个整数，表示最优网络布线方案的成本。</p><p>输入样例:<br>7 10<br>60 10 35 55 40 70 70<br>0 1 20<br>0 4 75<br>0 3 45<br>1 3 50<br>1 2 15<br>2 6 5<br>5 6 45<br>4 5 5<br>3 5 25<br>3 6 65</p><p>输出样例:<br>120</p><p>提示:<br>可引入一个虚拟顶点，将该顶点与其他所有顶点用边相连，边权等于那些顶点的权值。进而形成一个新图，对新图求最小支撑树。注意本题顶点编号从0开始。<br>image.png<br>image.png</p><p>代码长度限制<br>16 KB<br>时间限制<br>60 ms<br>内存限制<br>64 MB<br>栈限制<br>8</p><hr><p>思路都在提示里，唯一能补充的就是构造最小支撑树的算法，有Kruskal或Prim，本质就是在不产生回路的情况下，从最小边或某一点为角度切入，不断选取权值最小的边，并通过栈或队列存储下次可能检查的边或点</p><hr><h2 id="B-社交网络"><a href="#B-社交网络" class="headerlink" title="B 社交网络"></a>B 社交网络</h2><p>分数 50<br>作者 朱允刚<br>单位 吉林大学<br>可以将n个QQ用户间的好友关系建模为一个包含n个顶点的无向图，顶点编号为1至n，每个顶点对应一个用户，若2个用户i和j是QQ好友，则在顶点i和j之间连接一条边，并根据用户间的亲密度对该边附以一个权值c<br>ij。在该图中，可以利用两个顶点间的最短路径长度衡量两个用户的关系密切程度，也可以利用经过一个顶点的最短路径数目来衡量一个用户在关系网络中的影响力，具体地，我们定义用户k在QQ关系网络中的“影响力”为：</p><p>333.png</p><p>其中Nij 为顶点i到j的最短路径数目，Nijk 为顶点i到j的所有最短路径中经过顶点k的最短路径数目（上述二值可能超出int型范围，请使用long long类型）。Dij 表示i到j的最短路径长度。</p><p>现给定一个如上描述的无向图，请编写程序，计算每个顶点的“影响力”，假定给定的图是连通的。</p><p>输入格式:<br>输入第一行为两个正整数n和e，分别表示图的顶点数和边数，接下来e行表示每条边的信息，每行为3个正整数a、b、c，其中a和b表示该边的端点编号，c表示权值。各边并非按端点编号顺序排列。</p><p>n≤100，e≤5000，c≤1000，任意两点间的最短路径数目≤10<br>10</p><p>输出格式:<br>输出为n行，每行一个实数，精确到小数点后3位，第i行为顶点i的影响力。</p><p>输入样例:<br>4 4<br>3 2 6<br>4 3 1<br>1 3 9<br>4 1 1</p><p>输出样例:<br>0.000<br>0.000<br>30.000<br>20.000</p><p>解释:<br>对于顶点1：边2-3、3-4、2-4的最短路径均不经过顶点1，故顶点1的影响力为0.</p><p>对于顶点3：<br>顶点1到2的最短路径共1条，长度为8，经过点3，顶点2到4的最短路径共1条，长度为7，经过点3，顶点1到4的最短路径共1条，但不经过点3。<br>故f(3)&#x3D;D 12 ∗1+D 24 ∗1+D 14 ∗0+D 21 ∗1+D 42 ∗1+D 41 ∗0&#x3D;8+7+0+8+7+0&#x3D;30.000</p><p>提示:<br>若顶点a到顶点b有x条路径，点b到点c有y条路径，则a经过b到达c的路径有x*y条。</p><p>代码长度限制<br>16 KB<br>时间限制<br>50 ms<br>内存限制<br>64 MB<br>栈限制<br>8192 KB</p><hr><p>该程序的本质要求需要所有点到其余点的最短路径，以计算得出所谓的“影响力”。那么就有迪杰斯特拉算法和Floyd算法给选择。通常来说，点少边多适合Floyd，点多边少适合迪杰斯特拉算法。</p><p>陆爻齐在本题采用Floyd算法，得出所有的最短路径，然后遍历所有路径来统计影响力即可。</p><hr><h1 id="第二次上机"><a href="#第二次上机" class="headerlink" title="第二次上机"></a>第二次上机</h1><hr><h2 id="A-手撕STL-sort（基础版）"><a href="#A-手撕STL-sort（基础版）" class="headerlink" title="A 手撕STL sort（基础版）"></a>A 手撕STL sort（基础版）</h2><p>分数 40<br>作者 朱允刚<br>单位 吉林大学<br>C++ STL是Standard Template Library的简称，即标准模板库。简单来说，STL将常用的数据结构与算法进行了封装，用户需要时可以直接调用，不用重新开发。排序算法sort( )是STL包含的一个重要算法。</p><p>STL中的sort()函数基于快速排序算法实现，众所众知，快速排序是目前已知平均情况下最快的排序算法，被IEEE评选为20世纪十大算法之一，但其最坏情况下时间复杂度会退化为O(n 2 )。STL中的sort()对传统快速排序做了巧妙的改进，使其最坏情况下时间复杂度也能维持在O(nlogn)，它是如何实现的呢？</p><p>（1）快速排序算法最坏情况下时间复杂度退化为O(n 2 )的主要原因是，每次划分（Partition）操作时，都分在子数组的最边上，导致递归深度恶化为O(n)层。而STL的sort()在Partition操作有恶化倾向时，能够自我侦测，转而改为堆排序，使效率维持在堆排序的O(nlogn)。其具体方法是：侦测快速排序的递归深度，当递归深度达到⌊2log 2 n⌋&#x3D;O(logn)层时，强行停止递归，转而对当前处理的子数组进行堆排序。</p><p>（2）此外，传统的快速排序在数据量很小时，为极小的子数组产生许多的递归调用，得不偿失。为此，STL的sort()进行了优化，在小数据量的情况下改用插入排序。具体做法是：当递归处理的子数组长度（子数组包含的元素个数）小于等于某个阈值threshold 时，停止处理并退出本层递归，使当前子数组停留在“接近排序但尚未完成”的状态，最后待所有递归都退出后，再对整个序列进行一次插入排序（注意不是对当前处理的子数组进行插入排序，而是在快速排序的所有递归完全退出后，对整个数组统一进行一次插入排序）。实验表明，此种策略有着良好的效率，因为插入排序在面对“接近有序”的序列时拥有良好的性能。</p><p>在本题中，请你按照上述思路，自己实现STL的sort()函数。</p><p>备注：Partition操作选取第1个元素作为基准元素。Partition操作的不同实现可能导致不同的输出结果，为保证输出结果唯一，该操作的实现请以教材为准，即Hoare提出快速排序算法时最早给出的Partition实现</p><p>函数接口定义：<br>void sort(int *R, int n);<br>功能为对整数R[1]…R[n]递增排序。</p><p>裁判测试程序样例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int threshold;</span><br><span class="line"></span><br><span class="line">//请在这里补充你的代码，即你所实现的sort函数</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,i;</span><br><span class="line">    int a[50010];</span><br><span class="line">    scanf(&quot;%d %d&quot;, &amp;n, &amp;threshold);</span><br><span class="line">    for (i = 1; i &lt;= n; i++)</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    sort(a,n);</span><br><span class="line">    </span><br><span class="line">    printf(&quot;Final:&quot;);</span><br><span class="line">    for (i = 1; i &lt;= n; i++)</span><br><span class="line">        printf(&quot;%d &quot;,a[i]);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>备注：提交代码时，只需提交sort函数以及你自定义的其他函数，不用提交#include或者main函数等内容。</p><p>输入格式:<br>输入第一行为2个正整数n和threshold，n为待排序的元素个数，不超过50000，threshold为改用插入排序的阈值，不超过20，含义如上所述。第二行为n个空格间隔的整数。本题中读入数据的操作无需你来实现，而由框架程序完成。</p><p>输出格式:<br>输出第一行为以depth_limit:开头的整数，表示转为堆排序的递归深度，即⌊2log 2 n⌋。从第二行开始，输出对某子数组转为堆排序后，该子数组初始建堆的结果，每个元素后一个空格，每个堆占一行，以Heap:开头。注意，可能不止一个堆。接下来下一行，输出n个整数，每个整数后一个空格，为快速排序所有递归退出后，插入排序执行前的数组元素，以Intermediate:开头。最后一行为n整数，每个整数后一个空格，表示排序后的数组，以Final:开头（最后一行由框架程序完成，无需你来输出）。</p><p>输入样例1：<br>10 2<br>10 9 8 7 6 5 4 3 2 1</p><p>输出样例1：<br>depth_limit:6<br>Heap:7 6 5 4<br>Intermediate:1 2 3 4 5 6 7 8 9 10<br>Final:1 2 3 4 5 6 7 8 9 10 </p><p>输入样例2：<br>60 2<br>66 61 92 22 50 80 39 2 25 60 49 17 37 19 24 57 40 82 11 52 45 0 33 78 32 25 19 42 92 50 39 87 74 87 56 79 63 63 80 83 50 3 87 2 91 77 87 10 59 23 25 6 49 85 9 95 60 16 28 1 </p><p>输出样例2：<br>depth_limit:11<br>Heap:24 19 23 19 17 22<br>Intermediate:1 0 2 2 3 6 10 9 11 16 17 19 19 22 23 24 25 25 25 28 32 33 37 39 39 42 40 45 49 49 50 50 50 52 56 57 59 60 60 61 63 63 66 77 74 78 79 80 80 82 83 85 87 87 87 87 91 92 92 95<br>Final:0 1 2 2 3 6 9 10 11 16 17 19 19 22 23 24 25 25 25 28 32 33 37 39 39 40 42 45 49 49 50 50 50 52 56 57 59 60 60 61 63 63 66 74 77 78 79 80 80 82 83 85 87 87 87 87 91 92 92 95 </p><p>代码长度限制<br>16 KB<br>时间限制<br>100 ms<br>内存限制<br>64 MB</p><hr><p>这题思维上并无难点，堆排序，插入排序，快速排序都是基础要掌握的排序方式，但由于要检查一些中间输出，会限定得很死。</p><p>简要说下陆爻齐程序的大致思路好了，排序大体分两块，快排和插排，毕竟堆排是在快排中可能进入的，插排是快排完成后才开始的。快排的每层都会检测深度是否足够转化为堆排或是否要退出等待插排。至于快排的细节，如题所说，以教材相关内容为准吧，是在不行再看看老师ppt</p><hr><h2 id="B-排序"><a href="#B-排序" class="headerlink" title="B 排序"></a>B 排序</h2><p>分数 10<br>作者 朱允刚<br>单位 吉林大学<br>请编写程序对不超过50000个整数递增排序。<br>备注：本题不允许使用STL sort()或qsort()等现成的排序库函数。</p><p>输入格式:<br>输入第一行一个正整数n，表示待排序的元素个数。第二行为n个整数，表示待排序的元素。n不超过50000。</p><p>输出格式:<br>输出为一行，表示排序结果，每个整数后一个空格。</p><p>输入样例:<br>5<br>5 4 3 2 1</p><p>输出样例:<br>1 2 3 4 5 </p><p>代码长度限制<br>16 KB<br>时间限制<br>5000 ms<br>内存限制<br>64 MB<br>栈限制<br>8192 KB</p><hr><p>时间上限制很松，冒泡应该也行，其实把上道题写好的排序拉下来也行。</p><hr><h2 id="C-智能提示"><a href="#C-智能提示" class="headerlink" title="C 智能提示"></a>C 智能提示</h2><p>分数 30<br>作者 朱允刚<br>单位 吉林大学<br>百度、谷歌等搜索引擎，以及输入法等各种软件通常包含这样一个功能，当用户在输入框输入信息时，软件会提供一种“智能提示”。对用户所输入的信息，自动补全、列出可能的完整单词，提示给用户，以方便用户输入，提升用户体验。</p><p>pic.jpg</p><p>这个功能是如何实现的呢？一种典型的实现方式是，在系统后台维护一个字典，当用户输入字符时，在字典中查找以用户当前输入的字符串为前缀的全部单词，选取其中历史使用率最高的若干单词作为候选词，建议给用户。</p><p>请编写程序实现上述功能。</p><p>备注：这里约定一个字符串不能称为自己的前缀。若用户输入的字符串恰好是字典中的一个单词，则该单词不必向用户建议。</p><p>输入格式:<br>输入第一行为3个正整数n、m、k。n为字典中单词个数。m为用户查询数，即用户输入的单词个数。对于用户输入的每个字符串，程序需要返回字典中以该字符串为前缀的、历史使用频率最高的k个单词。接下来n行，表示字典信息，每行为1个整数和1个字符串，整数表示单词的历史使用频率，字符串表示单词，请注意，单词包含的每个字符为a-z的小写字母或0-9的数字，即数字也可能构成字典中的单词。字典内的单词并非按使用频率有序存放。接下来m行，表示用户的查询，每行为一个a-z的小写字母或0-9的数字组成的字符串，表示用户的查询。另外请注意，由于字典往往是在用户历史数据的基础上加工而得，所以字典中可能出现重复单词，若某个单词在字典中出现多次，则其历史使用频率以最高者为准。 (n ≤ 10000, m ≤ 20000, k ≤ 10, 每个单词长度不超过20，单词历史使用频率小于2<br>31<br> )</p><p>输出格式:<br>对于用户输入的每个字符串，按使用频率降序输出字典中以该字符串为前缀的、历史使用频率最高的k个单词，每个占1行。若多个单词历史使用频率相同，则字典序靠前的单词排名靠前。若单词中包含数字，则字典序以ACSII码判定，即0&lt;1&lt;2&lt;…&lt;9&lt;a&lt;b&lt;c&lt;…&lt;z。若字典中满足输出条件的单词个数大于0小于k，则有多少就输出多少个。若字典中没有满足输出条件的单词，则输出“no suggestion”。针对用户每个查询所输出的信息，用空行间隔。</p><p>输入样例:<br>20 3 4<br>1827187200the<br>1595609600to<br>1107331800that<br>401542500this<br>334039800they<br>282026500their<br>250991700them<br>196118888these<br>150877900than<br>144968100time<br>125563600then<br>109336600two<br>196120000there<br>87862100those<br>79292500through<br>75885600the<br>71578000think<br>674623002<br>65648600tx356<br>57087700though<br>th<br>xxx<br>the<br>输出样例:<br>the<br>that<br>this<br>they</p><p>no suggestion</p><p>they<br>their<br>them<br>there</p><p>代码长度限制<br>16 KB<br>时间限制<br>800 ms<br>内存限制<br>64 MB<br>栈限制<br>8192 KB</p><h2 id="D-智能提示（时间限制更严格）"><a href="#D-智能提示（时间限制更严格）" class="headerlink" title="D 智能提示（时间限制更严格）"></a>D 智能提示（时间限制更严格）</h2><p>分数 20<br>作者 朱允刚<br>单位 吉林大学<br>题目内容与前一题完全一致，但时间限制更为严格，若上题程序效率足够高，可直接将代码提交至本题。</p><p>备注：本题的测试点其实就是上一题的测试点4、5。如果上一题测试点4、5能在60ms内通过，本题就可以通过了。</p><p>输入格式:<br>与前一题相同。</p><p>输出格式:<br>与前一题相同。</p><p>输入样例:<br>与前一题相同。<br>输出样例:<br>与前一题相同。<br>代码长度限制<br>16 KB<br>时间限制<br>60 ms<br>内存限制<br>64 MB<br>栈限制<br>8192 KB</p><hr><p>CD两题一起讲，毕竟D就是C更严格时间限制罢了。</p><p>该题实际上是想学生建立字典树，并做一点改良，先从字典树简单说说好了，就如同此前的树一般，只不过树里面存的是单个字母，从树的根，也就是最“上面”的顶点往“下”走到叶子节点，途径字母组成单词，这便是字典树。</p><p>只要建立了字典树，并输出指定节点的所有叶子节点，就算是解决了C题。</p><p>那么如何解决D题呢？两个思路</p><p>其一是减少输入输出所消耗的时间，常用C++打OI的同学可能疑惑，已经给cin、cout加速了，还要继续优化吗？要的，陆爻齐最后用了scanf和printf才过，所以要把所有cout换printf和cin换scanf；</p><p>其二是优化中间步骤，其实我们细想下，在字典树的建立，查找对应点和搜寻点对应所有叶子节点哪个最复杂、很可能消耗最多时间呢？当然是搜寻叶子节点，毕竟同样的单词前缀，可对应的单词几乎无穷无尽。但其实，如果在建立字典树的时候，我们就把一个单词放进节点里，最后直接从该节点读取词，岂不美哉</p><p>有同学读完并实践完上述两点，发现还不够，就来说：陆爻齐，你骗人，还不行。确实，还差点，最后一点在于每个节点所存储的词可能太多了，要找出10个历史频率最高，同历史频率，字典序最低的词，还需要在每次把词放节点里时做下排序。这里可以用sort排序配合自己写的比较函数，这部分内容不会建议google一下或者bing一下。</p><hr><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>数据结构课程设计的前两次上机主要考察了图、排序和字典树，字典树的这两题很有趣，除了比较费时间、费精力、费脑子外挺好的：）</p>]]></content>
      
      
      <categories>
          
          <category> 吉林大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JLU </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JLU】 数据结构与算法上机题解思路分享-第三次上机 吉林大学</title>
      <link href="/posts/7624f419.html"/>
      <url>/posts/7624f419.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>首先</strong>，请务必自己尽全力尝试实现题目，直接看成品代码，思维就被拘束了，也很容易被查重。</p><p>这里只是思路解析的博客，代码仓库在 <a href="https://github.com/HSLix/JLU_Data_Structures_Record.git">JLU_Data_Structures_Record</a></p><p>希望你能在这里找到你想要的:)</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="A-图的创建"><a href="#A-图的创建" class="headerlink" title="A 图的创建"></a>A 图的创建</h2><p>分数 10<br>作者 朱允刚<br>单位 吉林大学<br>请编写程序创建一个有向图。有向图中包含n个顶点，编号为0至n-1。</p><p>输入格式:<br>输入第一行为两个正整数n和e，分别表示图的顶点数和边数，其中n不超过20000，e不超过20000。接下来e行表示每条边的信息，每行为3个非负整数a、b、c，其中a和b表示该边的端点编号，c表示权值。各边并非按端点编号顺序排列。</p><p>输出格式:<br>按顶点编号递增顺序输出每个顶点引出的边，每个顶点占一行，若某顶点没有引出边，则不输出。每行表示一个顶点引出的所有边，格式为a:(a,b,w)……，表示有向边a-&gt;b的权值为w，a引出的多条边按编号b的递增序排列。</p><p>输入样例:<br>7 7<br>0 1 5<br>0 3 7<br>0 6 6<br>1 2 4<br>2 5 1<br>3 5 3<br>6 5 4</p><p>输出样例:<br>0:(0,1,5)(0,3,7)(0,6,6)<br>1:(1,2,4)<br>2:(2,5,1)<br>3:(3,5,3)<br>6:(6,5,4)</p><p>代码长度限制<br>16 KB<br>时间限制<br>500 ms<br>内存限制<br>20 MB</p><hr><p>该题只是图的创建，众所周知，图可以用邻接矩阵或邻接链表实现，这里采用了邻接链表，只要记录边和权值即可。</p><hr><h2 id="B-图的删边操作"><a href="#B-图的删边操作" class="headerlink" title="B 图的删边操作"></a>B 图的删边操作</h2><p>分数 10<br>作者 朱允刚<br>单位 吉林大学<br>请编写程序对给定的有向图删除若干条边。有向图中包含n个顶点，编号为0至n-1。</p><p>输入格式:<br>输入第一行为两个正整数n和e，分别表示图的顶点数和边数，其中n不超过20000，e不超过1000。接下来e行表示每条边的信息，每行为3个非负整数a、b、c，其中a和b表示该边的端点编号，c表示权值。各边并非按端点编号顺序排列。随后一行为一个整数k，表示删除的边的条数，接下来k行，每行为2个非负整数a、b，表示待删除的边为a-&gt;b。保证删除的边一定在原图中。</p><p>输出格式:<br>输出执行删边操作之后的图。每行表示一个顶点引出的所有边，格式为a:(a,b,w)……，表示有向边a-&gt;b的权值为w，a引出的多条边按编号b的递增序排列。若某顶点没有引出边，则不输出。</p><p>输入样例:<br>7 7<br>0 1 5<br>0 3 7<br>0 6 6<br>1 2 4<br>2 5 1<br>3 5 3<br>6 5 4<br>2<br>2 5<br>0 1</p><p>输出样例:<br>0:(0,3,7)(0,6,6)<br>1:(1,2,4)<br>3:(3,5,3)<br>6:(6,5,4)</p><p>代码长度限制<br>16 KB<br>时间限制<br>200 ms<br>内存限制<br>64 MB</p><hr><p>图的创建同上图，这里的删边如果是邻接链表注意要删除时，确保不要一删就删了多个就行</p><hr><h2 id="C-图深度优先遍历"><a href="#C-图深度优先遍历" class="headerlink" title="C 图深度优先遍历"></a>C 图深度优先遍历</h2><p>分数 10<br>作者 朱允刚<br>单位 吉林大学<br>编写程序对给定的有向图（不一定连通）进行深度优先遍历，图中包含n个顶点，编号为0至n-1。本题限定在深度优先遍历过程中，如果同时出现多个待访问的顶点，则优先选择编号最小的一个进行访问，以顶点0为遍历起点。</p><p>输入格式:<br>输入第一行为两个整数n和e，分别表示图的顶点数和边数，其中n不超过20000，e不超过50。接下来e行表示每条边的信息，每行为两个整数a、b，表示该边的端点编号，但各边并非按端点编号顺序排列。</p><p>输出格式:<br>输出为一行整数，每个整数后一个空格，即该有向图的深度优先遍历结点序列。</p><p>输入样例1:<br>3 3<br>0 1<br>1 2<br>0 2<br>输出样例1:<br>0 1 2<br>输入样例2:<br>4 4<br>0 2<br>0 1<br>1 2<br>3 0<br>输出样例2:<br>0 1 2 3<br>代码长度限制<br>16 KB<br>时间限制<br>50 ms<br>内存限制<br>64 MB</p><hr><p>创建图后，进行DFS就行了，没啥讲的</p><p>要不简单讲下DFS或BFS好了，就是从一个点入手，搜寻该点所连的所有点并加入数组中，无论栈或队列，记录然后提出一点，继续搜寻，加入记录，往复至无点可寻。</p><p>嘛，突然想起，如果前这几道题都用邻接矩阵，或许实现就简单很多了</p><hr><h2 id="D-单源最短路径"><a href="#D-单源最短路径" class="headerlink" title="D 单源最短路径"></a>D 单源最短路径</h2><p>分数 30<br>作者 朱允刚<br>单位 吉林大学<br>请编写程序求给定正权有向图的单源最短路径长度。图中包含n个顶点，编号为0至n-1，以顶点0作为源点。</p><p>输入格式:<br>输入第一行为两个正整数n和e，分别表示图的顶点数和边数，其中n不超过20000，e不超过1000。接下来e行表示每条边的信息，每行为3个非负整数a、b、c，其中a和b表示该边的端点编号，c表示权值。各边并非按端点编号顺序排列。</p><p>输出格式:<br>输出为一行整数，为按顶点编号顺序排列的源点0到各顶点的最短路径长度（不含源点到源点），每个整数后一个空格。如源点到某顶点无最短路径，则不输出该条路径长度。</p><p>输入样例:<br>4 4<br>0 1 1<br>0 3 1<br>1 3 1<br>2 0 1<br>输出样例:<br>1 1<br>代码长度限制<br>16 KB<br>时间限制<br>100 ms<br>内存限制<br>20 MB</p><hr><p>就是迪杰斯特拉算法的使用，没有什么可以引申的</p><hr><h2 id="E-双十一"><a href="#E-双十一" class="headerlink" title="E 双十一"></a>E 双十一</h2><p>分数 20<br>作者 朱允刚<br>单位 吉林大学<br>双十一期间，某著名电商平台“东东”为应对销售高峰，准备在n个城市中再增加一个自营仓库，其要求是该仓库设在n个城市中的某个城市，且距离其他所有城市的最短距离之和最小。请编写程序帮助“东东”找出设立仓库的地点。假定n个城市编号为0至n-1，它们之间至少有一个城市与其他所有城市可及。</p><p>输入格式:<br>输入包含多组数据。每组数据第一行为两个正整数n和e，均不超过100。n表示城市数。接下来e行表示两个城市间的距离信息，每行为3个非负整数a、b、c，其中a和b表示两个城市编号，c表示城市间的距离。</p><p>提示：可使用EOF判断输入结束。</p><p>输出格式:<br>输出为一个整数，表示建立仓库的城市编号，如多个城市满足要求，则输出编号最小者。</p><p>输入样例:<br>6 5<br>0 1 1<br>0 2 1<br>0 3 1<br>0 4 1<br>0 5 1<br>4 5<br>0 1 1<br>0 2 5<br>1 2 2<br>1 3 4<br>2 3 1</p><p>输出样例:<br>0<br>1</p><p>代码长度限制<br>16 KB<br>时间限制<br>50 ms<br>内存限制<br>64 MB</p><hr><p>该题的本质是找到一个到其它点距离之和最小的点，理所当然地应该使用Prim算法，求出各个点到其它所有点距离之和最短。</p><hr><h2 id="F-任务拓扑排序"><a href="#F-任务拓扑排序" class="headerlink" title="F 任务拓扑排序"></a>F 任务拓扑排序</h2><p>分数 30<br>作者 朱允刚<br>单位 吉林大学<br>一个工程被分解成n个子任务，编号为0至n-1。要完成整个工程需要完成所有的子任务。其中一些子任务必须先于另外一些子任务被完成。给定各子任务之间的先后关系，请编写程序给出一个合理的任务完成顺序，若工程不可行，程序亦能识别。</p><p>输入格式:<br>输入第一行为两个整数n和e，均不超过100。n表示子任务数。接下来e行，表示已知的两个子任务间的先后关系，每行为两个整数a和b，表示任务a必须先于任务b完成。</p><p>输出格式:<br>若工程不可行（一些子任务以自己为先决条件），输出“unworkable project”；若工程可行，输出为1行整数，每个整数后一个空格，为n个子任务的编号，表示子任务的完成顺序，如果有多种可能的顺序，则输出字典序最小者。</p><p>注：字典序，即对象在字典中的顺序。对于两个数字序列，从第一个数字开始比较，当某一个位置的数字不同时，该位置数字较小的序列，字典序较小，例如1 2 3 9比1 2 4 5小，1 2 8 9比1 2 10 3小。</p><p>输入样例1:<br>3 2<br>0 1<br>1 2<br>输出样例1:<br>0 1 2<br>输入样例2:<br>3 3<br>0 1<br>1 2<br>2 0<br>输出样例2:<br>unworkable project<br>代码长度限制<br>16 KB<br>时间限制<br>50 ms<br>内存限制<br>64 MB</p><hr><p>拓扑排序，内容也是书上有的，简单说，就是从没有指着的点开始，把这个点弹出，并把点所连的点被连的标记数–，然后再从标记数0的点挑个点重复过程。</p><p>还有个字典序，无论字母、数字，是不是从前往后一个个比较，比如返回a &lt; b，true则a字典序比b小。</p><hr><h2 id="G-关键路径"><a href="#G-关键路径" class="headerlink" title="G 关键路径"></a>G 关键路径</h2><p>分数 30<br>作者 朱允刚<br>单位 吉林大学<br>假定一个工程由若干子任务构成，使用一个包含n个顶点、e条边的AOE网表示该工程，顶点编号为1至n，有向边表示该工程的每个子任务，边的权值表示完成该子任务所需的时间，假定网中只含一个源点和一个汇点。请编写程序求出该工程的所有关键活动，并计算完成该工程所需的最短时间。</p><p>输入格式:<br>每个测试点包含多组测试数据。每组数据第一行为2个整数n和e，均不超过200，分别表示AOE网的顶点数和边数。接下来e行表示每条边的信息，每行为3个正整数a、b、c，其中a和b表示该边的端点编号，c表示权值。各边并不一定按端点编号顺序排列，且各顶点并不一定按拓扑序排列。</p><p>输出格式:<br>对每组数据，若工程不可行（AOE网中存在环），输出“unworkable project”；若工程可行，则输出第一行为完成工程所需的最短时间，并从第2行开始输出关键活动，每个关键活动占一行，格式为i-&gt;j，其中i和j表示关键活动所在边的端点编号。各关键活动输出顺序为：按i的递增顺序输出，若多个关键活动的i值相同，则按j的递增顺序输出。</p><p>输入样例:<br>4 4<br>1 2 6<br>1 3 4<br>2 4 1<br>3 4 1</p><p>输出样例:<br>7<br>1-&gt;2<br>2-&gt;4</p><p>代码长度限制<br>16 KB<br>时间限制<br>100 ms<br>内存限制<br>64 MB</p><hr><p>简单的说，是计算最早完成时间与最晚完成时间相等的点，输出即可。</p><p>回头来看，这就是动态规划啊</p><hr><h2 id="H-联盟数目"><a href="#H-联盟数目" class="headerlink" title="H 联盟数目"></a>H 联盟数目</h2><p>分数 20<br>作者 朱允刚<br>单位 吉林大学<br>艾迪是一家集团公司的老板，该集团包含n家公司，为了管理公司，艾迪会时常通过网络向各公司发送消息。各公司间的网络是单向的，每个公司都有一个分发列表，表示其能向哪些公司直接传达消息。例如A公司的分发列表为B、C，表示A可将消息直接传送给B和C（由于网络是单向的，B或C不一定能向A传送消息），这样艾迪若想向A、B、C公司发送消息，则只需向A发送消息即可，随后A可将消息传送到B和C。</p><p>为了便于管理各公司，艾迪打算将n家公司分成若干组，每组称为一个区域联盟，每组满足如下条件：组内的任意公司消息互相可达。即对于组内任意公司u和v，u可将消息传送到v（可由u直接传送到v，也可通过组内其他公司中转传送到v），v也可将消息传送到u。可以认为一个公司可以将消息传送给自己，即一个公司可以自成一组。</p><p>艾迪希望组的数量尽可能少，即在满足上述条件的情况下，每组包含的公司数目尽可能多。</p><p>现给定每个公司的分发列表，请编写程序告知艾迪，他的集团最少能分成多少组。</p><p>输入格式:<br>第一行包含一个整数T (1≤T≤100)表示数据组数。对于每组数据，第一行为一个整数n (2≤n≤100)，表示公司数目，公司编号为1到n。随后n行，第i行包含若干整数，表示第i个公司的分发列表，每行以0结尾。</p><p>输出格式:<br>对于每组数据，输出一行，为一个整数，表示组数。</p><p>输入样例:<br>3<br>5<br>2 4 3 0<br>4 5 0<br>0<br>0<br>1 0<br>3<br>2 0<br>0<br>2 1 0<br>3<br>2 0<br>3 0<br>0</p><p>输出样例:<br>3<br>3<br>3</p><p>代码长度限制<br>16 KB<br>时间限制<br>100 ms<br>内存限制<br>64 MB</p><hr><p>这个点相对前面比较偏，实际上是要找到尽可能大的连通组，采用WarShall算法，找到各个组的最大闭包。</p><hr><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本次上机简答考察了图的基本使用，创建、遍历、删除等，然后又加了点场景考察迪杰斯特拉算法和普利姆算法，最后搞了应该比较难反应过来的WarShall算法，算是把书上的内容过了一遍力，加油罢</p>]]></content>
      
      
      <categories>
          
          <category> 吉林大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JLU </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JLU】 数据结构与算法上机题解思路分享-第二次上机 吉林大学</title>
      <link href="/posts/34307351.html"/>
      <url>/posts/34307351.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>首先</strong>，请务必自己尽全力尝试实现题目，直接看成品代码，思维就被拘束了，也很容易被查重。</p><p>这里只是思路解析的博客，代码仓库在 <a href="https://github.com/HSLix/JLU_Data_Structures_Record.git">JLU_Data_Structures_Record</a></p><p>希望你能在这里找到你想要的:)</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><hr><h2 id="A-二叉树的创建与遍历"><a href="#A-二叉树的创建与遍历" class="headerlink" title="A 二叉树的创建与遍历"></a>A 二叉树的创建与遍历</h2><p>分数 10<br>作者 朱允刚<br>单位 吉林大学<br>通过带空指针信息的先根序列（亦称先序序列）创建二叉树，并进行先根（先序）、中根（中序）、后根（后序）遍历。二叉树结点数据域值为不等于0的整数（可能是正数也可能是负数），空指针用0表示，例如1 5 8 0 0 0 6 0 0表示如下图的二叉树。</p><p>输入格式:<br>输入为一组用空格间隔的整数，表示带空指针信息的二叉树先根序列。其中空指针信息用0表示。二叉树结点个数不超过150000，高度不超过6000。输入数据保证二叉树各结点数据值互不相等。</p><p>输出格式:<br>输出为3行整数，每个整数后一个空格。第1行为该二叉树的先根序列，第2行为中根序列，第3行为后根序列。</p><p>输入样例:<br>1 5 8 0 0 0 6 0 0<br>输出样例:<br>1 5 8 6<br>8 5 1 6<br>8 5 6 1<br>代码长度限制<br>16 KB<br>时间限制<br>200 ms<br>内存限制<br>20 MB</p><hr><p>这道题没什么好解析的，从先根序列造二叉树，可以采用递归的方法，0则结束，否则就以该值创节点，并进入左节点的函数和右节点的函数。</p><hr><h2 id="B-二叉树查找结点及父结点"><a href="#B-二叉树查找结点及父结点" class="headerlink" title="B 二叉树查找结点及父结点"></a>B 二叉树查找结点及父结点</h2><p>分数 10<br>作者 朱允刚<br>单位 吉林大学<br>编写程序在二叉树中查找给定结点及父结点。二叉树结点的数据域值不等于0的整数。</p><p>输入格式:<br>输入第1行为一组用空格间隔的整数，表示带空指针信息的二叉树先根序列，其中空指针用0表示。例如1 5 8 0 0 0 6 0 0表示如下图的二叉树。第2行为整数m，表示查询个数。接下来m行，每行为一个不等于0的整数K，表示要查找的结点的数据值。m不超过100，二叉树结点个数不超过150000，高度不超过6000。输入数据保证二叉树各结点数据值互不相等。</p><p>输出格式:<br>输出为m行，每行1个整数，表示被查找结点K的父结点数据值，若二叉树中无结点K或结点K无父结点，则输出0。</p><p>输入样例:<br>1 5 8 0 0 0 6 0 0<br>3<br>8<br>1<br>6<br>输出样例:<br>5<br>0<br>1<br>代码长度限制<br>16 KB<br>时间限制<br>300 ms<br>内存限制<br>20 MB</p><hr><p>造树的函数可以复用上一题，本体考察的查找，更没有啥可以说的，你可以任选先、中、后三种顺序都可以</p><hr><h2 id="C-二叉树删除子树"><a href="#C-二叉树删除子树" class="headerlink" title="C 二叉树删除子树"></a>C 二叉树删除子树</h2><p>分数 10<br>作者 朱允刚<br>单位 吉林大学<br>编写程序对给定二叉树执行若干次删除子树操作，输出每次删除子树后剩余二叉树的中根序列。二叉树结点的数据域值为不等于0的整数。每次删除操作是在上一次删除操作后剩下的二叉树上执行。</p><p>输入格式:<br>输入第1行为一组用空格间隔的整数，表示带空指针信息的二叉树先根序列，其中空指针信息用0表示。例如1 5 8 0 0 0 6 0 0表示如下图的二叉树。第2行为整数m，表示要进行的删除操作次数。接下来m行，每行一个不等于0的整数K，表示要删除以K为根的子树。m不超过100，二叉树结点个数不超过5000。输入数据保证各结点数据值互不相等，且删除子树后二叉树不为空。</p><p>输出格式:<br>输出为m行，每行为一组整数，表示执行删除操作后剩余二叉树的中根序列（中根序列中每个整数后一个空格）。若要删除的子树不在当前二叉树中，则该行输出0（0后无空格）。</p><p>输入样例:<br>1 5 8 0 0 0 6 0 0<br>3<br>5<br>8<br>6<br>输出样例:<br>1 6<br>0<br>1<br>代码长度限制<br>16 KB<br>时间限制<br>100 ms<br>内存限制<br>10 MB</p><hr><p>此题可以分解为两部分，第一部分是找到要删的点，第二部分是执行删除。寻找部分就是第二题，那么我们实际上可以专注于如何执行二叉树的删除了。</p><p>那么什么是删除呢？可表现为其父节点对应指针为空，那么空间要不要释放呢？随你喜欢，毕竟答案检验是遍历，与内存无关：）所以把父节点对应指针置空即可。</p><p>整体的构造是递归，若没找到则向两子树找，找到就删除对应子树，没找到回报个0</p><hr><h2 id="D-重建二叉树"><a href="#D-重建二叉树" class="headerlink" title="D 重建二叉树"></a>D 重建二叉树</h2><p>分数 30<br>作者 朱允刚<br>单位 吉林大学<br>给定非空二叉树的中根序列和后根序列，请编写程序创建该二叉树，计算其高度和先根序列；如给定的中根和后根序列不合法，则亦能识别。</p><p>输入格式:<br>输入包含多组数据（不超过10组），每组为两行字符串，第一行表示某二叉树的后根序列，第二行表示其中根序列。结点的值均为A-Z的大写字母，故二叉树结点个数不超过26，且保证输入的两个序列都是结点的全排列，但不一定是合法的中根和后根序列。输入保证不是空二叉树。</p><p>输出格式:<br>对于每组数据，如果输入的序列不合法（不是同一棵树的中根序列和后根序列），则输出INVALID；若输入序列合法，输出为两行，第一行为一个整数，表示该二叉树的高度，第二行为一个字符串，表示该二叉树的先根序列。</p><p>输入样例1:<br>CEFDBHGA<br>CBEDFAGH<br>CBEDFAGH<br>CEFDBHGA<br>BCA<br>CAB</p><p>输出样例1:<br>3<br>ABCDEFGH<br>INVALID<br>INVALID</p><p>代码长度限制<br>16 KB<br>时间限制<br>50 ms<br>内存限制<br>64 MB</p><hr><p>本题也是书上有的内容此处就简单叙述下要点，中根和后根序列分别给了不同的信息，后根的最后一个表示该树的中点，也就是最上面那个，根据中点就可以从中根序列中找到该树的左子树有什么点，右子树有什么点。</p><p>而这样的分割可以不断递归，毕竟一个二叉树的左子树也是二叉树，只要不断地将子树的中后序列分割出来，总有左右子树只剩一点或者无点的情况，然后再不断组装回去，最后就得到了二叉树</p><hr><h2 id="E-二叉树路径和"><a href="#E-二叉树路径和" class="headerlink" title="E 二叉树路径和"></a>E 二叉树路径和</h2><p>分数 20<br>作者 朱允刚<br>单位 吉林大学<br>编写程序找出二叉树中和最大的路径，二叉树结点为不等于0的整数。本题的“路径”限定为以根结点为起点，以叶结点为终点的路径。路径的和，即该路径所包含的所有结点的数据值之和。</p><p>输入格式:<br>输入为一组用空格间隔的整数，个数不超过100个，表示带空指针信息的二叉树先根序列。</p><p>输出格式:<br>输出为两行，第一行为该二叉树路径和的最大值，第二行为一组整数，每个整数后一个空格，即该最大路径包含的结点值（按从根的叶的顺序），如果存在多条满足条件路径，则输出最左边一条。</p><p>输入样例1:<br>1 2 0 0 3 0 0<br>输出样例1:<br>4<br>1 3<br>输入样例2:<br>-1 2 0 0 3 0 0<br>输出样例2:<br>2<br>-1 3<br>代码长度限制<br>16 KB<br>时间限制<br>50 ms<br>内存限制<br>64 MB</p><hr><p>像这种寻找一条最优路的方法，基础办法有深度优先算法DFS或广度优先算法BFS。</p><p>以DFS为例，大致就是用栈（其实就是一个数组加指针）来记录路径，然后遍历一遍二叉树，以DFS或BFS的方式，到底时与已有路径记录比较，保留更大的</p><hr><h2 id="F-哈夫曼树编码"><a href="#F-哈夫曼树编码" class="headerlink" title="F 哈夫曼树编码"></a>F 哈夫曼树编码</h2><p>此题不做分享，毕竟陆爻齐也差一个点，没资格说话</p><hr><h2 id="G-S遍历"><a href="#G-S遍历" class="headerlink" title="G S遍历"></a>G S遍历</h2><p>分数 30<br>作者 朱允刚<br>单位 吉林大学<br>二叉树的“S遍历”定义为从根结点开始，先自右向左遍历，然后下一层自左向右遍历，再下一层自右向左遍历，以此类推…。例如下图所示二叉树的S遍历序列为1 2 3 6 5 4 7 8。现给定一棵非空二叉树，结点数据域值为互不相等且不等于0的正整数，同时给定两个正整数a和b，请编写程序输出结点a和b间的S遍历序列。</p><p>555.jpg</p><p>输入格式:<br>输入第一行为1组用空格间隔的正整数，表示带空指针信息的二叉树先根序列，二叉树结点个数不超过150000，高度不超过5000。第二行为两个正整数a和b，含义如题目所述，保证a和b一定在二叉树中，且在S遍历序列中a在b的前边。</p><p>输出格式:<br>输出为一行整数，每个整数后一个空格，表示数据值为a和b的两个结点间的S遍历序列。</p><p>输入样例1:<br>1 2 4 0 0 0 3 5 7 0 0 8 0 0 6 0 0<br>1 8<br>输出样例1:<br>1 2 3 6 5 4 7 8<br>输入样例2:<br>1 2 0 4 0 7 0 0 3 5 0 0 6 8 20 0 0 21 0 0 0<br>6 8<br>输出样例2:<br>6 5 4 7 8<br>输入样例3:<br>1 2 0 3 4 5 0 0 6 0 0 0 7 0 8 9 10 0 0 11 0 0 0<br>1 11<br>输出样例3:<br>1 2 7 8 3 4 9 11<br>输入样例4:<br>2 4 3 0 0 8 0 0 10 5 7 9 0 0 1 0 0 17 0 0 6 0 0<br>2 9<br>输出样例4:<br>2 4 10 6 5 8 3 7 17 1 9<br>数据规模:<br>测试点0-2、5-9：结点个数≤50，树高≤20<br>测试点3：4500≤结点个数≤5500，4000≤树高≤5000<br>测试点4：130000≤结点个数≤150000，10≤树高≤20</p><p>代码长度限制<br>16 KB<br>时间限制<br>100 ms<br>内存限制<br>20 MB</p><hr><p>此题看似是一个十分繁琐的搜索，但其实就是考察对于基本数据结构栈和队列的用法。</p><p>陆爻齐采用了栈来解决该问题，也就是用两个栈，分别存储向左和向右遍历时存储的点，然后向左向右分别用不同的顺序把点加进栈，模拟出所谓的S型</p><hr><h2 id="H-衣服挂游戏"><a href="#H-衣服挂游戏" class="headerlink" title="H 衣服挂游戏"></a>H 衣服挂游戏</h2><p>分数 20<br>作者 朱允刚<br>单位 吉林大学<br>有n个衣服挂，编号为1至n，初始时按顺序挂在一个晾衣杆上，每个衣挂自成一列（即相当于有n列，每列只含一个衣挂）。</p><p>1.jpg</p><p>爸爸让艾迪做如下操作“x y”，表示将衣挂x所在的列放在衣挂y所在的列下面，即把x所在列的第一个衣挂，挂在y所在列的最下面的衣挂下面，如果x和y已在同一列里，则忽略该操作。例如上图执行操作“3 5”后，得到下图：</p><p>2.jpg</p><p>再执行操作“3 2”后，得到下图：</p><p>3.jpg</p><p>爸爸给出一系列指令，请编写程序，输出艾迪完成爸爸的所有操作后，每个衣挂所在的列的第一个衣挂的编号。</p><p>输入格式:<br>每个测试点包含多组测试数据，第一行1个整数 T ，表示测试数据组数。对于每组数据，第一行两个整数 n 和 m，分别表示衣挂个数和操作次数。接下来 m 行，每行两个整数x和y，表示爸爸让艾迪执行的一个操作。T≤5，1≤n, m≤30000，1≤x, y≤n。</p><p>输出格式:<br>输出为T 行，每行为 n个整数a1 a2 … an ，每个整数后一个空格，ai(1≤i≤n)表示衣挂i所在列的第一个衣挂的编号。</p><p>输入样例:<br>2<br>4 2<br>2 1<br>4 3<br>5 4<br>1 2<br>2 3<br>4 5<br>1 3</p><p>输出样例:<br>1 1 3 3<br>3 3 3 5 5 </p><p>代码长度限制<br>16 KB<br>时间限制<br>80 ms<br>内存限制<br>64 MB</p><hr><p>该题的本质是考察并查集的创建和使用，像这种很喜欢溯源的，并查集往往都能比较好的解决。</p><p>再简单说下陆爻齐认为的并查集吧，并查集往往用数组实现，用下标表示其编号，而存储的数字则为其父亲的编号，也就是父节点的下标。</p><p>题中正好n个衣架，编号1-n，正好对应数组，把x挂y上，完全可以把x上的数字改成y；这是x无父节点的情况，若x有父节点，当然先要追溯到其曾曾祖父，把老人家挂y上。</p><hr><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这次上机主要考查了二叉树的创建、查找、删除等，还有并查集的使用，利用上机题巩固所学不失为一种好方法：）</p>]]></content>
      
      
      <categories>
          
          <category> 吉林大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JLU </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JLU】 数据结构与算法上机题解思路分享-第一次上机 吉林大学</title>
      <link href="/posts/edee5deb.html"/>
      <url>/posts/edee5deb.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>首先</strong>，请务必自己尽全力尝试实现题目，直接看成品代码，思维就被拘束了，也很容易被查重。</p><p>这里只是思路解析的博客，代码仓库是<a href="https://github.com/HSLix/JLU_Data_Structures_Record.git">JLU_Data_Structures_Record</a></p><p>希望你能在这里找到你想要的:)</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><hr><h2 id="A-调皮的哈利"><a href="#A-调皮的哈利" class="headerlink" title="A 调皮的哈利"></a>A 调皮的哈利</h2><p>分数 30<br>作者 朱允刚<br>单位 吉林大学<br>贝蒂是个打字高手，打字时有不看屏幕的习惯。在一次贝蒂打字时，调皮的哈利常常趁贝蒂不注意按下Home键、End键、左右方向键和退格键。当Home键被按下时，输入光标会跳到文本最开头；当End键被按下时，输入光标会跳到文本末尾；当左&#x2F;右方向键被按下时，输入光标会向左&#x2F;右移动一位；当退格键被按下时，输入光标左面的一个字符会被删除。现给出贝蒂和哈利按键的字符串，其中’{‘表示Home键，’}’表示End键，’&lt;’表示左方向键，’&gt;’表示右方向键，’#’表示退格键，其余字符均表示输入的内容，请输出屏幕上最终显示的文本。</p><p>img.jpg</p><p>输入格式:<br>输入一个字符串，长度不超过5×10<br>4<br> ，包含大小写字母、空格、下划线、{、}、&lt;、&gt;、#，表示贝蒂和哈利的按键序列。</p><p>输出格式:<br>输出为屏幕上最终显示的字符串。</p><p>输入样例1:<br>jlu_cc{i_love_}st</p><p>输出样例1:<br>i_love_jlu_ccst<br>输入样例2:<br>stre&lt;&lt;aaa</p><p>输出样例2:<br>staaare<br>输入样例3:<br>xxx&gt;&gt;&gt;yyy##z&lt;&lt;&gt;k</p><p>输出样例3:<br>xxxykz<br>输入样例4:<br>abcd{efghi}jklm{nopq}rs{t}uvwxyz</p><p>输出样例4:<br>tnopqefghiabcdjklmrsuvwxyz<br>代码长度限制<br>16 KB<br>时间限制<br>25 ms<br>内存限制<br>10 MB</p><hr><p>从题目可以知道，题目要求对于内部的数据结构有着频繁的更改，所以在我们已知的数据结构中，可以考虑采用链表来进行实现。</p><p>同时也能注意到，对于字符串的处理，有一些如同转义字符一样的特殊字符，将这些特殊字符的处理编为函数，也是一个不错的选择。</p><p>此外，也建议想象自己操纵着光标，输入时向光标左边插字，删除时删除左边的字这样。</p><hr><p>##B 括号匹配<br>分数 20<br>作者 朱允刚<br>单位 吉林大学<br>请编写程序判断一个包含“（”和“）”的括号序列是否匹配。如匹配则输出Match；如不匹配，计算出使该序列变为匹配序列所需添加的最少括号数目（只允许在该序列开始和结尾处添加括号），并输出经添加最少括号后得到的合法匹配序列。</p><p>输入格式:<br>输入为若干行，每行一个字符串，包含不超过10 ^ 5个括号。输入行数不超过10行。</p><p>输出格式:<br>对于输入的每个括号序列输出1行或2行信息。若输入的括号序列匹配，则输出Match。若不匹配，则输出分为2行，第1行为一个整数，表示将该序列变为匹配序列所需添加的最少括号数目，第2行为一个字符串，表示经添加最少括号后得到的合法匹配序列。</p><p>输入样例:<br>(())()<br>)(<br>()))((</p><p>输出样例:<br>Match<br>2<br>()()<br>4<br>((()))(())</p><p>代码长度限制<br>16 KB<br>时间限制<br>20 ms<br>内存限制<br>10 MB</p><hr><p>该题目与课内某题很像，通过栈记录匹配与否，再实现补充即可</p><p>由于全是小括号，基本不用考虑在哪里补充，缺几个左括号就直接向左补，缺几个右括号直接向右补即可</p><hr><h2 id="C-表达式求值"><a href="#C-表达式求值" class="headerlink" title="C 表达式求值"></a>C 表达式求值</h2><p>分数 30<br>作者 朱允刚<br>单位 吉林大学<br>给定一个中缀表达式，请编写程序计算该表达式的值。表达式包含+、-、*、\、^、(、)，所有运算均为二元运算，操作数均为正整数，但可能不止一位，不超过10位。运算结果为整数，值域为[−2^31,2^<br>31)。除法运算结果若为小数则进行截尾取整。若除法运算中除数为0，则输出INVALID。幂运算须自行实现，不允许调用pow等系统函数。测试数据保证幂运算中指数为非负，底数不为0。</p><p>输入格式:<br>输入为多行，每行为一个长度不超过1000的字符串，表示中缀表达式。</p><p>输出格式:<br>对每个表达式输出一行：为一个整数（表达式的值）或为一个字符串INVALID。</p><p>输入样例:<br>5+(10<em>2)-6<br>8</em>(999+1)<br>1+5&#x2F;(1-1)<br>7*2^3</p><p>输出样例:<br>19<br>8000<br>INVALID<br>56<br>代码长度限制<br>16 KB<br>时间限制<br>50 ms<br>内存限制<br>64 MB</p><hr><p>经典的中缀表达式转后缀表达式，基本与课本一样，不过需要快速幂来减少时间消耗，毕竟只有50ms嘛</p><p>陆爻齐采用了专门的函数判断符号优先级，是否为括号的函数来事得程序条理更清晰些，为了省事，或许能够统一个函数，直接用数字区分类别，不过更耗点脑子罢</p><hr><h2 id="D-EDG"><a href="#D-EDG" class="headerlink" title="D EDG"></a>D EDG</h2><p>分数 20<br>作者 朱允刚<br>单位 吉林大学<br>2021年11月6日，英雄联盟全球总决赛打响，中国电子竞技战队Edward Gaming（EDG）以3:2力克韩国强敌DWG KIA（DK）战队，历史上首次夺得全球总冠军。一时间全网沸腾，大家纷纷在社交平台上直呼“edgnb”。现给定一段文本，请编写程序识别出连续的k个“edgnb”组成的字符串在该文本中出现了多少次。</p><p>输入格式:<br>第一行为1个整数T，表示数据组数。对于每组数据，第一行为1个字符串，表示给定的文本。第二行为1个整数k，含义如题目所述。（1≤T≤10。各组数据给定的字符串长度之和不超过10<br>5<br> ，且字符串中只包含a-z的小写字母。k≥1且k×5小于给定字符串长度）。</p><p>输出格式:<br>对于每组数据输出一行，为1个整数，表示所求的出现次数。</p><p>输入样例:<br>5<br>xyzedgnbabcedgnb<br>1<br>xyzedgnbabcedgnb<br>2<br>defedgnbedgnbxyz<br>2<br>edgnbedgnbedgnb<br>2<br>fxedgnbedgnbedgnbedgnbmem<br>3</p><p>输出样例:<br>2<br>0<br>1<br>2<br>2</p><p>数据规模:<br>测试点0：5≤T≤10，400≤T个字符串长度之和≤500，k&#x3D;1<br>测试点1：5≤T≤10，400≤T个字符串长度之和≤500，k≥1<br>测试点2：5≤T≤10，4000≤T个字符串长度之和≤5000，k≥1<br>测试点3：1≤T≤3，90000≤T个字符串长度之和≤100000，k≥1<br>测试点4：1≤T≤3，90000≤T个字符串长度之和≤100000，k≥1</p><p>代码长度限制<br>16 KB<br>时间限制<br>400 ms<br>内存限制<br>64 MB</p><hr><p>这个题的实质是从字符串中匹配符合的字符串，而且不单单是匹配单个edgnb出现次数，而是可能变长的。只要理解了这一点，接下来只要实现经典的kmp就成功了。</p><p>你问kmp是什么？我也不知道捏（毕竟过去一年力</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这次上机实验主要考察了对链表、字符串匹配和操作，思考量肯定是有的，不过这里面很多东西我确实还是没有理解啊，纵使当时写下来了，现在也全忘了，hhh</p>]]></content>
      
      
      <categories>
          
          <category> 吉林大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JLU </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JLU】 吉林大学校园网上网攻略汇总与补充</title>
      <link href="/posts/c3a196a9.html"/>
      <url>/posts/c3a196a9.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如题，陆爻齐为了汇集一下觉得比较有用的 JLU 校园网相关的资源，同时对于一些比较重要但比较少被提及的地方做点补充而写本文。</p><p>希望能对吉林大学（也许）的各位有所帮助</p><p>如果陆爻齐再次重装系统，或许也用的到罢：）</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="现有攻略推介"><a href="#现有攻略推介" class="headerlink" title="现有攻略推介"></a>现有攻略推介</h2><h3 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h3><ul><li><h4 id="官方老文"><a href="#官方老文" class="headerlink" title="官方老文"></a>官方老文</h4></li></ul><p>如果你会搜索下“吉林大学 校园网”，那么第一个网址大概就是这个 <a href="https://nic.jlu.edu.cn/info/1025/1095.htm">吉林大学校园网入网指南</a> </p><p>实际上，这篇文章有点老，JLU校园网手机无线网络配置也得看 <a href="https://nic.jlu.edu.cn/info/1025/1988.htm">JLU.WIFI使用指南</a> ，而且其它配电脑部分篇幅较为冗余，反正我是太长，不看！！！（笑</p><ul><li><h4 id="官方新文"><a href="#官方新文" class="headerlink" title="官方新文"></a>官方新文</h4></li></ul><p>所以，可以参考这个应该比较难搜出来的 <a href="https://nic.jlu.edu.cn/info/1025/1718.htm">校园网入网指南（新生版）</a></p><p>相较而言，简洁不少（果然还是新生版攻略好用<br><a id="line_turation"></a></p><ul><li><h4 id="有线网"><a href="#有线网" class="headerlink" title="有线网"></a>有线网</h4></li></ul><p>而如果想配置有线网，那么可以参考 <a href="https://nic.jlu.edu.cn/info/1113/1727.htm">有线网络配置及登陆方法</a></p><p>PS：<del>登录</del> VS 登陆</p><p>如果你是小白建议看看下面的<a href="#line">补充</a></p><ul><li><h4 id="官方的常见问题与解答"><a href="#官方的常见问题与解答" class="headerlink" title="官方的常见问题与解答"></a>官方的常见问题与解答</h4></li></ul><p>有点老，仅供参考罢<br><a href="https://nic.jlu.edu.cn/cjwd/wxwlxgywjd_y_.htm">无线网络相关业务解答（一）</a></p><p><a href="https://nic.jlu.edu.cn/cjwd/wxwlxgywjd_e_.htm">无线网络相关业务解答（二）</a></p><p><a href="https://nic.jlu.edu.cn/cjwd/wlcjwtjd.htm">网络常见问题解答</a></p><p>里面有官方24小时答疑电话，这个应该最有用罢</p><h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><p>嘛，有个叫 JLUBOOK 的组织做了些攻略，2022年的，算比较新啦，在此贴贴</p><p><a href="https://www.bilibili.com/video/BV1te4y1f7Xv/?share_source=copy_web&vd_source=1423ba210b588816e333b03a9060d0b0">吉林大学新生必备指南讲解4.2（Windows＆Android校园网入网以及邮箱获取教程）</a></p><p><a href="https://www.bilibili.com/video/BV1cP411V7Bt/?share_source=copy_web&vd_source=1423ba210b588816e333b03a9060d0b0">吉林大学新生必备指南讲解4.3（Mac开通校园网）</a></p><p><a href="https://www.bilibili.com/video/BV1eW4y1t7UF/?share_source=copy_web&vd_source=1423ba210b588816e333b03a9060d0b0">吉林大学新生必备指南讲解4.4（Apple设备连接校园网）</a></p><h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><h3 id="关于收费"><a href="#关于收费" class="headerlink" title="关于收费"></a>关于收费</h3><p>目前JLU  校园网是不限流量 20r&#x2F;月，一次校园网需要充满 100 开户（如果没记错的），免费月为 2 月和 7 月，详细可以看下图</p><p><img src="https://img2024.cnblogs.com/blog/3207177/202406/3207177-20240609194449184-142657213.png" alt="校园网常见问题"></p><p>也就是说，8 月前其实可以推掉校园网省 20r，下学期再开通，这样就省了一个月，但要花点时间重新配置（笑</p><h3 id="充值"><a href="#充值" class="headerlink" title="充值"></a>充值</h3><p>如果没记错，月末或月初有几天不能充值续费，在乎这方面的同学建议早充早用，等发现用不了再充可能得难受几天。</p><h3 id="使用体验"><a href="#使用体验" class="headerlink" title="使用体验"></a>使用体验</h3><ul><li><p>范围上，基本覆盖全校区，但在人多的时候很不太好用，比如饭点的日新楼，还有像基础园澡堂这样就是没覆盖的（别问我怎么知道的</p></li><li><p>速度上无线基本在 8m 到几十m之间，但有线网极快，平时就几百m，状态好的时候可以上 1g，所以建议经常下载什么的，能配有线尽量配</p></li><li><p>稳定性上，PC的无线网络时不时会自己中断，要手动重连；而且有时明明关掉了，没有启动，又说正在运行而无法打开；笔记本电脑合上后也会自动断开，无法忍受的同学可以看看 <a href="#other_ser">其他客户端</a>，陆爻齐未来也打算写个新的客户端来使用，不过可能到时也用不着了</p></li></ul><p><a id="line"></a></p><h3 id="有线网配置补充与全流程参考"><a href="#有线网配置补充与全流程参考" class="headerlink" title="有线网配置补充与全流程参考"></a>有线网配置补充与全流程参考</h3><p>有线网和无线网不同的是，光靠文字或视频攻略可能无法配置，还需要购买硬件，比如网线、转换器什么的</p><p>1.首先，要确认自己的设备是否有网线接口，类似下图，如果有，请继续下面；如果没有却仍考虑有线网，可先查询自己设备有无 type-c 接口以及网卡是否支持通过 type-c 接口上网（近几年电脑大多支持），然后购买相关拓展坞（比如有 type-c 转网口的），再继续 </p><p><img src="https://img2024.cnblogs.com/blog/3207177/202406/3207177-20240609200724266-1733097933.png" alt="网口示例"></p><p>2.然后要确认好宿舍的路由器在哪里，自己桌子附近有无前辈留下的网线<del>遗产</del>，确认其是否连接到路由器上，如果有网线且连接看似正常，那么就回到 <a href="#line_turation">上面</a> 参照攻略尝试连接</p><p>3.如果连接失败，且在电话咨询学校网络中心后仍无法解决，建议更换网线，百兆够用，千兆更流畅，类别不重要。</p><p><a id="other_ser"></a></p><h3 id="其他客户端"><a href="#其他客户端" class="headerlink" title="其他客户端"></a>其他客户端</h3><p>在GitHub，你吉老学长们做了不同版本开源的客户端，虽然可能有点老，不过你吉的客户端应该更老，该兴趣的同学可以自行下载体验</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>没啥好总结，有用就行：）</p>]]></content>
      
      
      
        <tags>
            
            <tag> JLU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【方法论】再论如何读书——对过去阅读的总结与对未来的要求</title>
      <link href="/posts/bf4fcb62.html"/>
      <url>/posts/bf4fcb62.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>陆爻齐在以前曾花心思读了不少关于“如何阅读”这个主题的书，有时对某条表示“顿悟”，然后做了几次就往在一边，什么笔记法啊，阅读法啊，大多十分的繁杂，连把整个流程走完一边都十分繁琐无聊，坚持下去于陆爻齐而言就是天方夜谭。在偶然瞥见某篇文章时，突然又有所顿悟，希望能把这个简单的思维贯彻执行，也在此作下记录。</p><h1 id="知以阅读，行以实践"><a href="#知以阅读，行以实践" class="headerlink" title="知以阅读，行以实践"></a>知以阅读，行以实践</h1><h2 id="知行如何合一"><a href="#知行如何合一" class="headerlink" title="知行如何合一"></a>知行如何合一</h2><p>先摆结论，陆爻齐提倡“知行合一”，可以大致分两个场景</p><ul><li>带有强烈目的性的情况，也就是为了高效地获取知识而阅读，那么应该是“边做边读”最为有效，即一边阅读知识，一边将所读所学付诸实践。合适的时候，可以辅以康奈尔笔记这种“笔记”方法帮助记忆巩固。这种情景往往出现在大学牲速成期末考试中，或者狂热地为了实现某个目的而学习的过程中。</li><li>然后就是其它部分，也就是几乎没有目的性，平时随意阅读的时候，这种情形陆爻齐不推荐将阅读所得以“笔记”方式记录，但通过博客、视频等方式将所学输出是推荐的。</li><li>书是为人而看的。为了看书而看书，容易只会享受知识流淌过脑子的感觉。看书只是为了找到与自己共鸣的部分，即使一本书只有一句有用，那便足矣，充分吸收这句带来的益处便好。</li></ul><h2 id="脱离实践，黄金屋亦会蒙尘，颜如玉也会色衰"><a href="#脱离实践，黄金屋亦会蒙尘，颜如玉也会色衰" class="headerlink" title="脱离实践，黄金屋亦会蒙尘，颜如玉也会色衰"></a>脱离实践，黄金屋亦会蒙尘，颜如玉也会色衰</h2><p>这里说说陆爻齐的理由吧。</p><p>上大学来，陆爻齐曾尝试过自主泛读所谓的“杂书”，也做了些所谓“笔记”，但现在回顾，所写所记，全部忘在角落蒙尘，若非今日书写此文，定会继续被遗忘。即使未来真的遇到能用里面的知识解决问题，陆爻齐也一定会几乎从零开始。</p><p>与之相对，陆爻齐为了解决重装系统、电脑故障、自己的项目维护问题甚至期末考试等，而学到的东西即使有段时间未碰，也深深印刻在脑内。</p><p>陆爻齐也并非没有尝试解决几乎无目的性学习这种情况的问题，当前想到的便是采用“输出”来实现“知行合一”，比如写博客、做视频。这也正是陆爻齐写<a href="https://www.cnblogs.com/luyaoqi/p/17968076">重装系统记录</a>、<a href="https://www.cnblogs.com/luyaoqi/p/18172286">Git报错解决</a>等文章的用意。写完博客，这些知识也就在我试图输出的时候，通过整理很好地吸收了。</p><p>陆爻齐在想，或许是所谓阅读得来的知识对人脑而言还是过于抽象了。简单的说，平时使用没用过的东西，比起把“使用说明”背下来，直接上手使用实践或许带来的印象更为深刻吧。</p><h2 id="细谈阅读过程"><a href="#细谈阅读过程" class="headerlink" title="细谈阅读过程"></a>细谈阅读过程</h2><p>除了应试需要将规定内容几乎一字不落地吸收外，其他情况下可按几步走</p><ol><li>看目录，锁定感兴趣&#x2F;最需要的部分</li><li>浏览（1）锁定的部分，适当的时候略览与所需也匹配的部分</li><li>实践，输出所学内容</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>综上，除了带有强烈目的性，容易达成“知行合一”情景的阅读场景，其余场景也要尽量达成“知行合一”。谨以此文，献给为曾经如何读书而迷茫的陆爻齐，让他今后不再烦恼于此</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
            <tag> 方法论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Git Error】error Invalid path 报错，clone 失败，文件夹空白问题解决</title>
      <link href="/posts/7f94f797.html"/>
      <url>/posts/7f94f797.html</url>
      
        <content type="html"><![CDATA[<h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>可能是在 clone 某仓库后出现形如下面报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/*.git</span><br><span class="line">Cloning into &#x27;*&#x27;...</span><br><span class="line">remote: Enumerating objects: *, done.</span><br><span class="line">remote: Counting objects: 100% (*/*), done.</span><br><span class="line">remote: Compressing objects: 100% (*/*), done.</span><br><span class="line">remote: Total * (delta *), reused * (delta *), pack-reused *</span><br><span class="line">Receiving objects: 100% (*/*), * MiB | 8.40 MiB/s, done.</span><br><span class="line">Resolving deltas: 100% (*/*), done.</span><br><span class="line">error: invalid path &#x27;*.md&#x27;</span><br><span class="line">fatal: unable to checkout working tree</span><br><span class="line">warning: Clone succeeded, but checkout failed.</span><br><span class="line">You can inspect what was checked out with &#x27;git status&#x27;</span><br><span class="line">and retry with &#x27;git restore --source=HEAD :/&#x27;</span><br></pre></td></tr></table></figure><p>而且仓库里除了.git文件夹就“一尘不染”。</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>在仓库的文件夹中打开终端，并输入<br><code>git config core.protectNTFS false</code><br>大致意思是关闭文件保护之类的，然后切换为刚刚的分支，如<br><code>git checkout main</code><br>然后文件夹就正常咯</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>一个简单记录，并非笔者原创的方法，只是想以自己的方式记录该方法。</p><h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h1><p><a href="https://www.cnblogs.com/zackary/p/13702643.html">https://www.cnblogs.com/zackary/p/13702643.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【方法论】如何读论文 李沐视频笔记</title>
      <link href="/posts/b0ef00bb.html"/>
      <url>/posts/b0ef00bb.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>内容不多，但姑且记下来加深印象好了</p><p>[视频链接]（<a href="https://www.bilibili.com/video/BV1H44y1t75x/?spm_id_from=333.788&vd_source=0e55873fcd6a0d01839a7f7f37c36254%EF%BC%89">https://www.bilibili.com/video/BV1H44y1t75x/?spm_id_from=333.788&amp;vd_source=0e55873fcd6a0d01839a7f7f37c36254）</a></p><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><h2 id="总概"><a href="#总概" class="headerlink" title="总概"></a>总概</h2><p>读论文的重点在于筛选出适合自己的论文，通过三遍阅读来找出并吸收</p><p>论文大致分为<br>1、标题 title<br>2、摘要 abstract<br>3、介绍 introduction<br>4、方法 method<br>5、实验 exp<br>6、结论 conclusion</p><h2 id="第一遍阅读"><a href="#第一遍阅读" class="headerlink" title="第一遍阅读"></a>第一遍阅读</h2><p>只看标题、摘要和结论，从中判断论文的方向是否是自己所需</p><h2 id="第二遍阅读"><a href="#第二遍阅读" class="headerlink" title="第二遍阅读"></a>第二遍阅读</h2><p>看介绍和方法、实验中的图表，搞清图表每一个指标的含义，是这个方法多好，比别人厉害多少什么的</p><h2 id="第三遍阅读"><a href="#第三遍阅读" class="headerlink" title="第三遍阅读"></a>第三遍阅读</h2><p>全面仔细阅读，搞清楚每一步的过程、目的，其中的公式、证明可忽略，目的是跟着作者的思路复现一次论文</p><p>结束阅读后脑子里能大致复现内容，这就是一次阅读。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
            <tag> 方法论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【深度学习】一站式解决配置图神经网络 GNN 环境各种问题——以配置 HopGNN 运行环境为例记录</title>
      <link href="/posts/47a73986.html"/>
      <url>/posts/47a73986.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a id="section1"></a><br>当这篇文章发布时，估计成品论文已经出来了，不过本文的目的是以一个 python 菜鸟和科研新手的角度，记录配置环境时发现和解决问题的记录，希望能帮到未来的自己和遇到类似报错的你。</p><p>本文大致分为三个板块，第一个 <a href="#section1">前言</a>，第二个是 <a href="#section2">配置环境的具体记录（含各种报错）</a>，第三个则是 <a href="#section3">记录我总结的配置相关环境的办法</a>。</p><p><strong>注意</strong><br>陆爻齐在后续配置其它环境时也碰到了其它的问题，相关内容会记录到 <a href="#section4">补充内容</a>。</p><h1 id="配置环境的具体记录"><a href="#配置环境的具体记录" class="headerlink" title="配置环境的具体记录"></a>配置环境的具体记录</h1><p><a id="section2"></a></p><h2 id="官方提示与配置设备"><a href="#官方提示与配置设备" class="headerlink" title="官方提示与配置设备"></a>官方提示与配置设备</h2><p>配环境，首先肯定先看官方怎么说<br><a href="https://github.com/JC-202/HopGNN">HopGNN GitHub地址</a><br>无requirement，其中的Dependencies中内容是</p><ul><li>python 3.7.3</li><li>pytorch 1.10.1</li><li>dgl 0.6.0</li><li>ogb 1.2.3</li><li>torch-geometric 2.0.3</li></ul><p>而程序通过bash启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash scripts/citation.sh</span><br><span class="line">bash scripts/heterophily.sh</span><br><span class="line">bash scripts/large.sh </span><br></pre></td></tr></table></figure><p>笔者采用anaconda3来配置环境，由于设备配有独立显卡，故决定下载cuda利用上gpu。</p><h2 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h2><h3 id="bash配置"><a href="#bash配置" class="headerlink" title="bash配置"></a>bash配置</h3><p>第一个问题是安装的bash识别不到conda，而window的cmd可以，报错如下<br><code>bash: conda: command not found</code><br>故参考文章CSDN博客顺利解决：<a href="https://blog.csdn.net/Vertira/article/details/136271584">windows 中， bash: conda: command not found（已解决）</a></p><p>但是，虽然能识别 conda 指令，却不能在打开终端后直接运行 conda acivate 命令，必须用 source activate 环境来启动，后面才能直接激活环境。不过并没有太大影响，故按下不表。</p><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>conda python3.7.3<br>pytorch 1.10.1在torch官网下<br>dgl，ogb，和torch-geometric都在aconda搜索下载<br>均为对应版本</p><p>然后运行<br>bash scripts&#x2F;citation.sh<br>提示缺少模块einops，conda install后，发现版本0.7.0不匹配，故降级0.6.0<br>然后提示缺少模块scikit-learn，conda install 1.0.2解决<br>接着提示缺少模块pandas，conda install 1.3.5<br>提示缺少tqdm，conda install 4.64.1</p><p>现在不缺模块了，报错如下</p><details> <summary>ErrorReport</summary>$ bash scripts/citation.shTraceback (most recent call last):  File "train.py", line 8, in <module>    from datasets.dataloader import load_data  File "D:\Code\HopGNN\datasets\dataloader.py", line 5, in <module>    from ogb.nodeproppred import PygNodePropPredDataset  File "D:\anaconda3\envs\hopgnn\lib\site-packages\ogb\nodeproppred\__init__.py", line 10, in <module>    from .dataset_dgl import DglNodePropPredDataset  File "D:\anaconda3\envs\hopgnn\lib\site-packages\ogb\nodeproppred\dataset_dgl.py", line 6, in <module>    from dgl.data.utils import load_graphs, save_graphs, Subset  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\__init__.py", line 13, in <module>    from .backend import load_backend, backend_name  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\backend\__init__.py", line 95, in <module>    load_backend(get_preferred_backend())  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\backend\__init__.py", line 41, in load_backend    from .._ffi.base import load_tensor_adapter # imports DGL C library  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\_ffi\base.py", line 44, in <module>    _LIB, _LIB_NAME, _DIR_NAME = _load_lib()  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\_ffi\base.py", line 33, in _load_lib    lib_path = libinfo.find_lib_path()  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\_ffi\libinfo.py", line 83, in find_lib_path    raise RuntimeError(message)RuntimeError: Cannot find the files.List of candidates:D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\libdgl.dllD:\anaconda3\envs\hopgnn\lib\build\libdgl.dllD:\anaconda3\envs\hopgnn\lib\build\Release\libdgl.dllD:\anaconda3\envs\hopgnn\lib\lib\libdgl.dllD:\anaconda3\envs\hopgnn\libdgl.dllD:\anaconda3\envs\hopgnn\lib\site-packages\dgl\dgl.dllD:\anaconda3\envs\hopgnn\lib\build\dgl.dllD:\anaconda3\envs\hopgnn\lib\build\Release\dgl.dllD:\anaconda3\envs\hopgnn\lib\lib\dgl.dllD:\anaconda3\envs\hopgnn\dgl.dllTraceback (most recent call last):  File "train.py", line 8, in <module>    from datasets.dataloader import load_data  File "D:\Code\HopGNN\datasets\dataloader.py", line 5, in <module>    from ogb.nodeproppred import PygNodePropPredDataset  File "D:\anaconda3\envs\hopgnn\lib\site-packages\ogb\nodeproppred\__init__.py", line 10, in <module>    from .dataset_dgl import DglNodePropPredDataset  File "D:\anaconda3\envs\hopgnn\lib\site-packages\ogb\nodeproppred\dataset_dgl.py", line 6, in <module>    from dgl.data.utils import load_graphs, save_graphs, Subset  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\__init__.py", line 13, in <module>    from .backend import load_backend, backend_name  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\backend\__init__.py", line 95, in <module>    load_backend(get_preferred_backend())  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\backend\__init__.py", line 41, in load_backend    from .._ffi.base import load_tensor_adapter # imports DGL C library  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\_ffi\base.py", line 44, in <module>    _LIB, _LIB_NAME, _DIR_NAME = _load_lib()  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\_ffi\base.py", line 33, in _load_lib    lib_path = libinfo.find_lib_path()  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\_ffi\libinfo.py", line 83, in find_lib_path    raise RuntimeError(message)RuntimeError: Cannot find the files.List of candidates:D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\libdgl.dllD:\anaconda3\envs\hopgnn\lib\build\libdgl.dllD:\anaconda3\envs\hopgnn\lib\build\Release\libdgl.dllD:\anaconda3\envs\hopgnn\lib\lib\libdgl.dllD:\anaconda3\envs\hopgnn\libdgl.dllD:\anaconda3\envs\hopgnn\lib\site-packages\dgl\dgl.dllD:\anaconda3\envs\hopgnn\lib\build\dgl.dllD:\anaconda3\envs\hopgnn\lib\build\Release\dgl.dllD:\anaconda3\envs\hopgnn\lib\lib\dgl.dllD:\anaconda3\envs\hopgnn\dgl.dllTraceback (most recent call last):  File "train.py", line 8, in <module>    from datasets.dataloader import load_data  File "D:\Code\HopGNN\datasets\dataloader.py", line 5, in <module>    from ogb.nodeproppred import PygNodePropPredDataset  File "D:\anaconda3\envs\hopgnn\lib\site-packages\ogb\nodeproppred\__init__.py", line 10, in <module>    from .dataset_dgl import DglNodePropPredDataset  File "D:\anaconda3\envs\hopgnn\lib\site-packages\ogb\nodeproppred\dataset_dgl.py", line 6, in <module>    from dgl.data.utils import load_graphs, save_graphs, Subset  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\__init__.py", line 13, in <module>    from .backend import load_backend, backend_name  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\backend\__init__.py", line 95, in <module>    load_backend(get_preferred_backend())  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\backend\__init__.py", line 41, in load_backend    from .._ffi.base import load_tensor_adapter # imports DGL C library  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\_ffi\base.py", line 44, in <module>    _LIB, _LIB_NAME, _DIR_NAME = _load_lib()  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\_ffi\base.py", line 33, in _load_lib    lib_path = libinfo.find_lib_path()  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\_ffi\libinfo.py", line 83, in find_lib_path    raise RuntimeError(message)RuntimeError: Cannot find the files.List of candidates:D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\libdgl.dllD:\anaconda3\envs\hopgnn\lib\build\libdgl.dllD:\anaconda3\envs\hopgnn\lib\build\Release\libdgl.dllD:\anaconda3\envs\hopgnn\lib\lib\libdgl.dllD:\anaconda3\envs\hopgnn\libdgl.dllD:\anaconda3\envs\hopgnn\lib\site-packages\dgl\dgl.dllD:\anaconda3\envs\hopgnn\lib\build\dgl.dllD:\anaconda3\envs\hopgnn\lib\build\Release\dgl.dllD:\anaconda3\envs\hopgnn\lib\lib\dgl.dllD:\anaconda3\envs\hopgnn\dgl.dll</details>经分析，推测为dgl版本不匹配，更新为最新版仍不匹配，经搜索发现可发现解决方案无用<p>所以，我将除torch外的部分包都卸载，用pip重新安装最新版（<del>虽然犯了conda和pip混用的忌，但木得办法</del>）<br>pip将torch换为1.13，ogb换为1.3.6 dgl换为2.0.0 torch-geometric换为2.3.1<br>然后出现了新的报错</p><details><summary>ErrorReport</summary>$ bash scripts/citation.shTraceback (most recent call last):  File "train.py", line 8, in <module>    from datasets.dataloader import load_data  File "D:\Code\HopGNN\datasets\dataloader.py", line 8, in <module>    from dgl.data import *  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\__init__.py", line 16, in <module>    from . import (  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\dataloading\__init__.py", line 13, in <module>    from .dataloader import *  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\dataloading\dataloader.py", line 27, in <module>    from ..distributed import DistGraph  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\distributed\__init__.py", line 5, in <module>    from .dist_graph import DistGraph, DistGraphServer, edge_split, node_split  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\distributed\dist_graph.py", line 37, in <module>    from .partition import (  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\distributed\partition.py", line 15, in <module>    from ..data.utils import load_graphs, load_tensors, save_graphs, save_tensors  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\data\__init__.py", line 7, in <module>    from . import citation_graph as citegrh  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\data\citation_graph.py", line 20, in <module>    from .dgl_dataset import DGLBuiltinDataset  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\data\dgl_dataset.py", line 12, in <module>    from .utils import download, extract_archive, get_download_dir, makedirs  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\data\utils.py", line 14, in <module>    import requests  File "D:\anaconda3\envs\hopgnn\lib\site-packages\requests\__init__.py", line 43, in <module>    import urllib3  File "D:\anaconda3\envs\hopgnn\lib\site-packages\urllib3\__init__.py", line 42, in <module>    "urllib3 v2.0 only supports OpenSSL 1.1.1+, currently "ImportError: urllib3 v2.0 only supports OpenSSL 1.1.1+, currently the 'ssl' module is compiled with 'OpenSSL 1.1.0i  14 Aug 2018'. See: https://github.com/urllib3/urllib3/issues/2168Traceback (most recent call last):  File "train.py", line 8, in <module>    from datasets.dataloader import load_data  File "D:\Code\HopGNN\datasets\dataloader.py", line 8, in <module>    from dgl.data import *  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\__init__.py", line 16, in <module>    from . import (  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\dataloading\__init__.py", line 13, in <module>    from .dataloader import *  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\dataloading\dataloader.py", line 27, in <module>    from ..distributed import DistGraph  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\distributed\__init__.py", line 5, in <module>    from .dist_graph import DistGraph, DistGraphServer, edge_split, node_split  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\distributed\dist_graph.py", line 37, in <module>    from .partition import (  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\distributed\partition.py", line 15, in <module>    from ..data.utils import load_graphs, load_tensors, save_graphs, save_tensors  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\data\__init__.py", line 7, in <module>    from . import citation_graph as citegrh  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\data\citation_graph.py", line 20, in <module>    from .dgl_dataset import DGLBuiltinDataset  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\data\dgl_dataset.py", line 12, in <module>    from .utils import download, extract_archive, get_download_dir, makedirs  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\data\utils.py", line 14, in <module>    import requests  File "D:\anaconda3\envs\hopgnn\lib\site-packages\requests\__init__.py", line 43, in <module>    import urllib3  File "D:\anaconda3\envs\hopgnn\lib\site-packages\urllib3\__init__.py", line 42, in <module>    "urllib3 v2.0 only supports OpenSSL 1.1.1+, currently "ImportError: urllib3 v2.0 only supports OpenSSL 1.1.1+, currently the 'ssl' module is compiled with 'OpenSSL 1.1.0i  14 Aug 2018'. See: https://github.com/urllib3/urllib3/issues/2168Traceback (most recent call last):  File "train.py", line 8, in <module>    from datasets.dataloader import load_data  File "D:\Code\HopGNN\datasets\dataloader.py", line 8, in <module>    from dgl.data import *  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\__init__.py", line 16, in <module>    from . import (  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\dataloading\__init__.py", line 13, in <module>    from .dataloader import *  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\dataloading\dataloader.py", line 27, in <module>    from ..distributed import DistGraph  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\distributed\__init__.py", line 5, in <module>    from .dist_graph import DistGraph, DistGraphServer, edge_split, node_split  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\distributed\dist_graph.py", line 37, in <module>    from .partition import (  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\distributed\partition.py", line 15, in <module>    from ..data.utils import load_graphs, load_tensors, save_graphs, save_tensors  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\data\__init__.py", line 7, in <module>    from . import citation_graph as citegrh  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\data\citation_graph.py", line 20, in <module>    from .dgl_dataset import DGLBuiltinDataset  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\data\dgl_dataset.py", line 12, in <module>    from .utils import download, extract_archive, get_download_dir, makedirs  File "D:\anaconda3\envs\hopgnn\lib\site-packages\dgl\data\utils.py", line 14, in <module>    import requests  File "D:\anaconda3\envs\hopgnn\lib\site-packages\requests\__init__.py", line 43, in <module>    import urllib3  File "D:\anaconda3\envs\hopgnn\lib\site-packages\urllib3\__init__.py", line 42, in <module>    "urllib3 v2.0 only supports OpenSSL 1.1.1+, currently "ImportError: urllib3 v2.0 only supports OpenSSL 1.1.1+, currently the 'ssl' module is compiled with 'OpenSSL 1.1.0i  14 Aug 2018'. See: https://github.com/urllib3/urllib3/issues/2168</details><p>经查找，执行pip install urllib3&#x3D;&#x3D;1.26.15，解决<br>然后又出现<code>ModuleNotFoundError: No module named &#39;torch_sparse&#39;</code>，故pip安装torchsparse<br><code>ModuleNotFoundError: No module named &#39;torch_scatter&#39;</code> 故pip安装torchscatter<br><code>ModuleNotFoundError: No module named &#39;google_drive_downloader&#39;</code> 故pip安装</p><p>再次运行，这次报错<code>AssertionError: Torch not compiled with CUDA enabled</code><br>然后发现torch版本不对，发现下的是cpu版本，故删除重下，pytroch1.13.1 cuda11.7 cudacnn8.9.7参照适配表应不冲突</p><p>于是在配置正确的torch sca什么的之类后，成功跑通前两个，但第三个出现错误如下<br><code>ValueError: Cannot load file containing pickled data when allow_pickle=False</code></p><p>经把对应地方 allow pickle变true后，错误变成了<br><code>OSError Failed to interpret file as a pickle</code></p><p>经查询没有什么可用的办法，于是接下来八小时尝试了配置与要求环境一摸一样的环境，配置python版本更低的环境（参照一些github issue的回答，回退版本可能解决），但还是无果</p><p>中间出现报错<br><code>RuntimeError: Not compiled with CUDA support</code><br>参考博客解决<a href="https://blog.csdn.net/qq_44501429/article/details/129178459">RuntimeError: Not compiled with CUDA support此类错误解决方案</a></p><p>在经过学长解放思想，指点后，秉承能跑起来的就是好环境的原则，将python3.7更为python3.8，如此，便能下载更新的pytorch2.*版本。</p><p>但仍没有突破，于是查到之前的错误可能是下载文件不完整，于是删掉库重新clone并下载文件后，又出现新的错误报告<br><code>AttributeError: module numpy has no attribute int</code><br>参考文章 <a href="https://blog.csdn.net/weixin_46669612/article/details/129624331">AttributeError: module numpy has no attribute int .报错解决方案</a><br>经查询，numpy回退1.22.2后解决，这下彻底解决</p><p>同时又用之前的python3.7试着跑第三条，仍然报错，说明还是要结合python3.8以上版本的这个环境</p><h1 id="配置环境参考流程（运用Nvidia-GPU，pytorch、pyg的环境）"><a href="#配置环境参考流程（运用Nvidia-GPU，pytorch、pyg的环境）" class="headerlink" title="配置环境参考流程（运用Nvidia GPU，pytorch、pyg的环境）"></a>配置环境参考流程（运用Nvidia GPU，pytorch、pyg的环境）</h1><p><a id="section3"></a></p><p>首先是确认，设备有 nvidia 显卡</p><p>然后查看是否满足配置 CUDA 的环境，nvidia 控制面板-系统信息-组件中的 3d 设置右侧产品名称的右侧有 CUDA 后面一串数字，这就是自己电脑支持的 CUDA 版本，一般选择配套的，作者有时候会选择略低于这个的版本，不能高于。具体情况视情况而定。</p><p>接着结合自己的需求和 <a href="https://blog.csdn.net/u011489887/article/details/135250561">pytorch与cuda版本对应关系汇总</a> 来确定要下载的CUDA版本和pytorch版本</p><p>再到 <a href="https://developer.nvidia.com/cuda-toolkit-archive">CUDA官网</a> 下载cuda版本，安装用自定义，一般只用下CUDA即可，安装后配置环境变量并测试。此处安装程序开始选择的文件夹是临时安装文件夹，安装完成后会自行删除。</p><p>再到下载cuDNN，根据对应版本在 <a href="https://developer.nvidia.com/rdp/cudnn-archive">cuDNN官网</a> 下载即可（第一次下载需要注册账号），下载后将文件夹的bin，include，lib三个文件夹“替换”（直接拷贝即可）CUDA安装位置内的同名文件夹，再配置对应环境变量后验证</p><p>下面到 <a href="https://pytorch.org/get-started/previous-versions/#conda">pytorch官网</a> 下载对应 torch 版本，也可以自行在这个<a href="http://download.pytorch.org/whl/torch_stable.html">网站</a>下载（笔者偏向使用后者）</p><p>最后，如果要用到 pyg，就可以参考自己的 pytorch 版本和 CUDA 版本，在 <a href="https://data.pyg.org/whl/">该网站</a> 按需下载库，然后直接 pip install torch-geometric。（应该 pyg 下最新就行）<br>PS：cp38 代表适配 python 3.8</p><p>对于多个 CUDA 版本的管理，笔者参考 <a href="https://blog.csdn.net/qq_50677040/article/details/132131346">这篇博客</a></p><p>参考博客如下，后面再用我自己的话做个综合<br><a href="https://blog.csdn.net/by99031433/article/details/127721199">pytorch1.13安装</a><br><a href="https://blog.csdn.net/shdabai/article/details/131248257">window11系统CUDA、cuDNN 安装以及环境变量配置</a></p><h1 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h1><p><a id="section4"></a></p><h2 id="dgl"><a href="#dgl" class="headerlink" title="dgl"></a>dgl</h2><p>dgl 也分 cpu 和 gpu 版本，可以到 <a href="https://www.dgl.ai/pages/start.html">官网</a> 找到对应的下载方式，当然也有类似 torch 的离线下载方式，在这个 <a href="https://data.dgl.ai/wheels/repo.html">网站</a>。</p><p><strong>注意</strong>，该网站对 cuda 的 dgl 版本较为落后，最新不过 1.0.0，想要更新的 cuda 版本需要略微改动网址，该网址为 <a href="https://data.dgl.ai/wheels/repo.html">https://data.dgl.ai/wheels/repo.html</a> ，只要改成 <a href="https://data.dgl.ai/wheels/cu116/repo.html">https://data.dgl.ai/wheels/cu116/repo.html</a> 就能获取到 1.0.0 以上的 cuda11.6 的 dgl，你学废了吗：）</p><p>dgl 的数据集会放在根目录的 .dgl 文件夹下，linux 系统中，可输入 <code>cd ~</code>进入根目录，然后通过 <code>ls -al</code> 来详细输出每个文件找到文件夹，接着可通过 <code>cd .dgl</code> 进入数据集文件夹，可以自行寻找数据集放入其中使用。</p><h2 id="报错-Device-API-gpu-is-not-enabled-Please-install-the-cuda-version-of-dgl"><a href="#报错-Device-API-gpu-is-not-enabled-Please-install-the-cuda-version-of-dgl" class="headerlink" title="报错 Device API gpu is not enabled. Please install the cuda version of dgl"></a>报错 Device API gpu is not enabled. Please install the cuda version of dgl</h2><p>可以尝试回退dgl对应的cuda版本，参照<a href="https://zhuanlan.zhihu.com/p/434494642">该文章</a>cuda11.3装 dgl-cuda113 报错，可以装 dgl-cuda110 试试</p><h2 id="报错-RuntimeError-Could-not-infer-dtype-of-numpy-int64"><a href="#报错-RuntimeError-Could-not-infer-dtype-of-numpy-int64" class="headerlink" title="报错 RuntimeError: Could not infer dtype of numpy.int64"></a>报错 RuntimeError: Could not infer dtype of numpy.int64</h2><p>如果最后一条语句来自 dgl，很可能是因为 numpy 版本过新，即 numpy 的 2.* 版本，回退到 1.* 的版本即可解决</p><p>参考 <a href="https://github.com/DLR-RM/stable-baselines3/issues/1960">GitHub</a></p><h2 id="报错-AttributeError-module-‘dgl-function’-has-no-attribute-‘copy-src’"><a href="#报错-AttributeError-module-‘dgl-function’-has-no-attribute-‘copy-src’" class="headerlink" title="报错 AttributeError: module ‘dgl.function’ has no attribute ‘copy_src’"></a>报错 AttributeError: module ‘dgl.function’ has no attribute ‘copy_src’</h2><p>该报错是因为 dgl 版本过新，该函数自 1.* 版本开始就删掉了，回退之前版本即可解决，比如 0.9.1</p><p>参考 <a href="https://github.com/XingyanLiu/CAME/issues/24">GitHub</a></p><h2 id="多个-CUDA-可能发生的环境-CUDA-不变化问题"><a href="#多个-CUDA-可能发生的环境-CUDA-不变化问题" class="headerlink" title="多个 CUDA 可能发生的环境 CUDA 不变化问题"></a>多个 CUDA 可能发生的环境 CUDA 不变化问题</h2><p>通过修改环境变量 Path 几个 CUDA 的顺序确实能改变在命令行窗口输入<code>nvcc -V</code>显示的版本号，不过，一旦 conda create 了一个环境，那么环境里的 CUDA 就固定了，不可更换（至少此时笔者还不知如何更换）</p><h2 id="离线-pip-安装-torch-问题报错"><a href="#离线-pip-安装-torch-问题报错" class="headerlink" title="离线 pip 安装 torch 问题报错"></a>离线 pip 安装 torch 问题报错</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WARNING: Retrying (Retry(total=4, connect=None, read=None, redirect=None, status=None)) after connection broken by &#x27;SSLError(SSLError(1, &#x27;[SSL: KRB5_S_TKT_NYV] unexpected eof while reading (_ssl.c:1091)&#x27;))&#x27;: /simple/typing-extensions/</span><br><span class="line">WARNING: Retrying (Retry(total=3, connect=None, read=None, redirect=None, status=None)) after connection broken by &#x27;SSLError(SSLError(1, &#x27;[SSL: KRB5_S_TKT_NYV] unexpected eof while reading (_ssl.c:1091)&#x27;))&#x27;: /simple/typing-extensions/</span><br><span class="line">WARNING: Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by &#x27;SSLError(SSLError(1, &#x27;[SSL: KRB5_S_TKT_NYV] unexpected eof while reading (_ssl.c:1091)&#x27;))&#x27;: /simple/typing-extensions/</span><br><span class="line">WARNING: Retrying (Retry(total=1, connect=None, read=None, redirect=None, status=None)) after connection broken by &#x27;SSLError(SSLError(1, &#x27;[SSL: KRB5_S_TKT_NYV] unexpected eof while reading (_ssl.c:1091)&#x27;))&#x27;: /simple/typing-extensions/</span><br><span class="line">WARNING: Retrying (Retry(total=0, connect=None, read=None, redirect=None, status=None)) after connection broken by &#x27;SSLError(SSLError(1, &#x27;[SSL: KRB5_S_TKT_NYV] unexpected eof while reading (_ssl.c:1091)&#x27;))&#x27;: /simple/typing-extensions/</span><br><span class="line">Could not fetch URL https://pypi.org/simple/typing-extensions/: There was a problem confirming the ssl certificate: HTTPSConnectionPool(host=&#x27;pypi.org&#x27;, port=443): Max retries exceeded with url: /simple/typing-extensions/ (Caused by SSLError(SSLError(1, &#x27;[SSL: KRB5_S_TKT_NYV] unexpected eof while reading (_ssl.c:1091)&#x27;))) - skipping</span><br><span class="line">INFO: pip is looking at multiple versions of torch to determine which version is compatible with other requirements. This could take a while.</span><br><span class="line">ERROR: Could not find a version that satisfies the requirement typing-extensions (from torch) (from versions: none)</span><br><span class="line">ERROR: No matching distribution found for typing-extensions</span><br></pre></td></tr></table></figure><p>很显然，这是网络问题，笔者在关闭梯子后问题消失</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>小小 Python 环境配得汗流浃背，本以为此前经历了 LALC 的磨练能顺利些，不曾想如此“有意思”，希望本文的记录有所帮助</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CS61A-Fall-2020】学习记录四 Lecture4中有意思的点</title>
      <link href="/posts/3308aad7.html"/>
      <url>/posts/3308aad7.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>观前提示，笔者写的代码答案放在 <a href="https://github.com/HSLix/CS61A-Fall-2020">GitHub仓库</a> 中，此处仅记录过程与心得。</p><p>此外，请最好在尝试独立完成该任务后再看本文，否则就很可能失去了体验本项目精华的机会</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h3><p>课堂中在讲授函数，如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from math import pi</span><br><span class="line"></span><br><span class="line">def area_circle(r):</span><br><span class="line">    return r * r * pi</span><br></pre></td></tr></table></figure><p>但老师提出，当r为-10时，函数不会报错，于是引入assert来检测参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from math import pi</span><br><span class="line"></span><br><span class="line">def area_circle(r):</span><br><span class="line">    # 参数应为正数</span><br><span class="line">    assert r &gt; 0, &#x27;A length must be positive&#x27;</span><br><span class="line">    return r * r * pi</span><br><span class="line">assert r &gt; 0</span><br></pre></td></tr></table></figure><p>也就是当r大于0时，无事发生；否则发生错误并提示后面的语句</p><h3 id="Higher-Order-Functions"><a href="#Higher-Order-Functions" class="headerlink" title="Higher-Order Functions"></a>Higher-Order Functions</h3><p>一开始读题并不懂，什么是高等级的函数呢？课上有个例子大致如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def make_adder(k):</span><br><span class="line">    def adder(n):</span><br><span class="line">        return n + k</span><br><span class="line">    return adder</span><br></pre></td></tr></table></figure><p>make_adder函数内又定义了个adder函数</p><p>此时，如果调用make_adder(1)，会返回一个k为1的adder函数</p><p>而如果调用make_adder(1)(2)，则相当于调用adder(2)，此时k&#x3D;1</p><p>像这样的方式可以十分方便地减少重复代码，分离函数功能，更接近DRY(Don’t Repeat Yourself)</p><h3 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h3><p>square &#x3D; lambda x: x * x<br>lambda表达式使得简单函数无需用def定义后再调用</p><p>在python中，与def相比，lambda定义出的函数有一个特点，那就是没有内在自己的名字</p><p>直接输入上式， square，会发现在内存中，square对应的函数其实是lambda，不叫square</p><p>老师表示该功能在python中不常用，但其他有的地方会很重要，故学习并记录</p><p>下面是一个稍微有些难度的例子，与lambda本身关系不大</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 寻找到f值为True的正数x</span><br><span class="line">def search(f):</span><br><span class="line">    x = 0</span><br><span class="line">    while True:</span><br><span class="line">        if f(x):</span><br><span class="line">            return x</span><br><span class="line">        x += 1</span><br><span class="line"></span><br><span class="line">def square(x):</span><br><span class="line">    return x * x</span><br><span class="line"></span><br><span class="line"># 可以求出y对应的x满足f（x） == y</span><br><span class="line">def inverse(f):</span><br><span class="line">    return lambda y: search(lambda x, f(x) == y)</span><br></pre></td></tr></table></figure><p>这里的inverse函数在初次看的时候有些令人费解，但一点点看</p><p>首先从输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sqrt = inverse(square)</span><br><span class="line">&gt;&gt;&gt; square(8)</span><br><span class="line">64</span><br><span class="line">&gt;&gt;&gt; sqrt(64)</span><br><span class="line">8</span><br></pre></td></tr></table></figure><p>可见sqrt通过inverse承担了解平方的功能</p><p>inverse中f对应的是square，而在search函数中的f对应的是lambda x, f(x) &#x3D;&#x3D; y</p><p>sqrt(64)的64则是赋给了y，然后再在search中寻找让f(x) &#x3D;&#x3D; y成立的正数x并返回</p><p>If的另一种表达<br>直接举栗子比较清晰</p><p>x &#x3D; 0<br>x &#x3D; 1 if x &gt; 0 else x &#x3D; -1<br>x &gt; 0是条件，满足该条件时执行if前，否则执行else后</p><p>当作拓展知识吧</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> CS61A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CS61A-Fall-2020】学习记录三 Lab1 题解思路分享</title>
      <link href="/posts/83eef88b.html"/>
      <url>/posts/83eef88b.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>观前提示，笔者写的代码答案放在 <a href="https://github.com/HSLix/CS61A-Fall-2020">GitHub仓库</a> 中，此处仅记录过程与心得。</p><p>此外，请最好在尝试独立完成该任务后再看本文，否则就很可能失去了体验本项目精华的机会</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="Q1-WWPD-Control"><a href="#Q1-WWPD-Control" class="headerlink" title="Q1: WWPD: Control"></a>Q1: WWPD: Control</h3><h3 id="Q2-WWPD-Veritasiness"><a href="#Q2-WWPD-Veritasiness" class="headerlink" title="Q2: WWPD: Veritasiness"></a>Q2: WWPD: Veritasiness</h3><h3 id="Q3-Debugging-Quiz"><a href="#Q3-Debugging-Quiz" class="headerlink" title="Q3: Debugging Quiz!"></a>Q3: Debugging Quiz!</h3><p>前三问分别问函数执行结果，python中布尔运算结果，程序报错最可能情况</p><p>所以就摘录部分令我印象深刻的知识点也就是做错的（悲</p><p>复制代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def how_big(x):</span><br><span class="line">...     if x &gt; 10:</span><br><span class="line">...         print(&#x27;huge&#x27;)</span><br><span class="line">...     elif x &gt; 5:</span><br><span class="line">...         return &#x27;big&#x27;</span><br><span class="line">...     elif x &gt; 0:</span><br><span class="line">...         print(&#x27;small&#x27;)</span><br><span class="line">...     else:</span><br><span class="line">...         print(&quot;nothin&quot;)</span><br><span class="line">&gt;&gt;&gt; how_big(7)</span><br></pre></td></tr></table></figure><p>“这题好简单啊，有什么难的吗？不就是big？”</p><p>是big，也不是</p><p>仔细看，elif x&gt;5: 下面是return ‘big’不是print</p><p>所以答案是’big’</p><p>而对于布尔运算则有两种代表情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 1 and 3 and 6 and 10 and 15</span><br></pre></td></tr></table></figure><p>在结果为对的布尔运算中，返回最后对的部分，</p><p>所以这题答案为15</p><p>而结果为错的布尔运算中，则返回第一个错的部分</p><h3 id="Q4-Falling-Factorial"><a href="#Q4-Falling-Factorial" class="headerlink" title="Q4: Falling Factorial"></a>Q4: Falling Factorial</h3><p>Let’s write a function falling, which is a “falling” factorial that takes two arguments, n and k, and returns the product of k consecutive numbers, starting from n and working downwards.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def falling(n, k):</span><br><span class="line">    &quot;&quot;&quot;Compute the falling factorial of n to depth k.</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; falling(6, 3)  # 6 * 5 * 4</span><br><span class="line">    120</span><br><span class="line">    &gt;&gt;&gt; falling(4, 3)  # 4 * 3 * 2</span><br><span class="line">    24</span><br><span class="line">    &gt;&gt;&gt; falling(4, 1)  # 4</span><br><span class="line">    4</span><br><span class="line">    &gt;&gt;&gt; falling(4, 0)</span><br><span class="line">    1</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    &quot;*** YOUR CODE HERE ***&quot;</span><br></pre></td></tr></table></figure><p>题目大意，接收两参数n，k，执行k次，从n向下递减数连乘，并规定乘0次的结果为1</p><p>解题过程，先定个result&#x3D;1，并返回result，然后以k&gt;0为条件建立循环，并在其中用n乘result，n–</p><h3 id="Q5-Sum-Digits"><a href="#Q5-Sum-Digits" class="headerlink" title="Q5: Sum Digits"></a>Q5: Sum Digits</h3><p>Write a function that takes in a nonnegative integer and sums its digits. (Using floor division and modulo might be helpful here!)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def sum_digits(y):</span><br><span class="line">    &quot;&quot;&quot;Sum all the digits of y.</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; sum_digits(10) # 1 + 0 = 1</span><br><span class="line">    1</span><br><span class="line">    &gt;&gt;&gt; sum_digits(4224) # 4 + 2 + 2 + 4 = 12</span><br><span class="line">    12</span><br><span class="line">    &gt;&gt;&gt; sum_digits(1234567890)</span><br><span class="line">    45</span><br><span class="line">    &gt;&gt;&gt; a = sum_digits(123) # make sure that you are using return rather than print</span><br><span class="line">    &gt;&gt;&gt; a</span><br><span class="line">    6</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    &quot;*** YOUR CODE HERE ***&quot;</span><br></pre></td></tr></table></figure><p>题目大意，输入一个正数，返回该数各位之和</p><p>解题过程，循环条件为该数大于零，不断取余并用10整除该数，再将余数相加</p><h3 id="Q6-WWPD-What-If"><a href="#Q6-WWPD-What-If" class="headerlink" title="Q6: WWPD: What If?"></a>Q6: WWPD: What If?</h3><p>该题要注意的是，if如果有满足的条件，后面的elif，else不会执行，同时还要看好if和else的对应关系。</p><h3 id="Q7-Double-Eights"><a href="#Q7-Double-Eights" class="headerlink" title="Q7: Double Eights"></a>Q7: Double Eights</h3><p>Write a function that takes in a number and determines if the digits contain two adjacent 8s.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def double_eights(n):</span><br><span class="line">    &quot;&quot;&quot;Return true if n has two eights in a row.</span><br><span class="line">    &gt;&gt;&gt; double_eights(8)</span><br><span class="line">    False</span><br><span class="line">    &gt;&gt;&gt; double_eights(88)</span><br><span class="line">    True</span><br><span class="line">    &gt;&gt;&gt; double_eights(2882)</span><br><span class="line">    True</span><br><span class="line">    &gt;&gt;&gt; double_eights(880088)</span><br><span class="line">    True</span><br><span class="line">    &gt;&gt;&gt; double_eights(12345)</span><br><span class="line">    False</span><br><span class="line">    &gt;&gt;&gt; double_eights(80808080)</span><br><span class="line">    False</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    &quot;*** YOUR CODE HERE ***&quot;</span><br></pre></td></tr></table></figure><p>题目大意，检测一个给定数字有无两个紧挨的8</p><p>解题过程，循环取余，判断数字是否为8，是则让计数器加一，计数器为2时结果为真，停止循环，最后计数器仍不为2则为假。易错点是数字非8时，记得将计数器归0</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>题不难，但让我很好的领略了一些python的特点，期待后续的学习</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> CS61A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CS61A-Fall-2020】学习记录二 Lecture1，2，3中有意思的点</title>
      <link href="/posts/df4994c9.html"/>
      <url>/posts/df4994c9.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>观前提示，笔者写的代码答案放在 <a href="https://github.com/HSLix/CS61A-Fall-2020">GitHub仓库</a> 中，此处仅记录过程与心得。</p><p>此外，请最好在尝试独立完成该任务后再看本文，否则就很可能失去了体验本项目精华的机会</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="doctest"><a href="#doctest" class="headerlink" title="doctest"></a>doctest</h3><p>好东西啊，此前的学习从未看到过，可以在函数的注释中通过特定格式便可书写文档测试，比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def divide_exact(n, d):</span><br><span class="line"> 　&#x27;&#x27;&#x27;</span><br><span class="line">    Return the quotient and remainder of dividing N by D.</span><br><span class="line">    &gt;&gt;&gt;q, r = divide_exact(2013, 10)</span><br><span class="line">    &gt;&gt;&gt;q</span><br><span class="line">    201</span><br><span class="line">    &gt;&gt;&gt; r</span><br><span class="line">    3</span><br><span class="line">    &#x27;&#x27;&#x27;    </span><br><span class="line">    return floordiv(n, d), mod(n, d)</span><br></pre></td></tr></table></figure><p>假设该 python 文件命名为 file.py，此时在本文件夹打开 bash，并输入命令行</p><p>python3  file.py 就能通过 doctest 来检查，如果没有其它输出，说明测试正常</p><p>可通过 -v 来显示运行过程，</p><p>当写成python3 -m doctest -v file.py时，该命令会详细运行测试用例</p><p>此外，doctest只会在命令行这种测试环境下才会运行，不用担心会在正式使用时误触发</p><h3 id="None"><a href="#None" class="headerlink" title="None"></a>None</h3><p>与C不同，python的函数都有返回，只是一部分返回为None，举个栗子</p><p>print(3)<br>会输出3，那么</p><p>print(print(1), print(2))<br>会输出什么呢？</p><p>答案是……</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">None None</span><br></pre></td></tr></table></figure><p>为什么呢？</p><p>因为python在调用函数时会先将参数计算尽，所以才会先输出1，再输出2</p><p>而后面出现的 None None 则是 print 函数返回的是 None</p><p>老师将函数大致分为两类</p><p>pure functions 和 non-pure fuctions，前者单纯返回函数值，后者除函数值有其他的操作</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> CS61A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CS61A-Fall-2020】学习记录一 Homework1 题解思路分享</title>
      <link href="/posts/b3d376c9.html"/>
      <url>/posts/b3d376c9.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>观前提示，笔者写的代码答案放在 <a href="https://github.com/HSLix/CS61A-Fall-2020">GitHub仓库</a> 中，此处仅记录过程与心得。</p><p>此外，请最好在尝试独立完成该任务后再看本文，否则就很可能失去了体验本项目精华的机会</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>首先来看下hw的第一道题</p><h3 id="Q2-A-Plus-Abs-B"><a href="#Q2-A-Plus-Abs-B" class="headerlink" title="Q2: A Plus Abs B"></a>Q2: A Plus Abs B</h3><p>Fill in the blanks in the following function for adding a to the absolute value of b, without calling abs. You may not modify any of the provided code other than the two blanks.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from operator import add, sub</span><br><span class="line"></span><br><span class="line">def a_plus_abs_b(a, b):</span><br><span class="line">    &quot;&quot;&quot;Return a+abs(b), but without calling abs.</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; a_plus_abs_b(2, 3)</span><br><span class="line">    5</span><br><span class="line">    &gt;&gt;&gt; a_plus_abs_b(2, -3)</span><br><span class="line">    5</span><br><span class="line">    &gt;&gt;&gt; # a check that you didn&#x27;t change the return statement!</span><br><span class="line">    &gt;&gt;&gt; import inspect, re</span><br><span class="line">    &gt;&gt;&gt; re.findall(r&#x27;^\s*(return .*)&#x27;, inspect.getsource(a_plus_abs_b), re.M)</span><br><span class="line">    [&#x27;return f(a, b)&#x27;]</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if b &lt; 0:</span><br><span class="line">        f = _____</span><br><span class="line">    else:</span><br><span class="line">        f = _____</span><br><span class="line">    return f(a, b)</span><br></pre></td></tr></table></figure><p>题目大意，赋予f一个函数满足在不使用abs函数的情况下，实现a+abs（b）的效果</p><p>解题过程，刚开始没注意到是赋予函数，于是分别填了a - b和a + b的错误答案，看了报错类型才反应过来，然后想起python可以函数赋予，于是将sub和add分别赋予f即可</p><h3 id="Q3-Two-of-Three"><a href="#Q3-Two-of-Three" class="headerlink" title="Q3: Two of Three"></a>Q3: Two of Three</h3><p>Write a function that takes three positive numbers as arguments and returns the sum of the squares of the two smallest numbers. Use only a single line for the body of the function.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def two_of_three(x, y, z):</span><br><span class="line">    &quot;&quot;&quot;Return a*a + b*b, where a and b are the two smallest members of the</span><br><span class="line">    positive numbers x, y, and z.</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; two_of_three(1, 2, 3)</span><br><span class="line">    5</span><br><span class="line">    &gt;&gt;&gt; two_of_three(5, 3, 1)</span><br><span class="line">    10</span><br><span class="line">    &gt;&gt;&gt; two_of_three(10, 2, 8)</span><br><span class="line">    68</span><br><span class="line">    &gt;&gt;&gt; two_of_three(5, 5, 5)</span><br><span class="line">    50</span><br><span class="line">    &gt;&gt;&gt; # check that your code consists of nothing but an expression (this docstring)</span><br><span class="line">    &gt;&gt;&gt; # a return statement</span><br><span class="line">    &gt;&gt;&gt; import inspect, ast</span><br><span class="line">    &gt;&gt;&gt; [type(x).__name__ for x in ast.parse(inspect.getsource(two_of_three)).body[0].body]</span><br><span class="line">    [&#x27;Expr&#x27;, &#x27;Return&#x27;]</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    return _____</span><br></pre></td></tr></table></figure><p>题目大意，返回三个参数中最小两个的平方和</p><p>解题过程，刚开始想了会如何在一行里选出三个参数中最小两个，然后马上想到全部一起平方加起来再减去最大的平方不就行了吗</p><h3 id="Q4-Largest-Factor"><a href="#Q4-Largest-Factor" class="headerlink" title="Q4: Largest Factor"></a>Q4: Largest Factor</h3><p>Write a function that takes an integer n that is greater than 1 and returns the largest integer that is smaller than n and evenly divides n.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def largest_factor(n):</span><br><span class="line">    &quot;&quot;&quot;Return the largest factor of n that is smaller than n.</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; largest_factor(15) # factors are 1, 3, 5</span><br><span class="line">    5</span><br><span class="line">    &gt;&gt;&gt; largest_factor(80) # factors are 1, 2, 4, 5, 8, 10, 16, 20, 40</span><br><span class="line">    40</span><br><span class="line">    &gt;&gt;&gt; largest_factor(13) # factor is 1 since 13 is prime</span><br><span class="line">    1</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    &quot;*** YOUR CODE HERE ***&quot;</span><br></pre></td></tr></table></figure><p>题目大意，找到比整数n小的最大的能整除n的数字</p><p>解题过程，直接循环，从1开始穷举，可以对循环条件除2或取根号2来减少循环次数</p><h3 id="Q5-If-Function-vs-Statement"><a href="#Q5-If-Function-vs-Statement" class="headerlink" title="Q5: If Function vs Statement"></a>Q5: If Function vs Statement</h3><p>Let’s try to write a function that does the same thing as an if statement.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def if_function(condition, true_result, false_result):</span><br><span class="line">    &quot;&quot;&quot;Return true_result if condition is a true value, and</span><br><span class="line">    false_result otherwise.</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; if_function(True, 2, 3)</span><br><span class="line">    2</span><br><span class="line">    &gt;&gt;&gt; if_function(False, 2, 3)</span><br><span class="line">    3</span><br><span class="line">    &gt;&gt;&gt; if_function(3==2, 3+2, 3-2)</span><br><span class="line">    1</span><br><span class="line">    &gt;&gt;&gt; if_function(3&gt;2, 3+2, 3-2)</span><br><span class="line">    5</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if condition:</span><br><span class="line">        return true_result</span><br><span class="line">    else:</span><br><span class="line">        return false_result</span><br></pre></td></tr></table></figure><p>Despite the doctests above, this function actually does not do the same thing as an if statement in all cases. To prove this fact, write functions cond, true_func, and false_func such that with_if_statement prints the number 47, but with_if_function prints both 42 and 47.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">def with_if_statement():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    &gt;&gt;&gt; result = with_if_statement()</span><br><span class="line">    47</span><br><span class="line">    &gt;&gt;&gt; print(result)</span><br><span class="line">    None</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if cond():</span><br><span class="line">        return true_func()</span><br><span class="line">    else:</span><br><span class="line">        return false_func()</span><br><span class="line"></span><br><span class="line">def with_if_function():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    &gt;&gt;&gt; result = with_if_function()</span><br><span class="line">    42</span><br><span class="line">    47</span><br><span class="line">    &gt;&gt;&gt; print(result)</span><br><span class="line">    None</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    return if_function(cond(), true_func(), false_func())</span><br><span class="line"></span><br><span class="line">def cond():</span><br><span class="line">    &quot;*** YOUR CODE HERE ***&quot;</span><br><span class="line"></span><br><span class="line">def true_func():</span><br><span class="line">    &quot;*** YOUR CODE HERE ***&quot;</span><br><span class="line"></span><br><span class="line">def false_func():</span><br><span class="line">    &quot;*** YOUR CODE HERE ***&quot;</span><br></pre></td></tr></table></figure><p>题目大意，通过编辑三个函数cond(),true_func(),false_func()，使得with_if_statement和with_if_fuction()产生预想的结果</p><p>解题过程，关键之关键在于了解到python中，将函数作为参数时，会先将函数运行，再将其结果作为参数返回，因此填上对应的数字，并调好条件cond就能成功解题</p><h3 id="Q6-Hailstone"><a href="#Q6-Hailstone" class="headerlink" title="Q6: Hailstone"></a>Q6: Hailstone</h3><p>Douglas Hofstadter’s Pulitzer-prize-winning book, Gödel, Escher, Bach, poses the following mathematical puzzle.</p><p>Pick a positive integer n as the start.<br>If n is even, divide it by 2.<br>If n is odd, multiply it by 3 and add 1.<br>Continue this process until n is 1.<br>The number n will travel up and down but eventually end at 1 (at least for all numbers that have ever been tried – nobody has ever proved that the sequence will terminate). Analogously, a hailstone travels up and down in the atmosphere before eventually landing on earth.</p><p>Breaking News (or at least the closest thing to that in math). There was a recent development in the hailstone conjecture last year that shows that almost all numbers will eventually get to 1 if you repeat this process. This isn’t a complete proof but a major breakthrough.</p><p>This sequence of values of n is often called a Hailstone sequence. Write a function that takes a single argument with formal parameter name n, prints out the hailstone sequence starting at n, and returns the number of steps in the sequence:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def hailstone(n):</span><br><span class="line">    &quot;&quot;&quot;Print the hailstone sequence starting at n and return its</span><br><span class="line">    length.</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; a = hailstone(10)</span><br><span class="line">    10</span><br><span class="line">    5</span><br><span class="line">    16</span><br><span class="line">    8</span><br><span class="line">    4</span><br><span class="line">    2</span><br><span class="line">    1</span><br><span class="line">    &gt;&gt;&gt; a</span><br><span class="line">    7</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    &quot;*** YOUR CODE HERE ***&quot;</span><br></pre></td></tr></table></figure><p>题目大意，有一种数学规律（尚未完全证明），对一个正整数，若其为偶数，则除2，若其为奇数，则乘3并加1，重复上述步骤，此数定终为1。现有n，输出n经上述规律到1的过程，并返回计算次数</p><p>解题过程，写循环，循环条件是数为1，每次循环输出该数，再设一个变量每次循环++即可</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>虽然题目不难，但仍发现了自己一些问题，比如审题不清，有一定的原因是题目是英语而非中文，不过都要适应嘛</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> CS61A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【陆爻齐】为三台笔记本重装系统过程记录与反思——解决无法进入PE，运行内存不足等问题</title>
      <link href="/posts/5fa462b0.html"/>
      <url>/posts/5fa462b0.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大家早上中午晚上好，这里是第一次像这样写文章的陆爻齐。姑且不管什么格式，推广，吸引眼球乱七八糟的，做好记录再说。</p><p>本来吧，重装系统真没啥可记录的，但中间遇到的些许问题还是最好记录下来，备后面使用。  </p><p>#正文</p><p>装备：待重装系统的老旧电脑*3 装了微PE工具箱的u盘*1 能上网正常使用的电脑*1  </p><p>重装系统的参考教程：硬件茶谈的视频【装机教程】超详细WIN10系统安装教程，官方ISO直装与PE两种方法教程，UEFI+GUID分区与Legacy+MBR分区</p><p>接下来是三段难度依次递增的重装系统过程（：</p><p>##（1）联想笔记本 4G运行内存 原win10系统  </p><p>该笔记本因不明原因，缺失某系统文件导致不断反复开机的流程而不进入系统。经过PE辅助装机问题全部解决，无异常。</p><p>重新安装Window7，为了方便使用，硬盘只划分一个分区，重新启动后就已可以让原主正常使用。  </p><p>##（2）联想笔记本 1G运行内存 149G储存容量的固态硬盘 原XP系统  </p><p>该笔记本因360和各种“下崽器”，卡顿不堪，抢救其中的图片与视频后，正常将硬盘格式化并安装WindowsXP系统。  </p><p>重装过程中也出现问题，XP的ISO不能像win7，win10的一样，挂载后直接运行setup.exe即可，所以借助PE自带的WinNTsetup软件中安装XP的功能，选中挂载的ISO和要安装的系统盘即可。</p><p>这次重装系统遇到的问题在于使得XP系统能够正常使用，毕竟纯净的XP系统，既不能识别u盘，又不能直接上网。  </p><p>首先要解决的不能识别u盘的问题，既然重装系统前能正常识别，说明问题不在XP系统本身。经上网查询，问题大概率为没有打KB955704补丁，故在系统之家下载补丁，并通过PE将其转移并使用，问题解决。</p><p>然后顺便在景元论坛发现XP补丁合集，遂放入u盘收藏并应用于重装XP中。  </p><p>接着通过u盘转移winrar和xp_activate32来解决无法解压rar和激活XP的问题。</p><p>还有无法上网的问题，经查询，很可能是没有安装驱动，故在u盘里放了个驱动总裁，使用后问题也顺利解决。</p><p>##（3）戴尔笔记本 512M运行内存 80G储存容量的机械硬盘 原XP系统</p><p>这次问题主要集中在重装系统本身，刚开始PE无法进入，XP系统又无法自己打开ISO进行系统安装，一筹莫展。</p><p>刚开始的思路是，修复该笔记本各种dll缺失，启动微软自己的安装系统，但即便用DirectX修复后仍然无法解决，故转换思路。</p><p>经思考与查询，决定将PE更换为32位，然后成功进入PE。</p><p>然后发现0.5G的运行内存不能使用分区助手，分区精灵来分区，于是只能用系统自带分区来实现。</p><p>值得注意的是，给系统盘拓展卷时，会提示基本磁盘变为动态磁盘，不可作为系统盘。要解决这个问题需要先删除该盘所有分区，再将该磁盘变为基本磁盘，然后才新建简单卷。</p><p>接着通过WinNTSetup成功安装XP。</p><p>接下来进入下一个问题，拔掉u盘重启后，电脑显示no bootable device。</p><p>出现该问题有可能是硬盘连接断开，故在bios检查，发现硬盘仍正常连接，排除该原因。</p><p>接着考虑是引导程序出问题，故重新进入PE启动引导修复工具，在提示重新引导完成后重启电脑，但仍出现一样结果。</p><p>此时又进入一筹莫展之境地，经上网查询后，尝试以下步骤。</p><ol><li><p>进入PE，并运行cmd</p></li><li><p>diskpart</p></li><li><p>list disk</p></li><li><p>select disk 0（这里的数字0代表系统盘）</p></li><li><p>list partition</p></li><li><p>select partition 0（这里的数字0代表分区中装载系统的分区）</p></li><li><p>active</p></li></ol><p>如果最后一步无报错，说明系统分区成功激活，重启即可。</p><p>上述步骤出自知乎，我的电脑出现了no bootable device，怎么解决?</p><p>然后问题解决，成功进入XP安装，其余同（2）  </p><p>#总结  </p><p>重装系统其实不算难，难的是旧电脑遗留各种问题需要克服，运行内存不足，无法进入pe等，希望本文能给予后人一点参考，少踩坑，多休息。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

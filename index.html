<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>LuYaoQi&#39;s Blogs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="normal wants to be special">
<meta property="og:type" content="website">
<meta property="og:title" content="LuYaoQi&#39;s Blogs">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="LuYaoQi&#39;s Blogs">
<meta property="og:description" content="normal wants to be special">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="陆爻齐-LuYaoQi">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="LuYaoQi's Blogs" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">LuYaoQi&#39;s Blogs</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Hello my World</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-[Weekly Algorithm] 19算法周记之《代码随想录》图论（三）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/02/23/%5BWeekly%20Algorithm%5D%2019%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%9B%BE%E8%AE%BA%EF%BC%88%E4%B8%89%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2025-02-23T15:31:00.000Z" itemprop="datePublished">2025-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/02/23/%5BWeekly%20Algorithm%5D%2019%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%9B%BE%E8%AE%BA%EF%BC%88%E4%B8%89%EF%BC%89/">【Weekly Algorithm】算法周记之《代码随想录》图论（三）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h1><p>本周跟随《代码随想录》继续学习关于图论的知识，主要是关于并查集以及最小生成树的两个经典算法（prim和kruskal）。</p>
<p>并查集的作用在于快速区分不同的类别并补充内容。prim 则是从点的角度从图中划分出最小生成树，kruskal 是划分边来种最小生成树。</p>
<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><ul>
<li><h2 id="有向图的完全可达性"><a href="#有向图的完全可达性" class="headerlink" title="有向图的完全可达性"></a>有向图的完全可达性</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0105.%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%AE%8C%E5%85%A8%E5%8F%AF%E8%BE%BE%E6%80%A7.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1177">105. 有向图的完全可达性</a></p>
</li>
<li><p>问题：给一个有向图，但求中的1节点是否能到达其他节点。</p>
</li>
<li><p>方法：从 1 开始 dfs&#x2F;bfs 就可以，重点在于用邻接表存储</p>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void dfs(const vector&lt;list&lt;int&gt;&gt; grid, vector&lt;bool&gt; &amp;visited, int &amp;count, int node) &#123;</span><br><span class="line">    count++;</span><br><span class="line">    visited[node] = true;</span><br><span class="line">    // 遍历每个节点所链接的部分</span><br><span class="line">    for (const auto &amp;i : grid[node]) &#123;</span><br><span class="line">        if (visited[i]) continue;</span><br><span class="line">        dfs(grid, visited, count, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    </span><br><span class="line">    vector&lt;list&lt;int&gt;&gt; grid(n+1);</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">        int a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        grid[a].push_back(b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;bool&gt; visited(n+1, false);</span><br><span class="line">    int count = 0;</span><br><span class="line">    </span><br><span class="line">    dfs(grid, visited, count, 1);</span><br><span class="line">    </span><br><span class="line">    int result;</span><br><span class="line">    if (count == n) &#123;</span><br><span class="line">        result = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        result = -1;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    // 测试输出图</span><br><span class="line">    // for (int i = 0; i &lt; n+1; i++) &#123;</span><br><span class="line">    //     cout &lt;&lt; i &lt;&lt; &quot;: &quot;;</span><br><span class="line">    //     for (auto &amp;j : grid[i]) &#123;</span><br><span class="line">    //         cout &lt;&lt; j &lt;&lt; &quot; &quot;;</span><br><span class="line">    //     &#125;</span><br><span class="line">    //     cout &lt;&lt; endl;</span><br><span class="line">    // &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="岛屿的周长"><a href="#岛屿的周长" class="headerlink" title="岛屿的周长"></a>岛屿的周长</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0106.%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1178">106. 岛屿的周长</a></p>
</li>
<li><p>题意：二维数组中的岛屿没有内部水，求该一个岛屿的边缘周长。</p>
</li>
<li><p>方法：两个思路，一个是遍历岛屿，求每块的边界；第二个思路是求岛屿块数，4*块数 - 相邻区块的重叠边，该思路只要注意求相邻区块的方向不要重合，比如每个区块都只检查左上两个方向。</p>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 一格的四个方向</span><br><span class="line">int dr[4][2] = &#123;1, 0, -1, 0, 0, 1, 0, -1&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    </span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; grid(n, vector&lt;int&gt;(m, 0));</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 遍历统计边</span><br><span class="line">    int edge_num = 0;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            if (grid[i][j] == 0) continue;</span><br><span class="line">            </span><br><span class="line">            for (int k = 0; k &lt; 4; k++) &#123;</span><br><span class="line">                int nx = i + dr[k][0];</span><br><span class="line">                int ny = j + dr[k][1];</span><br><span class="line">                </span><br><span class="line">                if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m || grid[nx][ny] == 0) &#123;</span><br><span class="line">                    edge_num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; edge_num &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="寻找存在的路径"><a href="#寻找存在的路径" class="headerlink" title="寻找存在的路径"></a>寻找存在的路径</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0107.%E5%AF%BB%E6%89%BE%E5%AD%98%E5%9C%A8%E7%9A%84%E8%B7%AF%E5%BE%84.html">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1179">107. 寻找存在的路径</a></p>
</li>
<li><p>题意：给一个无向图和两个点，由于无向图不是连通，要判断两点是否连通</p>
</li>
<li><p>方法：用并查集，每次输入边就联系两点的并查集。</p>
</li>
<li><p>参考代码随想录思路的解法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int find(vector&lt;int&gt; &amp;father, int a) &#123;</span><br><span class="line">    return father[a] == a ? a : father[a] = find(father, father[a]);// 路径压缩</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    // n个点 m条边</span><br><span class="line">    vector&lt;int&gt; father(n+1, -1);</span><br><span class="line">    </span><br><span class="line">    // 初始化并查集</span><br><span class="line">    for (int i = 0; i &lt; n+1; i++) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        int a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        a = find(father, a);</span><br><span class="line">        b = find(father, b);</span><br><span class="line">        //cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">        if (a != b) father[a] = b;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // for (int i = 0; i &lt; n+1; i++) &#123;</span><br><span class="line">    //     cout &lt;&lt; father[i] &lt;&lt; endl;</span><br><span class="line">    // &#125;</span><br><span class="line">    </span><br><span class="line">    int source, destination;</span><br><span class="line">    cin &gt;&gt; source &gt;&gt; destination;</span><br><span class="line">    </span><br><span class="line">    // 本质上就是两个点是否属于统一个并查集（同一个无向连通图）</span><br><span class="line">    cout &lt;&lt; int(find(father, father[source])==find(father, father[destination])) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="冗余连接"><a href="#冗余连接" class="headerlink" title="冗余连接"></a>冗余连接</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0108.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1181">108. 冗余连接</a></p>
</li>
<li><p>题意：给一个无向图的构建，但要求返回最后一个连成环的边</p>
</li>
<li><p>方法：用并查集，一旦检测出一个边的两个点在同一个并查集，就返回这条边</p>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int find(vector&lt;int&gt; &amp;father, int a)&#123; // 查找并查集所属类</span><br><span class="line">    return father[a] == a ? a : father[a] = find(father, father[a]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool join(vector&lt;int&gt; &amp;father, int a, int b) &#123; // 尝试合并两个点</span><br><span class="line">    a = find(father, a);</span><br><span class="line">    b = find(father, b);</span><br><span class="line">    if (a == b) return false;</span><br><span class="line">    father[a] = b;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;int&gt; father(n, 0); // 并查集</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123; // 初始化</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        int a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        if (!join(father, a, b)) &#123;</span><br><span class="line">            cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="冗余连接II"><a href="#冗余连接II" class="headerlink" title="冗余连接II"></a>冗余连接II</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0109.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5II.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1182">109. 冗余连接II</a></p>
</li>
<li><p>题意：[[冗余连接]]的有向图版。</p>
</li>
<li><p>方法，由于无向图变成有向图，就不能无脑找那个并查集重复的那条边，这只能避免成环的情况，无法避免一个点有两个父节点的情况。</p>
</li>
<li><p>参考代码随想录思路的解法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">vector&lt;int&gt; father(1001, 0);</span><br><span class="line"></span><br><span class="line">// 并查集初始化</span><br><span class="line">void init() &#123;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) father[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 寻根</span><br><span class="line">int find(int u) &#123;</span><br><span class="line">    return father[u]==u ? u : father[u] = find(father[u]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 查看是否相同</span><br><span class="line">bool isSame(int p, int q) &#123;</span><br><span class="line">    return find(p) == find(q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 加入并查集</span><br><span class="line">void join(int p, int q) &#123;</span><br><span class="line">    p = find(p);</span><br><span class="line">    q = find(q);</span><br><span class="line">    if (p == q) return;</span><br><span class="line">    father[p] = q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在图里找到要删除的边</span><br><span class="line">// 原理是从前向后找到第一组同一个并查集的的一组点就行</span><br><span class="line">void deleteCircleEdge(const vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123;</span><br><span class="line">    init();</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        if (isSame(edges[i][0], edges[i][1])) &#123;</span><br><span class="line">            cout &lt;&lt; edges[i][0] &lt;&lt; &quot; &quot; &lt;&lt; edges[i][1] &lt;&lt; endl;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            join(edges[i][0], edges[i][1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 判断去除边后剩下能否成树</span><br><span class="line">bool isDelOk(const vector&lt;vector&lt;int&gt;&gt; edges, int del) &#123;</span><br><span class="line">    init();</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        if (i == del) continue;</span><br><span class="line">        if (isSame(edges[i][0], edges[i][1]))&#123; // 出现环说明删除到错的边了，换另一条即可</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        join(edges[i][0], edges[i][1]);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; edges; // 边的记录</span><br><span class="line">    vector&lt;int&gt; inDegree(n+1, 0); // 入度</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        int a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        edges.push_back(&#123;a,b&#125;);</span><br><span class="line">        inDegree[b]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 倒序添加入度为2的点对应的边</span><br><span class="line">    vector&lt;int&gt; vec;</span><br><span class="line">    for (int i = n-1; i &gt;= 0; i--) &#123;</span><br><span class="line">        if (inDegree[edges[i][1]] == 2) &#123;</span><br><span class="line">            vec.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 处理非成环的情况</span><br><span class="line">    if (vec.size() &gt; 0) &#123;</span><br><span class="line">        // 只有两种情况，倒数第一条或者倒数第二条</span><br><span class="line">        // 因为有可能倒数第一条取出后，会产生孤立点，所以去除另一条边</span><br><span class="line">        if (isDelOk(edges, vec[0])) &#123;</span><br><span class="line">            cout &lt;&lt; edges[vec[0]][0] &lt;&lt; &quot; &quot; &lt;&lt; edges[vec[0]][1] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            cout &lt;&lt; edges[vec[1]][0] &lt;&lt; &quot; &quot; &lt;&lt; edges[vec[1]][1] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 处理有向环</span><br><span class="line">    deleteCircleEdge(edges);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="最小生成树之prim"><a href="#最小生成树之prim" class="headerlink" title="最小生成树之prim"></a>最小生成树之prim</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0053.%E5%AF%BB%E5%AE%9D-prim.html#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1053">53. 寻宝（第七期模拟笔试）</a></p>
</li>
<li><p>题意：本质就是求最小生成树的值大小</p>
</li>
<li><p>方法：prim算法<br>分三步：  </p>
<ol>
<li>找到与最小生成树距离最近的节点（初始化就随便一个都行）</li>
<li>把节点加入最小生成树</li>
<li>根据加入节点，更新其他节点与最小生成树的距离</li>
</ol>
</li>
<li><p>但是具体实现还有很多细节，写在了注释中。</p>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;climits&gt;// INT_MAX</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int v, e;</span><br><span class="line">    cin &gt;&gt; v &gt;&gt; e;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; grid(v+1, vector&lt;int&gt;(v+1, 0));</span><br><span class="line">    for (int i = 0; i &lt; e; i++) &#123;</span><br><span class="line">        int x, y, k;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line">        grid[x][y] = k;</span><br><span class="line">        grid[y][x] = k;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; min_dist(v+1, 10001);// 题目最大值10000</span><br><span class="line">    vector&lt;bool&gt; visited(v+1, false);</span><br><span class="line">    // 找到构成最小生成树的v-1条边</span><br><span class="line">    for (int i = 1; i &lt; v; i++) &#123;</span><br><span class="line">        int min_val = INT_MAX;</span><br><span class="line">        int cur = -1;// 要加入最小生成树的点</span><br><span class="line">        </span><br><span class="line">        for (int j = 1; j &lt;= v; j++) &#123; // 遍历所有点</span><br><span class="line">            // 找一个不在树里面，且与最小生成树距离最小的点</span><br><span class="line">            if (!visited[j] &amp;&amp; min_dist[j] &lt; min_val) &#123;</span><br><span class="line">                min_val = min_dist[j];</span><br><span class="line">                cur = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 加入最小生成树的点</span><br><span class="line">        visited[cur] = true;</span><br><span class="line">        </span><br><span class="line">        // 遍历与加入点相连的其它点，更新与最小生成树的距离</span><br><span class="line">        for (int i = 1; i &lt;= v; i++) &#123;</span><br><span class="line">            if (visited[i]) continue; // 已在树内</span><br><span class="line">            if (grid[cur][i] == 0) continue; // 无连接</span><br><span class="line">            if (grid[cur][i] &lt; min_dist[i]) &#123;</span><br><span class="line">                min_dist[i] = grid[cur][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int result = 0;</span><br><span class="line">    for (int i = 2; i &lt;= v; i++) &#123; // 之所以i从2开始，是因为min_dist[1]不会赋值</span><br><span class="line">    // 从理解的角度，1一开始就在树内，所以没有计算距离（或是距离为0）</span><br><span class="line">        result += min_dist[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="最小生成树之kruskal"><a href="#最小生成树之kruskal" class="headerlink" title="最小生成树之kruskal"></a>最小生成树之kruskal</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0053.%E5%AF%BB%E5%AE%9D-Kruskal.html#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1053">53. 寻宝（第七期模拟笔试）</a></p>
</li>
<li><p>题目：与[[最小生成树之prim]]一样，但方法不同。</p>
</li>
<li><p>方法：kruskal看边，而prim看点。简单地说，kruskal会升序遍历边，不断加入不同并查集的边，最后得到最小生成树。</p>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;climits&gt;// INT_MAX</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef struct _Edge &#123;</span><br><span class="line">    int l;</span><br><span class="line">    int r;</span><br><span class="line">    int val;</span><br><span class="line">&#125;Edge;</span><br><span class="line"></span><br><span class="line">int n = 10001;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; father(n, 0);</span><br><span class="line"></span><br><span class="line">int find(int u) &#123;</span><br><span class="line">    return father[u]==u ? u : father[u] = find(father[u]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void join(int u, int v) &#123;</span><br><span class="line">    u = find(u);</span><br><span class="line">    v = find(v);</span><br><span class="line">    if (u == v) return;</span><br><span class="line">    father[u] = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isSame(int u, int v) &#123;</span><br><span class="line">    return find(u) == find(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    for (int i = 0; i &lt; 10001; i++) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;                                                     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int v, e;</span><br><span class="line">    cin &gt;&gt; v &gt;&gt; e;</span><br><span class="line">    </span><br><span class="line">    vector&lt;Edge&gt; edge;</span><br><span class="line">    </span><br><span class="line">    while(e--) &#123;</span><br><span class="line">        int l, r, val;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r &gt;&gt; val;</span><br><span class="line">        edge.push_back(&#123;l, r, val&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sort(edge.begin(), edge.end(), [](Edge &amp;e1, Edge &amp;e2) &#123;return e1.val &lt; e2.val;&#125;);</span><br><span class="line">    </span><br><span class="line">    init();</span><br><span class="line">    int result = 0;</span><br><span class="line">    </span><br><span class="line">    for (const auto &amp; line : edge) &#123;</span><br><span class="line">        int l = find(line.l);</span><br><span class="line">        int r = find(line.r);</span><br><span class="line">        if (l != r) &#123;</span><br><span class="line">            join(l, r);</span><br><span class="line">            result += line.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/02/23/[Weekly%20Algorithm]%2019%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%9B%BE%E8%AE%BA%EF%BC%88%E4%B8%89%EF%BC%89/" data-id="cm7j3jecd001g10aghe0107w8" data-title="【Weekly Algorithm】算法周记之《代码随想录》图论（三）" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-[Weekly Algorithm] 18算法周记之《代码随想录》图论（二）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/02/16/%5BWeekly%20Algorithm%5D%2018%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%9B%BE%E8%AE%BA%EF%BC%88%E4%BA%8C%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2025-02-16T14:11:00.000Z" itemprop="datePublished">2025-02-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/02/16/%5BWeekly%20Algorithm%5D%2018%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%9B%BE%E8%AE%BA%EF%BC%88%E4%BA%8C%EF%BC%89/">【Weekly Algorithm】算法周记之《代码随想录》图论（二）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h1><p>本周跟随《代码随想录》继续学习关于图论的知识，主要是学习岛屿，也就是 bfs&#x2F;dfs 的经典应用。同时还有[[字符串接龙]]这种新颖的图论题目，才知道各种字符串也能抽象为一个图。</p>
<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><ul>
<li><h2 id="岛屿数量广搜版"><a href="#岛屿数量广搜版" class="headerlink" title="岛屿数量广搜版"></a>岛屿数量广搜版</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0099.%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%95%B0%E9%87%8F%E5%B9%BF%E6%90%9C.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1171">99. 岛屿数量</a></p>
</li>
<li><p>直接说明区别和放代码好力，代码就是在[[岛屿数量深搜版]]的基础上做了一点更改，原本的搜索函数不断递归向深了探索，现在是用队列（栈也可，区别在于遍历顺序）来记录要遍历的区块，再按顺序处理</p>
</li>
<li><p>修改后的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int dir[4][2] = &#123;0, 1, 1, 0, -1, 0, 0, -1&#125;;</span><br><span class="line">void bfs(const vector&lt;vector&lt;int&gt;&gt; &amp;grid, vector&lt;vector&lt;bool&gt;&gt; &amp;visited, int x, int y) &#123;</span><br><span class="line">    queue&lt;pair&lt;int, int&gt;&gt; q;</span><br><span class="line">    q.push(make_pair(x, y));</span><br><span class="line">    while (!q.empty()) &#123;</span><br><span class="line">        int tmpx = q.front().first;</span><br><span class="line">        int tmpy = q.front().second;</span><br><span class="line">        q.pop();</span><br><span class="line">        for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">            int nextx = tmpx + dir[i][0];</span><br><span class="line">            int nexty = tmpy + dir[i][1];</span><br><span class="line">            if (nextx &lt; 0 || nextx &gt;= grid.size() || nexty &lt; 0 || nexty &gt;= grid[0].size()) continue;</span><br><span class="line">            if (!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == 1) &#123;</span><br><span class="line">                visited[nextx][nexty] = true;</span><br><span class="line">                q.push(make_pair(nextx, nexty));</span><br><span class="line">                // dfs(grid, visited, nextx, nexty);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; grid(n, vector&lt;int&gt;(m, 0));</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;bool&gt;&gt; visited(n, vector&lt;bool&gt;(m, false));</span><br><span class="line">    </span><br><span class="line">    int result = 0;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            if (!visited[i][j] &amp;&amp; grid[i][j] == 1) &#123;</span><br><span class="line">                visited[i][j] = true;</span><br><span class="line">                result++;</span><br><span class="line">                bfs(grid, visited, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="岛屿的最大面积"><a href="#岛屿的最大面积" class="headerlink" title="岛屿的最大面积"></a>岛屿的最大面积</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0100.%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1172">100. 岛屿的最大面积</a></p>
</li>
<li><p>题意：给一个二维数组，求其中纵横相连最大区块面积</p>
</li>
<li><p>方法：dfs&#x2F;bfs</p>
</li>
<li><p>从零手搓代码，重点在于visited的更新要及时，这也是易忘点<br>第一次把visited放再递归前，少了第一块的计算，故最后会多1<br>下面是最后修正的正确代码  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int result = 0;</span><br><span class="line"></span><br><span class="line">int dr[4][2] = &#123;1, 0, 0, 1, -1, 0, 0, -1&#125;;</span><br><span class="line"></span><br><span class="line">void dfs(const vector&lt;vector&lt;int&gt;&gt; &amp;grid, vector&lt;vector&lt;int&gt;&gt; &amp;visited, int &amp;cur_area, int x, int y) &#123;</span><br><span class="line">    cur_area++;</span><br><span class="line">    visited[x][y] = 1;</span><br><span class="line">    //cout &lt;&lt; &quot;visiting:&quot; &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">        int tmpx = x + dr[i][0];</span><br><span class="line">        int tmpy = y + dr[i][1];</span><br><span class="line">        if (tmpx &lt; 0 || tmpx &gt;= grid.size() || tmpy &lt; 0 || tmpy &gt;= grid[0].size()) continue;</span><br><span class="line">        if (grid[tmpx][tmpy] == 1 &amp;&amp; visited[tmpx][tmpy] == 0) &#123;</span><br><span class="line">            dfs(grid, visited, cur_area, tmpx, tmpy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; grid(n, vector&lt;int&gt;(m, 0));</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; visited(grid);</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            int cur_area = 0;</span><br><span class="line">            if (!(grid[i][j] == 1 &amp;&amp; visited[i][j] == 0)) continue;</span><br><span class="line">            dfs(grid, visited, cur_area, i, j);</span><br><span class="line">            if (cur_area &gt; result) result = cur_area;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="孤岛的总面积"><a href="#孤岛的总面积" class="headerlink" title="孤岛的总面积"></a>孤岛的总面积</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0101.%E5%AD%A4%E5%B2%9B%E7%9A%84%E6%80%BB%E9%9D%A2%E7%A7%AF.html">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1173">101. 孤岛的总面积</a></p>
</li>
<li><p>题意：求没有与边缘相连的纵横相连区块的总面积</p>
</li>
<li><p>方法：先对边缘的岛屿用dfs&#x2F;bfs，排除这些区块，然后再遍历中间的面积。</p>
</li>
<li><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int dr[4][2] = &#123;0, 1, 0, -1, 1, 0, -1, 0&#125;;</span><br><span class="line"></span><br><span class="line">void dfs(vector&lt;vector&lt;int&gt;&gt; &amp;grid, vector&lt;vector&lt;bool&gt;&gt; &amp;visited, int x, int y) &#123;</span><br><span class="line">    visited[x][y] = true;</span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">        int nextx = x + dr[i][0];</span><br><span class="line">        int nexty = y + dr[i][1];</span><br><span class="line">        if (nextx &lt; 0 || nextx &gt;= grid.size() || nexty &lt; 0 || nexty &gt;= grid[0].size()) continue;</span><br><span class="line">        if (!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == 1) &#123;</span><br><span class="line">            dfs(grid, visited, nextx, nexty);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; grid(n, vector&lt;int&gt;(m, 0));</span><br><span class="line">    vector&lt;vector&lt;bool&gt;&gt; visited(n, vector&lt;bool&gt;(m, false));</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        if (grid[i][0] == 1 &amp;&amp; !visited[i][0]) &#123;</span><br><span class="line">            dfs(grid, visited, i, 0);</span><br><span class="line">        &#125;</span><br><span class="line">        if (grid[i][m-1] &amp;&amp; !visited[i][m-1]) &#123;</span><br><span class="line">            dfs(grid, visited, i, m-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        if (grid[0][i] == 1 &amp;&amp; !visited[0][i]) &#123;</span><br><span class="line">            dfs(grid, visited, 0, i);</span><br><span class="line">        &#125;</span><br><span class="line">        if (grid[n-1][i] &amp;&amp; !visited[n-1][i]) &#123;</span><br><span class="line">            dfs(grid, visited, n-1, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int result = 0;</span><br><span class="line">    for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 1; j &lt; m; j++) &#123;</span><br><span class="line">            if (!visited[i][j] &amp;&amp; grid[i][j] == 1) &#123;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="沉没孤岛"><a href="#沉没孤岛" class="headerlink" title="沉没孤岛"></a>沉没孤岛</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0102.%E6%B2%89%E6%B2%A1%E5%AD%A4%E5%B2%9B.html">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1174">102. 沉没孤岛</a></p>
</li>
<li><p>题意：就是求孤岛之外的面积之和</p>
</li>
<li><p>方法：[[孤岛的总面积]]的小变式，只要在计算边缘区块时计算面积就行</p>
</li>
<li><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int dr[4][2] = &#123;0, 1, 0, -1, 1, 0, -1, 0&#125;;</span><br><span class="line"></span><br><span class="line">void dfs(vector&lt;vector&lt;int&gt;&gt; &amp;grid, vector&lt;vector&lt;bool&gt;&gt; &amp;visited, int x, int y) &#123;</span><br><span class="line">    visited[x][y] = true;</span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">        int nextx = x + dr[i][0];</span><br><span class="line">        int nexty = y + dr[i][1];</span><br><span class="line">        if (nextx &lt; 0 || nextx &gt;= grid.size() || nexty &lt; 0 || nexty &gt;= grid[0].size()) continue;</span><br><span class="line">        if (!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == 1) &#123;</span><br><span class="line">            dfs(grid, visited, nextx, nexty);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; grid(n, vector&lt;int&gt;(m, 0));</span><br><span class="line">    vector&lt;vector&lt;bool&gt;&gt; visited(n, vector&lt;bool&gt;(m, false));</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        if (grid[i][0] == 1 &amp;&amp; !visited[i][0]) &#123;</span><br><span class="line">            dfs(grid, visited, i, 0);</span><br><span class="line">        &#125;</span><br><span class="line">        if (grid[i][m-1] &amp;&amp; !visited[i][m-1]) &#123;</span><br><span class="line">            dfs(grid, visited, i, m-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        if (grid[0][i] == 1 &amp;&amp; !visited[0][i]) &#123;</span><br><span class="line">            dfs(grid, visited, 0, i);</span><br><span class="line">        &#125;</span><br><span class="line">        if (grid[n-1][i] &amp;&amp; !visited[n-1][i]) &#123;</span><br><span class="line">            dfs(grid, visited, n-1, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            if (visited[i][j] == true) &#123;</span><br><span class="line">                cout &lt;&lt; &quot;1 &quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                cout &lt;&lt; &quot;0 &quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="水流问题"><a href="#水流问题" class="headerlink" title="水流问题"></a>水流问题</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0103.%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98.html#%E4%BC%98%E5%8C%96">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1175">103. 水流问题</a></p>
</li>
<li><p>题意：给一个数组，找其中所有能够到达（左||上）&amp;&amp;（右||下）从高到低（同值也行）的格子</p>
</li>
<li><p>方法：普通思路是对每一个格子都做遍历，看是否能到两种边界。但是复杂度过高。反过来，从两种边界逆流遍历，再求两次遍历的交集即可获得格子</p>
</li>
<li><p>参考代码随想录思路的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n, m;</span><br><span class="line">int dir[4][2] = &#123;-1, 0, 0, -1, 1, 0, 0, 1&#125;;</span><br><span class="line">void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int x, int y) &#123;</span><br><span class="line">    if (visited[x][y]) return;</span><br><span class="line"></span><br><span class="line">    visited[x][y] = true;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">        int nextx = x + dir[i][0];</span><br><span class="line">        int nexty = y + dir[i][1];</span><br><span class="line">        if (nextx &lt; 0 || nextx &gt;= n || nexty &lt; 0 || nexty &gt;= m) continue;</span><br><span class="line">        if (grid[x][y] &gt; grid[nextx][nexty]) continue; // 注意：这里是从低向高遍历</span><br><span class="line"></span><br><span class="line">        dfs (grid, visited, nextx, nexty);</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; grid(n, vector&lt;int&gt;(m, 0));</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 逆流遍历,这些本质上就是visited</span><br><span class="line">    vector&lt;vector&lt;bool&gt;&gt; firstBoard(n, vector&lt;bool&gt;(m, false));</span><br><span class="line">    vector&lt;vector&lt;bool&gt;&gt; secondBoard(firstBoard);</span><br><span class="line">    </span><br><span class="line">    // 从第一组边界和第二组边界分别逆推</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        dfs(grid, firstBoard, i, 0);</span><br><span class="line">        dfs(grid, secondBoard, i, m-1);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        dfs(grid, firstBoard, 0, i);</span><br><span class="line">        dfs(grid, secondBoard, n-1, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 遍历并输出最终结果</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            if (firstBoard[i][j] &amp;&amp; secondBoard[i][j]) &#123;</span><br><span class="line">                cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="建造最大工岛"><a href="#建造最大工岛" class="headerlink" title="建造最大工岛"></a>建造最大工岛</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0104.%E5%BB%BA%E9%80%A0%E6%9C%80%E5%A4%A7%E5%B2%9B%E5%B1%BF.html#%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1176">104. 建造最大岛屿</a></p>
</li>
<li><p>题意：给一个二维数组，沿用上面的岛屿设定，不过本题可以最多填充一块陆地，求填充完最大的陆地面积</p>
</li>
<li><p>方法：普通的暴力思路是对每块海洋求四边的陆地和；优化后，先把所有陆地给遍历，求各陆地面积，避免暴力思路中的重复遍历。</p>
<p>实现的重点在于，考虑全陆地的情况，并且要考虑到四边的陆地可能是同一块陆地，所以要去重。  </p>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &lt;unordered_set&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n, m;</span><br><span class="line"></span><br><span class="line">int dr[4][2] = &#123;0, 1, 0, -1, 1, 0, -1, 0&#125;;</span><br><span class="line"></span><br><span class="line">void dfs(vector&lt;vector&lt;int&gt;&gt; &amp;grid, vector&lt;vector&lt;bool&gt;&gt; &amp;visited, int x, int y, int &amp;count, int mark) &#123;</span><br><span class="line">    // 加速返回</span><br><span class="line">    if (visited[x][y] || grid[x][y] == 0) return;</span><br><span class="line">    count++;</span><br><span class="line">    visited[x][y] = true;</span><br><span class="line">    grid[x][y] = mark;</span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">        int nextx = x + dr[i][0];</span><br><span class="line">        int nexty = y + dr[i][1];</span><br><span class="line">        if (nextx &lt; 0 || nextx &gt;= n || nexty &lt; 0 || nexty &gt;= m) continue;</span><br><span class="line">        if (grid[nextx][nexty] == 1 &amp;&amp; !visited[nextx][nexty]) &#123;</span><br><span class="line">            dfs(grid, visited, nextx, nexty, count, mark);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; grid(n, vector&lt;int&gt;(m, 0));</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;bool&gt;&gt; visited(n, vector&lt;bool&gt;(m, false));</span><br><span class="line">    unordered_map&lt;int, int&gt; gridNum;</span><br><span class="line">    </span><br><span class="line">    int flagNum = 2;</span><br><span class="line">    bool isAllGrid = true;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            if (grid[i][j] == 0) isAllGrid = false;</span><br><span class="line">            int count = 0;</span><br><span class="line">            if (!visited[i][j] &amp;&amp; grid[i][j] == 1) &#123;</span><br><span class="line">                dfs(grid, visited, i, j, count, flagNum);</span><br><span class="line">                gridNum[flagNum] = count;</span><br><span class="line">                //cout &lt;&lt; &quot;flagNum:&quot; &lt;&lt; flagNum &lt;&lt; &quot;; count:&quot; &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">                flagNum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (isAllGrid) &#123;</span><br><span class="line">        cout &lt;&lt; n*m &lt;&lt; endl;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    unordered_set&lt;int&gt; visitGrid;</span><br><span class="line">    int result = 0;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            if (grid[i][j] != 0) continue;</span><br><span class="line">            visitGrid.clear();</span><br><span class="line">            int area = 1;</span><br><span class="line">            //cout &lt;&lt; &quot;出发：&quot; &lt;&lt; i &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">            for (int k = 0; k &lt; 4; k++) &#123;</span><br><span class="line">                int nx = i + dr[k][0];</span><br><span class="line">                int ny = j + dr[k][1];</span><br><span class="line">                //cout &lt;&lt; &quot;查看：&quot; &lt;&lt; nx &lt;&lt; ny &lt;&lt; endl;</span><br><span class="line">                if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m || grid[nx][ny] == 0) continue;</span><br><span class="line">                if (visitGrid.count(grid[nx][ny])) continue;</span><br><span class="line">                area += gridNum[grid[nx][ny]];</span><br><span class="line">                //cout &lt;&lt; &quot;发现：&quot; &lt;&lt; grid[nx][ny] &lt;&lt; &quot;;gridNum:&quot; &lt;&lt; gridNum[grid[nx][ny]] &lt;&lt; &quot;;area:&quot; &lt;&lt; area &lt;&lt; endl;</span><br><span class="line">                visitGrid.insert(grid[nx][ny]);</span><br><span class="line">            &#125;</span><br><span class="line">            result = max(result, area);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="字符串接龙"><a href="#字符串接龙" class="headerlink" title="字符串接龙"></a>字符串接龙</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0110.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%A5%E9%BE%99.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1183">110. 字符串接龙</a></p>
</li>
<li><p>题意：给一个起始字符串和终止字符串，以及一系列字符串，求起始字符串每次更改一个字符，从这些字符串最少更改几步到终止字符串。</p>
</li>
<li><p>方法：看作从起始字符串开始的无向图，向周围bfs（bfs比dfs更方便找最短路径），也就是逐个尝试26字母。</p>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt; </span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;unordered_set&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string beginStr, endStr, str;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    unordered_set&lt;string&gt; strSet;</span><br><span class="line">    cin &gt;&gt; beginStr &gt;&gt; endStr;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; str;</span><br><span class="line">        strSet.insert(str);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 记录字符串是否访问，以及访问到字符串的路径长度</span><br><span class="line">    unordered_map&lt;string, int&gt; visitMap; </span><br><span class="line">    </span><br><span class="line">    // 为了bfs的队列</span><br><span class="line">    queue&lt;string&gt; que;</span><br><span class="line">    que.push(beginStr);</span><br><span class="line">    </span><br><span class="line">    // 起始的长度为1</span><br><span class="line">    visitMap.insert(make_pair(beginStr, 1));</span><br><span class="line">    </span><br><span class="line">    while(!que.empty()) &#123;</span><br><span class="line">        string word = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        int path = visitMap[word];</span><br><span class="line">        </span><br><span class="line">        // 对于word逐个字符尝试替换，然后匹配strSet</span><br><span class="line">        for (int i = 0; i &lt; word.size(); i++) &#123;</span><br><span class="line">            string newWord = word;</span><br><span class="line">            </span><br><span class="line">            // 遍历所有字母</span><br><span class="line">            for (int j = 0; j &lt; 26; j++) &#123;</span><br><span class="line">                newWord[i] = j + &#x27;a&#x27;;</span><br><span class="line">                // 到达重点，直接结束</span><br><span class="line">                if (newWord == endStr) &#123;</span><br><span class="line">                    cout &lt;&lt; path+1 &lt;&lt; endl;</span><br><span class="line">                    return 0;</span><br><span class="line">                &#125;</span><br><span class="line">                // 与字典匹配且没有匹配过</span><br><span class="line">                if (strSet.find(newWord) != strSet.end() &amp;&amp;</span><br><span class="line">                visitMap.find(newWord) == visitMap.end()) &#123;</span><br><span class="line">                    // 记录访问结果，并添加队列</span><br><span class="line">                    visitMap.insert(make_pair(newWord, path+1));</span><br><span class="line">                    que.push(newWord);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 无结果</span><br><span class="line">    cout &lt;&lt; 0 &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/02/16/[Weekly%20Algorithm]%2018%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%9B%BE%E8%AE%BA%EF%BC%88%E4%BA%8C%EF%BC%89/" data-id="cm7j3jecd001e10ag3iqg0jyh" data-title="【Weekly Algorithm】算法周记之《代码随想录》图论（二）" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-[Weekly Algorithm] 17算法周记之《代码随想录》单调栈和图论（一）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/02/09/%5BWeekly%20Algorithm%5D%2017%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8D%95%E8%B0%83%E6%A0%88%E5%92%8C%E5%9B%BE%E8%AE%BA%EF%BC%88%E4%B8%80%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2025-02-09T11:12:00.000Z" itemprop="datePublished">2025-02-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/02/09/%5BWeekly%20Algorithm%5D%2017%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8D%95%E8%B0%83%E6%A0%88%E5%92%8C%E5%9B%BE%E8%AE%BA%EF%BC%88%E4%B8%80%EF%BC%89/">【Weekly Algorithm】算法周记之《代码随想录》单调栈和图论（一）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h1><p>本周跟随《代码随想录》学习关于单调栈的知识，同时开启图论。</p>
<p>单调栈通过保持一个栈从栈顶到栈底的递增或是递减序列，来解决找一个元素左&#x2F;右的“第一个”更大&#x2F;更小元素。</p>
<p>图论则是初窥dfs的门路，虽然道理一年前早在算法课学过考过，但现在也得复习才能捡回来。</p>
<h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><ul>
<li><h2 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a>每日温度</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0739.%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意：给一个整数数组，求每个数字右侧比该数字更大的间距</p>
</li>
<li><p>方法：暴力解法就是O(n^2)的遍历。更高效率的方法是使用单调栈，所谓的单调栈就是从栈顶到栈底递增或递减的，如此排列，就能方便找任意元素的左右第一个更大更小的元素。</p>
<p>比如本题是找右边更大的，那么遍历数组时，遇到更小或相等的元素就直接入栈，而遇到更大的元素就弹栈，直到触底或碰到大元素再入栈，其中弹栈的元素就能记录本元素的下标与当时元素下标之差。  </p>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) &#123;</span><br><span class="line">        vector&lt;int&gt; result(temperatures.size(), 0);</span><br><span class="line"></span><br><span class="line">        stack&lt;int&gt; st;</span><br><span class="line"></span><br><span class="line">        st.push(0);</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; temperatures.size(); i++) &#123;</span><br><span class="line">            if (temperatures[i] &lt;= temperatures[st.top()]) &#123;</span><br><span class="line">                st.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                while(!st.empty() &amp;&amp; temperatures[i] &gt; temperatures[st.top()]) &#123;</span><br><span class="line">                    result[st.top()] = i - st.top();</span><br><span class="line">                    st.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                st.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="下一个更大的元素I"><a href="#下一个更大的元素I" class="headerlink" title="下一个更大的元素I"></a>下一个更大的元素I</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0496.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0I.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-greater-element-i/">496. 下一个更大元素 I - 力扣（LeetCode）</a></p>
</li>
<li><p>题意：给两个整数数组，找一个数组在另一个数组对应元素的下一个更大元素的集合。</p>
</li>
<li><p>方法：用哈希建立两个数组元素和下标的对应，单调栈则实现元素的下一个更大的元素。</p>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">        // 按照代码随想录思路，用哈希表构建两数组之间的映射，然后得出nums2单调栈，由此就得到了结果</span><br><span class="line">        unordered_map&lt;int, int&gt; umap; // 从nums2数字到nums1对应数字下标的映射</span><br><span class="line">        for (int i = 0; i &lt; nums1.size(); i++) &#123;</span><br><span class="line">            umap[nums1[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 求nums2单调栈</span><br><span class="line">        // vector&lt;int&gt; next(nums2.size(), -1);</span><br><span class="line">        stack&lt;int&gt; st;</span><br><span class="line">        vector&lt;int&gt; result(nums1.size(), -1);</span><br><span class="line">        if (result.size() == 1) return result;</span><br><span class="line">        st.push(0);</span><br><span class="line"></span><br><span class="line">        for(int i = 1; i &lt; nums2.size(); i++) &#123;</span><br><span class="line">            if (nums2[i] &lt;= nums2[st.top()]) &#123;</span><br><span class="line">                st.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                while(!st.empty() &amp;&amp; nums2[i] &gt; nums2[st.top()]) &#123;</span><br><span class="line">                    // next[st.top()] = i - st.top();</span><br><span class="line">                    if (umap.count(nums2[st.top()]) &gt; 0) &#123;</span><br><span class="line">                        result[umap[nums2[st.top()]]] = nums2[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                    st.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                st.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="下一个更大的元素II"><a href="#下一个更大的元素II" class="headerlink" title="下一个更大的元素II"></a>下一个更大的元素II</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0503.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0II.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-greater-element-ii/description/">503. 下一个更大元素 II - 力扣（LeetCode）</a></p>
</li>
<li><p>题意：和[[下一个更大的元素I]]相似，但是下一个更大元素要看循环数组。</p>
</li>
<li><p>方法：解决循环以往就有把数组循环乘二的情况，但是这种处理方式对于空间稍显浪费，所以还有一种方式，就是循环时当作两倍的情况。</p>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; result(nums.size(), -1);</span><br><span class="line"></span><br><span class="line">        stack&lt;int&gt; st;</span><br><span class="line">        st.push(0);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; nums.size()*2; i++) &#123;</span><br><span class="line">            if (nums[i % nums.size()] &lt;= nums[st.top()]) &#123;</span><br><span class="line">                st.push(i % nums.size());</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                while(!st.empty() &amp;&amp; nums[i % nums.size()] &gt; nums[st.top()]) &#123;</span><br><span class="line">                    result[st.top()] = nums[i % nums.size()];</span><br><span class="line">                    st.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                st.push(i % nums.size());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0042.%E6%8E%A5%E9%9B%A8%E6%B0%B4.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意，给一个高度数组，每个数字代表柱子高度，求下完雨后，柱子之间积水量</p>
</li>
<li><p>方法，暴力解法，按行或列求，以按列为例，对每一列求其左右最高柱子高度，取最小值，与该列高度差为该列水量。优化方法是用双指针，分别从两侧向另一侧遍历，求每个柱子一侧方向的最高柱子，这样就避免了暴力方法中重复求两侧柱子高度的浪费；</p>
<p>重点在于单调栈方法，按行求，单调栈保持递增（栈顶到栈底），具体处理方法写在注释中  </p>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int trap(vector&lt;int&gt;&amp; height) &#123;</span><br><span class="line">        stack&lt;int&gt; st;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        st.push(0);</span><br><span class="line">        for (int i = 1; i &lt; height.size(); i++) &#123;</span><br><span class="line">            // 三种情况</span><br><span class="line">            // 第一种，后续柱子高度低于栈顶，则直接入栈</span><br><span class="line">            if (height[i] &lt; height[st.top()]) &#123;</span><br><span class="line">                st.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">            // 第二种，后续柱子高度与栈顶一致，则更新栈顶，坐标保留靠右的</span><br><span class="line">            // 因为如果右侧有凹陷，计算积水的左侧左边起始是从靠右的柱子开始计算</span><br><span class="line">            else if (height[i] == height[st.top()]) &#123;</span><br><span class="line">                st.pop();</span><br><span class="line">                st.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">            // 第三种，后续柱子比栈顶高，开始计算积水</span><br><span class="line">            // 总得来说，就是计算i，栈顶和栈顶前一个柱子三个柱子之间的积水</span><br><span class="line">            // 高度上，取左右两柱子的最小值，宽度上，就计算左右柱子的间隔就好</span><br><span class="line">            // 上述步骤循环，直至新柱子小于栈顶位置再入栈（或者栈空）</span><br><span class="line">            // 计算完成后，左侧柱子在栈顶位置，还有计算价值，毕竟说不定后续用作底部柱子使用</span><br><span class="line">            else &#123;</span><br><span class="line">                while(!st.empty() &amp;&amp; height[i] &gt; height[st.top()]) &#123;</span><br><span class="line">                    int bottom = height[st.top()];</span><br><span class="line">                    st.pop();</span><br><span class="line">                    if (!st.empty()) &#123; // 防止遇到没有左侧柱子的情况</span><br><span class="line">                        int h = min(height[i], height[st.top()]) - bottom;</span><br><span class="line">                        int w = i - st.top() - 1;</span><br><span class="line">                        sum += h*w;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                st.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="柱状图中最大的矩形"><a href="#柱状图中最大的矩形" class="headerlink" title="柱状图中最大的矩形"></a>柱状图中最大的矩形</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0084.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-rectangle-in-histogram/submissions/597563485/">84. 柱状图中最大的矩形 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意：给一个柱状图（数组表示）求其中最大矩形面积</p>
</li>
<li><p>方法：实际上与[[接雨水]]相似，但是单调栈方向相反，[[接雨水]]栈顶到栈底递增，如此就能对于每个柱子找到旁边更大的柱子；这里则是递减，找到更小的柱子，以两侧小柱子为下标区间，乘以基准柱子高度，就是一块矩形面积</p>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;</span><br><span class="line">        heights.insert(heights.begin(), 0);</span><br><span class="line">        heights.push_back(0);</span><br><span class="line">        stack&lt;int&gt; st;// 存储下标</span><br><span class="line">        int result = 0;</span><br><span class="line">        </span><br><span class="line">        st.push(0);</span><br><span class="line">        for (int i = 1; i &lt; heights.size(); i++) &#123;</span><br><span class="line">            if (heights[st.top()] &lt; heights[i]) &#123;</span><br><span class="line">                st.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (heights[st.top()] == heights[i]) &#123;</span><br><span class="line">                st.pop();</span><br><span class="line">                st.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                while(!st.empty() &amp;&amp; heights[st.top()] &gt; heights[i]) &#123;</span><br><span class="line">                    int mid = st.top();</span><br><span class="line">                    st.pop();</span><br><span class="line">                    if (!st.empty()) &#123;</span><br><span class="line">                        int left = st.top();</span><br><span class="line">                        int right = i;</span><br><span class="line">                        int w = right - left - 1;</span><br><span class="line">                        int h = heights[mid];</span><br><span class="line">                        result = max(result, h * w);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                st.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><ul>
<li><h2 id="所有可达路径"><a href="#所有可达路径" class="headerlink" title="所有可达路径"></a>所有可达路径</h2></li>
<li><a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0098.%E6%89%80%E6%9C%89%E5%8F%AF%E8%BE%BE%E8%B7%AF%E5%BE%84.html#%E6%9C%AC%E9%A2%98%E4%BB%A3%E7%A0%81">代码随想录</a></li>
<li><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1170">98. 所有可达路径</a></li>
<li>题意：给一个无环有向图，要求一个初次节点到末尾节点的所有路径</li>
<li>方法：dfs，重点在于具体的实现方法，注意邻接矩阵的vector长度，是n+1，因为题目的编号是1-n。还有题目的输出示例格式要求。</li>
<li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">vector&lt;int&gt; path;</span><br><span class="line"></span><br><span class="line">void dfs(vector&lt;vector&lt;int&gt;&gt; &amp;g, int vis, int end) &#123;</span><br><span class="line">    if (vis == end) &#123;</span><br><span class="line">        result.push_back(path);</span><br><span class="line">        // cout &lt;&lt; &quot;path:&quot; &lt;&lt; endl;;</span><br><span class="line">        // for (int i = 0; i &lt; path.size(); i++) &#123;</span><br><span class="line">        //     cout &lt;&lt; path[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">        // &#125;</span><br><span class="line">        // cout &lt;&lt; endl;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= end; i++) &#123;</span><br><span class="line">        if (g[vis][i] == 1) &#123;</span><br><span class="line">            path.push_back(i);</span><br><span class="line">            dfs(g, i, end);</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    </span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    // 用邻接矩阵来存储看看</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; g(n+1, vector&lt;int&gt;(n+1, 0));</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        int s, t;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">        g[s][t] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    path.push_back(1);</span><br><span class="line">    dfs(g, 1, n);</span><br><span class="line">    </span><br><span class="line">    if (result.size() == 0) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; result.size(); i++) &#123;</span><br><span class="line">        vector&lt;int&gt; &amp;t = result[i];</span><br><span class="line">        for (int j = 0; j &lt; t.size()-1; j++) &#123;</span><br><span class="line">            cout &lt;&lt; t[j] &lt;&lt; &quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; t[t.size()-1] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="岛屿数量深搜版"><a href="#岛屿数量深搜版" class="headerlink" title="岛屿数量深搜版"></a>岛屿数量深搜版</h2></li>
<li><a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0099.%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%95%B0%E9%87%8F%E6%B7%B1%E6%90%9C.html#%E6%80%9D%E8%B7%AF">代码随想录</a></li>
<li><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1171">99. 岛屿数量</a></li>
<li>题意：给一个二维数组，数组中横纵相连视为一个岛，求岛屿数量</li>
<li>方法：dfs，模板题，重点在于注意数组的存储</li>
<li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int dir[4][2] = &#123;0, 1, 1, 0, -1, 0, 0, -1&#125;;</span><br><span class="line">void dfs(const vector&lt;vector&lt;int&gt;&gt; &amp;grid, vector&lt;vector&lt;bool&gt;&gt; &amp;visited, int x, int y) &#123;</span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">        int nextx = x + dir[i][0];</span><br><span class="line">        int nexty = y + dir[i][1];</span><br><span class="line">        if (nextx &lt; 0 || nextx &gt;= grid.size() || nexty &lt; 0 || nexty &gt;= grid[0].size()) continue;</span><br><span class="line">        if (!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == 1) &#123;</span><br><span class="line">            visited[nextx][nexty] = true;</span><br><span class="line">            dfs(grid, visited, nextx, nexty);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; grid(n, vector&lt;int&gt;(m, 0));</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;bool&gt;&gt; visited(n, vector&lt;bool&gt;(m, false));</span><br><span class="line">    </span><br><span class="line">    int result = 0;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            if (!visited[i][j] &amp;&amp; grid[i][j] == 1) &#123;</span><br><span class="line">                visited[i][j] = true;</span><br><span class="line">                result++;</span><br><span class="line">                dfs(grid, visited, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/02/09/[Weekly%20Algorithm]%2017%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8D%95%E8%B0%83%E6%A0%88%E5%92%8C%E5%9B%BE%E8%AE%BA%EF%BC%88%E4%B8%80%EF%BC%89/" data-id="cm7j3jecc001b10ag7h93gv6d" data-title="【Weekly Algorithm】算法周记之《代码随想录》单调栈和图论（一）" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-[Weekly Algorithm] 16算法周记之《代码随想录》动态规划（七）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/01/19/%5BWeekly%20Algorithm%5D%2016%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%83%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2025-01-19T12:12:00.000Z" itemprop="datePublished">2025-01-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/01/19/%5BWeekly%20Algorithm%5D%2016%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%83%EF%BC%89/">【Weekly Algorithm】算法周记之《代码随想录》动态规划（七）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h1><p>本周跟随《代码随想录》继续推进动态规划的相关学习，本周主要学习子序列相关内容，其中的编辑距离在网络搜索引擎的期末考试见过。但通过本次学习，逐渐感受到在算法，或者说计算机的世界中，很多事情往往会通过抽象来变得简洁从而易于处理。</p>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><ul>
<li><h2 id="最长重复子数组"><a href="#最长重复子数组" class="headerlink" title="最长重复子数组"></a>最长重复子数组</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0718.%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/">718. 最长重复子数组 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意：给两个数组，问两个数组中最长重复的子数组长度是什么</p>
</li>
<li><p>方法：用二维dp，dp[i][j] 代表第一个数组 i-1 为尾部和第二个数组 j-1 处为尾部，最长重复子数组长度。<br>递推公式，当 num1[i-1]&#x3D;&#x3D;num2[j-1]，即可 dp[i][j] &#x3D; dp[i-1][j-1]+1;<br>初始化，都为0<br>遍历顺序，无所谓，不过从前向后就可<br>举例……  </p>
</li>
<li><p>参考代码随想录思路的解法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findLength(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(nums1.size()+1, vector&lt;int&gt;(nums2.size()+1, 0));</span><br><span class="line">        </span><br><span class="line">        int max_len = 0;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; nums1.size()+1; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; nums2.size()+1; j++) &#123;</span><br><span class="line">                if(nums1[i-1] == nums2[j-1]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-1][j-1] + 1;</span><br><span class="line">                    if (dp[i][j] &gt; max_len) max_len = dp[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return max_len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>优化一下，用滚动数组，注意每次从后向前遍历，以及刷0  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findLength(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">        // vector&lt;vector&lt;int&gt;&gt; dp(nums1.size()+1, vector&lt;int&gt;(nums2.size()+1, 0));</span><br><span class="line">        vector&lt;int&gt; dp(nums2.size()+1, 0);</span><br><span class="line">        </span><br><span class="line">        int max_len = 0;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; nums1.size()+1; i++) &#123;</span><br><span class="line">            for (int j = nums2.size(); j &gt; 0; j--) &#123;</span><br><span class="line">                if(nums1[i-1] == nums2[j-1]) &#123;</span><br><span class="line">                    dp[j] = dp[j-1] + 1;</span><br><span class="line">                    if (dp[j] &gt; max_len) max_len = dp[j];</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    dp[j] = 0; // 需要刷零避免前两层的记录影响</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return max_len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/1143.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-subsequence/description/">1143. 最长公共子序列 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意，给两个字符串，给出两串的最长公共子序列的长度</p>
</li>
<li><p>方法：与[[最长重复子数组]]相近，不过本题不要求连续，所以递推公式除了上一个相同+1之外，还保存两个子序列可能的最长情况。</p>
</li>
<li><p>参考代码随想录的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int longestCommonSubsequence(string text1, string text2) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(text1.size()+1, vector&lt;int&gt;(text2.size()+1, 0));</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; text1.size()+1; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; text2.size()+1; j++) &#123;</span><br><span class="line">                if (text1[i-1] == text2[j-1]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-1][j-1]+1;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // for (int i = 0; i &lt; text1.size()+1; i++) &#123;</span><br><span class="line">        //     for (int j = 0; j &lt; text2.size()+1; j++) &#123;</span><br><span class="line">        //         cout &lt;&lt; dp[i][j] &lt;&lt; &quot; &quot;;</span><br><span class="line">        //     &#125;</span><br><span class="line">        //     cout &lt;&lt; endl;</span><br><span class="line">        // &#125;</span><br><span class="line"></span><br><span class="line">        return dp[text1.size()][text2.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="不相交的线"><a href="#不相交的线" class="headerlink" title="不相交的线"></a>不相交的线</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/1035.%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/uncrossed-lines/">1035. 不相交的线 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意：两个整型数组，相同数字可以两两相连，但是线不能交错。求最大连线数。</p>
</li>
<li><p>方法：换了个题意的[[最长公共子序列]]，除了题目，其余都一样，其余省略。</p>
</li>
<li><h2 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/description/">53. 最大子数组和 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意：给一个数组，找个其中子序列之和最大的和。</p>
</li>
<li><p>方法：<br>dp[i] 是到下标为 i 为尾部的子序列最大和数值<br>递推公式比较有意思，两种情况，一个是延续之前的最大和 dp[i] &#x3D; dp[i-1]+num[i];或者不延续，从 i 处新开 dp[i] &#x3D; num[i]，两种情况取较大数值即可。<br>初始化，dp[0] 取 num[0],其它的初始化不重要，毕竟都会被覆盖。<br>遍历顺序：从前向后。<br>举例：……  </p>
</li>
<li><p>参考代码随想录思路的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(nums.size(), 0);</span><br><span class="line">        dp[0] = nums[0];</span><br><span class="line">        int result = dp[0];</span><br><span class="line">        for (int i = 1; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            dp[i] = max(dp[i-1]+nums[i], nums[i]);</span><br><span class="line">            if (dp[i] &gt; result) &#123;</span><br><span class="line">                result = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        //     cout &lt;&lt; dp[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">        // &#125;</span><br><span class="line">        // cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a>判断子序列</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0392.%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/is-subsequence/submissions/595432953/">392. 判断子序列 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意：给两个字符串序列，判断一个字符串是否为另一个字符串的子序。</p>
</li>
<li><p>方法：其实[[最长公共子序列]]类似，只是说判断公共字符串的长度是否为子串长度相等，而且递推公式中，如果两个字符不相等，稍微更改，只会继承本字符的匹配情况，因为明确表示了该字符串是否为另一字符串的子串，不能反过来。</p>
</li>
<li><p>参考代码随想录思路的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSubsequence(string s, string t) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(s.size()+1, vector&lt;int&gt;( t.size()+1, 0));</span><br><span class="line">        // dp[i][j] 字符串s[i-1] 和 t[j-1] 为止最长子序列长度</span><br><span class="line">        // 初始化 第一行和第一列都为 0 即可</span><br><span class="line">        // 递推公式，当两个字符相等时，dp[i][j]=dp[i-1][j-1]+1;不同时，dp[i][j]则取dp[i][j-1];相当于匹配t失败，延续之前匹配结果（要么是匹配上的情况，要么是0，也就是断匹配了</span><br><span class="line">        for(int i = 1; i &lt;= s.size(); i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= t.size(); j++) &#123;</span><br><span class="line">                if (s[i-1] == t[j-1]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-1][j-1] + 1;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j-1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return (dp[s.size()][t.size()] == s.size()) ? true : false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="不同子序列"><a href="#不同子序列" class="headerlink" title="不同子序列"></a>不同子序列</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/distinct-subsequences/">115. 不同的子序列 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意，判断一个字符串和另一个字符串的几种不同子序列相同（这里的子序列由字符串删除字符获得），求不同子序列的数量。</p>
</li>
<li><p>方法，是编辑距离的简单版，只考虑删除字符的情况，如果对应字符相等，就取上个字符的匹配情况<br><img src="/../assets/image_1737950806585_0.png" alt="image.png"><br>dp[i][j]是s[i]到t[j]匹配时，已有匹配到的数量，这个数量指的是可能出现的前缀数量，如果字符匹配成功，就继承上一个；如果之前有重复字符，则会叠加  </p>
</li>
<li><p>参考代码随想录思路的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numDistinct(string s, string t) &#123;</span><br><span class="line">        vector&lt;vector&lt;uint64_t&gt;&gt; dp(s.size()+1, vector&lt;uint64_t&gt;(t.size()+1, 0));</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; s.size(); i++) &#123;</span><br><span class="line">            dp[i][0] = 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt;= s.size(); i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= t.size(); j++) &#123;</span><br><span class="line">                if (s[i-1] == t[j-1]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    dp[i][j] = dp[i-1][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[s.size()][t.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="两个字符串的删除操作"><a href="#两个字符串的删除操作" class="headerlink" title="两个字符串的删除操作"></a>两个字符串的删除操作</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0583.%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-operation-for-two-strings/">583. 两个字符串的删除操作 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意：给两个字符串，请给出多少次删除（一次删除任意字符串的一个字符）能使两个字符串相等。</p>
</li>
<li><p>方法：</p>
<ol>
<li>dp[i][j] 对于一个字符串的前 i-1 个字符和另一个字符串的前 j-1 个字符相同需要删除次数</li>
<li>递推公式，当字符相同时，dp[i][j] &#x3D; dp[i-1][j-1]；也就是说对于这两个位置的字符不需要删除。当字符不相同时，dp[i][j] &#x3D; min(dp[i-1][j]+1, dp[i][j-1]+1);也就是删除其中个字符串中的字符，那可能说，要是两个字符都要删除呢？这个状态包含于上一次内，也就是说两个删除一个字符情况也就是删除两个字符。</li>
<li>初始化，第一行第一列，分别是一个字符串与空字符串相等需要的删除次数，也就是删完，取字符串长度。</li>
<li>遍历顺序，从前向后，前上到下，普通顺序</li>
<li>举例……</li>
</ol>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minDistance(string word1, string word2) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(word1.size()+1,vector&lt;int&gt;(word2.size()+1, 0));</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; word1.size()+1; i++) &#123;</span><br><span class="line">            dp[i][0] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int j = 0; j &lt; word2.size()+1; j++) &#123;</span><br><span class="line">            dp[0][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; word1.size()+1; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; word2.size()+1; j++) &#123;</span><br><span class="line">                if (word1[i-1] == word2[j-1]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-1][j-1];</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    dp[i][j] = min(dp[i-1][j]+1, dp[i][j-1]+1);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[word1.size()][word2.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0072.%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/edit-distance/description/">72. 编辑距离 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意，给两个字符串，要求编辑距离（也就是对任意字符串增删换使其相同的次数），增一个字符，删一个字符，换一个字符的操作个数。</p>
</li>
<li><p>方法，[[两个字符串的删除操作]]的进阶，现在不只是删除，还有增加字符和替换的操作，但是，增加字符，其实可以等效为另一个字符串删除那个要增加的字符。而替换操作，可以理解为两边字符串同时删除，但只算一次操作(dp[i][j]&#x3D;dp[i-1][j-1]+1)，除了这个递推公式加上一条，其余相同。</p>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minDistance(string word1, string word2) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(word1.size()+1, vector&lt;int&gt;(word2.size()+1, 0));</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; word1.size()+1; i++) &#123;</span><br><span class="line">            dp[i][0] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int j = 0; j &lt; word2.size()+1; j++) &#123;</span><br><span class="line">            dp[0][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; word1.size()+1; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; word2.size()+1; j++) &#123;</span><br><span class="line">                if (word1[i-1] == word2[j-1]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-1][j-1];</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    dp[i][j] = min(&#123;dp[i-1][j-1], dp[i-1][j], dp[i][j-1]&#125;)+1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[word1.size()][word2.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a>回文子串</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0647.%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindromic-substrings/description/">647. 回文子串 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意，给一个字符串，统计其中回文字符串的个数</p>
</li>
<li><p>方法，如果按照之前思路dp[i]代表到下标 i 回文字符串个数的话，各个状态间无联系无规律。故用下面的 dp 定义。<br>除了 dp 定义有改变，还有遍历顺序与以往不太一样，由于递推公式的关系。<br>具体内容在注释中  </p>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int countSubstrings(string s) &#123;</span><br><span class="line">        vector&lt;vector&lt;bool&gt;&gt; dp(s.size(), vector&lt;bool&gt;(s.size(), false));</span><br><span class="line">        // 这里的 dp[i][j] 是字符串 i 到 j（闭区间）是否为回文字符串、</span><br><span class="line">        // 初始化默认全部为 false</span><br><span class="line"></span><br><span class="line">        // 先看递推公式，当 s[i] != s[j] dp[i][j] = false;</span><br><span class="line">        // 复杂的是 s[i] == s[j]时，如果 i==j，那么 dp[i][j] = true，因为”a“算回文字符串</span><br><span class="line">        // 如果j==i+1，那么也是true，“aa”这种情况中也算回文字符串</span><br><span class="line">        // 如果 上述都不是，那么 dp[i][j] = dp[i+1][j-1] ，i到j是否为回文字符串取决于 i+1到j-1是否为回文字符串</span><br><span class="line"></span><br><span class="line">        // 由于递推公式有 dp[i][j] = dp[i+1][j-1],那么要先遍历 i 较大的情况以及 j 较小的情况</span><br><span class="line"></span><br><span class="line">        for(int i = s.size()-1; i &gt;= 0; i--) &#123;</span><br><span class="line">            for (int j = i; j &lt; s.size(); j++) &#123;</span><br><span class="line">                if (s[i] != s[j]) &#123;</span><br><span class="line">                    dp[i][j] = false;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (i == j) &#123;</span><br><span class="line">                    dp[i][j] = true;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (j == i + 1) &#123;</span><br><span class="line">                    dp[i][j] = true;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    dp[i][j] = dp[i+1][j-1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int count = 0;</span><br><span class="line">        for (int i = 0; i &lt; s.size(); i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; s.size(); j++) &#123;</span><br><span class="line">                if (dp[i][j] == true) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                //cout &lt;&lt; dp[i][j] &lt;&lt; &quot; &quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            //cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0516.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-subsequence/description/">516. 最长回文子序列 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意：找出字符串上，最长回文子序列长度（可删字符）</p>
</li>
<li><p>方法：详情写在注释中，值得注意的是，dp是闭区间</p>
</li>
<li><p>参考代码随想录思路的解法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int longestPalindromeSubseq(string s) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(s.size(), vector&lt;int&gt;(s.size(), 0));</span><br><span class="line">        // dp[i][j]代表了 s[i]到s[j] 最长回文子序列的长度</span><br><span class="line"></span><br><span class="line">        // 在 s[i] == s[j] 时，dp[i][j] = dp[i+1][j-1]+2</span><br><span class="line">        // 不相等时， 则从两个方向取大值，dp[i][j] = max(dp[i][j-1], dp[i+1][j]);</span><br><span class="line"></span><br><span class="line">        // 初始化时，所有相等得先赋值1</span><br><span class="line">        for (int i = 0; i &lt; s.size(); i++) dp[i][i] = 1;</span><br><span class="line"></span><br><span class="line">        for (int i = s.size()-1; i &gt;= 0; i--) &#123;</span><br><span class="line">            for (int j = i+1; j &lt; s.size(); j++) &#123;</span><br><span class="line">                if (s[i] == s[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i+1][j-1] + 2;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    dp[i][j] = max(dp[i][j-1], dp[i+1][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[0][s.size()-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/01/19/[Weekly%20Algorithm]%2016%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%83%EF%BC%89/" data-id="cm7j3jecc001910ag0iv36ysi" data-title="【Weekly Algorithm】算法周记之《代码随想录》动态规划（七）" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-[Weekly Algorithm] 15算法周记之《代码随想录》动态规划（六）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/01/12/%5BWeekly%20Algorithm%5D%2015%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E5%85%AD%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2025-01-12T02:06:00.000Z" itemprop="datePublished">2025-01-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/01/12/%5BWeekly%20Algorithm%5D%2015%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E5%85%AD%EF%BC%89/">【Weekly Algorithm】算法周记之《代码随想录》动态规划（六）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h1><p>本周跟随《代码随想录》继续推进动态规划的相关学习，本周主要学习完买卖股票相关内容，并初步探索子序列的部分。</p>
<p>买卖股票的题有明显的状态转换，但子序列就没那么明显。</p>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><ul>
<li><h2 id="买卖股票的最佳时机II"><a href="#买卖股票的最佳时机II" class="headerlink" title="买卖股票的最佳时机II"></a>买卖股票的最佳时机II</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">122. 买卖股票的最佳时机 II - 力扣（LeetCode）</a></p>
</li>
<li><p>题意，在[[买卖股票的最佳时机]]的基础上，要求可以多次购买股票，但同一时段只能持有一支股票，也就是再卖出上一支股票前，不允许购入下一支股票。</p>
</li>
<li><p>方法，与[[买卖股票的最佳时机]]的差别，在于考虑购入当前股票时，是在上一支股票考虑购入和卖出的两个情况中取最大，并非直接取历史最便宜股票和当前股票对比。</p>
</li>
<li><p>参考代码随想录思路解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        // dp[i][0] 考虑第i支股票时，考虑买入的情况；dp[i][1] 考虑第i支股票时，卖出的情况</span><br><span class="line">        int len = prices.size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(len, vector&lt;int&gt;(2, 0));</span><br><span class="line">        dp[0][0] -= prices[0];</span><br><span class="line">        dp[0][1] = 0;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][0] = max(dp[i-1][0], dp[i-1][1]-prices[i]);</span><br><span class="line">            dp[i][1] = max(dp[i-1][1], dp[i-1][0]+prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[len-1][1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="买卖股票的最佳时机III"><a href="#买卖股票的最佳时机III" class="headerlink" title="买卖股票的最佳时机III"></a>买卖股票的最佳时机III</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0123.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III - 力扣（LeetCode）</a></p>
</li>
<li><p>题意，在[[买卖股票的最佳时机II]]基础上，要求最多只能进行两次股票的购入和卖出。</p>
</li>
<li><p>方法，可以想想此前两题的 dp，dp[i] 代表第 i 天，后面是状态，有两状态就是持有和卖出。换到此题就是状态更多了，故本题可设 5 个状态，0 代表不操作（可省略），1 代表第一次持有（不代表一定购入，可能是之前的购入），2代表第一次卖出，3 是第二次持有，4 是第二次卖出。后面的状态均依赖于自己与前一个状态。</p>
<ol>
<li>dp[i][0-4]，意思如上</li>
<li>递推公式，对于持有的状态，dp[i][1] &#x3D; max(dp[i-1][0]-price[i],dp[i-1][1])，就是在不购买的基础上购买当日股票和采用之前购买股票的抉择；对于卖出状态，dp[i][2] &#x3D; max(dp[i-1][1]+price[i], dp[i-1][2]); 就是在前一日购买股票的基础上，售出当日股票与延续此前卖出的抉择；</li>
<li>初始化，dp[0][0] &#x3D; 0, 不作为当然为 0，dp[0][1] &#x3D; -1 * price[0]; 购入股票成本, dp[0][2] &#x3D; 0，马上卖出即无收益；dp[0][3] &#x3D; -1 * price[0]，当日连续第二次买入; dp[0][4] &#x3D; 0; 当日连续第二次卖出。</li>
<li>遍历方向，从前向后</li>
<li>举例……</li>
</ol>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        // 分五个状态，0 是无操作，1 是第一次持有，2 是第一次卖出，3是第二次持有，4是第二次卖出</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(prices.size(), vector&lt;int&gt;(5, 0));</span><br><span class="line">        dp[0][1] -= prices[0];</span><br><span class="line">        dp[0][3] -= prices[0];</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            dp[i][1] = max(dp[i-1][0]-prices[i], dp[i-1][1]);</span><br><span class="line">            dp[i][2] = max(dp[i-1][1]+prices[i], dp[i-1][2]);</span><br><span class="line">            dp[i][3] = max(dp[i-1][2]-prices[i], dp[i-1][3]);</span><br><span class="line">            dp[i][4] = max(dp[i-1][3]+prices[i], dp[i-1][4]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[prices.size()-1][4];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="买卖股票的最佳时机IV"><a href="#买卖股票的最佳时机IV" class="headerlink" title="买卖股票的最佳时机IV"></a>买卖股票的最佳时机IV</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0188.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV - 力扣（LeetCode）</a></p>
</li>
<li><p>题意，在[[买卖股票的最佳时机III]]基础上，将购买股票的次数由 2 次，拓展为变量 k 次</p>
</li>
<li><p>方法，将dp数组拓展为 price.size() 个 2<em>k+1 的 vector，总共有 2</em>k+1 个状态，其余的思想与方法，同[[买卖股票的最佳时机III]]。</p>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        // dp[i][0] 为不操作，dp[i][2*k-1] 为第k笔交易持有, dp[i][2*k] 为第k笔交易卖出，k&gt;=1</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(prices.size(), vector&lt;int&gt;(2*k+1, 0));</span><br><span class="line"></span><br><span class="line">        // 初始化，对于奇数只是单纯买第一天的负价格，而偶数则是一买就卖的 0</span><br><span class="line">        for (int i = 1; i &lt; 2 * k; i+=2) &#123;</span><br><span class="line">            dp[0][i] -= prices[0];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 对往后每一行奇偶，分别是前一笔交易与上一天同笔交易的比较</span><br><span class="line">        for (int i = 1; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; 2*k+1; j+=2) &#123;</span><br><span class="line">                dp[i][j] = max(dp[i-1][j], dp[i-1][j-1]-prices[i]);</span><br><span class="line">                dp[i][j+1] = max(dp[i-1][j+1], dp[i-1][j]+prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[prices.size()-1][2*k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="买卖股票的最佳时机含冷冻期"><a href="#买卖股票的最佳时机含冷冻期" class="headerlink" title="买卖股票的最佳时机含冷冻期"></a>买卖股票的最佳时机含冷冻期</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0309.%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/">309. 买卖股票的最佳时机含冷冻期 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意，在 [[买卖股票的最佳时机II]] 可多次买卖股票的基础上，加入冷冻期，即在卖出股票的一天后，才能再买入股票。</p>
</li>
<li><p>方法，引入四种状态，买入，今日卖出，保持卖出，冷冻期。<br>买入状态可能有前一日的买入状态、保持卖出、冷冻期推出；<br>今日卖出只会由前一日买入状态卖出今日价格得出；<br>冷冻期保存前一日的今日卖出状态；<br>保持卖出则由前一日的保持卖出、冷冻期推出；  </p>
<p>dp[i][j] 则是 i 天的第 j 个状态<br>递推公式由上述的文字推出<br>初始化则是第一日的买入状态为价格负数，其余为零<br>遍历方向从前到后<br>举例……  </p>
</li>
<li><p>参考代码随想录思想的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        int n = prices.size();</span><br><span class="line">        if (n==0) return 0;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt;dp(n, vector&lt;int&gt;(4, 0));</span><br><span class="line">        // dp 有四种状态 1 买入；2 今日卖出；3 保持卖出； 4 冷静期</span><br><span class="line">        // 3 可能为 2 或 4 的延续</span><br><span class="line">        dp[0][0] -= prices[0];</span><br><span class="line">        for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][0] = max(dp[i-1][0], max(dp[i-1][2] - prices[i], dp[i-1][3] - prices[i]));</span><br><span class="line">            dp[i][1] = dp[i-1][0] + prices[i];</span><br><span class="line">            dp[i][2] = max(dp[i-1][2], dp[i-1][3]);</span><br><span class="line">            dp[i][3] = dp[i-1][1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return max(dp[n-1][1], max(dp[n-1][2], dp[n-1][3]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="买卖股票的最佳时机含手续费"><a href="#买卖股票的最佳时机含手续费" class="headerlink" title="买卖股票的最佳时机含手续费"></a>买卖股票的最佳时机含手续费</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0714.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/">714. 买卖股票的最佳时机含手续费 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意，在[[买卖股票的最佳时机II]]可多次交易的基础上，添加手续费，即每次交易后需扣除一定手续费。</p>
</li>
<li><p>方法，与[[买卖股票的最佳时机II]]的唯一差别在于递推公式，将卖出的部分添加手续费即可。</p>
<p>不过，陆爻齐由于太久没碰相关部分，想自己从零推出来，于是整合了三个状态，写下下面的代码  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123;</span><br><span class="line">        // 我觉着有三种状态</span><br><span class="line">        // 第一是直接买入，第二是今日卖出</span><br><span class="line">        // 与之前只会多次交易的题相比，多了个手续费，减一下就行了</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(prices.size(), vector&lt;int&gt;(3, 0));</span><br><span class="line"></span><br><span class="line">        // 递推公式的话，买入就直接取当日价格负数减下去，卖出则取前一日买入加上这一日卖出</span><br><span class="line">        // 初始化，除买入，取0</span><br><span class="line">        dp[0][0] -= prices[0];</span><br><span class="line">        for (int i = 1; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            dp[i][0] = max(dp[i-1][0], dp[i-1][2]-prices[i]);</span><br><span class="line">            dp[i][1] = dp[i-1][0] + prices[i] - fee;</span><br><span class="line">            dp[i][2] = max(dp[i-1][2], dp[i][1]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // for (int i = 0; i &lt; prices.size(); i++) &#123;</span><br><span class="line">        //     cout &lt;&lt; dp[i][0] &lt;&lt; &quot; &quot; &lt;&lt; dp[i][1] &lt;&lt; &quot; &quot; &lt;&lt; dp[i][2] &lt;&lt; endl;</span><br><span class="line">        // &#125;</span><br><span class="line"></span><br><span class="line">        return max(dp[prices.size()-1][1], dp[prices.size()-1][2]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>看完发现，第三个状态确实可以与第二个状态合并，要追求简洁的情况下，每个状态应是由过去的部分推导出来的，如果有状态与现有状态有关，则可考虑适当合并  </p>
<p>于是可以优化成下面的代码，与代码随想录思路相近了  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123;</span><br><span class="line">        // 我觉着有三种状态</span><br><span class="line">        // 第一是直接买入，第二是今日卖出</span><br><span class="line">        // 与之前只会多次交易的题相比，多了个手续费，减一下就行了</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(prices.size(), vector&lt;int&gt;(2, 0));</span><br><span class="line"></span><br><span class="line">        // 递推公式的话，买入就直接取当日价格负数减下去，卖出则取前一日买入加上这一日卖出</span><br><span class="line">        // 初始化，除买入，取0</span><br><span class="line">        dp[0][0] -= prices[0];</span><br><span class="line">        for (int i = 1; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            dp[i][0] = max(dp[i-1][0], dp[i-1][1]-prices[i]);</span><br><span class="line">            dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i] - fee);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // for (int i = 0; i &lt; prices.size(); i++) &#123;</span><br><span class="line">        //     cout &lt;&lt; dp[i][0] &lt;&lt; &quot; &quot; &lt;&lt; dp[i][1] &lt;&lt; &quot; &quot; &lt;&lt; dp[i][2] &lt;&lt; endl;</span><br><span class="line">        // &#125;</span><br><span class="line"></span><br><span class="line">        return dp[prices.size()-1][1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0300.%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97.html">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/description/">300. 最长递增子序列 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意：给一个数组，求其中最长递增子序列的长度，该子序列可由删除数组中元素得出。</p>
</li>
<li><p>方法：用 dp[i] 表示下标 i 之前的最长递增子序列长度，通过循环得出。<br>递推公式：dp[i] &#x3D; max(dp[i], dp[j]+1); j遍历 0 到 i 的元素，该元素数值小于 i 的元素<br>初始化，均初始化为 1，长度至少为 1；<br>遍历顺序：从前往后，毕竟是递增<br>举例：……  </p>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(nums.size(), 1);</span><br><span class="line">        // dp[i]为地址为 i 的最长子序列长度</span><br><span class="line">        int max_len = 1;</span><br><span class="line">        // 外循环遍历数组</span><br><span class="line">        for (int i = 1; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            // 内循环取到已有的最长子序列长度</span><br><span class="line">            for (int j = 0; j &lt;= i; j++) &#123;</span><br><span class="line">                if (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    dp[i] = max(dp[i], dp[j]+1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (dp[i] &gt; max_len) max_len = dp[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return max_len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="最长连续递增序列"><a href="#最长连续递增序列" class="headerlink" title="最长连续递增序列"></a>最长连续递增序列</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0674.%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97.html">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">674. 最长连续递增序列 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意：与[[非递减子序列]]相比，要求子序列得是连续的，中间数据不能删。</p>
</li>
<li><p>方法，不需要代码随想录的思路参考，自己都能分析出来。<br>dp[i] 是下标 i 为末尾的最长连续递增序列长度<br>递推公式为 dp[i] &#x3D; dp[i-1]+1; 前提是 dp[i] &gt; dp[i-1]<br>初始化 全初始化为1<br>遍历方向从前向后<br>举例……  </p>
</li>
<li><p>解法（与代码随想录思路相近）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(nums.size(), 1); // dp[i] 展示前面某一点到下标 i，最长连续递增子序列长度</span><br><span class="line">        int max_len = 1;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            if (nums[i]&gt;nums[i-1]) &#123;</span><br><span class="line">                dp[i] = dp[i-1]+1;</span><br><span class="line">                if (dp[i] &gt; max_len) max_len = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return max_len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/01/12/[Weekly%20Algorithm]%2015%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E5%85%AD%EF%BC%89/" data-id="cm7j3jecb001610aga58rcur4" data-title="【Weekly Algorithm】算法周记之《代码随想录》动态规划（六）" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-[Weekly Algorithm] 14算法周记之《代码随想录》动态规划（五）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/15/%5BWeekly%20Algorithm%5D%2014%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%94%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2024-12-15T03:06:00.000Z" itemprop="datePublished">2024-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/15/%5BWeekly%20Algorithm%5D%2014%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%94%EF%BC%89/">【Weekly Algorithm】算法周记之《代码随想录》动态规划（五）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h1><p>本周跟随《代码随想录》继续推进动态规划的相关学习，本周主要学会了完全背包的应用，多重背包的理论，<del>打劫</del>打家劫舍问题，和股票买卖问题的入门版。认识到了所存储的状态并不只有 整数 这一种形式，还能有多个整数并成的 vector 作为状态使用。</p>
<p>不得不说，动态规划十分的灵活，一百道题入门还不是说说而已啊。</p>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><ul>
<li><h2 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a>完全平方数</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/perfect-squares/description/">279. 完全平方数 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意，给一个整数 n，求其被完全平方数组成的最小个数。</p>
</li>
<li><p>方法，就是[[零钱兑换II]]的变体，给的零钱变成了自己找小于 n 的完全平方数，背包容量为 n</p>
<ol>
<li>dp[j] 含义为 在背包容量为 j 的情况下，完全平方数的最小组合</li>
<li>递推公式，dp[i]&#x3D;min(dp[i],dp[i-j*j]+1)，也就是要么保持不变，要么就在已有的组合上加一</li>
<li>初始化，dp[0]&#x3D;0,这是为了递推公式才这么初始化，也能理解，完全平方数不算 0，不会有组合的</li>
<li>遍历方向，完全背包，从前向后</li>
<li>举例……</li>
</ol>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numSquares(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(n+1, INT_MAX);</span><br><span class="line">        dp[0] = 0;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; n+1; i++) &#123;</span><br><span class="line">            for (int j = 0; j*j &lt; n+1; j++) &#123;</span><br><span class="line">                if (i-j*j &gt;= 0 &amp;&amp; dp[i-j*j]!=INT_MAX) dp[i] = min(dp[i], dp[i-j*j]+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        /*</span><br><span class="line">        for (auto i : dp) &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        */</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a>单词拆分</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0139.%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-break/description/">139. 单词拆分 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意，给字符串列表，看字符串能否由字符串列表中的字符串拼接而成（可重复利用，不要求全都用上）</p>
</li>
<li><p>方法，将字符串看成背包，列表中的字符串就是行李，对于每一处空间，可看其减去列表中字符串大小的前面空间，是否能由字符串列表组成，满足则该空间也能满足，如此便能递推至尾部。但注意本题要求的是排列数而非组合数，因为字符串如何拼接是没有顺序规定的。</p>
<ol>
<li>dp[j] 的意思是对于字符串 s 的前 j 个字符，能否用字符串列表组成</li>
<li>递推公式，if (str_list.find(str) !&#x3D; str_list.end() &amp;&amp; dp[j]) dp[i] &#x3D; true;即当前所截取的字符串在字符串列表中出现，且去掉该字符串的部分能由字符串列表组成，则该下标处的字符串也能由字符串列表组成</li>
<li>初始化，虽然空字符串无法组成，但递推公式决定 dp[0] &#x3D; true</li>
<li>遍历方向，先背包空间后物品，从前向后，求排列数</li>
<li>举例……</li>
</ol>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;</span><br><span class="line">        vector&lt;bool&gt; dp(s.size()+1, false); // dp[j] 代表在下标为 j 处能否由字典组成</span><br><span class="line">        dp[0] = true;</span><br><span class="line">        unordered_set&lt;string&gt; rec(wordDict.begin(), wordDict.end());</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; s.size()+1; i++) &#123;</span><br><span class="line">            // cout&lt;&lt; &quot;i:&quot; &lt;&lt; i &lt;&lt;endl;</span><br><span class="line">            for (int j = 0; j &lt; i; j++) &#123;</span><br><span class="line">                // cout&lt;&lt; &quot;j:&quot; &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">                string word = s.substr(j, i-j);</span><br><span class="line">                // cout&lt;&lt; &quot;word:&quot; &lt;&lt; word &lt;&lt; endl;</span><br><span class="line">                if (rec.find(word) != rec.end() &amp;&amp; dp[j]) &#123;</span><br><span class="line">                    dp[i] = true;</span><br><span class="line">                    // cout&lt;&lt; &quot;True i:&quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[s.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="多重背包理论"><a href="#多重背包理论" class="headerlink" title="多重背包理论"></a>多重背包理论</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85.html#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1066">56. 携带矿石资源（第八期模拟笔试）</a></p>
</li>
<li><p>题意，有 c 个背包空间，给 n 类矿石，每类矿石的重量、价值和最大携带数量</p>
</li>
<li><p>方法，其实是 01 背包的变体，因为把最大携带数量摊平，就是 01 背包，不过其中有一部分物品重量和价值相同，但是直接摊平到 vector 让他动态增长会超时，所以有另一个方法，也就是先遍历物品，再遍历空间，然后遍历空间，向前试探。</p>
<ol>
<li>dp[j] 是在空间 j 上，能容纳的最大价值</li>
<li>递推公式，dp[j] &#x3D; max(dp[j], dp[j - k*weigh[i]]+ k * price[i])，也就是要么就当前的价值，要么就因这个最大携带数量，从小到大，向前试探；</li>
<li>初始化，全 0， 毕竟是找最大价值嘛</li>
<li>遍历顺序，从前向后</li>
<li>举例……</li>
</ol>
</li>
<li><p>参考代码随想录思路的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int bag_size, n;</span><br><span class="line">    cin &gt;&gt; bag_size &gt;&gt; n;</span><br><span class="line">    vector&lt;int&gt; weigh;</span><br><span class="line">    vector&lt;int&gt; price;</span><br><span class="line">    vector&lt;int&gt; num;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        int tmp;</span><br><span class="line">        cin &gt;&gt; tmp;</span><br><span class="line">        weigh.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        int tmp;</span><br><span class="line">        cin &gt;&gt; tmp;</span><br><span class="line">        price.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        int tmp;</span><br><span class="line">        cin &gt;&gt; tmp;</span><br><span class="line">        num.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; dp(bag_size+1, 0);</span><br><span class="line">    for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">        for (int i = bag_size; i &gt;= weigh[j]; i--) &#123;</span><br><span class="line">            for (int k = 1; k &lt;= num[j] &amp;&amp; i - k * weigh[j] &gt;= 0; k++) &#123;</span><br><span class="line">                dp[i] = max(dp[i], dp[i - k * weigh[j]] + k*price[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[bag_size] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber/submissions/586612097/">198. 打家劫舍 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意，给一个数组（一组家），求取其中数值相加的最大值，但取值时不能取连续两值（不能连续偷两家）。</p>
</li>
<li><p>方法，由于每次取值与上一次有关，故递推公式为 dp[i] &#x3D; max(dp[i-1], dp[i-2]+nums[i]);，即要么间隔上一个数并加上当前值，要么考虑上一个数。</p>
<ol>
<li>dp[i] 的意思是在偷到 i 家时，能得到的最大金额；</li>
<li>递推公式， dp[i] &#x3D; max(dp[i-1], dp[i-2]+nums[i])</li>
<li>初始化，全 0，dp[0] &#x3D; nums[0]; dp[1] &#x3D; max(nums[0], nums[1]);</li>
<li>遍历方向，从前向后，其实后向前只要初始化变一变也行（dp[0] &#x3D; nums[nums.size()-1], dp[1] &#x3D; max(dp[0], nums[nums.size()-2]);</li>
<li>举例,……</li>
</ol>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rob(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if (nums.size() == 0) return 0;</span><br><span class="line">        vector&lt;int&gt; dp(nums.size(), 0); // dp[i] 在偷到 i 家时，窃取金额最高的数字</span><br><span class="line">        if (nums.size() == 1) return nums[0];</span><br><span class="line">        dp[0] = nums[0];</span><br><span class="line">        </span><br><span class="line">        dp[1] = max(nums[0], nums[1]);</span><br><span class="line">        for (int i = 2; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            dp[i] = max(dp[i-1], dp[i-2]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[nums.size()-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="打家劫舍II"><a href="#打家劫舍II" class="headerlink" title="打家劫舍II"></a>打家劫舍II</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0213.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-ii/description/">213. 打家劫舍 II - 力扣（LeetCode）</a></p>
</li>
<li><p>题意，在[[打家劫舍]]基础上，由于房屋成环，也就是首尾算相邻屋子，故不能同时取首尾。</p>
</li>
<li><p>方法，考虑有三种情况，1. 只考虑中间的房屋（无首尾）；2. 不考虑尾部屋子；3. 不考虑首部屋子。<br>发现情况 1 在 2 和 3 中，故只要考虑 2 和 3 即可。故可对 2 和 3 分别打家劫舍一次，取价值最高的情况。  </p>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rob(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">       if (nums.size() == 0) return 0;</span><br><span class="line">       if (nums.size() == 1) return nums[0];</span><br><span class="line">       if (nums.size() == 2) return max(nums[0], nums[1]);</span><br><span class="line"></span><br><span class="line">       int result1 = rogRange(nums, 0, nums.size()-2); // 只考虑首元素</span><br><span class="line">       int result2 = rogRange(nums, 1, nums.size()-1); // 只考虑尾元素</span><br><span class="line"></span><br><span class="line">       return max(result1, result2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int rogRange(vector&lt;int&gt; &amp;nums, int start, int end) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(end - start + 1, 0); // dp[j]为偷到 j 家可得最大价值</span><br><span class="line">        //cout &lt;&lt; &quot;start:&quot; &lt;&lt; start &lt;&lt; &quot; &quot; &lt;&lt; &quot;end:&quot; &lt;&lt; end &lt;&lt; endl;</span><br><span class="line">        dp[0] = nums[start];</span><br><span class="line">        dp[1] = max(nums[start], nums[start+1]);</span><br><span class="line">  </span><br><span class="line">        for (int i = start+2; i &lt; end+1; i++) &#123;</span><br><span class="line">            dp[i-start] = max(dp[i-start-1], dp[i-start-2]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return dp[end-start];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="打家劫舍III"><a href="#打家劫舍III" class="headerlink" title="打家劫舍III"></a>打家劫舍III</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0337.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-iii/description/">337. 打家劫舍 III - 力扣（LeetCode）</a></p>
</li>
<li><p>题意，本题可打劫的家变成二叉树形式排列，且同时不能偷一个节点和与之直接相连的节点，即其父节点与两个子节点；</p>
</li>
<li><p>方法，从递归的角度，采用后序遍历，从下向上，一个个计算并比较自己+孙子与儿子的组合哪个更好，采用 unordered map 来存储一个节点对应的值（该值为计算后可得最大价值）。<br>从动态规划的角度，可以让一个节点返回一对数，即不偷该点所得最大价值与偷该点所得最大价值，前者用子节点的最大价值和即可，后者则为该点当前价值加上子节点不偷的价值和。  </p>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; treeRob(TreeNode *root) &#123;</span><br><span class="line">        if (root == nullptr) return &#123;0, 0&#125;; // 不偷当前节点，得 0，偷当前节点，也是0</span><br><span class="line">        //if (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr) return &#123;0, root-&gt;val&#125;;</span><br><span class="line">        vector&lt;int&gt; left = treeRob(root-&gt;left);</span><br><span class="line">        vector&lt;int&gt; right = treeRob(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        int val1 = max(left[0],left[1]) + max(right[0],right[1]);</span><br><span class="line">        int val2 = root-&gt;val + left[0] + right[0];</span><br><span class="line"></span><br><span class="line">        return &#123;val1, val2&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int rob(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; tmp = treeRob(root);</span><br><span class="line">        return max(tmp[0], tmp[1]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意，给一个整型数组，分别是多天的股票价格，可买一天。</p>
</li>
<li><p>方法，用动态规划，记录一天买与不买持有资金，每天迭代选最大</p>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        // dp[i][0] 第i天持有金额（买入股票的利润，负数）</span><br><span class="line">        // dp[i][1] 第i天卖出股票的金额</span><br><span class="line">        /*</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(prices.size(), vector&lt;int&gt;(2, INT_MIN)); </span><br><span class="line">        dp[0][0] = -1 * prices[0];</span><br><span class="line">        dp[0][1] = 0;</span><br><span class="line">        for (int i = 1; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            dp[i][0] = max(dp[i-1][0], -1 * prices[i]);</span><br><span class="line">            dp[i][1] = max(dp[i-1][1], prices[i] + dp[i][0]);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[prices.size()-1][1];</span><br><span class="line">        */</span><br><span class="line">        // dp[i]只依赖于dp[i-1]的状态，优化为滚动数组</span><br><span class="line">        vector&lt;int&gt; dp(2, INT_MIN); </span><br><span class="line">        dp[0] = -1 * prices[0];</span><br><span class="line">        dp[1] = 0;</span><br><span class="line">        for (int i = 1; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            dp[0] = max(dp[0], -1 * prices[i]);</span><br><span class="line">            dp[1] = max(dp[1], prices[i] + dp[0]);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/12/15/[Weekly%20Algorithm]%2014%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%94%EF%BC%89/" data-id="cm7j3jeca001210agf1d531j8" data-title="【Weekly Algorithm】算法周记之《代码随想录》动态规划（五）" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-[Weekly Algorithm] 13算法周记之《代码随想录》动态规划（四）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/08/%5BWeekly%20Algorithm%5D%2013%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E5%9B%9B%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2024-12-08T15:22:00.000Z" itemprop="datePublished">2024-12-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/08/%5BWeekly%20Algorithm%5D%2013%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E5%9B%9B%EF%BC%89/">【Weekly Algorithm】算法周记之《代码随想录》动态规划（四）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h1><p>本周跟随《代码随想录》继续推进动态规划的相关学习，不过周五和周日两门考试太重了，浅做两题，接下来非考试周就继续至少一天一道罢。</p>
<p>本周两道题是完全背包求排列数的应用题和完全背包求 组合&#x2F;排列 的最小组合数，要记得组合与排列的区别在于背包空间和物品的遍历先后顺序，先遍历物品就不会出现物品乱序填背包的情况，所以是求组合数；而先遍历背包空间，使得同一个空间能有相同物品按不同顺序摆放，则是求排列数。</p>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><ul>
<li><h2 id="爬楼梯（进阶版）"><a href="#爬楼梯（进阶版）" class="headerlink" title="爬楼梯（进阶版）"></a>爬楼梯（进阶版）</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%89%88%E6%9C%AC.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1067">57. 爬楼梯（第八期模拟笔试）</a></p>
</li>
<li><p>题意，给 n 个台阶，和一起最多能迈 m 个台阶，问有多少不同方法可爬顶端</p>
</li>
<li><p>方法，由于同一步子可迈多次，故为完全背包问题，而且求的是排列数，与[[组合总和IV]]类似</p>
</li>
<li><p>陆爻齐的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    while(cin &gt;&gt; n &gt;&gt; m)&#123;</span><br><span class="line">        vector&lt;int&gt; dp(n+1, 0); // dp[j]到 j 有 dp[j] 个方法</span><br><span class="line">        </span><br><span class="line">        dp[0] = 1; // 初始化，如此上一阶台阶才能有一个</span><br><span class="line">        </span><br><span class="line">        for (int i = 1; i &lt; n+1; i++) &#123; // 先遍历背包容量，后遍历物品，才能求排列数，否则是组合数</span><br><span class="line">            for (int j = 1; j &lt; m+1; j++) &#123;</span><br><span class="line">                if (i - j &gt;= 0) &#123;</span><br><span class="line">                    dp[i] += dp[i-j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; dp[n] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/description/">322. 零钱兑换 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意，和[[零钱兑换II]]一样，给硬币面额和目标金额，但求的是凑齐该金额的最小硬币数。</p>
</li>
<li><p>方法，由于最小硬币数用组合和排列都行，故先遍历物品还是背包就无所谓了，重点是由于求的是最小，初始化dp数组时不能都是 0，否则递推公式会被覆盖，其它就照常了</p>
<ol>
<li>dp[j] ，凑齐金额 j 的最小硬币数</li>
<li>递推公式，dp[j] &#x3D; min(dp[j], dp[j-coin[i]]+1),不过如果 dp[j-coin[i]] 为初始值，说明这种情况不存在，那就跳过</li>
<li>初始化，dp[0]&#x3D;0, dp[other]&#x3D;INT_MAX</li>
<li>遍历顺序，从前到后，这是滚动数组，实现完全背包</li>
<li>举例……</li>
</ol>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;</span><br><span class="line">        if (amount == 0) return 0;</span><br><span class="line">        vector&lt;int&gt; dp(amount+1, INT_MAX); // dp[j] 为凑齐总金额 j 的最小硬币数</span><br><span class="line">        dp[0] = 0;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; coins.size(); i++) &#123;</span><br><span class="line">            for (int j = coins[i]; j &lt; amount+1; j++) &#123;</span><br><span class="line">                if (dp[j-coins[i]] == INT_MAX) continue;</span><br><span class="line">                dp[j] = min(dp[j], dp[j-coins[i]] + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        /*for (auto i : dp) &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;*/</span><br><span class="line"></span><br><span class="line">        return (dp[amount]==INT_MAX) ? -1 : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/12/08/[Weekly%20Algorithm]%2013%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E5%9B%9B%EF%BC%89/" data-id="cm7j3jecb001410agbdikgt1d" data-title="【Weekly Algorithm】算法周记之《代码随想录》动态规划（四）" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-[Weekly Algorithm] 12算法周记之《代码随想录》动态规划（三）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/01/%5BWeekly%20Algorithm%5D%2012%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%89%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2024-12-01T14:40:00.000Z" itemprop="datePublished">2024-12-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/01/%5BWeekly%20Algorithm%5D%2012%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%89%EF%BC%89/">【Weekly Algorithm】算法周记之《代码随想录》动态规划（三）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h1><p>本周跟随《代码随想录》继续推进动态规划的相关学习，主要是完全背包的入门，体会其与 01 背包的不同与关联。</p>
<p>下周两门考试，教务脑子真是进了水，搞这么紧干嘛。</p>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><ul>
<li><h2 id="完全背包理论"><a href="#完全背包理论" class="headerlink" title="完全背包理论"></a>完全背包理论</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1052">52. 携带研究材料（第七期模拟笔试）</a></p>
</li>
<li><p>题目，与 [[01背包理论]]的差别在于一个物品可携带多次，求最大价值</p>
</li>
<li><p>方法，</p>
<ol>
<li>dp[j]，在遍历物品时，截止到空间为 j，可装入的最大价值</li>
<li>递推公式，dp[j]&#x3D;max(dp[j],dp[j-weigh[i]]+val[i])</li>
<li>初始化，全 0</li>
<li>遍历方向，重点，这是与 01 背包区别最大的地方，01 的滚动数组强调倒序遍历就是为了避免重复，在完全背包中，恰恰需要正序从而利用重复装入物品</li>
<li>举例，……</li>
</ol>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, v;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; v;</span><br><span class="line">    vector&lt;int&gt; weigh;</span><br><span class="line">    vector&lt;int&gt; val;</span><br><span class="line">    // 初始化输入</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        int tmp_w, tmp_v;</span><br><span class="line">        cin &gt;&gt; tmp_w &gt;&gt; tmp_v;</span><br><span class="line">        weigh.push_back(tmp_w);</span><br><span class="line">        val.push_back(tmp_v);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; dp(v+1, 0);</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = weigh[i]; j &lt;= v; j++) &#123;</span><br><span class="line">            dp[j] = max(dp[j], dp[j-weigh[i]]+val[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[v] &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="零钱兑换II"><a href="#零钱兑换II" class="headerlink" title="零钱兑换II"></a>零钱兑换II</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change-ii/description/">518. 零钱兑换 II - 力扣（LeetCode）</a></p>
</li>
<li><p>题意，给硬币面额和目标面额，求凑出目标面额的硬币组合数（ 122 和 221 算重复组合）</p>
</li>
<li><p>方法，</p>
<ol>
<li>dp[j] 是在目标面额为 j 时，组合数</li>
<li>递推公式，dp[j] +&#x3D; dp[j-coin[i]]；</li>
<li>初始化，由于递推公式，决定了 dp[0]&#x3D;1</li>
<li>遍历方向，这是重点，不可颠倒，求组合数就要先遍历硬币面额，后遍历目标面额；求排列数就要先遍历目标面额，后遍历硬币面额；可以这么理解，先遍历硬币面额，就可以让后面 dp[j] 的硬币大小顺序固定，不会出现 221 这种情况。</li>
<li>举例……</li>
</ol>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int change(int amount, vector&lt;int&gt;&amp; coins) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(amount+1, 0); // dp[j] 代表考虑前i种硬币，可以凑出多少种组合</span><br><span class="line">        dp[0] = 1;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; coins.size(); i++) &#123;</span><br><span class="line">            for (int j = coins[i]; j &lt; amount+1; j++) &#123;</span><br><span class="line">                if (dp[j] &lt; INT_MAX - dp[j-coins[i]]) </span><br><span class="line">                    dp[j] += dp[j-coins[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="组合总和IV"><a href="#组合总和IV" class="headerlink" title="组合总和IV"></a>组合总和IV</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iv/description/">377. 组合总和 Ⅳ - 力扣（LeetCode）</a></p>
</li>
<li><p>题意，有一个整数数组与一个目标整数，求整数数组中和为目标数的排列数，其值必为 int 范围内</p>
</li>
<li><p>方法，与[[零钱兑换II]]相似，不同的是，求排列数需要先遍历背包容量，再遍历物品，才能达到取到乱序的效果</p>
</li>
<li><p>陆爻齐试探出的解法，与代码随想录思路相近</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int combinationSum4(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        // dp[j] 即在目标为 j 时，元素组合个数</span><br><span class="line">        vector&lt;int&gt; dp(target+1, 0);</span><br><span class="line">        dp[0] = 1;</span><br><span class="line"></span><br><span class="line">        for (int j = 0; j &lt; target+1; j++) &#123;</span><br><span class="line">            for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">                if (j &gt;= nums[i] &amp;&amp; dp[j] &lt; INT_MAX - dp[j-nums[i]]) dp[j] += dp[j-nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/12/01/[Weekly%20Algorithm]%2012%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%89%EF%BC%89/" data-id="cm7j3jeca001110ag6drd4ghg" data-title="【Weekly Algorithm】算法周记之《代码随想录》动态规划（三）" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-[Weekly Algorithm] 11算法周记之《代码随想录》动态规划（二）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/24/%5BWeekly%20Algorithm%5D%2011%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%8C%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2024-11-24T04:41:00.000Z" itemprop="datePublished">2024-11-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/11/24/%5BWeekly%20Algorithm%5D%2011%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%8C%EF%BC%89/">【Weekly Algorithm】算法周记之《代码随想录》动态规划（二）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h1><p>本周跟随《代码随想录》继续推进动态规划的相关学习，由于期末月的到来，以及题目难度的增加，暂且将动态规划的学习进度放慢一点。下面继续巩固五步法。</p>
<ol>
<li>分析 dp 数组及其下标含义</li>
<li>确定递推公式</li>
<li>确定 dp 数组初始化</li>
<li>确定遍历顺序</li>
<li>举例分析 dp 数组是否如所想迭代</li>
</ol>
<p>只能感叹，这动态规划真是一百道题才入门啊。</p>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><ul>
<li><h2 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-equal-subset-sum/">416. 分割等和子集 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意，给一个数组，返回判断该数组是否能平分为和相等的两部分</p>
</li>
<li><p>方法，直觉上，可以用回溯遍历树，找到那个子节点，但复杂度太高。<br>本题其实就是 01 背包的应用，nums[i] 本身，是物品，重量，以及价值。数组能否平分和的本质，就是平分和的大小的背包能否被刚好装满，也就是下标与值相等。  </p>
</li>
<li><p>参考代码随想录思路的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool canPartition(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int sum = accumulate(nums.begin(), nums.end(), 0); // 求整个数组之和</span><br><span class="line">        if (sum % 2 == 1) return false; // 不可能平分</span><br><span class="line">        int target = sum / 2;</span><br><span class="line">        vector&lt;int&gt; dp(10001, 0); // 由于总和不超 20000，最多 10001 元素足矣，dp[j]是在 j 内最接近 j 的和</span><br><span class="line">        for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            for (int j = target; j &gt;= nums[i]; j--) &#123;</span><br><span class="line">                dp[j] = max(dp[j], dp[j-nums[i]]+nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[target]==target; // 也就是在 target 处刚好有和能与之相等</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="最后一块石头的重量II"><a href="#最后一块石头的重量II" class="headerlink" title="最后一块石头的重量II"></a>最后一块石头的重量II</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/1049.%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/last-stone-weight-ii/">1049. 最后一块石头的重量 II - 力扣（LeetCode）</a></p>
</li>
<li><p>题意，从整型数组中，不断选取两数，使得大数减去小数同时小数消失，直到最后只剩一数，求剩下数字的最小值</p>
</li>
<li><p>方法，本质上，其实就是[[分割等和子集]]，还挺难看出来的。下面是五步法。</p>
<ol>
<li>确定 dp 数组及其下标含义，dp[j] 的意思是不大于 j 的重量内，最接近 j 的数值；</li>
<li>确认递推式，由于石头的重量和价值一体，故 dp[j]&#x3D;max(dp[j], dp[j-stone[i]]+stone[i]);</li>
<li>初始化，要避免初始值覆盖结果，而且重量不为负数，故初始化为 0，即可；</li>
<li>遍历顺序，从前往后即可，没有一定的要求</li>
<li>举例……</li>
</ol>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lastStoneWeightII(vector&lt;int&gt;&amp; stones) &#123;</span><br><span class="line">        int sum = accumulate(stones.begin(), stones.end(), 0);</span><br><span class="line">        int target = sum / 2;</span><br><span class="line">        vector&lt;int&gt; dp(target+1, 0); // 由于重量不为负数，初始化0比较合适</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; stones.size(); i++) &#123;</span><br><span class="line">            for (int j = target; j &gt;= stones[i]; j--) &#123;</span><br><span class="line">                dp[j] = max(dp[j], dp[j-stones[i]]+stones[i]);// 石头的重量和价值同义</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return (sum - dp[target]) - dp[target];// 前者为剩下石头，后者为分出来不大于一半的石头</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a>目标和</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/target-sum/description/">494. 目标和 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意，给一个数组和目标整数，可以数组每个数前用加号或减号，看最后有几个组合可得到目标数</p>
</li>
<li><p>方法，回溯有类似题目，但普通回溯会超时。这里首先要将其转化为 01 背包问题，数组很显然就是行李，需要做一些变换，从两个方程式可知为达成目标值，左边为正号的数字之和，故以此为背包容量，本质就是求有多少个数之和为此和。</p>
<ol>
<li>确定 dp 数组及其下标含义，dp[i][j] 是考虑 0-i 的数字时，目标和为 j 的方案数；</li>
<li>确定递推公式，一个方案多考虑一个物品时相当于，原方案数+必须带上该物品且剩下空间的方案数，dp[i][j] &#x3D; dp[i-1][j]+dp[i-1][j-nums[i]]</li>
<li>初始化，第一行就只有物品大小的那个下标赋值为1，第一列则得看中间 0 的个数，每遇到一个 0，后面放空间 0 的起始方案数就会 * 2</li>
<li>递推顺序，从前向后（滚动数组的空间从后向前）</li>
<li>举例……</li>
</ol>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int sum = accumulate(nums.begin(), nums.end(), 0); // 总和</span><br><span class="line">        if (target &gt; sum) return 0;</span><br><span class="line">        if ((sum+target) % 2 == 1 || (sum+target) &lt; 0) return 0;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">        left + right = sum</span><br><span class="line">        left - right = target</span><br><span class="line">        两式相加除 2 得 left</span><br><span class="line">        */</span><br><span class="line">        int left = (sum + target) / 2;// 也就是为达成目标和，左边为正号的和</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(nums.size(), vector&lt;int&gt;(left+1, 0));</span><br><span class="line">        // dp[i][j] 是从0-i下标的数字中，凑出和为 j 的方法</span><br><span class="line">        // 初始化第一列，容量为0，只有不放一种方法，但是如果是 0，那么该位正负皆可</span><br><span class="line">        int numZero = 0;</span><br><span class="line">        for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            if (nums[i] == 0) numZero++;</span><br><span class="line">            dp[i][0] = (int) pow(2.0, numZero);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 初始化第一行，只有数值恰好相等为1</span><br><span class="line">        for (int i = 1; i &lt; left+1; i++) &#123;</span><br><span class="line">            if (nums[0] &gt; i) continue;</span><br><span class="line">            else if (nums[0] == i) dp[0][i] = 1;</span><br><span class="line">            else break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; left+1; j++) &#123;</span><br><span class="line">                if (j &lt; nums[i]) dp[i][j] = dp[i-1][j];</span><br><span class="line">                else dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i]]; // 相当于不用该物品的旧方法和用该物品的新方法之和</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; left+1;j++) &#123;</span><br><span class="line">                cout &lt;&lt; dp[i][j] &lt;&lt; &quot; &quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        return dp[nums.size()-1][left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="一和零"><a href="#一和零" class="headerlink" title="一和零"></a>一和零</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0474.%E4%B8%80%E5%92%8C%E9%9B%B6.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ones-and-zeroes/submissions/582275874/">474. 一和零 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意，给一个各字符串只由 0 和 1 构成的字符串数组，再给两个整数，要求给出在 0 和 1 分别不超过这两数的情况下，最大子集的字符串个数（真子集）</p>
</li>
<li><p>方法，该题也是 01 背包，这两个分别代表最大 0 和 1 的数相当于两个背包容量的维度，实质上就是要求在这两个维度的束缚下，能装的最大的字符串个数</p>
<ol>
<li>dp[i][j]，最多有 i 个 0 和 j 个 1 的情况下，能装入的最多字符串个数</li>
<li>递推公式，dp[i][j]&#x3D;max(dp[i][j], dp[i-zero_num][j-one_num];意思是在原来的情况，与必须装入该字符串的情况相比，选取可装字符串最多的情况</li>
<li>初始化，由于是求个数，全数组初始化为 0 即可</li>
<li>遍历顺序，由于是二维滚动数组，从后向前</li>
<li>举例……</li>
</ol>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) &#123;</span><br><span class="line">        int zero_num, one_num; // 记录每个字符串的 0 和 1 数</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); // dp[i][j] 指在 i 和 j 的限制数内，包含最大字符串个数</span><br><span class="line">        for (string str : strs) &#123;</span><br><span class="line">            zero_num = 0; one_num = 0;</span><br><span class="line">            for (char c : str) &#123;</span><br><span class="line">                if (c == &#x27;0&#x27;) &#123;</span><br><span class="line">                    zero_num++;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    one_num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 实质就是比较原来的情况与必须加上这个字符串的情况，哪个装的字符串多</span><br><span class="line">            for (int i = m; i &gt;= zero_num; i--) &#123;</span><br><span class="line">                for (int j = n; j &gt;= one_num; j--) &#123;</span><br><span class="line">                    dp[i][j] = max(dp[i][j], dp[i-zero_num][j-one_num]+1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/11/24/[Weekly%20Algorithm]%2011%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%8C%EF%BC%89/" data-id="cm7j3jec9000y10aggeqt2nh0" data-title="【Weekly Algorithm】算法周记之《代码随想录》动态规划（二）" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-[Weekly Algorithm] 10算法周记之《代码随想录》动态规划（一）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/17/%5BWeekly%20Algorithm%5D%2010%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2024-11-17T03:50:00.000Z" itemprop="datePublished">2024-11-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/11/17/%5BWeekly%20Algorithm%5D%2010%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89/">【Weekly Algorithm】算法周记之《代码随想录》动态规划（一）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h1><p>本周跟随《代码随想录》开始学习动态规划的相关题目，从基础的斐波那契数到爬楼梯，再到 01 背包问题，慢慢熟悉动态规划的五步法。<br>《代码随想录》还提醒，调试重点是检查递推公式是否举例，检查打印 dp 数组是否和自己设想一致。</p>
<ol>
<li>分析 dp 数组及其下标含义</li>
<li>确定递推公式</li>
<li>确定 dp 数组初始化</li>
<li>确定遍历顺序</li>
<li>举例分析 dp 数组是否如所想迭代</li>
</ol>
<p>此外除了寻常的二维数组动态规划，也尝试做滚动数组的练习。</p>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><ul>
<li><h2 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a>斐波那契数</h2></li>
<li><p>题意，给一个数字 n，求斐波那契数中的第 n 个数</p>
</li>
<li><p>方法，虽然就算不看代码随想录也能轻易写出，但简单题的重点在于熟悉套路方法，下面按五步分析</p>
<ol>
<li>确定 dp 数组及其下标含义，这里的 dp[i] 代表斐波那契数中的第 i 个数</li>
<li>确认递推公式，题目给出 <code>dp[i]=dp[i-1]+dp[i-2]</code></li>
<li>dp 数组初始化，题目也给出<code>dp[0]=0;dp[1]=1;</code></li>
<li>确定遍历顺序，从递推公式可见，就是从前向后（0-n）遍历</li>
<li>举例推导 dp 公式，0 1 1 2 3 5 8 13 21 ……</li>
</ol>
</li>
<li><p>陆爻齐的解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int fib(int n) &#123;</span><br><span class="line">        if (n &lt;= 1) return n;</span><br><span class="line">        int dp[n+1]; // dp数组为斐波那契数列的存储</span><br><span class="line">        dp[0] = 0; // 初始化dp数组</span><br><span class="line">        dp[1] = 1;</span><br><span class="line">        for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i-1] + dp[i-2]; // 递推公式</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/description/">70. 爬楼梯 - 力扣（LeetCode）</a></p>
</li>
<li><p>题目，设定你一次能爬 1 或 2 层台阶，给你 n 个台阶，求上去的方式数量</p>
</li>
<li><p>方法，简单举例可见，上第 3 层台阶是根据第 1 层台阶和第 2 层台阶的状态决定的，那么就按五步法</p>
<ol>
<li>确认 dp 数组及其下标含义，这里的 dp[i] 表示上到第 i 个台阶的方法；</li>
<li>确认递推公式，从上面简单举例可见，dp[i]&#x3D;dp[i-1]+dp[i-2];也就是从 i-1 上一阶和 i-2 上两阶，若 i-2 上一阶就到 i-1 而不是 i 了；</li>
<li>dp 数组初始化，由于题目也没说 0 层的初始化，那么直接初始化 dp[1]&#x3D;1;dp[2]&#x3D;2;应当是无异议的；</li>
<li>确认遍历顺序，爬楼梯也是从前往后的  </li>
<li>举例推导 dp 数组， 1 2 3 5 8 13 ……</li>
</ol>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int climbStairs(int n) &#123;</span><br><span class="line">        int dp[n+1]; // 爬到第 i 楼梯的方法数</span><br><span class="line">        if (n &lt;= 2) return n;</span><br><span class="line">        dp[1]=1;</span><br><span class="line">        dp[2]=2;</span><br><span class="line">        for (int i = 3; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i-1] + dp[i-2]; // 递推式</span><br><span class="line">        &#125; </span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="使用最小花费爬楼梯"><a href="#使用最小花费爬楼梯" class="headerlink" title="使用最小花费爬楼梯"></a>使用最小花费爬楼梯</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0746.%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意，类似[[爬楼梯]]，但从一级楼梯向上爬一或二级都会消耗体力值，要求爬到顶的最小花费</p>
</li>
<li><p>方法，五步法</p>
<ol>
<li>确认 dp 数组及其下标含义，dp[i] 是到达第 i 阶的最小体力花费</li>
<li>确认递推公式，dp[i] &#x3D; min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])</li>
<li>确认初始化，由于上第一级或第二级不需要体力值，dp[0]&#x3D;0;dp[1]&#x3D;1;</li>
<li>确定遍历顺序，爬楼梯从前往后</li>
<li>举例，……</li>
</ol>
</li>
<li><p>参考代码随想录思路解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123;</span><br><span class="line">        int dp[cost.size()+1]; // dp[i]到达第i阶所需最小体力</span><br><span class="line">        dp[0] = 0; dp[1] = 0; // 初始化，第一步不用体力</span><br><span class="line">        for (int i = 2; i &lt; cost.size()+1; i++) &#123; // 遍历顺序从前到后</span><br><span class="line">            dp[i] = min(dp[i-2]+cost[i-2], dp[i-1]+cost[i-1]); // 递推公式，可从下两阶上两阶或下一阶上一阶</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[cost.size()];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0062.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/description/">62. 不同路径 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意，有一个 [m][n] 的数组，问题从左上角只能向右或向下移动，右下角有几条路径</p>
</li>
<li><p>方法，五步法</p>
<ol>
<li><p>确认 dp 数组及其下标含义，dp[i][j] 表示到达 i，j 的路径和</p>
</li>
<li><p>确认递推式，由于一个格子可由上或左来，故 dp[i][j] &#x3D; dp[i-1][j]+dp[i][j-1];  </p>
</li>
<li><p>确认初始化，陆爻齐在递推过程中判别了边界，所以只初始化 dp[0][0]&#x3D;1; 不过要是不想在中间做判别，可以把边缘初始化了在递推，即 dp[0][<em>]&#x3D;0;dp[</em>][0]&#x3D;0;（这里的 * 泛指数字）</p>
</li>
<li><p>确认遍历顺序，从上向下，从左向右</p>
</li>
<li><p>举例……</p>
</li>
</ol>
</li>
<li><p>陆爻齐的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePaths(int m, int n) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp = vector(m,vector&lt;int&gt;(n, 0)); // dp[i][j] 代表从左上角到 i，j 的路径数</span><br><span class="line">        dp[0][0] = 1; // 由于递推是取上和左路径和，故得取 1</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123; // 从上往下</span><br><span class="line">            for (int j = 0; j &lt; n; j++) &#123; // 从左往右</span><br><span class="line">                if (i &gt; 0) &#123;</span><br><span class="line">                    dp[i][j] += dp[i-1][j];</span><br><span class="line">                &#125;</span><br><span class="line">                if (j &gt; 0) &#123;</span><br><span class="line">                    dp[i][j] += dp[i][j-1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m-1][n-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>参考滚动数组的改进，即二维数组转一维数组  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePaths(int m, int n) &#123;</span><br><span class="line">        vector&lt;int&gt; dp = vector&lt;int&gt;(n, 0); // dp[j] 代表从左上角第 i 轮循环到 i，j 的路径数</span><br><span class="line">        dp[0] = 1; // 由于递推是取上和左路径和，故得取 1</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123; // 从上往下</span><br><span class="line">            for (int j = 0; j &lt; n; j++) &#123; // 从左往右</span><br><span class="line">                if (j &gt; 0) &#123;</span><br><span class="line">                    dp[j] += dp[j-1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>代码随想录的解法  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePaths(int m, int n) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0));</span><br><span class="line">        for (int i = 0; i &lt; m; i++) dp[i][0] = 1;</span><br><span class="line">        for (int j = 0; j &lt; n; j++) dp[0][j] = 1;</span><br><span class="line">        for (int i = 1; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m - 1][n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="不同路径II"><a href="#不同路径II" class="headerlink" title="不同路径II"></a>不同路径II</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0063.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths-ii/description/">63. 不同路径 II - 力扣（LeetCode）</a></p>
</li>
<li><p>题意，与[[不同路径]]类似，不过数组中可能有障碍物</p>
</li>
<li><p>方法，也类似，不过对于障碍物的那一格，就设置为零</p>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123;</span><br><span class="line">        int m = obstacleGrid.size();</span><br><span class="line">        int n = obstacleGrid[0].size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n,0)); // dp[i][j] 为从 0，0 到 i，j 的路径数和</span><br><span class="line">        </span><br><span class="line">        for (int i = 0; i &lt; m &amp;&amp; obstacleGrid[i][0] == 0; i++) &#123;</span><br><span class="line">            dp[i][0] = 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int j = 0; j &lt; n &amp;&amp; obstacleGrid[0][j] == 0; j++) &#123;</span><br><span class="line">            dp[0][j] = 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; n; j++) &#123;</span><br><span class="line">                if (obstacleGrid[i][j] == 1) continue; // 障碍物处路线为 0</span><br><span class="line">                dp[i][j] += dp[i-1][j] + dp[i][j-1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m-1][n-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a>整数拆分</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0343.%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/integer-break/description/">343. 整数拆分 - 力扣（LeetCode）</a></p>
</li>
<li><p>题意，给一个正整数，求其拆分为多个(大于等于2)正整数的最大乘积</p>
</li>
<li><p>方法，</p>
<ol>
<li>确认 dp[i] 的含义，为对 i 拆分多个正整数的最大乘积</li>
<li>确认递推式，dp[i] &#x3D; max(j * (i-j), j * dp[i-j], dp[i])，一是普通情况，拆分两数，三是原本值，二则是利用历史乘积，为拆分多个值的乘积</li>
<li>确认初始化，dp[0], dp[1] &#x3D; 0, 0; dp[2] &#x3D; 1；起码拆两数</li>
<li>遍历顺序，从前往后，虽然前面这些都是前-&gt;后，不过后面有些就不是了</li>
<li>举例……</li>
</ol>
</li>
<li><p>参考代码随想录思路的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int integerBreak(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(n+1, 0); // dp[i] 表示对 i 拆分后的最大乘积</span><br><span class="line">        dp[0] = 0; dp[1] = 0; // 这两没法拆两正整数</span><br><span class="line">        dp[2] = 1;</span><br><span class="line"></span><br><span class="line">        for (int i = 3; i &lt;= n; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= i/2; j++) &#123;</span><br><span class="line">                // 第一个是拆分为 2 个，第二个是拆分为大于 2 个的情况的乘积</span><br><span class="line">                dp[i] = max(j * (i-j), max(j * dp[i-j], dp[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a>不同的二叉搜索树</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0096.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树 - 力扣（LeetCode）</a></p>
</li>
<li><p>问题，给你数字 n，要求返回 n 个节点能组成的二叉搜索树个数</p>
</li>
<li><p>方法，一开始难以下手，总之先看看例子，n &#x3D; 0时，无节点算一个；n&#x3D;1时，也算一个；n&#x3D;2时，算两个，如下图所示<br><img src="/../assets/image_1731631111478_0.png" alt="image.png"><br>n&#x3D;3时，有五个，如下图所示<br><img src="/../assets/image_1731631134171_0.png" alt="image.png"><br>可见，n &#x3D; 3中，其实可分三类，左边两个为一类，是左子树 0 节点，右子树 2 节点，2 * 1 有 2 种； 中间一类，左子树和右子树各 1 节点，有 1 * 1 共 1 种； 右侧一类，左子树 2 节点，右子树 0 节点，有 2 * 1 共 2 种。一共五种。  </p>
</li>
<li><p>五步法：</p>
<ol>
<li>dp[i] 是 i 个节点组成的二叉搜索树的种类数</li>
<li>递推公式： dp[i] +&#x3D; dp[j-1]*dp[i-j]; 右边 i-1 个点，符合题意，毕竟固定有个点放根，不参与左右子树的方案</li>
<li>初始化，0 个节点二叉搜索树有 1 个，dp[0] &#x3D; 1;</li>
<li>遍历顺序，从前往后</li>
<li>举例 ……</li>
</ol>
</li>
<li><p>参考代码随想录思路的解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numTrees(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(n+1, 0); // dp[i] 是 i 个节点组成的二叉搜索树的种类数</span><br><span class="line">        dp[0] = 1; // 0个节点算二叉搜索树、</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= i; j++) &#123;</span><br><span class="line">                dp[i] += dp[j-1] * dp[i-j]; // 左子树方案数 * 右子树方案数</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="01-背包理论"><a href="#01-背包理论" class="headerlink" title="01 背包理论"></a>01 背包理论</h2></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1046">46. 携带研究材料（第六期模拟笔试）</a></p>
</li>
<li><p>题意，01 背包通常不会直接考，更多时候是把情景题转化为 01 背包问题，正如研究材料中，研究材料价值和重量也对应 01 背包</p>
</li>
<li><p>方法，</p>
<ol>
<li>确认 dp数组以及下标含义，dp[i][j] 的意思是当背包大小为 j，从0-i下标材料任选组合价值最大的值</li>
<li>确认递推公式, 若剩余重量不足 dp[i][j] &#x3D; dp[i-1][j] ,剩余重量充足就是 dp[i][j] &#x3D; max(dp[i-1][j], dp[i-1][j-weigh[i]]+val[i])，也就是不加入当前物品的最大价值和加入当前物品的价值与剩余重量最大价值之和相比较。</li>
<li>初始化，第一行和第一列都下应先为 0，再判断第一个物品在第一行是否能放入</li>
<li>遍历顺序，先遍历物品，其中遍历背包容量</li>
<li>举例……</li>
</ol>
</li>
<li><p>但此题还有一点，那就是滚动数组的解法，可以将二维数组转为一维数组，降低空间复杂度，具体可继续按上述五步法</p>
<ol>
<li>确定 dp 数组及其下标含义，dp[j] 的意思是背包空间为 j 时的最大价值容量</li>
<li>递推公式，由于压缩后，每层遍历相当于新值与原坐标的数值比较，dp[j] &#x3D; max(dp[j], dp[j-weigh[i]] + val[i])</li>
<li>初始化，dp[*]&#x3D;0,毕竟可从第一个物品开始做起</li>
<li>遍历顺序，这是该方法重点，必须在遍历空间时倒序，也就是 j 的值必须先取大值到小，从数组的角度，就是从右向左。原因是，每个值的更新可能与其更小坐标相关，如果先更新了小坐标，那么就会影响到大坐标的更新。</li>
<li>举例……</li>
</ol>
</li>
<li><p>参考代码随想录思路的二维数组解法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // init</span><br><span class="line">    int m, n; // 材料个数和背包大小</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    vector&lt;int&gt; weigh(m);// 分别是所占空间和价值</span><br><span class="line">    vector&lt;int&gt; val(m);</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; weigh[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; val[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n+1, 0)); </span><br><span class="line">    // dp[i][j] 为当背包大小为 j，从0-i下标材料任选组合价值最大的值</span><br><span class="line">    // dp[0][*]和dp[*][0]皆已初始化为0，还差第一个材料的初始化</span><br><span class="line">    for (int i = 0; i &lt;= n; i++) &#123;</span><br><span class="line">        if (i &gt;= weigh[0]) dp[0][i] = val[0];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 递推顺序，物品中遍历背包容量（本题反过来貌似也可）</span><br><span class="line">    for (int i = 1; i &lt; m; i++) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= n; j++) &#123;</span><br><span class="line">            if (j &lt; weigh[i]) dp[i][j] = dp[i-1][j];</span><br><span class="line">            else dp[i][j] = max(dp[i-1][j], dp[i-1][j-weigh[i]] + val[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n+1;j++) &#123;</span><br><span class="line">            cout &lt;&lt; dp[i][j] &lt;&lt; &quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    */</span><br><span class="line">    cout &lt;&lt; dp[m-1][n] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>滚动数组的解法  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // init</span><br><span class="line">    int m, n; // 材料个数和背包大小</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    vector&lt;int&gt; weigh(m);// 分别是所占空间和价值</span><br><span class="line">    vector&lt;int&gt; val(m);</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; weigh[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; val[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; dp(n+1, 0); </span><br><span class="line">    // dp[j] 为当背包大小为 j，从0-i下标材料任选组合价值最大的值</span><br><span class="line">    // dp[*]皆已初始化为0</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    // 递推顺序，物品中遍历背包容量（本题反过来貌似也可）</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        for (int j = n; j &gt; 0; j--) &#123;</span><br><span class="line">            if (j &gt;= weigh[i]) dp[j] = max(dp[j] ,dp[j-weigh[i]] + val[i]);</span><br><span class="line">            /*</span><br><span class="line">            for (int j = 0; j &lt; n+1;j++) &#123;</span><br><span class="line">                cout &lt;&lt; dp[j] &lt;&lt; &quot; &quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">            */</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; dp[n] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/11/17/[Weekly%20Algorithm]%2010%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89/" data-id="cm7j3jec9000w10agbth65slr" data-title="【Weekly Algorithm】算法周记之《代码随想录》动态规划（一）" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-[Weekly Algorithm] 9算法周记之《代码随想录》回溯（二）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/10/%5BWeekly%20Algorithm%5D%209%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%9B%9E%E6%BA%AF%EF%BC%88%E4%BA%8C%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2024-11-10T14:32:00.000Z" itemprop="datePublished">2024-11-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/11/10/%5BWeekly%20Algorithm%5D%209%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%9B%9E%E6%BA%AF%EF%BC%88%E4%BA%8C%EF%BC%89/">【Weekly Algorithm】算法周记之《代码随想录》回溯（二）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h1><p>本周跟随《代码随想录》学习回溯的剩余题目，如八皇后，全排列等问题，当初看上去可怕的题目，在回溯的套路下，显得也没那么难，重点在于理解整个回溯的树遍历过程。</p>
<p>通常回溯部分的函数无返回值，但当回溯只求全树唯一一个解时，比如[[全排列]][[解数独]]，可将回溯函数返回值设为 bool 类型，在一个叶子为 true，层层上传，避免无用遍历。</p>
<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><ul>
<li><h2 id="组合总和II"><a href="#组合总和II" class="headerlink" title="组合总和II"></a>组合总和II</h2></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html#%E6%80%9D%E8%B7%AF">代码随想录</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-ii/description/">40. 组合总和 II - 力扣（LeetCode）</a></li>
<li>题意，与[[组合总和III]]类似，但待选数组内出现重复元素，且结果的组合不能重复</li>
<li>方法，重点是分清两种去重，一种是同一树支的去重（纵向），一种是同一树层的去重（横向），两者都可以通过用 used 数组实现，前者要求 used 中同值点不可同时 true 才能加入结果，后者要求同值点必须 true 该点才能加入结果；换句话，used 中 ture 的点说明在同一树支（路径）上</li>
<li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">    vector&lt;int&gt; path;</span><br><span class="line">    void back_track(vector&lt;int&gt; &amp;candidates, int target, vector&lt;int&gt; &amp;used, int sum, int start_index) &#123;</span><br><span class="line">        // 终止条件，和过大或相等</span><br><span class="line">        if (sum &gt; target) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (sum == target) &#123;</span><br><span class="line">            result.push_back(path);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        for (int i = start_index; i &lt; candidates.size(); i++) &#123;</span><br><span class="line">            // 去重，used[i-1] true 说明在同一个路径上</span><br><span class="line">            // used[i-1] flase 说明在同一层，属于要去除的情况</span><br><span class="line">            if (i &gt; 0 &amp;&amp; candidates[i] == candidates[i-1] &amp;&amp; used[i-1] == false) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            used[i] = true;</span><br><span class="line">            path.push_back(candidates[i]);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            back_track(candidates, target, used, sum, i+1);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.pop_back();</span><br><span class="line">            used[i] = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;</span><br><span class="line">        vector&lt;int&gt; used = vector&lt;int&gt;(candidates.size());</span><br><span class="line">        result.clear();</span><br><span class="line">        path.clear();</span><br><span class="line">        sort(candidates.begin(), candidates.end()); // 使数组有序</span><br><span class="line">        back_track(candidates, target, used, 0, 0);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h2></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-partitioning/description/">131. 分割回文串 - 力扣（LeetCode）</a></li>
<li>题意，给一个字符串，把字符串分成多个回文串组成的字符串数组，返回所有组合</li>
<li>方法，难点有两，一是如何分割字符串，二是如何判断回文串。<br>对于一，采用 start_index 作为本层分割字符串的起点，用 for 循环决定重点，递归更新 start_index；对于二，就用 for 循环前后检测是否相等，可以用动态规划优化速度，但太麻烦了，等dp学完再回来罢：）  </li>
<li>参照代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    bool isRevStr(string s) &#123; // 判断回文串，前读和后读一样，其实前半和后半一样就行</span><br><span class="line">        for (int i = 0, j = s.size()-1; i &lt; j; i++,j--) &#123;</span><br><span class="line">            if (s[i] != s[j]) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line">    vector&lt;string&gt; path;</span><br><span class="line"></span><br><span class="line">    void back_track(string s, int start_index) &#123;</span><br><span class="line">        if (start_index &gt;= s.size()) &#123; // start_index 为分割线，分割到字符串外说明前面都割好了</span><br><span class="line">            result.push_back(path);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = start_index; i &lt; s.size(); i++) &#123; </span><br><span class="line">            // 从 start_index 到 i 割串，检测</span><br><span class="line">            string tmp = s.substr(start_index, i-start_index+1);</span><br><span class="line">            //cout &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line">            if (isRevStr(tmp)) &#123;</span><br><span class="line">                path.push_back(tmp);</span><br><span class="line">                back_track(s, i+1);</span><br><span class="line">                path.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123;</span><br><span class="line">        result.clear();</span><br><span class="line">        path.clear();</span><br><span class="line">        back_track(s, 0);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="复原IP地址"><a href="#复原IP地址" class="headerlink" title="复原IP地址"></a>复原IP地址</h2></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0093.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/restore-ip-addresses/description/">93. 复原 IP 地址 - 力扣（LeetCode）</a></li>
<li>题意，有一串数字，可能是 IP 地址，要求返回该数字可能组成所有有效的 IP 地址（最少4位、最多12位，中间有三个点分隔的数字字符串）</li>
<li>方法，与[[分割回文串]]类似，但这里限制了分割的个数，所以需要变量记录，且注意前导0和把字符串转整数的操作</li>
<li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line"></span><br><span class="line">    bool isValid(const string &amp;s, int start_index, int end_index) &#123;</span><br><span class="line">        // 满足字符串是0-255，无前导0，且是数字</span><br><span class="line">        if (start_index &gt; end_index) &#123; // 去除最后 i+2 后 start_index 比 end 大的情况，下面代码没考虑</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (s[start_index] == &#x27;0&#x27; &amp;&amp; start_index != end_index) &#123; // 前导0</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int num = 0; // 记录数值</span><br><span class="line">        for (int i = start_index; i &lt;= end_index; i++) &#123;</span><br><span class="line">            num *=10;</span><br><span class="line">            char c = s[i];</span><br><span class="line">            if (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            num += int(c - &#x27;0&#x27;);</span><br><span class="line">            if (num &gt; 255) &#123;// 过大</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void backTrack(string s, int start_index, int point_num) &#123;</span><br><span class="line">        if (point_num == 3 &amp;&amp; isValid(s, start_index, s.size()-1)) &#123;</span><br><span class="line">            result.push_back(s);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">        for (int i = start_index; i &lt; s.size(); i++) &#123;</span><br><span class="line">            if (isValid(s, start_index, i)) &#123;</span><br><span class="line">                s.insert(s.begin()+i+1, &#x27;.&#x27;); // 采用插点的方式来分割字符串，插入点的下标为 i+1</span><br><span class="line">                point_num++;</span><br><span class="line">                backTrack(s, i+2, point_num);</span><br><span class="line">                point_num--;</span><br><span class="line">                s.erase(s.begin()+i+1);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                break; // 要么数组过大，要么有非法字符，后面的都一定不符合</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; restoreIpAddresses(string s) &#123;</span><br><span class="line">        result.clear();</span><br><span class="line">        if (s.size() &lt; 4 || s.size() &gt; 12) &#123; // ip 地址最少4位，每处最多3位，共12位</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        backTrack(s, 0, 0);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h2></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/description/">78. 子集 - 力扣（LeetCode）</a></li>
<li>题意，给一个整数数组，求其所有子集</li>
<li>方法，回溯，注意由于集合内无序性，元素不能重复；该题其实遍历了树上所有节点，而之前的组合、分割则是收集树中的叶子节点。</li>
<li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">    vector&lt;int&gt; path;</span><br><span class="line"></span><br><span class="line">    void backTrack(vector&lt;int&gt; &amp;nums, int start_index) &#123;</span><br><span class="line">        if (start_index &gt; nums.size()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        result.push_back(path);</span><br><span class="line">        for (int i = start_index; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            path.push_back(nums[i]);</span><br><span class="line">            backTrack(nums, i+1);</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        result.clear();</span><br><span class="line">        path.clear();</span><br><span class="line">        backTrack(nums, 0);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="子集II"><a href="#子集II" class="headerlink" title="子集II"></a>子集II</h2></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0090.%E5%AD%90%E9%9B%86II.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets-ii/description/">90. 子集 II - 力扣（LeetCode）</a></li>
<li>题意，相比[[子集]]，数组中会有重复的数字元素，求的结果子集仍然要求一样</li>
<li>方法，类似[[组合总和II]]，通过 used 去除同层同值的节点造成子集重复的问题</li>
<li>陆爻齐自己解法（与代码随想录思路相近）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">    vector&lt;int&gt; path;</span><br><span class="line"></span><br><span class="line">    void backTrack(vector&lt;int&gt; &amp;nums, int start_index, vector&lt;int&gt; &amp;used) &#123;</span><br><span class="line">        // 记录结果，遍历每个节点</span><br><span class="line">        result.push_back(path);</span><br><span class="line">        if (start_index &gt;= nums.size()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = start_index; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            // 排除那些同层同值的节点</span><br><span class="line">            if (i&gt;0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; used[i-1] == false) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            used[i] = true;</span><br><span class="line">            path.push_back(nums[i]);</span><br><span class="line">            backTrack(nums, i+1, used);</span><br><span class="line">            path.pop_back();</span><br><span class="line">            used[i] = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        result.clear();</span><br><span class="line">        path.clear();</span><br><span class="line">        // 需要有序才能方便去除同层相同数，不排序的话需要哈希表</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        vector&lt;int&gt; used = vector&lt;int&gt;(nums.size());</span><br><span class="line">        backTrack(nums, 0, used);</span><br><span class="line">        return result; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="非递减子序列"><a href="#非递减子序列" class="headerlink" title="非递减子序列"></a>非递减子序列</h2></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0491.%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/non-decreasing-subsequences/description/">491. 非递减子序列 - 力扣（LeetCode）</a></li>
<li>题意，给一个数组，要求返回其中所有至少长度为2的递增子序列</li>
<li>方法，看似与[[子集II]]相似，只要排下序，回溯即可；其实不行，因为一旦排序，整个序列都是递增的，那么如何去重呢？那就要用到 hash。不过本地的数字大小在 -100 到 100，所以用大小为 201 的数组把数字映射上去即可</li>
<li>参考代码随想录思路的代码<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">    vector&lt;int&gt; path;</span><br><span class="line"></span><br><span class="line">    void backTrack(vector&lt;int&gt; &amp;nums, int start_index) &#123;</span><br><span class="line">        if (path.size() &gt;= 2) &#123;</span><br><span class="line">            result.push_back(path); // 添加结果条件</span><br><span class="line">            // 不需要 return，因为需要遍历整个树的节点</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; used = vector&lt;int&gt;(201); // 把-100至100两个个数，映射到0-200 的数组上</span><br><span class="line">        for (int i = start_index; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            if (used[nums[i]+100] == 1) continue; // 去重</span><br><span class="line">            if (path.size() &gt; 0 &amp;&amp; nums[i] &lt; path[path.size()-1]) continue; // 使得新加值不小于path末值</span><br><span class="line">            used[nums[i]+100] = 1; // 只管本层去重，所以记录有就行，不需要恢复0</span><br><span class="line">            path.push_back(nums[i]);</span><br><span class="line">            backTrack(nums, i+1);</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        result.clear();</span><br><span class="line">        path.clear();</span><br><span class="line">        backTrack(nums, 0);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0046.%E5%85%A8%E6%8E%92%E5%88%97.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/description/">46. 全排列 - 力扣（LeetCode）</a></li>
<li>题意，把一个无重复数字的数组所有可能的全排列按任意顺序返回答案</li>
<li>方法，运用回溯，不过由于要求全排列，也就是可能之前的值在下面也用得到，所以不用 start_index</li>
<li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">    vector&lt;int&gt; path;</span><br><span class="line"></span><br><span class="line">    void backTrack(vector&lt;int&gt; &amp;nums,vector&lt;int&gt; &amp;used) &#123;</span><br><span class="line">        if (path.size() == nums.size()) &#123; // 到叶子节点，说明全排列完成</span><br><span class="line">            result.push_back(path);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            if (used[i] == 1) continue; // 排除用过数字的情况</span><br><span class="line">            used[i] = 1;</span><br><span class="line">            path.push_back(nums[i]);</span><br><span class="line">            backTrack(nums, used);</span><br><span class="line">            path.pop_back();</span><br><span class="line">            used[i] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        result.clear();</span><br><span class="line">        path.clear();</span><br><span class="line">        vector&lt;int&gt; used = vector&lt;int&gt;(nums.size());</span><br><span class="line">        backTrack(nums, used);</span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="全排列II"><a href="#全排列II" class="headerlink" title="全排列II"></a>全排列II</h2></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0047.%E5%85%A8%E6%8E%92%E5%88%97II.html#%E6%80%9D%E8%B7%AF">代码随想录</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations-ii/">47. 全排列 II - 力扣（LeetCode）</a></li>
<li>题意，与[[全排列]]类似，但数组中出现重复元素</li>
<li>方法，在[[全排列]]的基础上，加入去重，不过这个去重其实在树枝去重和树层去重都是可以的，但对树层去重效率会高很多，可以举个【1，1，1】的例子试试</li>
<li>参考代码随想录思路的代码<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">    vector&lt;int&gt; path;</span><br><span class="line">    void backTrack(vector&lt;int&gt; &amp;nums, vector&lt;int&gt; &amp;used) &#123;</span><br><span class="line">        if (path.size() == nums.size()) &#123;</span><br><span class="line">            result.push_back(path);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            if (i&gt;0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; used[i-1]==0) continue;</span><br><span class="line">            if (used[i] == 0) &#123;</span><br><span class="line">                used[i] = 1;</span><br><span class="line">                path.push_back(nums[i]);</span><br><span class="line">                backTrack(nums, used);</span><br><span class="line">                path.pop_back();</span><br><span class="line">                used[i] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        result.clear();</span><br><span class="line">        path.clear();</span><br><span class="line">        vector&lt;int&gt; used(nums.size());// 映射这个值是否用过</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        backTrack(nums, used);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="重新安排行程"><a href="#重新安排行程" class="headerlink" title="重新安排行程"></a>重新安排行程</h2></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0332.%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B.html#%E6%80%9D%E8%B7%AF">代码随想录</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reconstruct-itinerary/description/">332. 重新安排行程 - 力扣（LeetCode）</a></li>
<li>题意，给一系列大小为 2 的字符串数组，当作机票的出发地和目的地，要求从 JFK 出发，每张票要用且只能使用一次，要求最后返回一条有效路程，若有多个有效路程则返回字典序最小的那条</li>
<li>方法，主要是如何在回溯过程中记录回溯历程，这里使用了一个 unordered_map&lt;string, map&lt;string, int&gt;&gt; 来记录，翻译为自然语言，就是 unordered_map&lt;出发地, map&lt;目的地，票数&gt;&gt;，map是有序的，直接遍历就是字典序从小到大</li>
<li>参考代码随想录思路的方法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line"></span><br><span class="line">    unordered_map&lt;string,map&lt;string, int&gt;&gt; rec_tic;</span><br><span class="line"></span><br><span class="line">    bool backTrack(int ticket_num) &#123;</span><br><span class="line">        if (ticket_num + 1 == result.size()) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        map&lt;string, int&gt; &amp;target = rec_tic[result[result.size()-1]];</span><br><span class="line">        for (pair&lt;const string, int&gt; &amp;travel : target) &#123;</span><br><span class="line">            if (travel.second &gt; 0) &#123;</span><br><span class="line">                travel.second--;</span><br><span class="line">                result.push_back(travel.first);</span><br><span class="line">                if (backTrack(ticket_num)) return true;</span><br><span class="line">                result.pop_back();</span><br><span class="line">                travel.second++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; findItinerary(vector&lt;vector&lt;string&gt;&gt;&amp; tickets) &#123;</span><br><span class="line">        result.clear();</span><br><span class="line">        rec_tic.clear();</span><br><span class="line"></span><br><span class="line">        for (vector&lt;string&gt; tic : tickets) &#123;</span><br><span class="line">            rec_tic[tic[0]][tic[1]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        result.push_back(&quot;JFK&quot;);</span><br><span class="line">        backTrack(tickets.size());</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h2></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0051.N%E7%9A%87%E5%90%8E.html#%E6%80%9D%E8%B7%AF">代码随想录</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-queens/">51. N 皇后 - 力扣（LeetCode）</a></li>
<li>题意，国际棋盘上，皇后这个棋子同行、同列、两斜线上都是唯一，给棋盘大小，要求摆皇后的所有方案</li>
<li>方法，把行作为递归深度，到底就是得出结果，然后代入回溯模板即可，由于在二维数组上（棋盘）从上往下遍历，故检查下棋位置是否合法只要检测上面即可</li>
<li>参考代码随想录思路的方法，时隔许久再做，好像也没那么恐怖哈<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line">    vector&lt;string&gt; chess_board;</span><br><span class="line"></span><br><span class="line">    bool isValid(int row, int col, int n) &#123;</span><br><span class="line"></span><br><span class="line">        // 检查同列</span><br><span class="line">        for (int i = 0; i &lt; row; i++) &#123;</span><br><span class="line">            if (chess_board[i][col] == &#x27;Q&#x27;) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        // 由于由上向下，故向上检查斜角即可</span><br><span class="line">        // 检查左上方的，45度</span><br><span class="line">        for (int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) &#123;</span><br><span class="line">            if (chess_board[i][j] == &#x27;Q&#x27;) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 检查右上方，135度</span><br><span class="line">        for (int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">            if (chess_board[i][j] == &#x27;Q&#x27;) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void backTrack(int n, int row) &#123;</span><br><span class="line">        if (row == n) &#123;</span><br><span class="line">            result.push_back(chess_board);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int col = 0; col &lt; n; col++) &#123;</span><br><span class="line">            if (isValid(row, col, n)) &#123;</span><br><span class="line">                chess_board[row][col] = &#x27;Q&#x27;;</span><br><span class="line">                backTrack(n, row+1);</span><br><span class="line">                chess_board[row][col] = &#x27;.&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;</span><br><span class="line">        result.clear();</span><br><span class="line">        chess_board.clear();</span><br><span class="line">        chess_board = vector&lt;string&gt;(n, string(n, &#x27;.&#x27;));</span><br><span class="line">        backTrack(n, 0);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="解数独"><a href="#解数独" class="headerlink" title="解数独"></a>解数独</h2></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0037.%E8%A7%A3%E6%95%B0%E7%8B%AC.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sudoku-solver/submissions/579312550/">37. 解数独 - 力扣（LeetCode）</a></li>
<li>题意，给出一个二维数组，其中待填部分为 .，要求填入合适数字完成数独</li>
<li>方法，和[[八皇后]]类似的棋盘问题，也是需要二重回溯，区别就是在判断终止条件，由于该题需要遍历一整棵树找一个合理方案，故让回溯方法返回布尔值，以去除不必要的遍历。</li>
<li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    bool isValid(int row, int col, char k, vector&lt;vector&lt;char&gt;&gt; &amp;board, int size) &#123;</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123; // 同列是否有相同值</span><br><span class="line">            if (board[i][col] == k) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int j = 0; j &lt; size; j++) &#123; // 同行是否有相同值</span><br><span class="line">            if (board[row][j] == k) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int start_row = row/3*3; // 同九方格起始坐标</span><br><span class="line">        int start_col = col/3*3;</span><br><span class="line">        for (int i = start_row; i &lt; start_row + 3; i++) &#123;</span><br><span class="line">            for (int j = start_col; j &lt; start_col + 3; j++)</span><br><span class="line">            if (board[i][j] == k) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool backTrack(vector&lt;vector&lt;char&gt;&gt; &amp;board, int size) &#123;</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; size; j++) &#123;</span><br><span class="line">                if (board[i][j] != &#x27;.&#x27;) continue;</span><br><span class="line">                for (char k = &#x27;1&#x27;; k &lt;= &#x27;9&#x27;; k++) &#123;</span><br><span class="line">                    if (isValid(i, j, k, board, size)) &#123;</span><br><span class="line">                        board[i][j] = k;</span><br><span class="line">                        if (backTrack(board, size)) return true;</span><br><span class="line">                        board[i][j] = &#x27;.&#x27;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                return false; // 如果有一个可填处 9 个值都填不了，那么这个方案不可行</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true; // 如果全填完了，说明必定出现答案了</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;</span><br><span class="line">        backTrack(board, board.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/11/10/[Weekly%20Algorithm]%209%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%9B%9E%E6%BA%AF%EF%BC%88%E4%BA%8C%EF%BC%89/" data-id="cm7j3jecn002110ag85fhehoj" data-title="【Weekly Algorithm】算法周记之《代码随想录》回溯（二）" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-[Weekly Algorithm] 8算法周记之《代码随想录》二叉树（四）与回溯（一）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/03/%5BWeekly%20Algorithm%5D%208%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B8%8E%E5%9B%9E%E6%BA%AF%EF%BC%88%E4%B8%80%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2024-11-03T02:31:00.000Z" itemprop="datePublished">2024-11-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/11/03/%5BWeekly%20Algorithm%5D%208%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B8%8E%E5%9B%9E%E6%BA%AF%EF%BC%88%E4%B8%80%EF%BC%89/">【Weekly Algorithm】算法周记之《代码随想录》二叉树（四）与回溯（一）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h1><p>本周跟随《代码随想录》学习二叉树和二叉搜索树的相关题目，还在递归中主要学习了关于组合的一部分题目。</p>
<p>回溯，用代码随想录中的一句话概括：- for 循环横向遍历，递归纵向遍历，回溯调整结果集。</p>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><ul>
<li><h2 id="二叉搜索树的最小绝对差"><a href="#二叉搜索树的最小绝对差" class="headerlink" title="二叉搜索树的最小绝对差"></a>二叉搜索树的最小绝对差</h2></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0530.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/description/">530. 二叉搜索树的最小绝对差 - 力扣（LeetCode）</a></li>
<li>题意，找二叉搜索树中任意两个节点两值之差的最小值</li>
<li>方法，由于二叉搜索树的本质是有序数组，按中序遍历比较相邻节点之差</li>
<li>陆爻齐的解法 与代码随想录思路相近<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode *pre = nullptr;</span><br><span class="line">    int getMinimumDifference(TreeNode* root) &#123;</span><br><span class="line">        int result = INT32_MAX;</span><br><span class="line">        travel_cal(result, root);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void travel_cal(int &amp;result, TreeNode *root) &#123;</span><br><span class="line">        if (root == nullptr) return;</span><br><span class="line"></span><br><span class="line">        // 下面是中序</span><br><span class="line">        travel_cal(result, root-&gt;left);</span><br><span class="line">        if (pre != nullptr &amp;&amp; (root-&gt;val - pre-&gt;val) &lt; result) &#123;</span><br><span class="line">            result = (root-&gt;val - pre-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line">        travel_cal(result, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="二叉搜索树的众数"><a href="#二叉搜索树的众数" class="headerlink" title="二叉搜索树的众数"></a>二叉搜索树的众数</h2></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0501.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0.html#%E6%80%9D%E8%B7%AF">代码随想录</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">501. 二叉搜索树中的众数 - 力扣（LeetCode）</a></li>
<li>题意就是找二叉搜索树的众数，但可能有多个众数</li>
<li>方法，寻常方法便是遍历，hash 记录频次，转为 vector 排序取众数，时间复杂度 O(n^2)；但由于是二叉搜索树，可以用 O(n) 的方法，即中序遍历时就直接记录频次和当前最高频次的数字，更新频次时清空已记录的数字</li>
<li>陆爻齐参考代码随想录的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // 准备</span><br><span class="line">    vector&lt;int&gt; result;</span><br><span class="line">    int max_count = INT32_MIN;</span><br><span class="line">    int count = 1;</span><br><span class="line">    TreeNode *pre = nullptr;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; findMode(TreeNode* root) &#123;</span><br><span class="line">        travel_val(root);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void travel_val(TreeNode *root) &#123;</span><br><span class="line">        if (root == nullptr) return;</span><br><span class="line"></span><br><span class="line">        // 总体依旧按中序遍历</span><br><span class="line">        travel_val(root-&gt;left);</span><br><span class="line">        if (pre != nullptr) &#123; // 更新频次计数</span><br><span class="line">            if (pre-&gt;val == root-&gt;val) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                count = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root; // 更新上一个点</span><br><span class="line">        if (count == max_count) &#123;</span><br><span class="line">            result.push_back(root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (count &gt; max_count) &#123;</span><br><span class="line">            max_count = count;</span><br><span class="line">            result.clear();</span><br><span class="line">            result.push_back(root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        travel_val(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h2></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html#%E6%80%9D%E8%B7%AF">代码随想录</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/">236. 二叉树的最近公共祖先 - 力扣（LeetCode）</a></li>
<li>题意，二叉树中无 val 相同点，给两个 val 不同点，找到它们的公共祖先</li>
<li>方法，要找公共祖先，最好能自底向上遍历，最类似的遍历是后序遍历，让找到的两个 val 和公共祖先返回上去</li>
<li>陆爻齐参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        // 终止条件，使得上面的点可知道是否子树有 p q</span><br><span class="line">        if (root == nullptr || root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val) return root;</span><br><span class="line">        </span><br><span class="line">        // 遍历左右子树</span><br><span class="line">        TreeNode *left = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">        TreeNode *right = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line"></span><br><span class="line">        // 若有 q 或 p，则返回</span><br><span class="line">        if (left == nullptr || right == nullptr) &#123;</span><br><span class="line">            if (left != nullptr) return left;</span><br><span class="line">            else return right;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123; // 若 q p都有了，那就返回公共祖先</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h2></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0235.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html#%E6%80%9D%E8%B7%AF">代码随想录</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先 - 力扣（LeetCode）</a></li>
<li>题意，与[[二叉树的最近公共祖先]]类似，不过环岛路二叉搜索树上</li>
<li>方法，[[二叉树的最近公共祖先]]的解法也能用，不过二叉搜索树的有序特性能使得代码更简单。由于二叉搜索树中的节点值大于左子树所有节点并小于右子树所有节点，所以两节点的公共祖先的左子树有较小点而右子树有较大点。而从上往下，第一个值在 q 和 p之间的节点就是最近的祖先节点，暂时不知如何证明，姑且作为特性</li>
<li>陆爻齐参照代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        if (p-&gt;val &lt; q-&gt;val) swap(p, q); // 确保 p 总是更大的那个</span><br><span class="line">        return findAncestor(root, p, q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode *findAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        // 终止条件，防止空，虽然本题无太大必要</span><br><span class="line">        if (root == nullptr) return root;</span><br><span class="line"></span><br><span class="line">        if (root-&gt;val &lt; q-&gt;val) &#123;</span><br><span class="line">            return findAncestor(root-&gt;right, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(root-&gt;val &gt; p-&gt;val) &#123;</span><br><span class="line">            return findAncestor(root-&gt;left, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="二叉搜索树中的插入操作"><a href="#二叉搜索树中的插入操作" class="headerlink" title="二叉搜索树中的插入操作"></a>二叉搜索树中的插入操作</h2></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0701.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC">代码随想录</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/description/">701. 二叉搜索树中的插入操作 - 力扣（LeetCode）</a></li>
<li>题意，在二叉搜索树中插入点，并返回插入后的树</li>
<li>方法，在[[二叉搜索树的搜索]]后的结束处插入即可，这是最简单朴实直观的办法，无需重构二叉搜索树</li>
<li>陆爻齐参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* insertIntoBST(TreeNode* root, int val) &#123;</span><br><span class="line">        // 终止条件，找到插入地方</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            TreeNode *result = new TreeNode(val);</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 不会有相同值点的插入寻找</span><br><span class="line">        if (val &gt; root-&gt;val) &#123;</span><br><span class="line">            root-&gt;right = insertIntoBST(root-&gt;right, val);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            root-&gt;left = insertIntoBST(root-&gt;left, val);</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="删除二叉搜索树中的节点"><a href="#删除二叉搜索树中的节点" class="headerlink" title="删除二叉搜索树中的节点"></a>删除二叉搜索树中的节点</h2></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-node-in-a-bst/description/">450. 删除二叉搜索树中的节点 - 力扣（LeetCode）</a></li>
<li>题意，如题要删点后的树</li>
<li>方法，删点有五种情况，1. 没找到，2. 点无子树，3.点只有左子树，4.点只有右子树，5.点左右子树都有。重点是第五种情况，需要把左子树放到右子树的最左节点的左子树，然后用右子树代替</li>
<li>陆爻齐参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* deleteNode(TreeNode* root, int key) &#123;</span><br><span class="line">        if (root == nullptr) return nullptr;</span><br><span class="line">        </span><br><span class="line">        if (root-&gt;val != key) &#123; // 没找到</span><br><span class="line">            root-&gt;left = deleteNode(root-&gt;left, key);</span><br><span class="line">            root-&gt;right = deleteNode(root-&gt;right, key);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr) &#123; // 都为空，直接返空</span><br><span class="line">            delete root;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(root-&gt;left != nullptr &amp;&amp; root-&gt;right == nullptr) &#123; // 只有左</span><br><span class="line">            TreeNode *result = root-&gt;left;</span><br><span class="line">            delete root;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(root-&gt;left == nullptr &amp;&amp; root-&gt;right != nullptr) &#123; // 只有右</span><br><span class="line">            TreeNode *result = root-&gt;right;</span><br><span class="line">            delete root;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123; // 左右都有，把左放右的最左，返右</span><br><span class="line">            TreeNode *cur = root-&gt;right;</span><br><span class="line">            while(cur-&gt;left != nullptr) cur = cur-&gt;left;</span><br><span class="line">            cur-&gt;left = root-&gt;left;</span><br><span class="line">            cur = root-&gt;right;</span><br><span class="line">            delete root;</span><br><span class="line">            return cur;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="修剪二叉搜索树"><a href="#修剪二叉搜索树" class="headerlink" title="修剪二叉搜索树"></a>修剪二叉搜索树</h2></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0669.%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html">代码随想录</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trim-a-binary-search-tree/submissions/577278029/">669. 修剪二叉搜索树 - 力扣（LeetCode）</a></li>
<li>题意，给出一个数值范围，要求二叉搜索树内的节点都得在这个范围内</li>
<li>方法，直观一点可以转为数组重建二叉搜索树，略复杂；其实可以利用二叉搜索树性质，递归返回符合条件的节点来构建二叉搜索树</li>
<li>陆爻齐参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* trimBST(TreeNode* root, int low, int high) &#123;</span><br><span class="line">        if (root == nullptr) return nullptr; // 一个终止条件</span><br><span class="line"></span><br><span class="line">        // 由于二叉搜索树有序，当前根过小或过大就可以直接向另一方向搜索</span><br><span class="line">        if (root-&gt;val &lt; low) &#123;</span><br><span class="line">            return trimBST(root-&gt;right, low, high);</span><br><span class="line">        &#125; </span><br><span class="line">        else if (root-&gt;val &gt; high) &#123;</span><br><span class="line">            return trimBST(root-&gt;left, low, high);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 即使根符合要求，不保证子树所有节点也符合</span><br><span class="line">        root-&gt;left = trimBST(root-&gt;left, low, high);</span><br><span class="line">        root-&gt;right = trimBST(root-&gt;right, low, high);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="将有序数组转换为二叉搜索树"><a href="#将有序数组转换为二叉搜索树" class="headerlink" title="将有序数组转换为二叉搜索树"></a>将有序数组转换为二叉搜索树</h2></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0108.%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html#%E6%80%9D%E8%B7%AF">代码随想录</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树 - 力扣（LeetCode）</a></li>
<li>题意：将有序的升序数组转化为平衡二叉搜索树</li>
<li>方法，平衡，要求点得从中间取，由于升序，故不断取中点递归即可</li>
<li>陆爻齐参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        return buildTree(nums, 0, nums.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode *buildTree(vector&lt;int&gt;&amp; nums, int left, int right) &#123;</span><br><span class="line">        // 终止条件区间长度为0</span><br><span class="line">        if (left == right) &#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 中间，也就是当前的节点</span><br><span class="line">        int middle = (left + right) / 2;</span><br><span class="line">        TreeNode *cur = new TreeNode(nums[middle]);</span><br><span class="line">        cur-&gt;left = buildTree(nums, left, middle);</span><br><span class="line">        cur-&gt;right = buildTree(nums, middle + 1, right);</span><br><span class="line">        return cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="把二叉搜索树转换为累加树"><a href="#把二叉搜索树转换为累加树" class="headerlink" title="把二叉搜索树转换为累加树"></a>把二叉搜索树转换为累加树</h2></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0108.%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树 - 力扣（LeetCode）</a></li>
<li>题意，在二叉搜索树上，从右向左，从下向上，把点的值累加上去</li>
<li>方法，经观察，点加值的情况符合“右中左”的遍历顺序，故用一个变量记录遍历过的点的累加值，并按右中左来遍历</li>
<li>参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int pre = 0;</span><br><span class="line">    TreeNode* convertBST(TreeNode* root) &#123;</span><br><span class="line">        if (root == nullptr) return nullptr;</span><br><span class="line">        root-&gt;right = convertBST(root-&gt;right);</span><br><span class="line">        pre += root-&gt;val;</span><br><span class="line">        root-&gt;val = pre;</span><br><span class="line">        root-&gt;left = convertBST(root-&gt;left);</span><br><span class="line"></span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><ul>
<li><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html#%E6%80%9D%E8%B7%AF">代码随想录</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combinations/description/">77. 组合 - 力扣（LeetCode）</a></li>
<li>题意，在 1-n 个数中，取 k 个数的所有组合</li>
<li>方法，采用普通的回溯方法，注意优化方法，由于限制要 k 个，所以如果一层的 for 循环最多只要遍历到 n-(k-层数)+1 即可，加一是因为自己要求了左闭区间</li>
<li>陆爻齐参考代码随想录思路的剪枝代码<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">    vector&lt;int&gt; path;</span><br><span class="line">    void backtrack(int n, int k, int start_index) &#123;</span><br><span class="line">        // 终止条件保存结果</span><br><span class="line">        if (k == path.size()) &#123;</span><br><span class="line">            result.push_back(path);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 寻找组合</span><br><span class="line">        for (int i = start_index; i &lt;= (n - (k - path.size()) + 1); i++) &#123;</span><br><span class="line">            path.push_back(i);</span><br><span class="line">            backtrack(n, k, i+1);</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;</span><br><span class="line">        // 两个clear是为了保险</span><br><span class="line">        result.clear();</span><br><span class="line">        path.clear();</span><br><span class="line">        backtrack(n, k , 1);</span><br><span class="line">        return result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和 |||"></a>组合总和 |||</h2></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html#%E6%80%9D%E8%B7%AF">代码随想录</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iii/description/">216. 组合总和 III - 力扣（LeetCode）</a></li>
<li>该题要求，收集所有从1-9中选取 k 个不重复的数字组成和为 n 的组合</li>
<li>方法，就是在[[组合]]上简单改造终止条件为和为n，剪枝可从和入手，过大就剪</li>
<li>陆爻齐的剪枝思路，和代码随想录思路差不多<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">    vector&lt;int&gt; path;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    void backTrack(int k, int n, int start_index) &#123;</span><br><span class="line">        if(sum &gt; n) &#123; // 剪枝</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (path.size() == k) &#123; // 终止条件</span><br><span class="line">            if(sum == n) result.push_back(path);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 单层处理</span><br><span class="line">        for (int i = start_index; i &lt; 10; i++) &#123;</span><br><span class="line">            path.push_back(i);</span><br><span class="line">            sum += i;</span><br><span class="line">            backTrack(k, n, i+1);</span><br><span class="line">            path.pop_back();</span><br><span class="line">            sum -= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123;</span><br><span class="line">        result.clear();</span><br><span class="line">        path.clear();</span><br><span class="line">        backTrack(k, n, 1);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h2></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/">17. 电话号码的字母组合 - 力扣（LeetCode）</a></li>
<li>题意，电话号码中的2-9各对应几个字母，要求根据一串2-9的数字来排列出所有字母组合</li>
<li>方法，在[[组合]]的基础上，该题有多个字母区间，可先用数组存下下标数字与字符串的对应，再做单层遍历</li>
<li>陆爻齐参照代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    string path;</span><br><span class="line">    vector&lt;string&gt; str_map = &#123;</span><br><span class="line">        &quot;&quot;,</span><br><span class="line">        &quot;&quot;,</span><br><span class="line">        &quot;abc&quot;,</span><br><span class="line">        &quot;def&quot;,</span><br><span class="line">        &quot;ghi&quot;,</span><br><span class="line">        &quot;jkl&quot;,</span><br><span class="line">        &quot;mno&quot;,</span><br><span class="line">        &quot;pqrs&quot;,</span><br><span class="line">        &quot;tuv&quot;,</span><br><span class="line">        &quot;wxyz&quot;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    void back_track(const string &amp;digits, int start_index) &#123;</span><br><span class="line">        if (start_index == digits.size()) &#123;</span><br><span class="line">            result.push_back(path);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string range = str_map[int(digits[start_index] - &#x27;0&#x27;)];</span><br><span class="line">        for (auto c : range) &#123;</span><br><span class="line">            path += c;</span><br><span class="line">            back_track(digits, start_index+1);</span><br><span class="line">            path = path.substr(0, path.size()-1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; letterCombinations(string digits) &#123;</span><br><span class="line">        result.clear();</span><br><span class="line">        path.clear();</span><br><span class="line">        if (digits.size() == 0) return result;</span><br><span class="line">        back_track(digits, 0);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="组合总和-1"><a href="#组合总和-1" class="headerlink" title="组合总和"></a>组合总和</h2></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html#%E6%80%9D%E8%B7%AF">代码随想录</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum/description/">39. 组合总和 - 力扣（LeetCode）</a></li>
<li>题意，从无重复元素且数字大于零的整形数组中可重复选取元素，选出所有和为 target 的组合</li>
<li>方法，由于可重复选取，故在递归下一层时，不用令选值区间左侧+1来避免重复，且可通过排序然后剪去和大于目标的部分剪枝</li>
<li>陆爻齐参考代码随想录思路的方法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">    vector&lt;int&gt; path;</span><br><span class="line"></span><br><span class="line">    void back_track(vector&lt;int&gt; &amp;candidates, int target, int sum, int start_index) &#123;</span><br><span class="line">        // 终止条件</span><br><span class="line">        if (sum &gt; target) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (sum == target) result.push_back(path);</span><br><span class="line">        // 排序后，可根据和大于目标来剪枝</span><br><span class="line">        for (int i = start_index; i &lt; candidates.size() &amp;&amp; sum + candidates[i] &lt;= target; i++) &#123;</span><br><span class="line">            path.push_back(candidates[i]);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            back_track(candidates, target, sum, i);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;</span><br><span class="line">        result.clear();</span><br><span class="line">        path.clear();</span><br><span class="line">        sort(candidates.begin(), candidates.end()); // 便于剪枝的排序</span><br><span class="line">        back_track(candidates, target, 0, 0);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/11/03/[Weekly%20Algorithm]%208%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B8%8E%E5%9B%9E%E6%BA%AF%EF%BC%88%E4%B8%80%EF%BC%89/" data-id="cm7j3jecm001w10ag9w8xadps" data-title="【Weekly Algorithm】算法周记之《代码随想录》二叉树（四）与回溯（一）" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-[Weekly Algorithm] 7算法周记之《代码随想录》二叉树（三）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/27/%5BWeekly%20Algorithm%5D%207%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E4%B8%89%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2024-10-27T13:11:00.000Z" itemprop="datePublished">2024-10-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/27/%5BWeekly%20Algorithm%5D%207%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E4%B8%89%EF%BC%89/">【Weekly Algorithm】算法周记之《代码随想录》二叉树（三）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h1><p>本周跟随《代码随想录》学习二叉树和二叉搜索树的算法题目，比如完全二叉树的节点个数，平衡二叉树，二叉树的路径、二叉树的合并，二叉搜索树的检索和验证等。</p>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><ul>
<li><h2 id="完全二叉树的节点个数"><a href="#完全二叉树的节点个数" class="headerlink" title="完全二叉树的节点个数"></a>完全二叉树的节点个数</h2></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0222.%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0.html#%E6%80%9D%E8%B7%AF">代码随想录</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-complete-tree-nodes/description/">222. 完全二叉树的节点个数 - 力扣（LeetCode）</a></li>
<li>题意就是让你求一个完全二叉树的节点个数</li>
<li>方法有大致两种，一种是把这个当普通二叉树求，直接先序、中序、后序遍历都行，统计节点，时间复杂度 O(n)；第二种是利用完全二叉树的特性，由于完全二叉树可视作是满二叉树组成的二叉树，满二叉树的节点由深度 n，经 2^n - 1 计算得出。</li>
<li>陆爻齐的先序求法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int result = 0;</span><br><span class="line">    int countNodes(TreeNode* root) &#123;</span><br><span class="line">        pre_val(root);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void pre_val(TreeNode *root) &#123;</span><br><span class="line">        if (root == nullptr) return;</span><br><span class="line"></span><br><span class="line">        result++;</span><br><span class="line">        pre_val(root-&gt;left);</span><br><span class="line">        pre_val(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
陆爻齐参照代码随想录思路写的利用完全二叉树特性解法  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    int countNodes(TreeNode* root) &#123;</span><br><span class="line">        int result = full_val(root);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int full_val(TreeNode *root) &#123;</span><br><span class="line">        // 空指针的情况</span><br><span class="line">        if (root == nullptr) return 0;</span><br><span class="line"></span><br><span class="line">        // 满二叉树的情况</span><br><span class="line">        int left_depth = 0, right_depth = 0;</span><br><span class="line">        TreeNode *left = root, *right = root;</span><br><span class="line">        while (left) &#123;</span><br><span class="line">            left = left-&gt;left;</span><br><span class="line">            left_depth++;</span><br><span class="line">        &#125;</span><br><span class="line">        while (right) &#123;</span><br><span class="line">            right = right-&gt;right;</span><br><span class="line">            right_depth;</span><br><span class="line">        &#125;</span><br><span class="line">        if (left_depth == right_depth) &#123; // 左边深度与右边相等是满二叉树</span><br><span class="line">            return (2 &lt;&lt; left_depth) - 1; // 节点数量为 2 的深度次方 - 1</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 非满二叉树，可递归下去</span><br><span class="line">        int left_nodes = full_val(root-&gt;left);</span><br><span class="line">        int right_nodes = full_val(root-&gt;right);</span><br><span class="line">        return left_nodes + right_nodes + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E6%9C%AC%E9%A2%98%E6%80%9D%E8%B7%AF">代码随想录</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/balanced-binary-tree/description/">110. 平衡二叉树 - 力扣（LeetCode）</a></li>
<li>题意，判断该二叉树是否为平衡二叉树，即左右子树高度差小于等于一，高度为节点到叶子节点的最远距离</li>
<li>方法就是利用递归求两侧高度，若有非平衡二叉树情况，则使得整棵树不是即可</li>
<li>陆爻齐参照代码随想录思路解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isBalanced(TreeNode* root) &#123;</span><br><span class="line">        return getHeight(root) == -1 ? false : true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int getHeight(TreeNode *root) &#123;</span><br><span class="line">        // 叶子节点高度为 0</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 左右子树若有非平衡二叉树，则该二叉树非平衡二叉树</span><br><span class="line">        int left_height = getHeight(root-&gt;left);</span><br><span class="line">        if (left_height == -1) return -1;</span><br><span class="line">        int right_height = getHeight(root-&gt;right);</span><br><span class="line">        if (right_height == -1) return -1;</span><br><span class="line"></span><br><span class="line">        return abs(left_height - right_height) &gt; 1 ? -1 : max(left_height, right_height) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="二叉树的所有路径"><a href="#二叉树的所有路径" class="headerlink" title="二叉树的所有路径"></a>二叉树的所有路径</h2></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html#%E6%80%9D%E8%B7%AF">代码随想录</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-paths/description/">257. 二叉树的所有路径 - 力扣（LeetCode）</a></li>
<li>题意，找到二叉树从根节点到叶子节点的所有路径</li>
<li>方法，回溯递归，最重要的点在于，传的 string path 最好不要引用传递，因为每个节点放进去的数字可能有好几位，传引用需要精确去除数字，比较麻烦，传值的话就不用担心后面加的数字影响到这一层的 path。</li>
<li>陆爻齐参照代码随想录修复了 path 引用bug的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123;</span><br><span class="line">        string path;</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        all_val(root, path, result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 这个path用复制非常重要，引用很难去除本点值</span><br><span class="line">    void all_val(TreeNode *root, string path, vector&lt;string&gt; &amp;result) &#123;</span><br><span class="line">        // 防第一个点就是空</span><br><span class="line">        if (root == nullptr) return;</span><br><span class="line">        </span><br><span class="line">        // 非空时，加入该点值</span><br><span class="line">        path += to_string(root-&gt;val);</span><br><span class="line">        //cout &lt;&lt; path &lt;&lt; endl;</span><br><span class="line">        path += &quot;-&gt;&quot;;</span><br><span class="line">        if (root-&gt;left != nullptr) &#123; // 左子树</span><br><span class="line">            all_val(root-&gt;left, path, result); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (root-&gt;right != nullptr) &#123; // 右子树</span><br><span class="line">            all_val(root-&gt;right, path, result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        path = path.substr(0, path.size() - 2); // 去除-》</span><br><span class="line">        // 加入叶子节点的路径</span><br><span class="line">        if (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr) &#123;</span><br><span class="line">            result.push_back(path);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
代码随想录的解法  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    void traversal(TreeNode* cur, string path, vector&lt;string&gt;&amp; result) &#123;</span><br><span class="line">        path += to_string(cur-&gt;val); // 中，中为什么写在这里，因为最后一个节点也要加入到path中</span><br><span class="line">        if (cur-&gt;left == NULL &amp;&amp; cur-&gt;right == NULL) &#123;</span><br><span class="line">            result.push_back(path);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (cur-&gt;left) &#123;</span><br><span class="line">            path += &quot;-&gt;&quot;;</span><br><span class="line">            traversal(cur-&gt;left, path, result); // 左</span><br><span class="line">            path.pop_back(); // 回溯 &#x27;&gt;&#x27;</span><br><span class="line">            path.pop_back(); // 回溯 &#x27;-&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        if (cur-&gt;right) &#123;</span><br><span class="line">            path += &quot;-&gt;&quot;;</span><br><span class="line">            traversal(cur-&gt;right, path, result); // 右</span><br><span class="line">            path.pop_back(); // 回溯&#x27;&gt;&#x27;</span><br><span class="line">            path.pop_back(); // 回溯 &#x27;-&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        string path;</span><br><span class="line">        if (root == NULL) return result;</span><br><span class="line">        traversal(root, path, result);</span><br><span class="line">        return result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="左叶子之和"><a href="#左叶子之和" class="headerlink" title="左叶子之和"></a>左叶子之和</h2></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0404.%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C.html#%E6%80%9D%E8%B7%AF">代码随想录</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-of-left-leaves/description/">404. 左叶子之和 - 力扣（LeetCode）</a></li>
<li>题意，找出二叉树中的所有左叶子节点，求其和</li>
<li>方法，不难，重点是左叶子的定义，若 A 点的左节点非空为 B，B 无左节点和右节点，那么 B 为左叶子，由此便可直接遍历找左叶子即可</li>
<li>陆爻齐的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int sumOfLeftLeaves(TreeNode* root) &#123;</span><br><span class="line">        int result = 0;</span><br><span class="line">        pre_val_pro(root, result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void pre_val_pro(TreeNode *root, int &amp;result) &#123;</span><br><span class="line">        if (root == nullptr) return; // 排除空的场景</span><br><span class="line"></span><br><span class="line">        // 添加左叶子节点</span><br><span class="line">        if (root-&gt;left != nullptr &amp;&amp; root-&gt;left-&gt;left == nullptr &amp;&amp; root-&gt;left-&gt;right == nullptr) &#123;</span><br><span class="line">            result+=root-&gt;left-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 遍历左右子树</span><br><span class="line">        pre_val_pro(root-&gt;left, result);</span><br><span class="line">        pre_val_pro(root-&gt;right, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
代码随想录的解法  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int sumOfLeftLeaves(TreeNode* root) &#123;</span><br><span class="line">        if (root == NULL) return 0;</span><br><span class="line">        if (root-&gt;left == NULL &amp;&amp; root-&gt;right== NULL) return 0; //陆爻齐注释后也可AC，这是加速进程的</span><br><span class="line"></span><br><span class="line">        int leftValue = sumOfLeftLeaves(root-&gt;left);    // 左</span><br><span class="line">        if (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) &#123; // 左子树就是一个左叶子的情况</span><br><span class="line">            leftValue = root-&gt;left-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        int rightValue = sumOfLeftLeaves(root-&gt;right);  // 右</span><br><span class="line"></span><br><span class="line">        int sum = leftValue + rightValue;               // 中</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="找树左下角的值"><a href="#找树左下角的值" class="headerlink" title="找树左下角的值"></a>找树左下角的值</h2></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0513.%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-bottom-left-tree-value/description/">513. 找树左下角的值 - 力扣（LeetCode）</a></li>
<li>题意，找出一棵二叉树最底边最左边的值</li>
<li>方法，迭代的方法好说，只要层序遍历取最左边，也就是第一个点就可以；但是递归的方法没那么好理解，其实只要在递归时优先遍历下一层就可以保证：第一个深度最深的点，就是最左边的。</li>
<li>陆爻齐参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int result = 0;</span><br><span class="line">    int max_depth = INT32_MIN;</span><br><span class="line">    int findBottomLeftValue(TreeNode* root) &#123;</span><br><span class="line">        search_left(root, 0);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void search_left(TreeNode *root, int depth) &#123;</span><br><span class="line">        if (root == nullptr) return;</span><br><span class="line"></span><br><span class="line">        // 由于总是先遍历左边，故第一个大深度必为最左</span><br><span class="line">        if (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr) &#123;</span><br><span class="line">            if (depth &gt; max_depth) &#123;</span><br><span class="line">                max_depth = depth;</span><br><span class="line">                result = root-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 先左后右</span><br><span class="line">        search_left(root-&gt;left, depth+1);</span><br><span class="line">        search_left(root-&gt;right, depth+1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h2></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum/">112. 路径总和 - 力扣（LeetCode）</a></li>
<li>题意，给一个目标和，要求判断二叉树中是否有一条根节点到叶节点的路径和恰好为目标和</li>
<li>方法，DFS，递归或迭代</li>
<li>陆爻齐的解法，比较冗余，不过不用多改下一题也能用：）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; path; // 记录路径，主要是记上一层的数字</span><br><span class="line">    bool result = false; // 记录结果</span><br><span class="line">    int sum = 0; // 记录和</span><br><span class="line">    bool hasPathSum(TreeNode* root, int targetSum) &#123;</span><br><span class="line">        val(root, targetSum);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void val(TreeNode *root, int targetSum) &#123;</span><br><span class="line">        if (root == nullptr) return; // 空节点的终止条件</span><br><span class="line">        path.push_back(root-&gt;val); // 加入路径并更新路径和</span><br><span class="line">        sum += root-&gt;val;</span><br><span class="line">        if (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr &amp;&amp; sum == targetSum) &#123; // 到了叶节点且和恰好相同才行</span><br><span class="line">            result = true;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        val(root-&gt;left, targetSum); </span><br><span class="line">        val(root-&gt;right, targetSum);</span><br><span class="line"></span><br><span class="line">        sum -= path[path.size()-1]; // 去除路径</span><br><span class="line">        path.erase(path.end()-1); // 去除和</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
代码随想录的解法  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    bool traversal(TreeNode* cur, int count) &#123;</span><br><span class="line">        if (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; count == 0) return true; // 遇到叶子节点，并且计数为0</span><br><span class="line">        if (!cur-&gt;left &amp;&amp; !cur-&gt;right) return false; // 遇到叶子节点直接返回</span><br><span class="line"></span><br><span class="line">        if (cur-&gt;left) &#123; // 左</span><br><span class="line">            count -= cur-&gt;left-&gt;val; // 递归，处理节点;</span><br><span class="line">            if (traversal(cur-&gt;left, count)) return true;</span><br><span class="line">            count += cur-&gt;left-&gt;val; // 回溯，撤销处理结果</span><br><span class="line">        &#125;</span><br><span class="line">        if (cur-&gt;right) &#123; // 右</span><br><span class="line">            count -= cur-&gt;right-&gt;val; // 递归，处理节点;</span><br><span class="line">            if (traversal(cur-&gt;right, count)) return true;</span><br><span class="line">            count += cur-&gt;right-&gt;val; // 回溯，撤销处理结果</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    bool hasPathSum(TreeNode* root, int sum) &#123;</span><br><span class="line">        if (root == NULL) return false;</span><br><span class="line">        return traversal(root, sum - root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="路径总和ii"><a href="#路径总和ii" class="headerlink" title="路径总和ii"></a>路径总和ii</h2></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-ii/submissions/574988363/">113. 路径总和 II - 力扣（LeetCode）</a></li>
<li>题意，基本同上一题，但要求返回所有和为目标和的路径</li>
<li>方法，用vector记路径，再递归即可</li>
<li>陆爻齐的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; path; // 记录路径，主要是记上一层的数字</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; result; // 记录结果</span><br><span class="line">    int sum = 0; // 记录和</span><br><span class="line"></span><br><span class="line">    void val(TreeNode *root, int targetSum) &#123;</span><br><span class="line">        if (root == nullptr) return; // 空节点的终止条件</span><br><span class="line">        path.push_back(root-&gt;val); // 加入路径并更新路径和</span><br><span class="line">        sum += root-&gt;val;</span><br><span class="line">        if (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr &amp;&amp; sum == targetSum) &#123; // 到了叶节点且和恰好相同才行</span><br><span class="line">            result.push_back(path);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        val(root-&gt;left, targetSum); </span><br><span class="line">        val(root-&gt;right, targetSum);</span><br><span class="line"></span><br><span class="line">        sum -= path[path.size()-1]; // 去除路径</span><br><span class="line">        path.erase(path.end()-1); // 去除和</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123;</span><br><span class="line">        val(root, targetSum);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
代码随想录的解法  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">    vector&lt;int&gt; path;</span><br><span class="line">    // 递归函数不需要返回值，因为我们要遍历整个树</span><br><span class="line">    void traversal(TreeNode* cur, int count) &#123;</span><br><span class="line">        if (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; count == 0) &#123; // 遇到了叶子节点且找到了和为sum的路径</span><br><span class="line">            result.push_back(path);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!cur-&gt;left &amp;&amp; !cur-&gt;right) return ; // 遇到叶子节点而没有找到合适的边，直接返回</span><br><span class="line"></span><br><span class="line">        if (cur-&gt;left) &#123; // 左 （空节点不遍历）</span><br><span class="line">            path.push_back(cur-&gt;left-&gt;val);</span><br><span class="line">            count -= cur-&gt;left-&gt;val;</span><br><span class="line">            traversal(cur-&gt;left, count);    // 递归</span><br><span class="line">            count += cur-&gt;left-&gt;val;        // 回溯</span><br><span class="line">            path.pop_back();                // 回溯</span><br><span class="line">        &#125;</span><br><span class="line">        if (cur-&gt;right) &#123; // 右 （空节点不遍历）</span><br><span class="line">            path.push_back(cur-&gt;right-&gt;val);</span><br><span class="line">            count -= cur-&gt;right-&gt;val;</span><br><span class="line">            traversal(cur-&gt;right, count);   // 递归</span><br><span class="line">            count += cur-&gt;right-&gt;val;       // 回溯</span><br><span class="line">            path.pop_back();                // 回溯</span><br><span class="line">        &#125;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123;</span><br><span class="line">        result.clear();</span><br><span class="line">        path.clear();</span><br><span class="line">        if (root == NULL) return result;</span><br><span class="line">        path.push_back(root-&gt;val); // 把根节点放进路径</span><br><span class="line">        traversal(root, sum - root-&gt;val);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="从中序与后序遍历序列构造二叉树"><a href="#从中序与后序遍历序列构造二叉树" class="headerlink" title="从中序与后序遍历序列构造二叉树"></a>从中序与后序遍历序列构造二叉树</h2></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/">106. 从中序与后序遍历序列构造二叉树 - 力扣（LeetCode）</a></li>
<li>题意便是根据一颗二叉树的中序和后序来构造二叉树</li>
<li>方法，利用后序遍历的最后一个点为根，且中序的根左侧为左子树，右侧为右子树，递归下来可得唯一二叉树</li>
<li>陆爻齐参照代码随想录思路的复制 vector 的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;</span><br><span class="line">        if (postorder.size() == 0) return nullptr;</span><br><span class="line"></span><br><span class="line">        int mid_val = postorder[postorder.size()-1]; // 取当前的中点</span><br><span class="line">        TreeNode *root = new TreeNode(mid_val);</span><br><span class="line"></span><br><span class="line">        int mid_index = 0; // 找中序里面中点位置</span><br><span class="line">        for (int i = 0; i &lt; inorder.size(); i++) &#123;</span><br><span class="line">            if (inorder[i] == mid_val) &#123;</span><br><span class="line">                mid_index = i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 下面切割按左闭右开来算</span><br><span class="line">        // 中序切割顺便去除中点</span><br><span class="line">        vector&lt;int&gt; left_inorder = vector&lt;int&gt;(inorder.begin(), inorder.begin()+mid_index);</span><br><span class="line">        vector&lt;int&gt; right_inorder = vector&lt;int&gt;(inorder.begin()+mid_index+1, inorder.end());</span><br><span class="line">        // 后序要去除最后一个</span><br><span class="line">        vector&lt;int&gt; left_postorder = vector&lt;int&gt;(postorder.begin(), postorder.begin()+mid_index);</span><br><span class="line">        vector&lt;int&gt; right_postorder = vector&lt;int&gt;(postorder.begin()+mid_index, postorder.end()-1);</span><br><span class="line"></span><br><span class="line">        root-&gt;left = buildTree(left_inorder, left_postorder);</span><br><span class="line">        root-&gt;right = buildTree(right_inorder, right_postorder);</span><br><span class="line"></span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
陆爻齐根据上述思路不复制vector只传坐标的优化办法：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;int&gt;inorder;</span><br><span class="line">    vector&lt;int&gt;postorder;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;</span><br><span class="line">        this-&gt;inorder = inorder;</span><br><span class="line">        this-&gt;postorder = postorder;</span><br><span class="line">        TreeNode *root = travel_build(0, inorder.size(), 0, postorder.size());</span><br><span class="line"></span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode *travel_build(int inorder_left, int inorder_right, int postorder_left, int postorder_right) &#123;</span><br><span class="line">        if (inorder_right == inorder_left) return nullptr; // 说明该子树无节点</span><br><span class="line"></span><br><span class="line">        int root_val = this-&gt;postorder[postorder_right-1];</span><br><span class="line">        TreeNode *root = new TreeNode(root_val); // 取本子树的根</span><br><span class="line"></span><br><span class="line">        int left_inorder_count = 0; // 相当于左子树有几个节点</span><br><span class="line">        for (int i = inorder_left; i &lt; inorder_right; i++) &#123;</span><br><span class="line">            if (inorder[i] == root_val) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            left_inorder_count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 中序去中点，后序去末点</span><br><span class="line">        root-&gt;left = travel_build(inorder_left, inorder_left+left_inorder_count, postorder_left, postorder_left+left_inorder_count);</span><br><span class="line">        root-&gt;right = travel_build(inorder_left+left_inorder_count+1, inorder_right, postorder_left+left_inorder_count, postorder_right-1);</span><br><span class="line">        </span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="从前序与中序遍历序列构造二叉树"><a href="#从前序与中序遍历序列构造二叉树" class="headerlink" title="从前序与中序遍历序列构造二叉树"></a>从前序与中序遍历序列构造二叉树</h2></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/">105. 从前序与中序遍历序列构造二叉树 - 力扣（LeetCode）</a></li>
<li>题意，如题</li>
<li>方法，基本同上，只不过找中点是什么值换成了前序而已，前序的中点在第一个</li>
<li>陆爻齐在上面方法改出来的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; inorder;</span><br><span class="line">    vector&lt;int&gt; preorder;</span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;</span><br><span class="line">        this-&gt;inorder = inorder;</span><br><span class="line">        this-&gt;preorder = preorder;</span><br><span class="line">        TreeNode *root = travel_build(0, inorder.size(), 0, preorder.size());</span><br><span class="line"></span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode *travel_build(int inorder_left, int inorder_right, int preorder_left, int preorder_right) &#123;</span><br><span class="line">        if (inorder_right == inorder_left) return nullptr; // 说明该子树无节点</span><br><span class="line">        //if (preorder_right &lt;= preorder_left) return nullptr; // 说明该子树无节点</span><br><span class="line">        //cout &lt;&lt; &quot;il:&quot; &lt;&lt; inorder_left &lt;&lt; &quot;; ir:&quot; &lt;&lt; inorder_right &lt;&lt; &quot;; pl:&quot; &lt;&lt; preorder_left &lt;&lt; &quot;; pr:&quot; &lt;&lt; preorder_right &lt;&lt; endl;</span><br><span class="line">        int root_val = this-&gt;preorder[preorder_left];</span><br><span class="line">        TreeNode *root = new TreeNode(root_val); // 取本子树的根</span><br><span class="line">        //cout &lt;&lt; &quot;root:&quot; &lt;&lt; root_val &lt;&lt; endl;</span><br><span class="line">        //cout &lt;&lt; &quot;il:&quot; &lt;&lt; inorder_left &lt;&lt; &quot;; ir:&quot; &lt;&lt; inorder_right &lt;&lt; &quot;; pl:&quot; &lt;&lt; preorder_left &lt;&lt; &quot;; pr:&quot; &lt;&lt; preorder_right &lt;&lt; endl;</span><br><span class="line">        int left_inorder_count = 0; // 相当于左子树有几个节点</span><br><span class="line">        for (int i = inorder_left; i &lt; inorder_right; i++) &#123;</span><br><span class="line">            if (inorder[i] == root_val) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            left_inorder_count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 中序去中点，先序去首个点</span><br><span class="line">        root-&gt;left = travel_build(inorder_left, inorder_left+left_inorder_count, preorder_left+1, preorder_left+1+left_inorder_count);</span><br><span class="line">        root-&gt;right = travel_build(inorder_left+left_inorder_count+1, inorder_right, preorder_left+1+left_inorder_count, preorder_right);</span><br><span class="line">        </span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h2></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0654.%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-binary-tree/description/">654. 最大二叉树 - 力扣（LeetCode）</a></li>
<li>题意：像大顶堆一样，二叉树的根为最大值，左子树根为数组中左边的最大值，右子树同理</li>
<li>方法，递归取大放根即可，陆爻齐直接写出了下标的简洁解法</li>
<li>陆爻齐的解法，与代码随想录的优化解法相近<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        // 根据下标构造二叉树，按照左闭右开原则</span><br><span class="line">        TreeNode *result = find_max_build_tree(nums, 0, nums.size());</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode *find_max_build_tree(vector&lt;int&gt; &amp;nums, int left, int right) &#123;</span><br><span class="line">        if (right &lt;= left) return nullptr; //终止条件，即判断的区间为0</span><br><span class="line"></span><br><span class="line">        // 从下标范围找最大值以及下标</span><br><span class="line">        int max_num = INT32_MIN;</span><br><span class="line">        int max_index = left;</span><br><span class="line">        for (int i = left; i &lt; right; i++) &#123;</span><br><span class="line">            if (nums[i] &gt; max_num) &#123;</span><br><span class="line">                max_num = nums[i];</span><br><span class="line">                max_index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 构造本节点下标</span><br><span class="line">        TreeNode *result = new TreeNode(max_num);</span><br><span class="line"></span><br><span class="line">        // 左子树与右子树</span><br><span class="line">        result-&gt;left = find_max_build_tree(nums, left, max_index);</span><br><span class="line">        result-&gt;right = find_max_build_tree(nums, max_index+1, right);</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h2></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-binary-trees/description/">617. 合并二叉树 - 力扣（LeetCode）</a></li>
<li>题意，两个二叉树相同位置的节点值相加（int），相当于重合一起</li>
<li>方法，递归算重合，陆爻齐写得繁琐，其实一边为空时，可以直接返回非空部分</li>
<li>陆爻齐的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) &#123;</span><br><span class="line">        TreeNode *result = nullptr;</span><br><span class="line">        if (root1 || root2) &#123; // 两边有一个非空，那么该节点非空</span><br><span class="line">            if (root1 == nullptr) &#123;</span><br><span class="line">                result = new TreeNode(root2-&gt;val);</span><br><span class="line">                result-&gt;left = mergeTrees(root1, root2-&gt;left);</span><br><span class="line">                result-&gt;right = mergeTrees(root1, root2-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (root2 == nullptr) &#123;</span><br><span class="line">                result = new TreeNode(root1-&gt;val);</span><br><span class="line">                result-&gt;left = mergeTrees(root1-&gt;left, root2);</span><br><span class="line">                result-&gt;right = mergeTrees(root1-&gt;right, root2);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                result = new TreeNode(root1-&gt;val + root2-&gt;val);</span><br><span class="line">                result-&gt;left = mergeTrees(root1-&gt;left, root2-&gt;left);</span><br><span class="line">                result-&gt;right = mergeTrees(root1-&gt;right, root2-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
代码随想录解法  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) &#123;</span><br><span class="line">        if (t1 == NULL) return t2; // 如果t1为空，合并之后就应该是t2</span><br><span class="line">        if (t2 == NULL) return t1; // 如果t2为空，合并之后就应该是t1</span><br><span class="line">        // 修改了t1的数值和结构</span><br><span class="line">        t1-&gt;val += t2-&gt;val;                             // 中</span><br><span class="line">        t1-&gt;left = mergeTrees(t1-&gt;left, t2-&gt;left);      // 左</span><br><span class="line">        t1-&gt;right = mergeTrees(t1-&gt;right, t2-&gt;right);   // 右</span><br><span class="line">        return t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="二叉搜索树的搜索"><a href="#二叉搜索树的搜索" class="headerlink" title="二叉搜索树的搜索"></a>二叉搜索树的搜索</h2></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-a-binary-search-tree/description/">700. 二叉搜索树中的搜索 - 力扣（LeetCode）</a></li>
<li>题意：在二叉搜索树上找对应值的节点</li>
<li>方法，重点是认识二叉搜索树的概念，二叉搜索树的根左子树小于根，右子树大于根，且子树皆满足这个性质，所以搜索很简单，大了就向右，小了向左</li>
<li>陆爻齐的递归方法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* searchBST(TreeNode* root, int val) &#123;</span><br><span class="line">        if (root == nullptr) return nullptr; // 说明没有这个val 的节点</span><br><span class="line"></span><br><span class="line">        if (root-&gt;val == val) return root;// 找到了</span><br><span class="line">        else if (root-&gt;val &lt; val) return searchBST(root-&gt;right, val); // val偏大</span><br><span class="line">        else return searchBST(root-&gt;left, val); // val偏小</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
陆爻齐的迭代方法  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* searchBST(TreeNode* root, int val) &#123;</span><br><span class="line">        while (root != nullptr) &#123;</span><br><span class="line">            if (root-&gt;val == val) break;</span><br><span class="line">            else if (root-&gt;val &gt; val) root = root-&gt;left;</span><br><span class="line">            else root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h2></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0098.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html#%E6%80%9D%E8%B7%AF">代码随想录</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/description/">98. 验证二叉搜索树 - 力扣（LeetCode）</a></li>
<li>题意，验证一个二叉树是否为二叉搜索树</li>
<li>方法，递归查</li>
<li>陆爻齐参考代码随想录的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    TreeNode *pre = nullptr; // 记录上一个访问节点，由于中序，所以会按二叉搜索左到右</span><br><span class="line">    bool travelTree(TreeNode *root) &#123;</span><br><span class="line">        if (root == nullptr) return true; // 空树也算二叉搜索树</span><br><span class="line"></span><br><span class="line">        bool left = travelTree(root-&gt;left); // 中序</span><br><span class="line">        if (pre != nullptr &amp;&amp; pre-&gt;val &gt;= root-&gt;val) return false;</span><br><span class="line">        pre = root;</span><br><span class="line">        bool right = travelTree(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        return left &amp;&amp; right;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    bool isValidBST(TreeNode* root) &#123;</span><br><span class="line">        return travelTree(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/27/[Weekly%20Algorithm]%207%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E4%B8%89%EF%BC%89/" data-id="cm7j3jecl001u10agbg3eaf7v" data-title="【Weekly Algorithm】算法周记之《代码随想录》二叉树（三）" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-[Weekly Algorithm] 6算法周记之《代码随想录》二叉树（二）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/20/%5BWeekly%20Algorithm%5D%206%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E4%BA%8C%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2024-10-20T14:12:00.000Z" itemprop="datePublished">2024-10-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/20/%5BWeekly%20Algorithm%5D%206%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E4%BA%8C%EF%BC%89/">【Weekly Algorithm】算法周记之《代码随想录》二叉树（二）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h1><p>本周跟随《代码随想录》学习二叉树的层序遍历，以及对于二叉树的翻转、对称，深度问题等。</p>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><ul>
<li><h2 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h2></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录 (programmercarl.com)</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/">102. 二叉树的层序遍历 - 力扣（LeetCode）</a></li>
<li>题意就是一层层地从左到右遍历二叉树</li>
<li>方法就是利用队列，把一层层排进去，一层层遍历，陆爻齐用两个队列实现这个操作，不过通过 for 循环，其实只要一个队列就行</li>
<li></li>
<li>陆爻齐的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; rec; // 记录当前要遍历的层</span><br><span class="line">        if (root != nullptr) rec.push(root);</span><br><span class="line"></span><br><span class="line">        while(!rec.empty()) &#123;</span><br><span class="line">            vector&lt;int&gt; rec_val;</span><br><span class="line">            queue&lt;TreeNode*&gt; rec_nextlevel;</span><br><span class="line">            // 遍历一层</span><br><span class="line">            while(!rec.empty()) &#123;</span><br><span class="line">                TreeNode *cur = rec.front();</span><br><span class="line">                rec.pop();</span><br><span class="line"></span><br><span class="line">                if (cur-&gt;left != nullptr) rec_nextlevel.push(cur-&gt;left); // 存储下一层</span><br><span class="line">                if (cur-&gt;right != nullptr) rec_nextlevel.push(cur-&gt;right);</span><br><span class="line"></span><br><span class="line">                rec_val.push_back(cur-&gt;val); // 记录当前层遍历的数值</span><br><span class="line">            &#125;</span><br><span class="line">            result.push_back(rec_val); // 记录一层</span><br><span class="line">            rec = rec_nextlevel; // 准备遍历下一层</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
代码随想录的解法  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        if (root != NULL) que.push(root);</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">        while (!que.empty()) &#123;</span><br><span class="line">            int size = que.size();</span><br><span class="line">            vector&lt;int&gt; vec;</span><br><span class="line">            // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的</span><br><span class="line">            for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                vec.push_back(node-&gt;val);</span><br><span class="line">                if (node-&gt;left) que.push(node-&gt;left);</span><br><span class="line">                if (node-&gt;right) que.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.push_back(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li></li>
<li><h2 id=""><a href="#" class="headerlink" title=""></a></h2></li>
<li><h2 id="二叉树的层次遍历-II"><a href="#二叉树的层次遍历-II" class="headerlink" title="二叉树的层次遍历 II"></a>二叉树的层次遍历 II</h2></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层序遍历 II - 力扣（LeetCode）</a></li>
<li>题意，在层序遍历的基础上，要求从下向上遍历</li>
<li>方法，在层序遍历后，把结果翻转下就可以了</li>
<li>陆爻齐的解法（和代码随想录差不多）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; rec; // 记录当前要遍历的层</span><br><span class="line">        if (root != nullptr) rec.push(root);</span><br><span class="line"></span><br><span class="line">        while(!rec.empty()) &#123;</span><br><span class="line">            vector&lt;int&gt; rec_val;</span><br><span class="line">            queue&lt;TreeNode*&gt; rec_nextlevel;</span><br><span class="line">            // 遍历一层</span><br><span class="line">            while(!rec.empty()) &#123;</span><br><span class="line">                TreeNode *cur = rec.front();</span><br><span class="line">                rec.pop();</span><br><span class="line"></span><br><span class="line">                if (cur-&gt;left != nullptr) rec_nextlevel.push(cur-&gt;left); // 存储下一层</span><br><span class="line">                if (cur-&gt;right != nullptr) rec_nextlevel.push(cur-&gt;right);</span><br><span class="line"></span><br><span class="line">                rec_val.push_back(cur-&gt;val); // 记录当前层遍历的数值</span><br><span class="line">            &#125;</span><br><span class="line">            result.push_back(rec_val); // 记录一层</span><br><span class="line">            rec = rec_nextlevel; // 准备遍历下一层</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(result.begin(),result.end());</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li></li>
<li><h2 id="二叉树的右视图"><a href="#二叉树的右视图" class="headerlink" title="二叉树的右视图"></a>二叉树的右视图</h2></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图 - 力扣（LeetCode）</a></li>
<li>题意，要求输出一个二叉树右边看到的第一层数值，从上往下</li>
<li>方法，层序遍历时，只保留最后一个值即可</li>
<li>陆爻齐的解法（代码随想录也差不多）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; rightSideView(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; result;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; rec; // 记录当前要遍历的层</span><br><span class="line">        if (root != nullptr) rec.push(root);</span><br><span class="line"></span><br><span class="line">        while(!rec.empty()) &#123;</span><br><span class="line">            vector&lt;int&gt; rec_val;</span><br><span class="line">            queue&lt;TreeNode*&gt; rec_nextlevel;</span><br><span class="line">            // 遍历一层</span><br><span class="line">            while(!rec.empty()) &#123;</span><br><span class="line">                TreeNode *cur = rec.front();</span><br><span class="line">                rec.pop();</span><br><span class="line"></span><br><span class="line">                if (cur-&gt;left != nullptr) rec_nextlevel.push(cur-&gt;left); // 存储下一层</span><br><span class="line">                if (cur-&gt;right != nullptr) rec_nextlevel.push(cur-&gt;right);</span><br><span class="line"></span><br><span class="line">                rec_val.push_back(cur-&gt;val); // 记录当前层遍历的数值</span><br><span class="line">            &#125;</span><br><span class="line">            result.push_back(rec_val.back()); // 记录一层的最后一个</span><br><span class="line">            rec = rec_nextlevel; // 准备遍历下一层</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li></li>
<li><h2 id="二叉树的层平均值"><a href="#二叉树的层平均值" class="headerlink" title="二叉树的层平均值"></a>二叉树的层平均值</h2></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/description/">637. 二叉树的层平均值 - 力扣（LeetCode）</a></li>
<li>题意，即求每一层的均值</li>
<li>方法，层序遍历基础上，记录每层均值保存即可</li>
<li>陆爻齐解法（和代码随想录差不多）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;double&gt; averageOfLevels(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;double&gt; result;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; rec; // 记录当前要遍历的层</span><br><span class="line">        if (root != nullptr) rec.push(root);</span><br><span class="line"></span><br><span class="line">        while(!rec.empty()) &#123;</span><br><span class="line">            vector&lt;int&gt; rec_val;</span><br><span class="line">            queue&lt;TreeNode*&gt; rec_nextlevel;</span><br><span class="line">            double sum = 0;</span><br><span class="line">            double count = 0;</span><br><span class="line">            // 遍历一层</span><br><span class="line">            while(!rec.empty()) &#123;</span><br><span class="line">                TreeNode *cur = rec.front();</span><br><span class="line">                </span><br><span class="line">                rec.pop();</span><br><span class="line"></span><br><span class="line">                if (cur-&gt;left != nullptr) rec_nextlevel.push(cur-&gt;left); // 存储下一层</span><br><span class="line">                if (cur-&gt;right != nullptr) rec_nextlevel.push(cur-&gt;right);</span><br><span class="line"></span><br><span class="line">                //rec_val.push_back(cur-&gt;val); // 记录当前层遍历的数值</span><br><span class="line">                sum += cur-&gt;val;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            result.push_back(sum / count); // 记录一层</span><br><span class="line">            rec = rec_nextlevel; // 准备遍历下一层</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li></li>
<li><h2 id="N-叉树的层序遍历"><a href="#N-叉树的层序遍历" class="headerlink" title="N 叉树的层序遍历"></a>N 叉树的层序遍历</h2></li>
<li>题意，如题</li>
<li>方法，把普通二叉树的层序遍历，中下一层的添加，换成遍历其孩子就行</li>
<li>陆爻齐的解法（和代码随想录相近）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">// Definition for a Node.</span><br><span class="line">class Node &#123;</span><br><span class="line">public:</span><br><span class="line">    int val;</span><br><span class="line">    vector&lt;Node*&gt; children;</span><br><span class="line"></span><br><span class="line">    Node() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Node(int _val) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        children = _children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line"></span><br><span class="line">        queue&lt;Node*&gt; rec; // 记录当前要遍历的层</span><br><span class="line">        if (root != nullptr) rec.push(root);</span><br><span class="line"></span><br><span class="line">        while(!rec.empty()) &#123;</span><br><span class="line">            vector&lt;int&gt; rec_val;</span><br><span class="line">            queue&lt;Node*&gt; rec_nextlevel;</span><br><span class="line">            // 遍历一层</span><br><span class="line">            while(!rec.empty()) &#123;</span><br><span class="line">                Node *cur = rec.front();</span><br><span class="line">                rec.pop();</span><br><span class="line">                // 存储下一层</span><br><span class="line">                for (Node *tmp : cur-&gt;children) &#123;</span><br><span class="line">                    if (tmp != nullptr) &#123;</span><br><span class="line">                        rec_nextlevel.push(tmp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                rec_val.push_back(cur-&gt;val); // 记录当前层遍历的数值</span><br><span class="line">            &#125;</span><br><span class="line">            result.push_back(rec_val); // 记录一层</span><br><span class="line">            rec = rec_nextlevel; // 准备遍历下一层</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li></li>
<li><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2></li>
<li><h2 id="在每个树行中找最大值"><a href="#在每个树行中找最大值" class="headerlink" title="在每个树行中找最大值"></a>在每个树行中找最大值</h2></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/submissions/573871357/">515. 在每个树行中找最大值 - 力扣（LeetCode）</a></li>
<li>题意，找出二叉树中每层的最大值</li>
<li>方法，就是在层序遍历的基础上，去记录每层的最大值</li>
<li>陆爻齐的解法（与代码随想录差不多）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; largestValues(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; result;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; rec; // 记录当前要遍历的层</span><br><span class="line">        if (root != nullptr) rec.push(root);</span><br><span class="line"></span><br><span class="line">        while(!rec.empty()) &#123;</span><br><span class="line">            vector&lt;int&gt; rec_val;</span><br><span class="line">            queue&lt;TreeNode*&gt; rec_nextlevel;</span><br><span class="line">            int max_num = INT32_MIN;</span><br><span class="line">            // 遍历一层</span><br><span class="line">            while(!rec.empty()) &#123;</span><br><span class="line">                TreeNode *cur = rec.front();</span><br><span class="line">                </span><br><span class="line">                rec.pop();</span><br><span class="line"></span><br><span class="line">                if (cur-&gt;left != nullptr) rec_nextlevel.push(cur-&gt;left); // 存储下一层</span><br><span class="line">                if (cur-&gt;right != nullptr) rec_nextlevel.push(cur-&gt;right);</span><br><span class="line"></span><br><span class="line">                //rec_val.push_back(cur-&gt;val); // 记录当前层遍历的数值</span><br><span class="line">                if (cur-&gt;val &gt; max_num) &#123;</span><br><span class="line">                    max_num = cur-&gt;val;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.push_back(max_num); // 记录一层</span><br><span class="line">            rec = rec_nextlevel; // 准备遍历下一层</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li></li>
<li><h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2></li>
<li><h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2></li>
<li><h2 id="填充每个节点的下一个右侧节点指针"><a href="#填充每个节点的下一个右侧节点指针" class="headerlink" title="填充每个节点的下一个右侧节点指针"></a>填充每个节点的下一个右侧节点指针</h2></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针 - 力扣（LeetCode）</a></li>
<li>题意，让二叉树的每个节点都指向其右侧节点，无则指空</li>
<li>方法，在层序遍历中，取点让其指右即可，代码随想录中用 for 循环看着挺复杂的样子，其实只是他专门区分了第一个点和其它点</li>
<li>陆爻齐的解法（这次和代码随想录有点差别）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">// Definition for a Node.</span><br><span class="line">class Node &#123;</span><br><span class="line">public:</span><br><span class="line">    int val;</span><br><span class="line">    Node* left;</span><br><span class="line">    Node* right;</span><br><span class="line">    Node* next;</span><br><span class="line"></span><br><span class="line">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Node(int _val, Node* _left, Node* _right, Node* _next)</span><br><span class="line">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    Node* connect(Node* root) &#123;</span><br><span class="line">        //vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line"></span><br><span class="line">        queue&lt;Node*&gt; rec; // 记录当前要遍历的层</span><br><span class="line">        if (root != nullptr) rec.push(root);</span><br><span class="line"></span><br><span class="line">        while(!rec.empty()) &#123;</span><br><span class="line">            vector&lt;int&gt; rec_val;</span><br><span class="line">            queue&lt;Node*&gt; rec_nextlevel;</span><br><span class="line">            // 遍历一层</span><br><span class="line">            while(!rec.empty()) &#123;</span><br><span class="line">                Node *cur = rec.front();</span><br><span class="line">                rec.pop();</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">                if (cur-&gt;left != nullptr) rec_nextlevel.push(cur-&gt;left); // 存储下一层</span><br><span class="line">                if (cur-&gt;right != nullptr) rec_nextlevel.push(cur-&gt;right);</span><br><span class="line"></span><br><span class="line">                rec_val.push_back(cur-&gt;val); // 记录当前层遍历的数值</span><br><span class="line">                </span><br><span class="line">                // 让每个节点指右边（无则指空）</span><br><span class="line">                if (!rec.empty()) &#123;</span><br><span class="line">                    cur-&gt;next = rec.front();</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    cur-&gt;next = nullptr;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //result.push_back(rec_val); // 记录一层</span><br><span class="line">            rec = rec_nextlevel; // 准备遍历下一层</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
代码随想录的解法  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    Node* connect(Node* root) &#123;</span><br><span class="line">        queue&lt;Node*&gt; que;</span><br><span class="line">        if (root != NULL) que.push(root);</span><br><span class="line">        while (!que.empty()) &#123;</span><br><span class="line">            int size = que.size();</span><br><span class="line">            // vector&lt;int&gt; vec;</span><br><span class="line">            Node* nodePre;</span><br><span class="line">            Node* node;</span><br><span class="line">            for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">                if (i == 0) &#123;</span><br><span class="line">                    nodePre = que.front(); // 取出一层的头结点</span><br><span class="line">                    que.pop();</span><br><span class="line">                    node = nodePre;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    node = que.front();</span><br><span class="line">                    que.pop();</span><br><span class="line">                    nodePre-&gt;next = node; // 本层前一个节点next指向本节点</span><br><span class="line">                    nodePre = nodePre-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                if (node-&gt;left) que.push(node-&gt;left);</span><br><span class="line">                if (node-&gt;right) que.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            nodePre-&gt;next = NULL; // 本层最后一个节点指向NULL</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li></li>
<li><h2 id="-4"><a href="#-4" class="headerlink" title=""></a></h2></li>
<li><h2 id="填充每个节点的下一个右侧节点指针II"><a href="#填充每个节点的下一个右侧节点指针II" class="headerlink" title="填充每个节点的下一个右侧节点指针II"></a>填充每个节点的下一个右侧节点指针II</h2></li>
<li>题意，和上一题差不多，不过面对的二叉树不是完美二叉树</li>
<li>方法，和上一题一样，不知此题有何意义</li>
<li>解法略，同上</li>
<li></li>
<li><h2 id="-5"><a href="#-5" class="headerlink" title=""></a></h2></li>
<li><h2 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h2></li>
<li>题意，即找出二叉树的根节点与其最远叶节点的距离</li>
<li>方法，层序遍历时，记录层数即可</li>
<li>陆爻齐的解法（和代码随想录差不多）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxDepth(TreeNode* root) &#123;</span><br><span class="line">        int depth = 0;</span><br><span class="line">        queue&lt;TreeNode*&gt; rec; // 记录当前要遍历的层</span><br><span class="line">        if (root != nullptr) &#123;</span><br><span class="line">            rec.push(root);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        while(!rec.empty()) &#123;</span><br><span class="line">            vector&lt;int&gt; rec_val;</span><br><span class="line">            queue&lt;TreeNode*&gt; rec_nextlevel;</span><br><span class="line">            depth++;</span><br><span class="line">            // 遍历一层</span><br><span class="line">            while(!rec.empty()) &#123;</span><br><span class="line">                TreeNode *cur = rec.front();</span><br><span class="line">                rec.pop();</span><br><span class="line"></span><br><span class="line">                if (cur-&gt;left != nullptr) rec_nextlevel.push(cur-&gt;left); // 存储下一层</span><br><span class="line">                if (cur-&gt;right != nullptr) rec_nextlevel.push(cur-&gt;right);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            rec = rec_nextlevel; // 准备遍历下一层</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li></li>
<li><h2 id="-6"><a href="#-6" class="headerlink" title=""></a></h2></li>
<li><h2 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h2></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度 - 力扣（LeetCode）</a></li>
<li>题目要求，找到最小深度，即第一个叶子节点出现的层数</li>
<li>方法，每个点检测下，若是叶子节点，则返回当前层数，代码随想录的解法相对陆爻齐的解法重复检测孩子是否为空，陆爻齐 win ：）</li>
<li>陆爻齐的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minDepth(TreeNode* root) &#123;</span><br><span class="line">        int depth = 0;</span><br><span class="line">        queue&lt;TreeNode*&gt; rec; // 记录当前要遍历的层</span><br><span class="line">        if (root != nullptr) &#123;</span><br><span class="line">            rec.push(root);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        while(!rec.empty()) &#123;</span><br><span class="line">            vector&lt;int&gt; rec_val;</span><br><span class="line">            queue&lt;TreeNode*&gt; rec_nextlevel;</span><br><span class="line">            depth++;</span><br><span class="line">            // 遍历一层</span><br><span class="line">            while(!rec.empty()) &#123;</span><br><span class="line">                TreeNode *cur = rec.front();</span><br><span class="line">                rec.pop();</span><br><span class="line">                int count = 0; // 记录有无孩子</span><br><span class="line"></span><br><span class="line">                // 存储下一层</span><br><span class="line">                if (cur-&gt;left != nullptr) &#123;</span><br><span class="line">                    rec_nextlevel.push(cur-&gt;left); </span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                if (cur-&gt;right != nullptr) &#123;</span><br><span class="line">                    rec_nextlevel.push(cur-&gt;right);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 找到了第一个叶子节点</span><br><span class="line">                if (count == 0) &#123;</span><br><span class="line">                    return depth;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            rec = rec_nextlevel; // 准备遍历下一层</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
代码随想录的解法  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minDepth(TreeNode* root) &#123;</span><br><span class="line">        if (root == NULL) return 0;</span><br><span class="line">        int depth = 0;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.push(root);</span><br><span class="line">        while(!que.empty()) &#123;</span><br><span class="line">            int size = que.size();</span><br><span class="line">            depth++; // 记录最小深度</span><br><span class="line">            for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                if (node-&gt;left) que.push(node-&gt;left);</span><br><span class="line">                if (node-&gt;right) que.push(node-&gt;right);</span><br><span class="line">                if (!node-&gt;left &amp;&amp; !node-&gt;right) &#123; // 当左右孩子都为空的时候，说明是最低点的一层了，退出</span><br><span class="line">                    return depth;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0226.%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E6%8B%93%E5%B1%95">代码随想录</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/description/">226. 翻转二叉树 - 力扣（LeetCode）</a></li>
<li>题意，把整个二叉树左右翻转</li>
<li>方法，其实把每个节点的左右子树交换即可</li>
<li>陆爻齐的方法（类似前序）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* invertTree(TreeNode* root) &#123;</span><br><span class="line">        // 终止条件</span><br><span class="line">        if (root == nullptr) return root;</span><br><span class="line"></span><br><span class="line">        // 交换左右子树</span><br><span class="line">        TreeNode *tmp = root-&gt;left;</span><br><span class="line">        root-&gt;left = root-&gt;right;</span><br><span class="line">        root-&gt;right = tmp;</span><br><span class="line">        // 递归翻转</span><br><span class="line">        if (root-&gt;left != nullptr) invertTree(root-&gt;left);</span><br><span class="line">        if (root-&gt;right != nullptr) invertTree(root-&gt;right);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
代码随想录补充的类中序方法  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* invertTree(TreeNode* root) &#123;</span><br><span class="line">        if (root == NULL) return root;</span><br><span class="line">        invertTree(root-&gt;left);         // 左</span><br><span class="line">        swap(root-&gt;left, root-&gt;right);  // 中</span><br><span class="line">        invertTree(root-&gt;left);         // 注意 这里依然要遍历左孩子，因为中间节点已经翻转了</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E6%80%9D%E8%B7%AF">代码随想录</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树 - 力扣（LeetCode）</a></li>
<li>题意，判断二叉树是否沿中间水平对称</li>
<li>方法，注意不是判断一个节点的左右子树是否相等，而是判断左子树的右子树与右子树的左子树以及左子树的左子树和右子树的右子树是否相等。</li>
<li>陆爻齐参照代码随想录的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSymmetric(TreeNode* root) &#123;</span><br><span class="line">        if (root == nullptr) return true;</span><br><span class="line">        return compare(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool compare(TreeNode *left, TreeNode *right) &#123;</span><br><span class="line">        // 判断两节点是否空的相同情况或值不同的情况</span><br><span class="line">        if (left == nullptr &amp;&amp; right == nullptr) return true;</span><br><span class="line">        else if (left != nullptr &amp;&amp; right == nullptr) return false;</span><br><span class="line">        else if (left == nullptr &amp;&amp; right != nullptr) return false;</span><br><span class="line">        else if (left-&gt;val != right-&gt;val) return false;</span><br><span class="line"></span><br><span class="line">        // 剩下已是两个节点存在且数值相同，因此要判断他们子树情况</span><br><span class="line">        bool inSide = compare(left-&gt;right, right-&gt;left);</span><br><span class="line">        bool outSide = compare(left-&gt;left, right-&gt;right);</span><br><span class="line">        bool isSame = inSide &amp;&amp; outSide;</span><br><span class="line">        return isSame;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="浅谈二叉树的深度和高度"><a href="#浅谈二叉树的深度和高度" class="headerlink" title="浅谈二叉树的深度和高度"></a>浅谈二叉树的深度和高度</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录</a></p>
</li>
<li><p>二叉树的深度指根节点到叶子节点的最大距离，计算时相当于从上往下，1、2、3……这么数；</p>
<p>二叉树的高度，指一个节点到叶子节点的最大距离，计算时相当于从下往上数  </p>
</li>
<li><p>易得，深度适合用前序遍历，而高度适合用后序遍历</p>
</li>
<li><p>根节点的高度就是二叉树的深度</p>
</li>
</ul>
<h2 id="二叉树的最大深度-1"><a href="#二叉树的最大深度-1" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h2><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/">104. 二叉树的最大深度 - 力扣（LeetCode）</a></li>
<li>题意，即求根节点到叶节点的最长距离</li>
<li>方法，此题在[[二叉树的层序遍历]]有所描述，用层序遍历即可解决，但这里再介绍下递归方法</li>
<li>陆爻齐参照代码随想录的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxDepth(TreeNode* root) &#123;</span><br><span class="line">        if (root == nullptr) return 0;</span><br><span class="line">        int left_depth = maxDepth(root-&gt;left);</span><br><span class="line">        int right_depth = maxDepth(root-&gt;right);</span><br><span class="line">        int max_depth = max(left_depth,right_depth);</span><br><span class="line">        return 1+max_depth;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="N-叉树的最大深度"><a href="#N-叉树的最大深度" class="headerlink" title="N 叉树的最大深度"></a>N 叉树的最大深度</h2><ul>
<li>题意，求 N 叉树的最大深度</li>
<li>方法，和上题类似，只要把遍历孩子时用循环遍历完即可</li>
<li>陆爻齐的解法（和代码随想录类似）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">// Definition for a Node.</span><br><span class="line">class Node &#123;</span><br><span class="line">public:</span><br><span class="line">    int val;</span><br><span class="line">    vector&lt;Node*&gt; children;</span><br><span class="line"></span><br><span class="line">    Node() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Node(int _val) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        children = _children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int max_depth = 0;</span><br><span class="line">    int maxDepth(Node* root) &#123;</span><br><span class="line">        search_depth(root, 0);</span><br><span class="line">        return max_depth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    void search_depth(Node *root, int depth) &#123;</span><br><span class="line">        if (root == nullptr) return;</span><br><span class="line">        depth++; // 当前层非零，深度加一</span><br><span class="line"></span><br><span class="line">        // 遍历孩子，算 DFS</span><br><span class="line">        for (Node *child : root-&gt;children) &#123;</span><br><span class="line">            search_depth(child, depth);</span><br><span class="line">        &#125;</span><br><span class="line">        // 更新层数</span><br><span class="line">        if (depth &gt; max_depth) &#123;</span><br><span class="line">            max_depth = depth;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="二叉树的最小深度-1"><a href="#二叉树的最小深度-1" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h2><ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0111.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6.html#%E6%80%9D%E8%B7%AF">代码随想录</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/">111. 二叉树的最小深度 - 力扣（LeetCode）</a></li>
<li>题意：求二叉树的最小深度，最小深度就是根节点到叶子节点（无左子树和右子树的节点）</li>
<li>方法：也可用层序遍历解决，[[二叉树的层序遍历]]，这里也要介绍下递归方法，与[[二叉树的最大深度]]有些许差别，在于对待非叶子节点的方式需要单独设置，尤其是有一侧空的节点，只要另一侧的深度即可</li>
<li>陆爻齐参考代码随想录的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minDepth(TreeNode* root) &#123;</span><br><span class="line">        return getDepth(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int getDepth(TreeNode *root) &#123;</span><br><span class="line">        if (root == nullptr) return 0;</span><br><span class="line">        int left_depth = getDepth(root-&gt;left);</span><br><span class="line">        int right_depth = getDepth(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        // 对于有一个点位空的点，不算叶节点，故只传另一侧的深度</span><br><span class="line">        if (left_depth == 0 &amp;&amp; right_depth &gt; 0) return 1 + right_depth;</span><br><span class="line">        if(left_depth &gt; 0 &amp;&amp; right_depth == 0) return 1 + left_depth;</span><br><span class="line"></span><br><span class="line">        int min_depth = min(left_depth, right_depth);</span><br><span class="line">        return 1 + min_depth; // 加上本层的点（+1）</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/20/[Weekly%20Algorithm]%206%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E4%BA%8C%EF%BC%89/" data-id="cm7j3jecl001s10ag075pdmjq" data-title="【Weekly Algorithm】算法周记之《代码随想录》二叉树（二）" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-[Weekly Algorithm] 5算法周记之《代码随想录》栈与队列与二叉树（一）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/13/%5BWeekly%20Algorithm%5D%205%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E4%B8%80%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2024-10-13T11:48:00.000Z" itemprop="datePublished">2024-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/13/%5BWeekly%20Algorithm%5D%205%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E4%B8%80%EF%BC%89/">【Weekly Algorithm】算法周记之《代码随想录》栈与队列与二叉树（一）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h1><p>本周跟随《代码随想录》学习栈与队列和二叉树遍历的一部分，学到了栈和队列在算法中的应用，以及优先级队列的使用；此外还有二叉树的前中后序的递归、迭代、统一迭代方法。</p>
<h1 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h1><h2 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h2><ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></li>
<li>题意就是用栈实现队列的一部分功能</li>
<li>核心就是通过两栈，一个管输入，一个管输出，输出空了时，执行输出操作需从输入中把数字倒入输出的栈中</li>
<li>陆爻齐参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class MyQueue &#123;</span><br><span class="line">public:</span><br><span class="line">    stack&lt;int&gt; in;</span><br><span class="line">    stack&lt;int&gt; out;</span><br><span class="line"></span><br><span class="line">    MyQueue() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void push(int x) &#123;</span><br><span class="line">        in.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int pop() &#123;</span><br><span class="line">        int num = this-&gt;peek();</span><br><span class="line">        out.pop();</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int peek() &#123;</span><br><span class="line">        // 这个判空很重要，意味着如果在两次push中有pop，下次pop不会得到刚push进去的数字，而是按队列下去</span><br><span class="line">        if (out.empty()) &#123;</span><br><span class="line">            while(!in.empty()) &#123;</span><br><span class="line">            out.push(in.top());</span><br><span class="line">            in.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return out.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool empty() &#123;</span><br><span class="line">        return in.empty() &amp;&amp; out.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your MyQueue object will be instantiated and called as such:</span><br><span class="line"> * MyQueue* obj = new MyQueue();</span><br><span class="line"> * obj-&gt;push(x);</span><br><span class="line"> * int param_2 = obj-&gt;pop();</span><br><span class="line"> * int param_3 = obj-&gt;peek();</span><br><span class="line"> * bool param_4 = obj-&gt;empty();</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h2><ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录 (programmercarl.com)</a></li>
<li>如题，用队列实现栈，强调是单向队列</li>
<li>乍一看，还想用 [[用栈实现队列]] 的方法，两个队列，一个模拟输入，一个模拟输出，但其实不行，因为队列先进先出，不会改变输入顺序，另一个队列只能起到备份作用，甚至乎，只要一个队列就行，在 pop（）时先获取队列长度 size，把前面 size-1 个元素放后面，再把最前面拿出来就行。</li>
<li>陆爻齐参考代码随想录思路的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class MyStack &#123;</span><br><span class="line">public:</span><br><span class="line">    queue&lt;int&gt; q;</span><br><span class="line">    queue&lt;int&gt; backup;</span><br><span class="line">    MyStack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void push(int x) &#123;</span><br><span class="line">        q.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int pop() &#123;</span><br><span class="line">    	// 备份</span><br><span class="line">        while(q.size() &gt; 1) &#123;</span><br><span class="line">            backup.push(q.front());</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        int top = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        // 恢复</span><br><span class="line">        while (!backup.empty()) &#123;</span><br><span class="line">            q.push(backup.front());</span><br><span class="line">            backup.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return top;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int top() &#123;</span><br><span class="line">        int top = this-&gt;pop();</span><br><span class="line">        this-&gt;push(top);</span><br><span class="line">        return top;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool empty() &#123;</span><br><span class="line">        return q.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your MyStack object will be instantiated and called as such:</span><br><span class="line"> * MyStack* obj = new MyStack();</span><br><span class="line"> * obj-&gt;push(x);</span><br><span class="line"> * int param_2 = obj-&gt;pop();</span><br><span class="line"> * int param_3 = obj-&gt;top();</span><br><span class="line"> * bool param_4 = obj-&gt;empty();</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h2><ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0020.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></li>
<li>题意是给一个只有小中大括号的字符串，判断其是否正确地两两匹配</li>
<li>方法是利用栈，若两两匹配则弹出，后面的判断陆爻齐简单地判断栈是否空作为结果，毕竟陆爻齐是把无法匹配的括号也放进去了，代码随想录则分别判断了情况并处理，更为周全</li>
<li>陆爻齐的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    stack&lt;char&gt; rec;</span><br><span class="line">    bool isValid(string s) &#123;</span><br><span class="line">        if (s.size() % 2 != 0) return false;</span><br><span class="line"></span><br><span class="line">        for (auto c : s) &#123;</span><br><span class="line">            char top_c = get_top();</span><br><span class="line">            // 匹配成功则弹栈，否则压栈</span><br><span class="line">            if ((c == &#x27;)&#x27; &amp;&amp; &#x27;(&#x27; == top_c) ||</span><br><span class="line">                (c == &#x27;]&#x27; &amp;&amp; &#x27;[&#x27; == top_c) ||</span><br><span class="line">                (c == &#x27;&#125;&#x27; &amp;&amp; &#x27;&#123;&#x27; == top_c)) &#123;</span><br><span class="line">                rec.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                rec.push(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">        if (rec.empty()) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;*/</span><br><span class="line">        // 若全部匹配成功，则有效</span><br><span class="line">        return rec.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inline char get_top() &#123;</span><br><span class="line">        if (!rec.empty()) &#123;</span><br><span class="line">            return rec.top();</span><br><span class="line">        &#125;</span><br><span class="line">        return &#x27; &#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>代码随想录的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isValid(string s) &#123;</span><br><span class="line">        if (s.size() % 2 != 0) return false; // 如果s的长度为奇数，一定不符合要求</span><br><span class="line">        stack&lt;char&gt; st;</span><br><span class="line">        for (int i = 0; i &lt; s.size(); i++) &#123;</span><br><span class="line">            if (s[i] == &#x27;(&#x27;) st.push(&#x27;)&#x27;);</span><br><span class="line">            else if (s[i] == &#x27;&#123;&#x27;) st.push(&#x27;&#125;&#x27;);</span><br><span class="line">            else if (s[i] == &#x27;[&#x27;) st.push(&#x27;]&#x27;);</span><br><span class="line">            // 第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号 return false</span><br><span class="line">            // 第二种情况：遍历字符串匹配的过程中，发现栈里没有我们要匹配的字符。所以return false</span><br><span class="line">            else if (st.empty() || st.top() != s[i]) return false;</span><br><span class="line">            else st.pop(); // st.top() 与 s[i]相等，栈弹出元素</span><br><span class="line">        &#125;</span><br><span class="line">        // 第一种情况：此时我们已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false，否则就return true</span><br><span class="line">        return st.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="删除字符串中的所有相邻重复项"><a href="#删除字符串中的所有相邻重复项" class="headerlink" title="删除字符串中的所有相邻重复项"></a>删除字符串中的所有相邻重复项</h2><ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.html">代码随想录 (programmercarl.com)</a></li>
<li>如题，比如“abbaac”，先去 “bb”，得 “aaac”，再去 “aa”，得 “ac”。</li>
<li>方法就是用栈，来了与栈顶相同的字符就弹栈，否则压栈</li>
<li>陆爻齐参考代码随想录思路的解法</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string removeDuplicates(string s) &#123;</span><br><span class="line">        string result;</span><br><span class="line">        for(auto c : s) &#123;</span><br><span class="line">            if (result.empty() || c != result.back()) &#123;</span><br><span class="line">                result.push_back(c);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                result.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="逆波兰表达式求值"><a href="#逆波兰表达式求值" class="headerlink" title="逆波兰表达式求值"></a>逆波兰表达式求值</h2><ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录 (programmercarl.com)</a></li>
<li>题意，就是对后缀表达式计算求值，比如 [“2”, “1”, “+”, “3”, “ * “]</li>
<li>方法，就是用栈去保存遍历到的值，一旦遍历到符号，就取出两次顶来做计算然后压栈，具体实现，可以先判断是否符号再处理，也可分别判断，前者代码更简洁，后者判断少一次</li>
<li>代码随想录，简洁点<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;</span><br><span class="line">        // 力扣修改了后台测试数据，需要用longlong</span><br><span class="line">        stack&lt;long long&gt; st; </span><br><span class="line">        for (int i = 0; i &lt; tokens.size(); i++) &#123;</span><br><span class="line">            if (tokens[i] == &quot;+&quot; || tokens[i] == &quot;-&quot; || tokens[i] == &quot;*&quot; || tokens[i] == &quot;/&quot;) &#123;</span><br><span class="line">                long long num1 = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                long long num2 = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                if (tokens[i] == &quot;+&quot;) st.push(num2 + num1);</span><br><span class="line">                if (tokens[i] == &quot;-&quot;) st.push(num2 - num1);</span><br><span class="line">                if (tokens[i] == &quot;*&quot;) st.push(num2 * num1);</span><br><span class="line">                if (tokens[i] == &quot;/&quot;) st.push(num2 / num1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                st.push(stoll(tokens[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int result = st.top();</span><br><span class="line">        st.pop(); // 把栈里最后一个元素弹出（其实不弹出也没事）</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>陆爻齐，判断少一次<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;</span><br><span class="line">        stack&lt;int&gt; s;</span><br><span class="line">        for (auto c : tokens) &#123;</span><br><span class="line">            if (c == &quot;+&quot;) &#123;</span><br><span class="line">                int top1 = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                int top2 = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                s.push(top1 + top2);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (c == &quot;-&quot;) &#123;</span><br><span class="line">                int top1 = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                int top2 = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                s.push(top2 - top1);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (c == &quot;*&quot;) &#123;</span><br><span class="line">                int top1 = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                int top2 = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                s.push(top1 * top2);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (c == &quot;/&quot;) &#123;</span><br><span class="line">                int top1 = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                int top2 = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                s.push(top2 / top1);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                s.push(stoi(c));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h2><ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录 (programmercarl.com)</a></li>
<li>题意，设定一个窗口大小，然后在 vector 上从左向右滑动，每次都计算一次窗口内最大值并保存</li>
<li>方法，最简单的暴力解法，O(n^2)，每次窗口都遍历下窗口内；想让时间复杂度变 O(n)，就需要一个叫做单调队列的数据结构，该队列保证内部数值按降序或升序排列，在 C++ 无标准库实现，本题中可让其按降序，每次找最大值仅需取 front 即可</li>
<li>PS: 单调队列实现不唯一，本题只看最大值，故把较小的数值直接弹栈，不做保存</li>
<li>陆爻齐参考代码随想录思路的解法</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // 实现单调队列</span><br><span class="line">    class MyQueue &#123;</span><br><span class="line">    private:</span><br><span class="line">        deque&lt;int&gt; q;</span><br><span class="line">    public:</span><br><span class="line">        void push(int num) &#123;</span><br><span class="line">            // 由于只关心大值，故小值可直接pop</span><br><span class="line">            while(!q.empty() &amp;&amp; num &gt; q.back()) &#123;</span><br><span class="line">                q.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            q.push_back(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void pop(int num) &#123;</span><br><span class="line">            if (!q.empty() &amp;&amp; num == q.front()) &#123;</span><br><span class="line">                q.pop_front();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 保证 front 是最大值</span><br><span class="line">        int front() &#123;</span><br><span class="line">            return q.front();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        MyQueue q;</span><br><span class="line">        vector&lt;int&gt; result;</span><br><span class="line">        int size = nums.size();</span><br><span class="line">        // 先处理前面 k 个值，并记录一次</span><br><span class="line">        for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">            q.push(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        result.push_back(q.front());</span><br><span class="line">        // 滑动窗口</span><br><span class="line">        for (int i = k; i &lt; size; i++) &#123;</span><br><span class="line">            q.push(nums[i]);</span><br><span class="line">            q.pop(nums[i - k]);</span><br><span class="line">            result.push_back(q.front());</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="前K个高频元素"><a href="#前K个高频元素" class="headerlink" title="前K个高频元素"></a>前K个高频元素</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0347.%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录 (programmercarl.com)</a></p>
</li>
<li><p>题意就是给一个整型数组，要求给出其中出现频率最高的前 K 个元素</p>
</li>
<li><p>最直观的解法，就是用 map 记录频率，导入 vector 再用快速排序，但这么做时间复杂度就达到了 O(n*logn)，还有没有更快的方法呢？</p>
<p>这里就要引入优先级队列，在[[滑动窗口最大值]]其实就有所应用，这次不止要最大值，因此那次实现的优先级队列不好直接应用。  </p>
<p>优先级队列在 C++ 的 STL 中就有实现，priority_queue，本质为堆，默认大顶堆。和  </p>
<p>虽然直观上使用大顶堆来保存前 K 个元素比较合适，但是在本题中使用小顶堆更好，因为小顶堆意味着每次 pop 出的就是最小的元素，这么做就可以反复添加元素并去除多于元素来保证堆内都是最大的一批元素。  </p>
</li>
<li><p>陆爻齐参考代码随想录思路的解法</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // 自定义排序</span><br><span class="line">    class my_compare &#123;</span><br><span class="line">    public:</span><br><span class="line">        bool operator() (const pair&lt;int,int&gt; &amp;l, const pair&lt;int,int&gt; &amp;r) &#123;</span><br><span class="line">            return l.second &gt; r.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        // 统计所有数字的频率</span><br><span class="line">        unordered_map&lt;int, int&gt; rec;</span><br><span class="line">        for (auto i : nums) &#123;</span><br><span class="line">            rec[i]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 小顶堆</span><br><span class="line">        priority_queue&lt;pair&lt;int,int&gt;, vector&lt;pair&lt;int,int&gt;&gt;, my_compare&gt; pri_que;</span><br><span class="line"></span><br><span class="line">        for (unordered_map&lt;int,int&gt;::iterator it = rec.begin(); it != rec.end(); it++) &#123;</span><br><span class="line">            pri_que.push(*it);</span><br><span class="line">            // 对于小顶堆，总是保持非降序，故加入元素后弹出最小即可保持前 k 个最高频次元素</span><br><span class="line">            if (pri_que.size() &gt; k) &#123;</span><br><span class="line">                pri_que.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; result(k);</span><br><span class="line">        for (int i = k-1; i &gt;= 0; i--) &#123;</span><br><span class="line">            result[i] = pri_que.top().first;</span><br><span class="line">            pri_que.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a>二叉树的递归遍历</h2><ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></li>
<li>如题，用递归的方式完成二叉树的遍历</li>
<li>本题更多的是引入递归的写法，首先确认递归的参数和返回值，然后定好终止条件，最后写好单层递归逻辑</li>
<li>本质上不同的是输出结果的顺序，前序时，先输出结果再遍历，中序时输出结果再遍历之间，后序时输出结果在遍历后</li>
<li>前序遍历：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; result;</span><br><span class="line">    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        pre_val(root);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void pre_val(TreeNode* n) &#123;</span><br><span class="line">        if (n == nullptr) return;</span><br><span class="line">        result.push_back(n-&gt;val);</span><br><span class="line">        pre_val(n-&gt;left);</span><br><span class="line">        pre_val(n-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
中序遍历：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; result;</span><br><span class="line">    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        mid_val(root);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void mid_val(TreeNode *n) &#123;</span><br><span class="line">        if (n == nullptr) return;</span><br><span class="line">        mid_val(n-&gt;left);</span><br><span class="line">        result.push_back(n-&gt;val);</span><br><span class="line">        mid_val(n-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
后序遍历：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; result;</span><br><span class="line">    vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        back_val(root);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void back_val(TreeNode *root) &#123;</span><br><span class="line">        if (root == nullptr) return;</span><br><span class="line">        back_val(root-&gt;left);</span><br><span class="line">        back_val(root-&gt;right);</span><br><span class="line">        result.push_back(root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="二叉树的迭代遍历"><a href="#二叉树的迭代遍历" class="headerlink" title="二叉树的迭代遍历"></a>二叉树的迭代遍历</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录 (.com)</a></p>
</li>
<li><p>如题，要用迭代的方式来解决遍历二叉树的问题</p>
</li>
<li><p>不同于递归遍历的简洁明了，迭代方式需要用栈来模拟递归的方式</p>
<p>前序遍历则简单点，由于搜寻的点就是马上要处理的点，但中序遍历则要分两部分，一部分是一味地搜寻左子树，另一部分开始处理栈积攒的点并切换到右子树；后序遍历则把前序遍历的 “中右左” 换成 “中左右” 再反转成 “右左中” 即可  </p>
</li>
<li><p>前序遍历</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; result;</span><br><span class="line">    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        TreeNode *p = root;</span><br><span class="line">        stack&lt;TreeNode*&gt; rec;</span><br><span class="line">        if(root != nullptr) rec.push(root);</span><br><span class="line">        while(!rec.empty()) &#123;</span><br><span class="line">            p = rec.top();</span><br><span class="line">            rec.pop();</span><br><span class="line">            result.push_back(p-&gt;val);</span><br><span class="line">            // 由于是栈，所以先入右，就会有遍历时先左后右的效果</span><br><span class="line">            if (p-&gt;right != nullptr) rec.push(p-&gt;right);</span><br><span class="line">            if (p-&gt;left != nullptr) rec.push(p-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>中序遍历  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; result;</span><br><span class="line">    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        TreeNode *cur = root;</span><br><span class="line">        stack&lt;TreeNode *&gt; rec;</span><br><span class="line">        while (cur!= nullptr || !rec.empty()) &#123;</span><br><span class="line">            if (cur != NULL) &#123;</span><br><span class="line">                rec.push(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                cur = rec.top();</span><br><span class="line">                rec.pop();</span><br><span class="line">                result.push_back(cur-&gt;val);</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>后序遍历  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; result;</span><br><span class="line">    vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        TreeNode *cur = root;</span><br><span class="line">        stack&lt;TreeNode*&gt; rec;</span><br><span class="line">        if (cur != nullptr) rec.push(cur);</span><br><span class="line"></span><br><span class="line">        while(!rec.empty()) &#123;</span><br><span class="line">            cur = rec.top();</span><br><span class="line">            rec.pop();</span><br><span class="line">            result.push_back(cur-&gt;val);</span><br><span class="line">            if (cur-&gt;left != nullptr) rec.push(cur-&gt;left);</span><br><span class="line">            if (cur-&gt;right != nullptr) rec.push(cur-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(result.begin(), result.end());</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="二叉树的统一迭代遍历法"><a href="#二叉树的统一迭代遍历法" class="headerlink" title="二叉树的统一迭代遍历法"></a>二叉树的统一迭代遍历法</h2><ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></li>
<li>如题，就是用类似递归那样可比较通用的迭代遍历法</li>
<li>方法就是在压栈遍历过的节点时，再压入一个空指针，遍历到空指针就意味着要输出这个值了</li>
<li>前序遍历<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt;result;</span><br><span class="line">    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        if (root != nullptr) st.push(root);</span><br><span class="line">        while (!st.empty()) &#123;</span><br><span class="line">            TreeNode *cur = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            // 给遍历过的点一个标记，即在后面压一个空指针，遍历到则说明该读取了</span><br><span class="line">            if (cur != nullptr) &#123;</span><br><span class="line">                if (cur-&gt;right != nullptr) st.push(cur-&gt;right);</span><br><span class="line"></span><br><span class="line">                if (cur-&gt;left != nullptr) st.push(cur-&gt;left);</span><br><span class="line"></span><br><span class="line">                st.push(cur);</span><br><span class="line">                st.push(nullptr);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                cur = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                result.push_back(cur-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
中序遍历  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; result;</span><br><span class="line">    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        if (root != nullptr) st.push(root);</span><br><span class="line">        while (!st.empty()) &#123;</span><br><span class="line">            TreeNode *cur = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            // 给遍历过的点一个标记，即在后面压一个空指针，遍历到则说明该读取了</span><br><span class="line">            if (cur != nullptr) &#123;</span><br><span class="line">                if (cur-&gt;right != nullptr) st.push(cur-&gt;right);</span><br><span class="line"></span><br><span class="line">                st.push(cur);</span><br><span class="line">                st.push(nullptr);</span><br><span class="line"></span><br><span class="line">                if (cur-&gt;left != nullptr) st.push(cur-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                cur = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                result.push_back(cur-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
后序遍历  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; result;</span><br><span class="line">    vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        if (root != nullptr) st.push(root);</span><br><span class="line">        while (!st.empty()) &#123;</span><br><span class="line">            TreeNode *cur = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            // 给遍历过的点一个标记，即在后面压一个空指针，遍历到则说明该读取了</span><br><span class="line">            if (cur != nullptr) &#123;</span><br><span class="line">                st.push(cur);</span><br><span class="line">                st.push(nullptr);</span><br><span class="line"></span><br><span class="line">                if (cur-&gt;right != nullptr) st.push(cur-&gt;right);</span><br><span class="line"></span><br><span class="line">                if (cur-&gt;left != nullptr) st.push(cur-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                cur = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                result.push_back(cur-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/13/[Weekly%20Algorithm]%205%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E4%B8%80%EF%BC%89/" data-id="cm7j3jeck001q10agepq7esav" data-title="【Weekly Algorithm】算法周记之《代码随想录》栈与队列与二叉树（一）" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-[Weekly Algorithm] 4算法周记之《代码随想录》字符串" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/06/%5BWeekly%20Algorithm%5D%204%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="article-date">
  <time class="dt-published" datetime="2024-10-06T05:45:00.000Z" itemprop="datePublished">2024-10-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/06/%5BWeekly%20Algorithm%5D%204%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/">【Weekly Algorithm】 算法周记之《代码随想录》字符串</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h1><p>本周跟随《代码随想录》学习字符串部分，较深入地了解了字符串的相关算法题，除了双指针，还有 KMP 算法。</p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="简评"><a href="#简评" class="headerlink" title="简评"></a>简评</h2><p>究其本质而言，就是数组，只不过内容换成了字母。</p>
<h2 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h2><ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录 (programmercarl.com)</a></li>
<li>就是把字符串前后翻转，和[[翻转链表]]相似</li>
<li>由于字符串可以随机读取，可以简单很多，直接 <code>swap</code> i 和 str.size()-1-i 的字符即可</li>
<li>陆爻齐参照代码随想录的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void reverseString(vector&lt;char&gt;&amp; s) &#123;</span><br><span class="line">        int size = s.size();</span><br><span class="line">        for (int i = 0; i &lt; size / 2; i++) &#123;</span><br><span class="line">            swap(s[i],s[size - 1 - i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="反转字符串-1"><a href="#反转字符串-1" class="headerlink" title="反转字符串||"></a>反转字符串||</h2><ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0541.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></li>
<li>与 [[反转字符串]] 类似，不过要求每 2k 个字符的前 k 个字符反转</li>
<li>方法不难，可以像陆爻齐这样把两个阶段分开，也可像代码随想录这样合一起处理，不过还是要注意循环不变原则，比如反转字符串保持左闭右闭的区间</li>
<li>陆爻齐的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string reverseStr(string s, int k) &#123;</span><br><span class="line">        int begin = 0, end = s.size() - 1;</span><br><span class="line">        int size = s.size();</span><br><span class="line"></span><br><span class="line">        // 先处理了大于 2k 的情况</span><br><span class="line">        while(size &gt; 2 * k) &#123;</span><br><span class="line">            rev_str(s, begin, begin + k - 1);</span><br><span class="line">            begin += 2 * k;</span><br><span class="line">            size -= 2 * k;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 单独处理小于等于 k 的情况</span><br><span class="line">        if (size &gt;= k) &#123;</span><br><span class="line">            rev_str(s, begin, begin + k - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            rev_str(s, begin, begin + size - 1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 反转字符串单独实现，左闭右闭</span><br><span class="line">    void rev_str(string &amp;s, int begin, int end) &#123;</span><br><span class="line">        int size = end - begin + 1;</span><br><span class="line">        //cout &lt;&lt; &quot;rec: &quot;;</span><br><span class="line">        /*for (int i = begin; i &lt;= end; i++) &#123;</span><br><span class="line">            cout &lt;&lt; s[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">        &#125;*/</span><br><span class="line">        //cout &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">        for (int i = 0; i &lt; size / 2; i++) &#123;</span><br><span class="line">            swap(s[begin + i], s[end - i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>代码随想录的解法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void reverse(string&amp; s, int start, int end) &#123;</span><br><span class="line">        for (int i = start, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">            swap(s[i], s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    string reverseStr(string s, int k) &#123;</span><br><span class="line">        for (int i = 0; i &lt; s.size(); i += (2 * k)) &#123;</span><br><span class="line">            // 1. 每隔 2k 个字符的前 k 个字符进行反转</span><br><span class="line">            // 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符</span><br><span class="line">            if (i + k &lt;= s.size()) &#123;</span><br><span class="line">                reverse(s, i, i + k - 1);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            // 3. 剩余字符少于 k 个，则将剩余字符全部反转。</span><br><span class="line">            reverse(s, i, s.size() - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="替换数字"><a href="#替换数字" class="headerlink" title="替换数字"></a>替换数字</h2><ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/kamacoder/0054.%E6%9B%BF%E6%8D%A2%E6%95%B0%E5%AD%97.html#%E6%80%9D%E8%B7%AF">替换数字 | 代码随想录 (programmercarl.com)</a></li>
</ul>
</li>
<li>题意是让字符串中的数字，替换为 “number”</li>
<li>最普通的方法是从前往后遍历，对于数字，则将后面的字母向后移位，插入 “number”，但时间复杂度为 O(n^2)，如果创建新的字符串来辅助，那么空间复杂度就高了（JAVA 好像不能对字符串直接修改，必须辅助来着）</li>
<li>比较好的方法是，先遍历字符串，确认其中数字个数，然后直接对字符串重定大小，从后向前填充，遇到数字就倒着写 number</li>
<li>陆爻齐参考代码随想录思路的解法</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string s;// 存储字符串</span><br><span class="line">    int count;// 记录字符串中数字个数</span><br><span class="line">    </span><br><span class="line">    while(cin &gt;&gt; s) &#123; //只要一直有输入就不会停止</span><br><span class="line">        int ori_size = s.size(); //记录原来大小</span><br><span class="line">        count = 0;</span><br><span class="line">        for(auto c : s) &#123; // 计算数字个数</span><br><span class="line">            if (int(c) &lt; int(&#x27;a&#x27;)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        s.resize(s.size() + 5 * count); // 重置字符串大小</span><br><span class="line">        </span><br><span class="line">        int index = ori_size - 1;// 对原内容遍历下标</span><br><span class="line">        int input_ind = s.size() - 1;// 插入下标</span><br><span class="line">        </span><br><span class="line">        while(input_ind &gt; 0) &#123; // 从后向前遍历</span><br><span class="line">            if (int(s[index]) &lt; int(&#x27;a&#x27;)) &#123;  // 对数字从后向前替换numver</span><br><span class="line">                s[input_ind--] = &#x27;r&#x27;;</span><br><span class="line">                s[input_ind--] = &#x27;e&#x27;;</span><br><span class="line">                s[input_ind--] = &#x27;b&#x27;;</span><br><span class="line">                s[input_ind--] = &#x27;m&#x27;;</span><br><span class="line">                s[input_ind--] = &#x27;u&#x27;;</span><br><span class="line">                s[input_ind--] = &#x27;n&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                s[input_ind--] = s[index]; // 对非数字直接替换</span><br><span class="line">            &#125;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="翻转字符串里的单词"><a href="#翻转字符串里的单词" class="headerlink" title="翻转字符串里的单词"></a>翻转字符串里的单词</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0151.%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></p>
</li>
<li><p>本题要求只是翻转字符串中每个单词，单词内不翻转，若遇到多个空格，则合并一个</p>
</li>
<li><p>整体分三步：</p>
<ol>
<li>去除多余空格</li>
<li>整体翻转</li>
<li>局部翻转单词</li>
</ol>
</li>
<li><p>第一步可以遍历然后erase，但erase时间复杂度O(n)，这样第一步复杂度O(n^2)，虽然也能过，但有更好的方法；这里就要用到[[移除元素]]中用到的双指针，同样的方法可以消除多余空格，区别就是每次消除前，先自己补个空格</p>
</li>
<li><p>第二步和第三步用[[反转字符串]]即可，注意第三步对每个单词反转时，由于默认用左闭右闭的反转函数，遍历的变量 i 是可以取到 s.size() 的。</p>
</li>
<li><p>陆爻齐参考代码随想录思路的解法</p>
</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string reverseWords(string s) &#123;</span><br><span class="line">        removeExactSpaces(s);</span><br><span class="line">        reverseStr(s, 0, s.size() - 1);</span><br><span class="line"></span><br><span class="line">        int start = 0;</span><br><span class="line">        for (int i = 0; i &lt;= s.size(); i++) &#123; // 由于反转对i-1，i可以取s.size()</span><br><span class="line">            if (s[i] == &#x27; &#x27; || i == s.size()) &#123;</span><br><span class="line">                reverseStr(s, start, i - 1);</span><br><span class="line">                start = i+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 左闭右闭区间交换</span><br><span class="line">    void reverseStr(string &amp;s, int begin, int end) &#123;</span><br><span class="line">        for (int i = begin, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">            swap(s[i], s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void removeExactSpaces(string &amp;s) &#123;</span><br><span class="line">        // 参考此前的移除元素，双指针O(n)</span><br><span class="line">        int slow = 0;</span><br><span class="line">        int size = s.size();</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            if (s[i] != &#x27; &#x27;) &#123;</span><br><span class="line">                if (slow != 0) &#123;</span><br><span class="line">                    s[slow++] = &#x27; &#x27;;</span><br><span class="line">                &#125;</span><br><span class="line">                while (i &lt; size &amp;&amp; s[i] != &#x27; &#x27;) &#123;</span><br><span class="line">                    s[slow++] = s[i++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //cout &lt;&lt; slow &lt;&lt; endl;</span><br><span class="line">        s.resize(slow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="右旋字符串"><a href="#右旋字符串" class="headerlink" title="右旋字符串"></a>右旋字符串</h2><ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/kamacoder/0055.%E5%8F%B3%E6%97%8B%E5%AD%97%E7%AC%A6%E4%B8%B2.html">右旋字符串 | 代码随想录 (programmercarl.com)</a></li>
<li>题意就是要求将一个字符串的后 k 个字符放前面</li>
<li>不难，最容易想到的方法就是新建个字符串，先把后 k 个放前面，再回头放前面；BUT！！如果不准用辅助空间呢？（又是排除 JAVA 的一集）</li>
<li>答案是通过 [[反转字符串]]，整体反转，再将前 k 个（也就是后面 k 个字符反转过来的部分）和后面部分分别反转即可</li>
<li>陆爻齐参考代码随想录思路的解法</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 左闭右闭反转</span><br><span class="line">void reverse_str(string &amp;s, int begin, int end) &#123;</span><br><span class="line">    for (int i = begin, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">        swap(s[i], s[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string s;</span><br><span class="line">    int k;</span><br><span class="line">    cin &gt;&gt; k &gt;&gt; s;</span><br><span class="line">    int size = s.size();</span><br><span class="line">    reverse_str(s, 0, size-1); // 整体反转</span><br><span class="line">    // 两部分分别反转</span><br><span class="line">    reverse_str(s, 0, k-1);</span><br><span class="line">    reverse_str(s, k, size-1);</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现strStr"><a href="#实现strStr" class="headerlink" title="实现strStr()"></a>实现strStr()</h2><ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></li>
<li>即求出一个文本串中模板串第一次出现的首字母下标</li>
<li>本题利用暴力解法也可 AC，即对每个字符起都循环遍历模板串是否匹配，但想比较好地完成此题，就不得不提到 [[KMP算法]]，本题也就可是KMP匹配成功后立即返回即可</li>
<li>陆爻齐参考代码随想录思路的解法</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void getNext(int *next, string s) &#123;</span><br><span class="line">        int j = -1;</span><br><span class="line">        next[0] = j;</span><br><span class="line">        int size = s.size();</span><br><span class="line">        for (int i = 1; i &lt; size; i++) &#123; // 循环不变原则，i为后缀末下标，j为前缀末下标</span><br><span class="line">            while (j &gt;= 0 &amp;&amp; s[i] != s[j + 1]) &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">            if (s[i] == s[j + 1]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int strStr(string haystack, string needle) &#123;</span><br><span class="line">        if (needle.size() == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        vector&lt;int&gt; next(needle.size());</span><br><span class="line">        getNext(&amp;next[0], needle);</span><br><span class="line">        int j = -1;</span><br><span class="line">        for(int i = 0; i &lt; haystack.size(); i++) &#123;</span><br><span class="line">            while(j &gt;= 0 &amp;&amp; haystack[i] != needle[j + 1]) &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">            if (haystack[i] == needle[j + 1]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (j == (needle.size() - 1)) &#123; // 可理解为结果是 i -</span><br><span class="line">                return (i - needle.size() + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="重复的子字符串"><a href="#重复的子字符串" class="headerlink" title="重复的子字符串"></a>重复的子字符串</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></p>
</li>
<li><p>即判断字符串是否由自身的子字符串组成</p>
</li>
<li><p>方法大致有三个</p>
<ol>
<li>暴力解法，O(n^2)时间复杂度，中间可以只遍历一半字符串优化</li>
</ol>
<p>2.移动匹配，把字符串*2拼一起，掐头去尾，若中间有字符串，则是<br>  3. [[KMP算法]] ，若KMP找到最长相同前后缀所不包含的串长度可整除字符串，则是</p>
</li>
<li><p>移动匹配：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool repeatedSubstringPattern(string s) &#123;</span><br><span class="line">        string ss = s + s;</span><br><span class="line">        // 掐头去尾</span><br><span class="line">        ss.erase(ss.begin());</span><br><span class="line">        ss.erase(ss.end() - 1);</span><br><span class="line">        // 如果中间出现原串，说明确实是</span><br><span class="line">        if (ss.find(s) != string::npos) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>KMP</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void getNext(int *next, string s) &#123;</span><br><span class="line">        int j = -1;</span><br><span class="line">        next[0] = j;</span><br><span class="line">        for (int i = 1; i &lt; s.size(); i++) &#123;</span><br><span class="line">            while (j &gt;= 0 &amp;&amp; s[i] != s[j + 1]) &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">            if (s[i] == s[j + 1]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    bool repeatedSubstringPattern(string s) &#123;</span><br><span class="line">        if (s.size() == 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; next(s.size());</span><br><span class="line">        getNext(&amp;next[0], s);</span><br><span class="line">        int len = s.size();</span><br><span class="line">        // 只要最长前后缀在末尾大于零，且剩余部分长度整除字符串</span><br><span class="line">        if (next[len - 1] != -1 &amp;&amp; len % (len - (next[len - 1] + 1)) == 0) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/06/[Weekly%20Algorithm]%204%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/" data-id="cm7j3jeck001p10ag9khn6up0" data-title="【Weekly Algorithm】 算法周记之《代码随想录》字符串" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CINTA/" rel="tag">CINTA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CS61A/" rel="tag">CS61A</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Conda/" rel="tag">Conda</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JLU/" rel="tag">JLU</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%92%AD%E5%AE%A2%E7%AC%94%E8%AE%B0/" rel="tag">播客笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag">数据结构与算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/" rel="tag">方法论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" rel="tag">深度学习</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algorithm/" style="font-size: 20px;">Algorithm</a> <a href="/tags/CINTA/" style="font-size: 10px;">CINTA</a> <a href="/tags/CS61A/" style="font-size: 17.14px;">CS61A</a> <a href="/tags/Conda/" style="font-size: 10px;">Conda</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/JLU/" style="font-size: 15.71px;">JLU</a> <a href="/tags/Python/" style="font-size: 18.57px;">Python</a> <a href="/tags/%E6%92%AD%E5%AE%A2%E7%AC%94%E8%AE%B0/" style="font-size: 11.43px;">播客笔记</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size: 14.29px;">数据结构与算法</a> <a href="/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/" style="font-size: 11.43px;">方法论</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 11.43px;">机器学习</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 12.86px;">杂谈</a> <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">深度学习</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/02/">二月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/01/">一月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/12/">十二月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">十一月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">十月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">九月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">八月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">七月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">六月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">五月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">三月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">二月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">一月 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/02/23/%5BWeekly%20Algorithm%5D%2019%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%9B%BE%E8%AE%BA%EF%BC%88%E4%B8%89%EF%BC%89/">【Weekly Algorithm】算法周记之《代码随想录》图论（三）</a>
          </li>
        
          <li>
            <a href="/2025/02/16/%5BWeekly%20Algorithm%5D%2018%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%9B%BE%E8%AE%BA%EF%BC%88%E4%BA%8C%EF%BC%89/">【Weekly Algorithm】算法周记之《代码随想录》图论（二）</a>
          </li>
        
          <li>
            <a href="/2025/02/09/%5BWeekly%20Algorithm%5D%2017%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8D%95%E8%B0%83%E6%A0%88%E5%92%8C%E5%9B%BE%E8%AE%BA%EF%BC%88%E4%B8%80%EF%BC%89/">【Weekly Algorithm】算法周记之《代码随想录》单调栈和图论（一）</a>
          </li>
        
          <li>
            <a href="/2025/01/19/%5BWeekly%20Algorithm%5D%2016%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%83%EF%BC%89/">【Weekly Algorithm】算法周记之《代码随想录》动态规划（七）</a>
          </li>
        
          <li>
            <a href="/2025/01/12/%5BWeekly%20Algorithm%5D%2015%E7%AE%97%E6%B3%95%E5%91%A8%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E5%85%AD%EF%BC%89/">【Weekly Algorithm】算法周记之《代码随想录》动态规划（六）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 陆爻齐-LuYaoQi<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>